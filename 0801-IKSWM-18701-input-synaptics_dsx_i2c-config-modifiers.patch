From 5554dbe597a6be9f46309da63c62b1eff5e68271 Mon Sep 17 00:00:00 2001
From: Konstantin Makariev <kmakariev@motorola.com>
Date: Thu, 21 Jan 2016 17:01:11 -0600
Subject: [PATCH 801/959] IKSWM-18701 input: synaptics_dsx_i2c: config
 modifiers concept

This change introduces config modifier concept in touch driver.
Modifier represents a set of configuration (registers values)
and/or functional (touch events clipping) restrictions. There can
be multiple modifiers defined via device tree. Any number of
modifiers from defined list can be applied simultaneously to
craft unique touch behavior required by certain conditions.

Change-Id: I4d2b64d41bcd7ba99341a438a5bb39a2bbbc0f17
Signed-off-by: Konstantin Makariev <kmakariev@motorola.com>
Reviewed-on: http://gerrit.mot.com/823379
SME-Granted: SME Approvals Granted
SLTApproved: Slta Waiver <sltawvr@motorola.com>
Tested-by: Jira Key <jirakey@motorola.com>
Reviewed-by: Igor Kovalenko <igork@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
---
 .../input/touchscreen/synaptics_dsx_i2c_mmi.txt    |   83 +
 drivers/input/touchscreen/synaptics_dsx_i2c.c      | 1672 +++++++++++++-------
 drivers/input/touchscreen/synaptics_dsx_i2c.h      |   80 +-
 3 files changed, 1202 insertions(+), 633 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/input/touchscreen/synaptics_dsx_i2c_mmi.txt

diff --git a/Documentation/devicetree/bindings/input/touchscreen/synaptics_dsx_i2c_mmi.txt b/Documentation/devicetree/bindings/input/touchscreen/synaptics_dsx_i2c_mmi.txt
new file mode 100644
index 00000000000..ddf1b23130a
--- /dev/null
+++ b/Documentation/devicetree/bindings/input/touchscreen/synaptics_dsx_i2c_mmi.txt
@@ -0,0 +1,83 @@
+Synaptics DSX touch controller MMI implementation
+
+Required properties:
+
+ - compatible		: should be "synaptics,synaptics_dsx_i2c"
+ - reg			: i2c slave address of the device
+ - interrupt-parent	: parent of interrupt
+ - interrupts		: touch sample interrupt to indicate presense or release
+				of fingers on the panel.
+ - gpios		: irq and reset gpios
+ - pinctrl-names	: This should be defined if a target uses pinctrl framework.
+			  See "pinctrl" in Documentation/devicetree/bindings/pinctrl/msm-pinctrl.txt.
+			  It should specify the names of the configs that pinctrl can install in
+			  driver. Following are the pinctrl configs that can be installed:
+			  "active" : Active configuration of pins, this should specify active
+			  config defined in pin groups of interrupt and reset gpio.
+			  "default" : Disabled configuration of pins, this should specify sleep
+			  config defined in pin groups of interrupt and reset gpio.
+Optional property:
+ - touch_vdd-supply		: digital voltage power supply needed to power device
+ - synaptics,key-buttons	: virtual key code mappings to be used
+ - synaptics,aod-multi-touch	: number of fingers to support in AoD (control access block feature)
+ - synaptics,x-flip		: modify orientation of the x axis
+ - synaptics,y-flip		: modify orientation of the y axis
+ - synaptics,gpio-config	: execute gpio configuration function in probe
+ - synaptics,purge-enabled	: purge touch events received prior frame buffer resume notification
+ - config_modifier-names	: list of modifiers names used in current setup
+				  Typically, modifier is a set of configuration (register) and/or
+				  functional (clipping) restrictions.
+				  Following names are defined: "aod", "folio", "charger", "fps",
+				  "wakeup" and "stats". Where:
+				   * aod     - Always On Display (not AP controlled)
+				   * folio   - cover with access window
+				   * charger - charger insertion/removal
+				   * fps     - finger print sensor
+				   * wakeup  - wakeup gesture
+				   * stats   - touch noise mitigation statistics (if supported by FW)
+
+Optional properties inside config_modifier-modname child node:
+ - enable-notification		: modifier has a switch notifier
+ - modname-active		: modier has active restrictions
+ - modname-suspended		: modifier has suspended restrictions
+ - patch-data			: modifier specific touch IC registers values
+ - touch-clip-area		: modifier specific touch events clipping
+
+Example:
+	i2c@f9927000 {
+		synaptics@20 {
+			compatible = "synaptics,synaptics_dsx_i2c"
+			reg = <0x20>;
+			interrupt-parent = <&tlmm>;
+			interrupts = <40 0>;
+			gpios = <&tlmm 40 0>,
+				<&tlmm 39 0>;
+			touch_vdd-supply = <&pm8994_l22>;
+			synaptics,gpio-config;
+			synaptics,x-flip;
+			synaptics,y-flip;
+			pinctrl-names = "default","active";
+			pinctrl-0 = <&touch_int_default &touch_reset_active>;
+			pinctrl-1 = <&touch_int_active &touch_reset_active>;
+			config_modifier-names = "folio", "charger";
+			config_modifier-folio {
+				enable-notification;
+				folio-active {
+					/* Saturation cap; Force update; */
+					patch-data = "F54@2=B400;F12@10=1E1F;U";
+					touch-clip-area = <64 0 1015 1014 0>;
+				};
+				folio-suspended {
+					/* Saturation cap; Force update; Power->sleep; */
+					patch-data = "F54@2=9000;U;S";
+				};
+			};
+			config_modifier-charger {
+				enable-notification;
+				charger-active {
+					/* Charger bit; */
+					patch-data = "F1@0=1&20";
+				};
+			};
+		};
+	};
diff --git a/drivers/input/touchscreen/synaptics_dsx_i2c.c b/drivers/input/touchscreen/synaptics_dsx_i2c.c
index 01db5edde5f..e1b3781b2fc 100644
--- a/drivers/input/touchscreen/synaptics_dsx_i2c.c
+++ b/drivers/input/touchscreen/synaptics_dsx_i2c.c
@@ -96,18 +96,13 @@
 
 #define tk_debug(fmt, args...)
 
-extern int FPS_register_notifier(struct notifier_block *nb,
-				unsigned long stype, bool report);
-
-extern int FPS_unregister_notifier(struct notifier_block *nb,
-				unsigned long stype);
-
-static int fps_notifier_callback(struct notifier_block *self,
-				 unsigned long event, void *data);
 #ifdef CONFIG_MMI_HALL_NOTIFICATIONS
 static int folio_notifier_callback(struct notifier_block *self,
 				 unsigned long event, void *data);
 #endif
+static int fps_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data);
+
 static void synaptics_dsx_resumeinfo_start(
 		struct synaptics_rmi4_data *rmi4_data);
 static void synaptics_dsx_resumeinfo_finish(
@@ -140,19 +135,51 @@ static struct {
 	unsigned char max_y_msb;
 } f12_c08_0;
 
+static struct {
+	unsigned char noise_floor;
+	unsigned char min_peak_amplitude;
+	unsigned char peak_merge_threshold_lsb;
+	unsigned char peak_merge_threshold_msb;
+} f12_c10_0;
+
+static struct {
+	unsigned char finger_threshold;
+	unsigned char small_finger_threshold;
+	unsigned char small_finger_border;
+	unsigned char negative_finger_threshold;
+} f12_c15_0;
+
+static struct {
+	unsigned char zone0_x_lsb;
+	unsigned char zone0_x_msb;
+	unsigned char zone0_y_lsb;
+	unsigned char zone0_y_msb;
+	unsigned char zone1_x_lsb;
+	unsigned char zone1_x_msb;
+	unsigned char zone1_y_lsb;
+	unsigned char zone1_y_msb;
+	unsigned char max_timer;
+	unsigned char max_distance;
+} f12_c18_0;
+
 static struct f12_c20_0_type {
 	unsigned char x_suppression;
 	unsigned char y_suppression;
 } f12_c20_0;
 
-static struct f12_c20_1_type {
+static struct {
 	union {
 		struct {
-			unsigned char reserved:1;
-			unsigned char report_lpwg_only:1;
-			unsigned char reserved2:6;
+			unsigned char flags:1;
+			unsigned char wakeup_gesture_only:1;
+			unsigned char dribble:1;
+			unsigned char proximity_only:1;
+			unsigned char hover_swipe:1;
+			unsigned char proximity:1;
+			unsigned char hover_pinch:1;
+			unsigned char lp_proximity:1;
 		} __packed;
-		unsigned char data[1];
+		unsigned char report;
 	};
 } f12_c20_1;
 
@@ -174,49 +201,33 @@ static struct f12_c23_1_type {
 } f12_c23_1;
 
 static struct {
-	unsigned char reported_bytes_per_object;
-} f12_c28_0;
-
-static struct {
-	unsigned char finger_threshold;
-	unsigned char small_finger_threshold;
-	unsigned char small_finger_border;
-	unsigned char negative_finger_threshold;
-} f12_c15_0;
+	union {
+		struct {
+			unsigned char double_tap:1;
+			unsigned char swipe:1;
+			unsigned char tap_n_hold:1;
+			unsigned char circle:1;
+			unsigned char triangle:1;
+			unsigned char vee:1;
+			unsigned char unicode:1;
+			unsigned char reserved:1;
+		} __packed;
+		unsigned char wakeup_gesture;
+	};
+} f12_c27_0;
 
 static struct {
-	unsigned char noise_floor;
-	unsigned char min_peak_amplitude;
-	unsigned char peak_merge_threshold_lsb;
-	unsigned char peak_merge_threshold_msb;
-} f12_c10_0;
+	unsigned char reported_bytes_per_object;
+} f12_c28_0;
 
 static struct {
 	unsigned char data[128];
 } dummy_subpkt;
 
-static struct synaptics_rmi4_subpkt f12_c15[] = {
-	RMI4_SUBPKT(f12_c15_0),
-};
-
 static struct synaptics_rmi4_subpkt f12_c08[] = {
 	RMI4_SUBPKT(f12_c08_0),
 };
 
-static struct synaptics_rmi4_subpkt f12_c20[] = {
-	RMI4_SUBPKT(f12_c20_0),
-	RMI4_SUBPKT(f12_c20_1),
-};
-
-static struct synaptics_rmi4_subpkt f12_c23[] = {
-	RMI4_SUBPKT(f12_c23_0),
-	RMI4_SUBPKT(f12_c23_1),
-};
-
-static struct synaptics_rmi4_subpkt f12_c28[] = {
-	RMI4_SUBPKT(f12_c28_0),
-};
-
 static struct synaptics_rmi4_subpkt f12_c09[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
@@ -241,6 +252,10 @@ static struct synaptics_rmi4_subpkt f12_c14[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
 
+static struct synaptics_rmi4_subpkt f12_c15[] = {
+	RMI4_SUBPKT(f12_c15_0),
+};
+
 static struct synaptics_rmi4_subpkt f12_c16[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
@@ -250,13 +265,18 @@ static struct synaptics_rmi4_subpkt f12_c17[] = {
 };
 
 static struct synaptics_rmi4_subpkt f12_c18[] = {
-	RMI4_SUBPKT(dummy_subpkt),
+	RMI4_SUBPKT(f12_c18_0),
 };
 
 static struct synaptics_rmi4_subpkt f12_c19[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
 
+static struct synaptics_rmi4_subpkt f12_c20[] = {
+	RMI4_SUBPKT(f12_c20_0),
+	RMI4_SUBPKT(f12_c20_1),
+};
+
 static struct synaptics_rmi4_subpkt f12_c21[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
@@ -265,6 +285,11 @@ static struct synaptics_rmi4_subpkt f12_c22[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
 
+static struct synaptics_rmi4_subpkt f12_c23[] = {
+	RMI4_SUBPKT(f12_c23_0),
+	RMI4_SUBPKT(f12_c23_1),
+};
+
 static struct synaptics_rmi4_subpkt f12_c24[] = {
 	RMI4_SUBPKT(dummy_subpkt),
 };
@@ -278,7 +303,11 @@ static struct synaptics_rmi4_subpkt f12_c26[] = {
 };
 
 static struct synaptics_rmi4_subpkt f12_c27[] = {
-	RMI4_SUBPKT(dummy_subpkt),
+	RMI4_SUBPKT(f12_c27_0),
+};
+
+static struct synaptics_rmi4_subpkt f12_c28[] = {
+	RMI4_SUBPKT(f12_c28_0),
 };
 
 static struct synaptics_rmi4_subpkt f12_c29[] = {
@@ -340,6 +369,39 @@ static struct synaptics_rmi4_subpkt f12_d1[] = {
 	RMI4_SUBPKT(f12_d1_9),
 };
 
+/* RMI4 has the following wakeup gesture defined:
+	• 0x00 = No gesture
+	• 0x01 = One-Finger single tap
+	• 0x02 = One-Finger tap-and-hold
+	• 0x03 = One-Finger double tap
+	• 0x04 = One-Finger early tap
+	• 0x05 = One-Finger flick
+	• 0x06 = One-Finger press
+	• 0x07 = One-Finger swipe
+	• 0x08 = One-Finger Circle
+	• 0x09 = One-Finger Triangle
+	• 0x0A = One-Finger Vee
+	• 0x0B = Reserved
+	• 0x0C = Triple Tap
+	• 0x0D = Click
+	• 0x0E = Reserved
+	• 0x30 = Edge gesture
+	• 0x7F = Reserved
+	• 0x80 = Pinch
+	• 0x81 = Rotate
+	• 0x82 through 0xFF = Reserved
+*/
+
+#define DOUBLE_TAP_GESTURE 0x03
+
+static struct f12_d4_type {
+	unsigned char gesture;
+} f12_d4_0;
+
+static struct synaptics_rmi4_subpkt f12_d4[] = {
+	RMI4_SUBPKT(f12_d4_0),
+};
+
 static struct {
 	unsigned char attn[2];
 } f12_d15_0;
@@ -350,6 +412,7 @@ static struct synaptics_rmi4_subpkt f12_d15[] = {
 
 static struct synaptics_rmi4_packet_reg f12_data_reg_array[] = {
 	RMI4_REG(1, f12_d1),
+	RMI4_REG(4, f12_d4),
 	RMI4_REG(15, f12_d15),
 };
 
@@ -624,6 +687,29 @@ static struct synaptics_rmi4_packet_reg f54_query_reg_array[] = {
 #define QUERY_TYPE	(2 << 8)
 #define COMMAND_TYPE	(3 << 8)
 
+static unsigned char power_sleep_value = 1;
+static struct synaptics_dsx_func_patch power_sleep_func_patch = {
+	.func = SYNAPTICS_RMI4_F01,
+	.regstr = 0,
+	.subpkt = 0,
+	.size = 1,
+	.bitmask = 7,
+	.data = &power_sleep_value,
+};
+
+static unsigned char force_update_value = 4;
+static struct synaptics_dsx_func_patch force_update_func_patch = {
+	.func = SYNAPTICS_RMI4_F54 | COMMAND_TYPE,
+	.regstr = 0,
+	.subpkt = 0,
+	.size = 1,
+	.bitmask = 0,
+	.data = &force_update_value,
+};
+
+static struct synaptics_dsx_patch *force_update_patch;
+static struct synaptics_dsx_patch *power_sleep_patch;
+
 static inline int register_ascii_to_type(unsigned char *symbol)
 {
 	int reg_type = CTRL_TYPE;
@@ -684,6 +770,9 @@ static struct synaptics_rmi4_func_packet_regs synaptics_cfg_regs[] = {
 		.f_number = SYNAPTICS_RMI4_F12 | DATA_TYPE,
 		.base_addr = 0,
 		.query_offset = 7,
+#define F12_D1_IDX 0
+#define F12_D4_IDX 1
+#define F12_D15_IDX 2
 		.nr_regs = ARRAY_SIZE(f12_data_reg_array),
 		.regs = f12_data_reg_array,
 	},
@@ -895,9 +984,25 @@ static void synaptics_dsx_parse_string(struct synaptics_rmi4_data *data,
 			break;
 
 		dev_dbg(dev, "patch set %d: \"%s\"\n", i, patch_set);
-
 		config_p = strpbrk(patch_set, "@");
-		if ((*patch_set != 'F' && *patch_set != 'f') || !config_p) {
+
+		/* consider force update and power seetings here */
+		if (!config_p) {
+			switch (*patch_set) {
+			case 'S':
+				patch->flags |= FLAG_POWER_SLEEP;
+				break;
+			case 'U':
+				patch->flags |= FLAG_FORCE_UPDATE;
+				break;
+			case 'W':
+				patch->flags |= FLAG_WAKEABLE;
+				break;
+			}
+			continue;
+		}
+
+		if (*patch_set != 'F' && *patch_set != 'f') {
 			dev_err(dev, "invalid syntax '%s'\n", patch_set);
 			continue;
 		}
@@ -1224,7 +1329,10 @@ static int synaptics_rmi4_write_packet_reg(
 			}
 		} else {
 			retval = -EINVAL;
-			pr_err("cannot update subpacket %d\n", ii);
+			pr_err("cannot update subpacket %d: "\
+				"sz=%d, offset=%d, data=%p, reg_sz=%d\n",
+				ii, subpkt->size, offset,
+				subpkt->data, reg->size);
 			goto out;
 		}
 	}
@@ -1288,89 +1396,211 @@ err_gpio:
 	return retval;
 }
 
-int synaptics_dsx_dt_parse_state(struct synaptics_rmi4_data *data,
-		struct device_node *np_config,
-		struct synaptics_dsx_patch *state)
+static void synaptics_dsx_dt_parse_modifier(struct synaptics_rmi4_data *data,
+		struct device_node *parent, struct config_modifier *config,
+		const char *modifier_name, bool active)
 {
-	const char *patch_data;
-	struct device_node *np_state;
+	struct device *dev = &data->i2c_client->dev;
+	const char *patch_string;
+	char node_name[64];
+	struct synaptics_clip_area clipa;
+	struct device_node *np_config;
 	int err;
 
-	np_state = of_node_get(np_config);
+	scnprintf(node_name, 63, "%s-%s", modifier_name,
+			active ? "active" : "suspended");
+	np_config = of_find_node_by_name(parent, node_name);
+	if (!np_config) {
+		dev_dbg(dev, "%s: node does not exist\n", node_name);
+		return;
+	}
+
 	err = of_property_read_string(np_config, "patch-data",
-				(const char **)&patch_data);
-	if (err < 0) {
-		pr_err("unable to read patch-data\n");
-		return err;
+				(const char **)&patch_string);
+	if (!err) {
+		struct synaptics_dsx_patch *p_data =
+			synaptics_dsx_init_patch(modifier_name);
+
+		if (!p_data) {
+			dev_err(dev, "%s: alloc error\n", node_name);
+			goto clip_area;
+		}
+		synaptics_dsx_parse_string(data, patch_string, p_data, true);
+		if (active)
+			config->active = p_data;
+		else
+			config->suspended = p_data;
 	}
 
-	synaptics_dsx_parse_string(data, patch_data, state, true);
+clip_area:
 
-	return 0;
+	err = of_property_read_u32_array(np_config, "touch-clip-area",
+		(unsigned int *)&clipa, sizeof(clipa)/sizeof(unsigned int));
+	if (!err) {
+		config->clipa = kzalloc(sizeof(clipa), GFP_KERNEL);
+		if (!config->clipa) {
+			dev_err(dev, "clip area allocation failure\n");
+			return;
+		}
+		memcpy(config->clipa, &clipa, sizeof(clipa));
+		pr_notice("using touch clip area in %s\n", node_name);
+	}
+
+	of_node_put(np_config);
 }
 
-int synaptics_dsx_dt_parse_mode(struct synaptics_rmi4_data *data,
-		const char *mode_name, struct synaptics_dsx_patchset *mode)
+/* ASCII names order MUST match enum */
+static const char const *ascii_names[] = { "aod", "stats", "folio",
+	"charger", "wakeup", "fps", "query", "runtime", "na"
+};
+
+static int modifier_name2id(const char *name)
 {
-	struct device *dev = &data->i2c_client->dev;
-	struct device_node *np = dev->of_node;
-	struct device_node *np_modes;
-	int ret = 0;
-	char *propname;
-	struct property *prop;
-	const __be32 *list;
-	int size, config;
-	phandle phandle;
-	struct device_node *np_config;
+	int i, len2cmp, chosen = -1;
 
-	np_modes = of_find_node_by_name(np, "touchstate_modes");
-	if (!np_modes) {
-		pr_warn("can't find touchstate modes node\n");
-		ret = -EINVAL;
-		goto err;
+	for (i = 0; i < SYNA_MOD_MAX; i++) {
+		len2cmp = min_t(int, strlen(name), strlen(ascii_names[i]));
+		if (!strncmp(name, ascii_names[i], len2cmp)) {
+			chosen = i;
+			break;
+		}
 	}
+	return chosen;
+}
+
+static inline const char *modifier_id2name(int id)
+{
+	return (id >= 0 && id < SYNA_MOD_MAX) ?
+		ascii_names[id] : ascii_names[SYNA_MOD_MAX];
+}
+
+static struct config_modifier *modifier_by_id(
+	struct synaptics_rmi4_data *data, int id)
+{
+	struct config_modifier *cm, *found = NULL;
 
-	pr_debug("processing mode %s\n", mode_name);
-	propname = kasprintf(GFP_KERNEL, "touchmode-%s", mode_name);
-	prop = of_find_property(np_modes, propname, &size);
-	kfree(propname);
-	of_node_put(np_modes);
-	if (!prop) {
-		pr_err("can't find mode %s\n", mode_name);
-		ret = -EINVAL;
-		goto err;
+	down(&data->modifiers.list_sema);
+	list_for_each_entry(cm, &data->modifiers.mod_head, link) {
+		pr_debug("walk-thru: ptr=%p modifier[%s] id=%d\n",
+					cm, cm->name, cm->id);
+		if (cm->id == id) {
+			found = cm;
+			break;
+		}
 	}
-	list = prop->value;
-	size /= sizeof(*list);
+	up(&data->modifiers.list_sema);
+	pr_debug("returning modifier id=%d[%d]\n", found ? found->id : -1, id);
+	return found;
+}
 
-	if (size > MAX_NUM_STATES) {
-		pr_err("unexpected number of states %d\n", size);
-		ret = -EINVAL;
-		goto err;
+static int synaptics_dsx_dt_parse_modifiers(struct synaptics_rmi4_data *data)
+{
+	struct device *dev = &data->i2c_client->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *np_mod;
+	int i, num_names, ret = 0;
+	char node_name[64];
+	static const char **modifiers_names;
+
+	sema_init(&data->modifiers.list_sema, 1);
+	INIT_LIST_HEAD(&data->modifiers.mod_head);
+	data->modifiers.mods_num = 0;
+
+	num_names = of_property_count_strings(np, "config_modifier-names");
+	if (num_names < 0) {
+		dev_err(dev, "Cannot parse config_modifier-names: %d\n",
+			num_names);
+		return -ENODEV;
 	}
 
-	for (config = 0; config < size; config++) {
-		phandle = be32_to_cpup(list++);
+	modifiers_names = devm_kzalloc(dev,
+			sizeof(*modifiers_names) * num_names, GFP_KERNEL);
+	if (!modifiers_names)
+		return -ENOMEM;
 
-		/* Look up the touchstate configuration node */
-		np_config = of_find_node_by_phandle(phandle);
-		if (!np_config) {
-			dev_err(dev,
-				"prop %s index %i invalid phandle\n",
-				prop->name, config);
-			ret = -EINVAL;
-			goto err;
+	for (i = 0; i < num_names; i++) {
+		ret = of_property_read_string_index(np, "config_modifier-names",
+			i, &modifiers_names[i]);
+		if (ret < 0) {
+			dev_err(dev, "Cannot parse modifier-names: %d\n", ret);
+			return ret;
 		}
+	}
 
-		/* Parse the node */
-		ret = synaptics_dsx_dt_parse_state(data, np_config,
-				 mode->patch_data[config]);
-		of_node_put(np_config);
-		if (ret < 0)
-			goto err;
+	data->modifiers.mods_num = num_names;
+
+	for (i = 0; i < num_names; i++) {
+		int id;
+		struct config_modifier *cm, *config;
+
+		scnprintf(node_name, 63, "config_modifier-%s",
+				modifiers_names[i]);
+		np_mod = of_find_node_by_name(np, node_name);
+		if (!np_mod) {
+			dev_warn(dev, "cannot find modifier node %s\n",
+				node_name);
+			continue;
+		}
+
+		/* check for duplicate nodes in devtree */
+		id = modifier_name2id(modifiers_names[i]);
+		pr_err("processing modifier %s[%d]\n", node_name, id);
+		list_for_each_entry(cm, &data->modifiers.mod_head, link) {
+			if (cm->id == id) {
+				dev_err(dev, "duplicate modifier node %s\n",
+					node_name);
+				return -EFAULT;
+			}
+		}
+		/* allocate modifier's structure */
+		config = kzalloc(sizeof(*config), GFP_KERNEL);
+		if (!config)
+			return -ENOMEM;
+
+		list_add_tail(&config->link, &data->modifiers.mod_head);
+		config->name = modifiers_names[i];
+		config->id = id;
+
+		if (of_property_read_bool(np_mod, "enable-notification")) {
+			switch (id) {
+			case SYNA_MOD_FOLIO:
+				pr_notice("using folio detection\n");
+				data->folio_detection_enabled = true;
+				break;
+			case SYNA_MOD_CHARGER:
+				pr_notice("using charger detection\n");
+				data->charger_detection_enabled = true;
+				break;
+			case SYNA_MOD_FPS:
+				pr_notice("using fingerprint sensor detection\n");
+				data->fps_detection_enabled = true;
+				break;
+			case SYNA_MOD_WAKEUP:
+				pr_notice("using wakeup detection\n");
+				data->wakeup_detection_enabled = true;
+				break;
+			case SYNA_MOD_AOD:
+			case SYNA_MOD_STATS:
+				break;
+
+			}
+		} else {
+			config->effective = true;
+			dev_dbg(dev, "modifier %s enabled unconditionally\n",
+					node_name);
+		}
+
+		dev_dbg(dev, "processing modifier %s[%d]\n",
+				node_name, config->id);
+
+		synaptics_dsx_dt_parse_modifier(data, np_mod, config,
+				modifiers_names[i], true);
+		synaptics_dsx_dt_parse_modifier(data, np_mod, config,
+				modifiers_names[i], false);
+		of_node_put(np_mod);
 	}
-err:
-	return ret;
+
+	return 0;
 }
 
 static struct synaptics_dsx_platform_data *
@@ -1382,24 +1612,33 @@ static struct synaptics_dsx_platform_data *
 	struct synaptics_dsx_platform_data *pdata;
 	struct device_node *np = client->dev.of_node;
 	struct synaptics_dsx_cap_button_map *button_map = NULL;
-	struct synaptics_clip_area clip_area;
 
 	rmi4_data->patching_enabled = 1;
-	retval = synaptics_dsx_dt_parse_mode(rmi4_data, "default",
-			rmi4_data->default_mode);
-	if (retval) {
-		pr_warn("failed to load default mode\n");
+	retval = synaptics_dsx_dt_parse_modifiers(rmi4_data);
+	if (retval)
 		rmi4_data->patching_enabled = 0;
-	}
+	else {
+		force_update_patch = devm_kzalloc(&client->dev,
+				sizeof(struct synaptics_dsx_patch), GFP_KERNEL);
+		power_sleep_patch = devm_kzalloc(&client->dev,
+				sizeof(struct synaptics_dsx_patch), GFP_KERNEL);
 
-	if (rmi4_data->patching_enabled) {
-		retval = synaptics_dsx_dt_parse_mode(rmi4_data, "alternate",
-				rmi4_data->alternate_mode);
-		if (retval) {
-			pr_warn("alternate mode not found;"
-				" using default instead\n");
-			rmi4_data->alternate_mode = rmi4_data->default_mode;
-		}
+		if (!force_update_patch || !power_sleep_patch)
+			return NULL;
+
+		force_update_patch->name = "force-update";
+		force_update_patch->cfg_num = 1;
+		sema_init(&force_update_patch->list_sema, 1);
+		INIT_LIST_HEAD(&force_update_patch->cfg_head);
+		list_add(&force_update_func_patch.link,
+					&force_update_patch->cfg_head);
+
+		power_sleep_patch->name = "power-sleep";
+		power_sleep_patch->cfg_num = 1;
+		sema_init(&power_sleep_patch->list_sema, 1);
+		INIT_LIST_HEAD(&power_sleep_patch->cfg_head);
+		list_add(&power_sleep_func_patch.link,
+					&power_sleep_patch->cfg_head);
 	}
 
 	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
@@ -1464,11 +1703,6 @@ static struct synaptics_dsx_platform_data *
 		rmi4_data->purge_enabled = true;
 	}
 
-	if (of_property_read_bool(np, "synaptics,charger-detection")) {
-		pr_notice("using charger detection\n");
-		rmi4_data->charger_detection = true;
-	}
-
 	retval = of_property_read_u32(np,
 				"synaptics,aod-multi-touch", &u32_data);
 	if (!retval) {
@@ -1479,20 +1713,6 @@ static struct synaptics_dsx_platform_data *
 		rmi4_data->aod_mt = 1;
 	}
 
-	retval = of_property_read_u32_array(np,
-			"synaptics,touch-clip-area",
-			(unsigned *)&clip_area, 4);
-	if (!retval) {
-		rmi4_data->clipa = kzalloc(sizeof(clip_area), GFP_KERNEL);
-		if (!rmi4_data->clipa) {
-			dev_err(&client->dev, "clip area allocation failure\n");
-			return NULL;
-		}
-		memcpy(rmi4_data->clipa, &clip_area, sizeof(clip_area));
-		pr_notice("using touch clip area\n");
-	} else
-		dev_err(&client->dev, "clip area read failure\n");
-
 	if (of_property_read_bool(np, "synaptics,use-in-progress-event-blank")) {
 		pr_notice("using in progress event blank\n");
 		rmi4_data->event_blank = FB_IN_PROGRESS_EVENT_BLANK;
@@ -1799,8 +2019,10 @@ static int statistics_init(struct synaptics_rmi4_data *rmi4_data)
 	error = statistics_start_timekeeping(rmi4_data);
 	if (error < 0)
 		pr_err("statistics init failed\n");
-	else
+	else {
+		pr_notice("touch statistics enabled\n");
 		gStat.enabled = true;
+	}
 
 	return error;
 }
@@ -1893,21 +2115,24 @@ static ssize_t synaptics_rmi4_ic_ver_show(struct device *dev,
 static ssize_t synaptics_rmi4_poweron_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t synaptics_rmi4_query_idx_store(struct device *dev,
+static ssize_t synaptics_rmi4_mod_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_mod_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
-static ssize_t synaptics_rmi4_query_idx_show(struct device *dev,
+static ssize_t synaptics_rmi4_mod_sw_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
+static ssize_t synaptics_rmi4_mod_sw_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
 static ssize_t synaptics_rmi4_query_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
 static ssize_t synaptics_rmi4_query_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t synaptics_rmi4_patch_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
 static ssize_t synaptics_rmi4_reporting_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
@@ -2069,15 +2294,15 @@ static struct device_attribute attrs[] = {
 	__ATTR(poweron, S_IRUSR | S_IRGRP,
 			synaptics_rmi4_poweron_show,
 			synaptics_rmi4_store_error),
-	__ATTR(query_idx, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
-			synaptics_rmi4_query_idx_show,
-			synaptics_rmi4_query_idx_store),
+	__ATTR(mod, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_mod_show,
+			synaptics_rmi4_mod_store),
+	__ATTR(mod_sw, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_mod_sw_show,
+			synaptics_rmi4_mod_sw_store),
 	__ATTR(query, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
 			synaptics_rmi4_query_show,
 			synaptics_rmi4_query_store),
-	__ATTR(patch, S_IWUSR | S_IWGRP,
-			synaptics_rmi4_show_error,
-			synaptics_rmi4_patch_store),
 	__ATTR(tsi, S_IRUSR | S_IRGRP,
 			synaptics_rmi4_ud_show,
 			synaptics_rmi4_store_error),
@@ -2232,6 +2457,9 @@ static int synaptics_dsx_alloc_input(struct synaptics_rmi4_data *rmi4_data)
 	rmi4_data->input_dev->dev.parent = &rmi4_data->i2c_client->dev;
 
 	set_bit(EV_SYN, rmi4_data->input_dev->evbit);
+	/* enable power key injection */
+	set_bit(EV_KEY, rmi4_data->input_dev->evbit);
+	input_set_capability(rmi4_data->input_dev, EV_KEY, KEY_POWER);
 
 	pr_debug("allocated input device\n");
 
@@ -2259,9 +2487,8 @@ static void synaptics_copy_multiple_subpkts(
 	pr_debug("%s misalignement detected\n", !leftover ? "no" : "");
 }
 
-static void synaptics_dsx_patch_func(
-		struct synaptics_rmi4_data *rmi4_data,
-		int f_number,
+static void synaptics_dsx_patch_function(
+		struct synaptics_rmi4_data *rmi4_data, int f_number,
 		struct synaptics_dsx_patch *patch)
 {
 	int r, error, function;
@@ -2403,71 +2630,90 @@ static void synaptics_dsx_enable_wakeup_source(
 	pr_debug("%s wakeup; rc=%d\n", enable ? "enabled" : "disabled", error);
 }
 
-static inline void synaptics_dsx_set_alternate_mode(
-		struct synaptics_rmi4_data *rmi4_data,
-		struct synaptics_dsx_patchset *mode,
-		bool wakeable, bool persistent)
-{
-	rmi4_data->mode_is_wakeable = wakeable;
-	rmi4_data->mode_is_persistent = persistent;
-	rmi4_data->current_mode = mode;
-	if (wakeable)
-		synaptics_dsx_enable_wakeup_source(rmi4_data, true);
-	pr_debug("set alternate mode\n");
-}
+static const char * const synaptics_state_names[] = {"UNKNOWN",
+	"ACTIVE", "SUSPEND", "UNUSED", "STANDBY", "BL", "INIT",
+	"FLASH", "QUERY", "INVALID" };
 
-static inline void synaptics_dsx_restore_default_mode(
-		struct synaptics_rmi4_data *rmi4_data)
+static const char *synaptics_dsx_state_name(int state)
 {
-	if (rmi4_data->mode_is_wakeable)
-		synaptics_dsx_enable_wakeup_source(rmi4_data, false);
-	rmi4_data->mode_is_wakeable = false;
-	rmi4_data->mode_is_persistent = true;
-	rmi4_data->current_mode = rmi4_data->default_mode;
-	pr_debug("set default mode\n");
+	int index = state < 0 || state > STATE_INVALID ? STATE_INVALID : state;
+	return synaptics_state_names[index];
 }
 
-static void synaptics_dsx_state_config(
+static void synaptics_dsx_apply_modifiers(
 		struct synaptics_rmi4_data *rmi4_data, int state)
 {
+	bool wakeup = false, update = false, sleep = false;
 	int i;
-	struct synaptics_dsx_patch *patch =
-			rmi4_data->current_mode->patch_data[state];
 
-	if (!patch || !patch->cfg_num) {
+	if (!rmi4_data->modifiers.mods_num) {
 		pr_debug("patchset is empty!\n");
-		goto nothing_to_patch;
+		goto no_modifiers;
 	}
 
-	if (rmi4_data->mode_is_wakeable)
-		synaptics_dsx_enable_wakeup_source(rmi4_data, true);
+	down(&rmi4_data->modifiers.list_sema);
+	for (i = 0; i < ARRAY_SIZE(synaptics_cfg_regs); i++) {
+		struct config_modifier *cm;
+
+		/* skip query registers */
+		if (synaptics_cfg_regs[i].f_number & QUERY_TYPE)
+			continue;
+
+		list_for_each_entry(cm, &rmi4_data->modifiers.mod_head, link) {
+			struct synaptics_dsx_patch *patch = NULL;
 
-	if (rmi4_data->patching_enabled) {
-		for (i = 0; i < ARRAY_SIZE(synaptics_cfg_regs); i++)
-			synaptics_dsx_patch_func(rmi4_data,
+			/* skip disabled modifiers */
+			if (!cm->effective)
+				continue;
+
+			if (state == STATE_ACTIVE)
+				patch = cm->active;
+			else if (state == STATE_SUSPEND)
+				patch = cm->suspended;
+
+			/* skip effective modifier without patch */
+			if (!patch)
+				continue;
+
+			/* keep track of flags among effective modifiers */
+			if (!update && (patch->flags & FLAG_FORCE_UPDATE))
+				update = true;
+			if (!wakeup && (patch->flags & FLAG_WAKEABLE))
+				wakeup = true;
+			if (!sleep && (patch->flags & FLAG_POWER_SLEEP))
+				sleep = true;
+			/* finally apply patch */
+			synaptics_dsx_patch_function(rmi4_data,
 				synaptics_cfg_regs[i].f_number, patch);
+		}
+	}
+	up(&rmi4_data->modifiers.list_sema);
+
+	/* force update regardless the current state */
+	if (update && force_update_patch)
+		synaptics_dsx_patch_function(rmi4_data,
+			SYNAPTICS_RMI4_F54 | COMMAND_TYPE, force_update_patch);
+
+	/* power mode and wakeability only on entering suspend */
+	if (state == STATE_SUSPEND) {
+		if (wakeup) {
+			rmi4_data->suspend_is_wakeable = true;
+			synaptics_dsx_enable_wakeup_source(rmi4_data, true);
+		} else if (sleep && power_sleep_patch)
+			synaptics_dsx_patch_function(rmi4_data,
+				SYNAPTICS_RMI4_F01, power_sleep_patch);
+	}
 
-		pr_debug("applied %s in mode %s\n",
-			state == ACTIVE_IDX ? "ACTIVE" : "SUSPEND",
-			rmi4_data->current_mode == rmi4_data->default_mode ?
-			"DEFAULT" : "OTHER");
+	if (!wakeup && rmi4_data->suspend_is_wakeable) {
+		rmi4_data->suspend_is_wakeable = false;
+		synaptics_dsx_enable_wakeup_source(rmi4_data, false);
 	}
 
-nothing_to_patch:
+no_modifiers:
 	/* keep page 0 active */
 	synaptics_rmi4_set_page(rmi4_data, 0);
 }
 
-static const char * const synaptics_state_names[] = {"UNKNOWN",
-	"ACTIVE", "SUSPEND", "UNUSED", "STANDBY", "BL", "INIT",
-	"FLASH", "QUERY", "INVALID" };
-
-static const char *synaptics_dsx_state_name(int state)
-{
-	int index = state < 0 || state > STATE_INVALID ? STATE_INVALID : state;
-	return synaptics_state_names[index];
-}
-
 static int synaptics_dsx_get_state_safe(struct synaptics_rmi4_data *rmi4_data)
 {
 	int state;
@@ -2553,6 +2799,29 @@ static int synaptics_dsx_sensor_ready_state(
 	return 0;
 }
 
+static void synaptics_dsx_enforce_modifiers(
+		struct synaptics_rmi4_data *rmi4_data,
+		struct config_modifier *modifier)
+{
+	int error, state = synaptics_dsx_get_state_safe(rmi4_data);
+
+	if (state == STATE_ACTIVE) {
+		if (!modifier->active)
+			return;
+		/* set unknown state to ensure IRQ gets */
+		/* enabled on state transition to active */
+		synaptics_dsx_sensor_state(rmi4_data, STATE_UNKNOWN);
+		/* disable IRQ to handle reset */
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+		/* perform SW reset to restore defaults */
+		error = synaptics_dsx_ic_reset(rmi4_data, RMI4_SW_RESET);
+		if (error < 0)
+			dev_err(&rmi4_data->i2c_client->dev,
+				"folio: sw reset failed %d\n", error);
+	}
+	synaptics_dsx_sensor_ready_state(rmi4_data, false);
+}
+
 static void synaptics_dsx_sensor_state(struct synaptics_rmi4_data *rmi4_data,
 		int state)
 {
@@ -2567,15 +2836,17 @@ static void synaptics_dsx_sensor_state(struct synaptics_rmi4_data *rmi4_data,
 
 	case STATE_SUSPEND:
 		synaptics_dsx_wait_for_idle(rmi4_data);
-		if (!rmi4_data->mode_is_wakeable)
-			synaptics_rmi4_irq_enable(rmi4_data, false);
+
 		if (!rmi4_data->in_bootloader)
-			synaptics_dsx_state_config(rmi4_data, SUSPEND_IDX);
+			synaptics_dsx_apply_modifiers(rmi4_data, STATE_SUSPEND);
+
+		if (!rmi4_data->suspend_is_wakeable)
+			synaptics_rmi4_irq_enable(rmi4_data, false);
 			break;
 
 	case STATE_ACTIVE:
 		if (!rmi4_data->in_bootloader)
-			synaptics_dsx_state_config(rmi4_data, ACTIVE_IDX);
+			synaptics_dsx_apply_modifiers(rmi4_data, STATE_ACTIVE);
 
 		if (rmi4_data->input_registered)
 			synaptics_rmi4_irq_enable(rmi4_data, true);
@@ -2584,11 +2855,6 @@ static void synaptics_dsx_sensor_state(struct synaptics_rmi4_data *rmi4_data,
 			pr_err("Active state without input device\n");
 		}
 
-		if (!rmi4_data->mode_is_persistent) {
-			synaptics_dsx_restore_default_mode(rmi4_data);
-			pr_debug("Non-persistent mode; restoring default\n");
-		}
-
 		if (gStat.enabled)
 			statistics_start_timekeeping(rmi4_data);
 			break;
@@ -3202,137 +3468,461 @@ static ssize_t synaptics_rmi4_ic_ver_show(struct device *dev,
 			"Config ID: ", config_id);
 }
 
-static ssize_t synaptics_rmi4_poweron_show(struct device *dev,
+static ssize_t synaptics_rmi4_poweron_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	return scnprintf(buf, PAGE_SIZE, "%d\n",
+		atomic_read(&rmi4_data->touch_stopped) == 0 &&
+		rmi4_data->flash_enabled);
+}
+
+static ssize_t synaptics_dsx_patch_dump(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_dsx_patch *patch,
+	char *pout, ssize_t msize)
+{
+	struct synaptics_dsx_func_patch *fp;
+	ssize_t blen = 0;
+
+	down(&patch->list_sema);
+	list_for_each_entry(fp, &patch->cfg_head, link) {
+		int i;
+		unsigned int data_size = fp->size;
+		unsigned char *value = fp->data;
+
+		blen += scnprintf(pout + blen, msize - blen,
+			"F%02x%c@%d:%d=", fp->func & 0xff,
+			register_type_to_ascii(fp->func & 0xf00),
+			fp->regstr, fp->subpkt);
+
+		for (i = 0; i < data_size; i++)
+			blen += scnprintf(pout + blen, msize - blen,
+					"%02x", *value++);
+		if (fp->bitmask)
+			blen += scnprintf(pout + blen, msize - blen,
+				"&%02x", fp->bitmask);
+		blen += scnprintf(pout + blen, msize - blen, "; ");
+	}
+	up(&patch->list_sema);
+
+	if (patch->flags & FLAG_FORCE_UPDATE)
+		blen += scnprintf(pout + blen, msize - blen, "U; ");
+	if (patch->flags & FLAG_WAKEABLE)
+		blen += scnprintf(pout + blen, msize - blen, "W; ");
+	if (patch->flags & FLAG_POWER_SLEEP)
+		blen += scnprintf(pout + blen, msize - blen, "S; ");
+	blen += scnprintf(pout + blen, msize - blen, "\n");
+
+	return blen;
+}
+
+static ssize_t synaptics_dsx_patch_query(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_dsx_patch *patch,
+	char *pout, ssize_t msize)
+{
+	struct synaptics_dsx_func_patch *fp;
+	ssize_t blen = 0;
+
+	down(&patch->list_sema);
+	list_for_each_entry(fp, &patch->cfg_head, link) {
+		struct synaptics_rmi4_func_packet_regs *regs;
+		struct synaptics_rmi4_packet_reg *reg;
+		int i, error, function;
+		unsigned short data_addr;
+		unsigned int data_size;
+		unsigned char *value, rt_mod;
+
+		regs = find_function(fp->func);
+		if (!regs)
+			continue;
+		reg = find_packet_reg(regs, fp->regstr);
+		if (!reg || reg->offset < 0) {
+			pr_err("F%x@%d not present\n", fp->func, fp->regstr);
+			continue;
+		}
+
+		rt_mod = register_type_to_ascii(fp->func & 0xf00);
+		function = fp->func & 0xff;
+
+		error = synaptics_rmi4_read_packet_reg(rmi4_data,
+				regs, reg->r_number);
+		if (error < 0) {
+			pr_err("F%x@%d register read failed\n",
+				function, fp->regstr);
+			continue;
+		}
+		/* calculate register address */
+		data_addr = regs->base_addr + reg->offset;
+		/* dump whole register if subpacket is 255 */
+		if (fp->subpkt == 0xff) {
+			value = reg->data;
+			data_size = reg->size;
+			blen += scnprintf(pout + blen, msize - blen,
+				"F%x%c@%d{%X}=",
+				function, rt_mod, fp->regstr, data_addr);
+		} else {
+			struct synaptics_rmi4_subpkt *subpkt;
+
+			subpkt = reg->subpkt + fp->subpkt;
+			value = (unsigned char *)subpkt->data;
+			data_size = subpkt->size;
+			data_addr += subpkt->offset;
+			blen += scnprintf(pout + blen, msize - blen,
+				"F%x%c@%d:%d{%X}=",
+				function, rt_mod, fp->regstr,
+				fp->subpkt, data_addr);
+		}
+
+		for (i = 0; i < data_size; i++)
+			blen += scnprintf(pout + blen, msize - blen,
+				"%02x", *value++);
+		blen += scnprintf(pout + blen, msize - blen, "; ");
+	}
+	up(&patch->list_sema);
+	blen += scnprintf(pout + blen, msize - blen, "\n");
+	return blen;
+}
+
+static ssize_t modifiers_show(struct synaptics_rmi4_data *rmi4_data,
+	char *buf, size_t count, bool show_data, bool show_query)
+{
+	struct config_modifier *cm;
+	ssize_t (*handler)(struct synaptics_rmi4_data *,
+			   struct synaptics_dsx_patch *,
+			   char *, ssize_t);
+	ssize_t added, blen = 0;
+
+	if (!rmi4_data->modifiers.mods_num) {
+		pr_debug("patchset is empty!\n");
+		return 0;
+	}
+
+	down(&rmi4_data->modifiers.list_sema);
+	list_for_each_entry(cm, &rmi4_data->modifiers.mod_head, link) {
+		const char *name = cm->name ? cm->name : "na";
+		bool is_query = cm->id == SYNA_MOD_QUERY;
+
+		/* skip printing modifiers, but query */
+		if (!is_query && show_query)
+			continue;
+		blen += scnprintf(buf + blen, count - blen, "%c[%s]\n",
+					cm->effective ? '+' : '-', name);
+		if (!show_data)
+			continue;
+
+		if (is_query && show_query)
+			handler = &synaptics_dsx_patch_query;
+		else
+			handler = &synaptics_dsx_patch_dump;
+
+		if (cm->active) {
+			blen += scnprintf(buf + blen,
+					count - blen, " [active]");
+			added = (*handler)(rmi4_data, cm->active,
+					buf + blen, count - blen);
+			blen += added;
+			count -= added;
+		}
+
+		if (cm->clipa) {
+			blen += scnprintf(buf + blen, count - blen,
+				" [clip]<%u,%u,%u,%u>%s\n",
+				cm->clipa->xul_clip, cm->clipa->yul_clip,
+				cm->clipa->xbr_clip, cm->clipa->ybr_clip,
+				cm->clipa->inversion ? "in" : "out");
+		}
+
+		if (cm->suspended) {
+			blen += scnprintf(buf + blen,
+					count - blen, " [suspended]");
+			added = (*handler)(rmi4_data, cm->suspended,
+					buf + blen, count - blen);
+			blen += added;
+			count -= added;
+		}
+	}
+	up(&rmi4_data->modifiers.list_sema);
+
+	return blen;
+}
+
+#define NAME_ID		0
+#define ACTION_ID	1
+
+static ssize_t synaptics_rmi4_mod_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct synaptics_dsx_patch **patch_ptr, *patch;
+	struct config_modifier *cm;
+	bool clear_only = false;
+	int id, bytes_left, ntokens = 0;
+	char *internal, *ptr, *token[2] = {0};
+
+	internal = kstrdup(buf, GFP_KERNEL);
+	for (ptr = internal; ntokens < 2; ntokens++) {
+		bytes_left = count - (ptr - internal);
+		ptr = strnchr(ptr, bytes_left, '[');
+		if (!ptr)
+			break;
+		token[ntokens] = ++ptr;	/* advance to the name */
+		bytes_left = count - (ptr - internal);
+		ptr = strnchr(ptr, bytes_left, ']');
+		if (ptr)
+			*ptr++ = 0;
+		dev_dbg(dev, "token[%d]='%s'\n", ntokens, token[ntokens]);
+	}
+
+	if (*buf != '[' && ntokens != 2) {
+		dev_err(dev, "invalid modifier syntax\n");
+		count = -EINVAL;
+		goto leave_now;
+	}
+
+	id = modifier_name2id(token[NAME_ID]);
+	switch (id) {
+	case SYNA_MOD_QUERY:
+		dev_err(dev, "use query attribute instead\n");
+		count = -EINVAL;
+		break;
+	case -1:
+		dev_err(dev, "[%s] is invalid modifier\n", token[NAME_ID]);
+		count = -EINVAL;
+		break;
+	}
+
+	if (count == -EINVAL)
+		goto leave_now;
+
+	/* pointer has been advanced in the loop above to point to patch */
+	if (*ptr == '\n')
+		clear_only = true;
+
+	cm = modifier_by_id(rmi4_data, id);
+	if (!cm) {
+		if (clear_only)
+			goto leave_now;
+
+		dev_info(dev, "allocating modifier [%s]\n", token[NAME_ID]);
+		cm = kzalloc(sizeof(*cm), GFP_KERNEL);
+		if (!cm) {
+			count = -ENOMEM;
+			goto leave_now;
+		}
+
+		down(&rmi4_data->modifiers.list_sema);
+		list_add_tail(&cm->link, &rmi4_data->modifiers.mod_head);
+		up(&rmi4_data->modifiers.list_sema);
+		rmi4_data->modifiers.mods_num++;
+		cm->name = ascii_names[id];
+		cm->id = id;
+	}
+
+	if (!strncmp(token[ACTION_ID], "clip", 4)) {
+		bool clipping_is_active = false;
+		struct synaptics_clip_area clipa;
+
+		if (cm->clipa) {
+			if (rmi4_data->clipping_on &&
+				rmi4_data->clipa == cm->clipa) {
+				/* if currently effective clipping */
+				/* is the one being edited */
+				rmi4_data->clipa = NULL;
+				clipping_is_active = true;
+			}
+			kfree(cm->clipa);
+		}
+
+		if (clear_only) {
+			if (clipping_is_active) {
+				rmi4_data->clipping_on = false;
+				pr_debug("removed [clip] from modifier [%s]\n",
+					token[NAME_ID]);
+			}
+			goto leave_now;
+		}
+
+		ntokens = sscanf(ptr, "<%u %u %u %u %u>", &clipa.xul_clip,
+				&clipa.yul_clip, &clipa.xbr_clip,
+				&clipa.ybr_clip, &clipa.inversion);
+		if (ntokens != 5) {
+			dev_err(dev, "Invalid clip area modifier\n");
+			goto leave_now;
+		}
+
+		if (!cm->clipa) {
+			cm->clipa = kzalloc(sizeof(clipa), GFP_KERNEL);
+			if (!cm->clipa) {
+				count = -ENOMEM;
+				goto leave_now;
+			}
+		}
+
+		memcpy(cm->clipa, &clipa, sizeof(clipa));
+
+		if (clipping_is_active)
+			rmi4_data->clipa = cm->clipa;
+
+		pr_debug("added [clip] area to modifier [%s]\n",
+			token[NAME_ID]);
+		goto leave_now;
+	}
+
+	if (!strncmp(token[ACTION_ID], "active", 6))
+		patch_ptr = &cm->active;
+	else
+		patch_ptr = &cm->suspended;
+
+	if (*patch_ptr) {
+		synaptics_dsx_free_patch(*patch_ptr);
+		*patch_ptr = NULL;
+	}
+
+	if (clear_only) {
+		pr_debug("removed [%s] from modifier [%s]\n",
+			token[ACTION_ID], token[NAME_ID]);
+		goto apply_and_leave;
+	}
+
+	patch = synaptics_dsx_init_patch(token[ACTION_ID]);
+	if (!patch) {
+		count = -ENOMEM;
+		goto leave_now;
+	}
+
+	synaptics_dsx_parse_string(rmi4_data, ptr, patch, true);
+	*patch_ptr = patch;
+	pr_debug("added [%s] patch to modifier [%s]\n",
+		token[ACTION_ID], token[NAME_ID]);
+apply_and_leave:
+	if (!rmi4_data->in_bootloader)
+		synaptics_dsx_enforce_modifiers(rmi4_data, cm);
+leave_now:
+	kfree(internal);
+	return count;
+}
+
+static ssize_t synaptics_rmi4_mod_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct synaptics_rmi4_data *rmi4_data =
-					i2c_get_clientdata(to_i2c_client(dev));
-	return scnprintf(buf, PAGE_SIZE, "%d\n",
-		atomic_read(&rmi4_data->touch_stopped) == 0 &&
-		rmi4_data->flash_enabled);
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return modifiers_show(rmi4_data, buf, PAGE_SIZE, true, false);
 }
 
-static struct synaptics_dsx_patch *query_data;
-static unsigned int query_index;
+static ssize_t synaptics_rmi4_mod_sw_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int id;
+	bool set_op;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct config_modifier *cm;
+	char mod_name[32];
 
-#define SPRINTF_RANGE(fmt, args...) {\
-		blen += scnprintf(out + blen, count - blen, fmt, ##args);\
+	if (*buf != '+' && *buf != '-') {
+		dev_err(dev, "invalid modifier syntax\n");
+		return -EINVAL;
 	}
 
-static ssize_t synaptics_dsx_patch_dump(
-	struct synaptics_rmi4_data *rmi4_data, char *out, ssize_t count)
-{
-	int i;
-	const char *name;
-	struct synaptics_dsx_func_patch *fp;
-	ssize_t blen = 0;
+	set_op = *buf == '-' ? false : true;
+	if (sscanf(buf + 1, "[%s]", mod_name) != 1) {
+		dev_err(dev, "unable to read modifier name\n");
+		return -EINVAL;
+	}
 
-	if (!query_data) {
-		SPRINTF_RANGE("nothing to query\n");
-		goto time_to_leave;
+	id = modifier_name2id(mod_name);
+	if (id == -1) {
+		dev_err(dev, "invalid modifier name '%s'\n", mod_name);
+		return -EINVAL;
 	}
-	name = query_data->name ? query_data->name : "noname";
-	SPRINTF_RANGE("[%s", name);
-	if (!strnstr(name, "runtime", 7))
-		SPRINTF_RANGE("-%s", !query_index ? "active" : "suspended");
-	SPRINTF_RANGE("] ");
-	list_for_each_entry(fp, &query_data->cfg_head, link) {
-		struct synaptics_rmi4_func_packet_regs *regs;
-		struct synaptics_rmi4_packet_reg *reg;
-		int error;
-		unsigned short data_addr;
-		unsigned int data_size;
-		unsigned char *value;
 
-		regs = find_function(fp->func);
-		if (!regs)
-			continue;
-		reg = find_packet_reg(regs, fp->regstr);
-		if (!reg || reg->offset < 0) {
-			pr_err("F%x@%d not present\n", fp->func, fp->regstr);
-			continue;
-		}
+	cm = modifier_by_id(rmi4_data, id);
+	if (!cm) {
+		dev_err(dev, "modifier with id=%d does not exist\n", id);
+		return -EINVAL;
+	}
 
-		error = synaptics_rmi4_read_packet_reg(rmi4_data,
-				regs, reg->r_number);
-		if (error < 0) {
-			pr_err("F%x@%d register read failed\n",
-				fp->func, fp->regstr);
-			continue;
-		}
-		/* calculate register address */
-		data_addr = regs->base_addr + reg->offset;
-		/* dump whole register if subpacket is 255 */
-		if (fp->subpkt == 0xff) {
-			value = reg->data;
-			data_size = reg->size;
-			SPRINTF_RANGE("F%x@%d{%X}=",
-				fp->func, fp->regstr, data_addr);
-		} else {
-			struct synaptics_rmi4_subpkt *subpkt;
-			subpkt = reg->subpkt + fp->subpkt;
-			value = (unsigned char *)subpkt->data;
-			data_size = subpkt->size;
-			data_addr += subpkt->offset;
-			SPRINTF_RANGE("F%x@%d:%d{%X}=",
-				fp->func, fp->regstr, fp->subpkt, data_addr);
+	if (cm->effective != set_op) {
+		cm->effective = set_op;
+		pr_debug("set [%s] %s\n", cm->name,
+				cm->effective ? "on" : "off");
+
+		if (cm->effective) {
+			if (cm->clipa) {
+				rmi4_data->clipping_on = true;
+				rmi4_data->clipa = cm->clipa;
+				pr_debug("enable clipping in [%s]\n", cm->name);
+			}
+		} else if (cm->clipa && rmi4_data->clipa == cm->clipa) {
+			rmi4_data->clipping_on = false;
+			rmi4_data->clipa = NULL;
+			pr_debug("disable clipping in [%s]\n", cm->name);
 		}
 
-		for (i = 0; i < data_size; i++)
-			SPRINTF_RANGE("%02x", *value++);
-		SPRINTF_RANGE("; ");
+		if (!rmi4_data->in_bootloader)
+			synaptics_dsx_enforce_modifiers(rmi4_data, cm);
 	}
-	SPRINTF_RANGE("\n");
-time_to_leave:
-	return blen;
-}
-
-static ssize_t synaptics_rmi4_query_idx_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int index;
-	if (sscanf(buf, "%u", &index) != 1)
-		return -EINVAL;
-	query_index = index > 0 ? 1 : 0;
-	pr_debug("index setup to %u\n", query_index);
 	return count;
 }
 
-static ssize_t synaptics_rmi4_query_idx_show(struct device *dev,
+static ssize_t synaptics_rmi4_mod_sw_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return scnprintf(buf, PAGE_SIZE, "%s\n",
-			!query_index ? "active" : "suspended");
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return modifiers_show(rmi4_data, buf, PAGE_SIZE, false, false);
 }
 
+/* NOTE: query is stored in active */
 static ssize_t synaptics_rmi4_query_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
 	struct synaptics_dsx_patch *patch;
+	struct config_modifier *cm = modifier_by_id(rmi4_data, SYNA_MOD_QUERY);
+
+	if (!cm) {
+		dev_info(dev, "allocating modifier [%s]\n",
+			modifier_id2name(SYNA_MOD_QUERY));
+		cm = kzalloc(sizeof(*cm), GFP_KERNEL);
+		if (!cm) {
+			dev_err(dev, "Cannot allocate query modifier\n");
+			return -ENOMEM;
+		}
+
+		down(&rmi4_data->modifiers.list_sema);
+		list_add_tail(&cm->link, &rmi4_data->modifiers.mod_head);
+		up(&rmi4_data->modifiers.list_sema);
+		rmi4_data->modifiers.mods_num++;
+		cm->name = ascii_names[SYNA_MOD_QUERY];
+		cm->id = SYNA_MOD_QUERY;
+	}
 
 	if (*buf == '\n') {
-		if (query_data) {
-			synaptics_dsx_free_patch(query_data);
-			query_data = NULL;
+		if (cm->active) {
+			synaptics_dsx_free_patch(cm->active);
+			cm->active = NULL;
 			pr_debug("discarded current query\n");
 		}
 		goto leave_now;
 	}
+
 	if (*buf != 'F') {
-		pr_err("invalid query syntax\n");
+		dev_err(dev, "invalid query syntax\n");
 		return -EINVAL;
 	}
-	patch = synaptics_dsx_init_patch("sysfs-runtime");
+
+	patch = synaptics_dsx_init_patch(ascii_names[SYNA_MOD_QUERY]);
 	if (!patch)
 		return -ENOMEM;
+
 	synaptics_dsx_parse_string(rmi4_data, buf, patch, false);
-	if (query_data) {
-		synaptics_dsx_free_patch(query_data);
-		pr_debug("previous query discarded\n");
-	}
-	query_data = patch;
+	cm->active = patch;
 	pr_debug("new query added\n");
+
 leave_now:
 	return count;
 }
@@ -3341,53 +3931,9 @@ static ssize_t synaptics_rmi4_query_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
-	bool clear_after_use = false;
-	ssize_t length;
-
-	if (!query_data) {
-		query_data = rmi4_data->current_mode->patch_data[query_index];
-		clear_after_use = true;
-	}
-	length = synaptics_dsx_patch_dump(rmi4_data, buf, PAGE_SIZE);
-	if (clear_after_use)
-		query_data = NULL;
-	return length;
-}
-
-static ssize_t synaptics_rmi4_patch_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
-	struct synaptics_dsx_patch *patch;
+	struct config_modifier *cm = modifier_by_id(rmi4_data, SYNA_MOD_QUERY);
 
-	if (*buf == '\n') {
-		pr_debug("discarding %s patch set from %s mode\n",
-			!query_index ? "active" : "suspended",
-			rmi4_data->current_mode == rmi4_data->default_mode ?
-			"default" : "alternate");
-		synaptics_dsx_free_patch(
-			rmi4_data->current_mode->patch_data[query_index]);
-		patch = synaptics_dsx_init_patch("sysfs");
-		rmi4_data->current_mode->patch_data[query_index] = patch;
-		goto leave_now;
-	}
-	if (*buf != 'F') {
-		pr_err("invalid patch syntax\n");
-		return -EINVAL;
-	}
-	patch = synaptics_dsx_init_patch("sysfs");
-	if (!patch)
-		return -ENOMEM;
-	synaptics_dsx_parse_string(rmi4_data, buf, patch, true);
-	synaptics_dsx_free_patch(
-		rmi4_data->current_mode->patch_data[query_index]);
-	rmi4_data->current_mode->patch_data[query_index] = patch;
-	pr_debug("[sysfs-%s] patch set added to %s mode\n",
-		!query_index ? "active" : "suspended",
-		rmi4_data->current_mode == rmi4_data->default_mode ?
-				"default" : "alternate");
-leave_now:
-	return count;
+	return !cm ? 0 : modifiers_show(rmi4_data, buf, PAGE_SIZE, true, true);
 }
 
  /**
@@ -3549,6 +4095,45 @@ exit:
 	return retval;
 }
 
+static int synaptics_rmi4_f12_wakeup_gesture(
+		struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	struct synaptics_rmi4_packet_reg *reg_data_4 =
+			&rmi4_data->f12_data_registers_ptr->regs[F12_D4_IDX];
+
+	if (reg_data_4->offset == -1) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"unable to clear wakeup gesture IRQ\n");
+		return -EINVAL;
+	}
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			fhandler->full_addr.data_base + reg_data_4->offset,
+			&f12_d4_0.gesture, sizeof(f12_d4_0));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"failure clearing wakeup gesture IRQ rc=%d\n", retval);
+		return retval;
+	}
+
+	dev_dbg(&rmi4_data->i2c_client->dev,
+		"wakeup gesture status=0x%02x\n", f12_d4_0.gesture);
+
+	if (f12_d4_0.gesture & DOUBLE_TAP_GESTURE) {
+		/* emulate power key press */
+		input_report_key(rmi4_data->input_dev, KEY_POWER, 1);
+		input_report_key(rmi4_data->input_dev, KEY_POWER, 0);
+		input_sync(rmi4_data->input_dev);
+
+		dev_dbg(&rmi4_data->i2c_client->dev,
+			"DBL_TAP wakeup gesture detected\n");
+	}
+
+	return 0;
+}
+
  /**
  * synaptics_rmi4_f12_abs_report()
  *
@@ -3579,9 +4164,9 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 	struct timespec hw_time = ktime_to_timespec(ktime_get());
 	struct f12_d1_type *finger_data;
 	struct synaptics_rmi4_packet_reg *reg_data_1 =
-				&rmi4_data->f12_data_registers_ptr->regs[0];
+			&rmi4_data->f12_data_registers_ptr->regs[F12_D1_IDX];
 	struct synaptics_rmi4_packet_reg *reg_data_15 =
-				&rmi4_data->f12_data_registers_ptr->regs[1];
+			&rmi4_data->f12_data_registers_ptr->regs[F12_D15_IDX];
 #ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
 	unsigned char number_of_fingers_actually_touching = 0;
 #endif
@@ -3685,17 +4270,10 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 					(x <= rmi4_data->clipa->xbr_clip) &&
 					(y >= rmi4_data->clipa->yul_clip) &&
 					(y <= rmi4_data->clipa->ybr_clip);
-/*
-				if (!inside) {
-					dev_dbg(&rmi4_data->i2c_client->dev,
-						"%d,%d ouside clipping area\n",
-						x, y);
-					continue;
-				}
-*/
-				if (inside) {
+
+				if (inside == rmi4_data->clipa->inversion) {
 					dev_dbg(&rmi4_data->i2c_client->dev,
-						"%d,%d inside clipping area\n",
+						"%d,%d belong clipping area\n",
 						x, y);
 					continue;
 				}
@@ -4259,11 +4837,17 @@ static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data,
 		break;
 
 	case SYNAPTICS_RMI4_F12:
+		if (rmi4_data->suspend_is_wakeable) {
+			synaptics_rmi4_f12_wakeup_gesture(rmi4_data, fhandler);
+			break;
+		}
+
 		synaptics_dsx_resumeinfo_isr(rmi4_data);
 
 		touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,
 				fhandler);
 
+
 		*touch_count += touch_count_2d;
 
 		if (touch_count_2d)
@@ -5685,8 +6269,7 @@ static int control_access_block_update_dynamic(
 {
 	int i;
 	struct touch_control_access_block *cab = control_access_block_get();
-	struct synaptics_dsx_patch *patch =
-			rmi4_data->current_mode->patch_data[SUSPEND_IDX];
+	struct synaptics_dsx_patch *patch = NULL;
 
 	if (!rmi4_data->patching_enabled || !cab || !patch || !patch->cfg_num) {
 		pr_debug("nothing to add to control access block\n");
@@ -5696,10 +6279,15 @@ static int control_access_block_update_dynamic(
 	control_access_block_zap(SYN_DSX_CONFIG);
 
 	for (i = 0; i < ARRAY_SIZE(synaptics_cfg_regs); i++) {
-		int f_number = synaptics_cfg_regs[i].f_number;
+		int f_number;
 		struct synaptics_dsx_func_patch *fp;
-		struct synaptics_rmi4_func_packet_regs *regs =
-						find_function(f_number);
+		struct synaptics_rmi4_func_packet_regs *regs;
+
+		/* skip query registers */
+		if (synaptics_cfg_regs[i].f_number & QUERY_TYPE)
+			continue;
+		f_number = synaptics_cfg_regs[i].f_number;
+		regs = find_function(f_number);
 
 		list_for_each_entry(fp, &patch->cfg_head, link) {
 			struct synaptics_rmi4_subpkt *subpkt;
@@ -5720,6 +6308,8 @@ static int control_access_block_update_dynamic(
 				continue;
 
 			/* exclude power control from patch set */
+			/* TODO: with modifiers introduced, this */
+			/* check might not be necessary anymore */
 			if (fp->func == SYNAPTICS_RMI4_F01 &&
 				fp->regstr == 0 && fp->subpkt == 0)
 				continue;
@@ -5765,21 +6355,25 @@ static void synaptics_rmi4_detection_work(struct work_struct *work)
 		return;
 	}
 
-	if (!rmi4_data->is_fps_registered &&
-		fps_registered_retry < SYN_FPS_REGISTERED_RETRY_TIMES) {
+	if (rmi4_data->fps_detection_enabled &&
+		!rmi4_data->is_fps_registered) {
 		error = FPS_register_notifier(
 				&rmi4_data->fps_notif, 0xBEEF, false);
 		if (error) {
-			fps_registered_retry++;
-			if (exp_fn_ctrl.det_workqueue)
+			if (++fps_registered_retry ==
+				SYN_FPS_REGISTERED_RETRY_TIMES) {
+				rmi4_data->fps_detection_enabled = false;
+			} else if (exp_fn_ctrl.det_workqueue)
 				queue_delayed_work(
 					exp_fn_ctrl.det_workqueue,
 					&exp_fn_ctrl.det_work,
 					msecs_to_jiffies(EXP_FN_DET_INTERVAL));
 			pr_err("Failed to register fps_notifier retry %d\n",
 				fps_registered_retry);
-		} else
+		} else {
 			rmi4_data->is_fps_registered = true;
+			pr_debug("registered FPS notifier\n");
+		}
 	}
 
 	mutex_lock(&exp_fn_ctrl.list_mutex);
@@ -5960,61 +6554,6 @@ static struct synaptics_dsx_patch *synaptics_dsx_init_patch(const char *name)
 	return patch_set;
 }
 
-static int synaptics_dsx_init_mode(struct synaptics_rmi4_data *data,
-		struct synaptics_dsx_patchset **pmode)
-{
-	int i;
-	struct synaptics_dsx_patchset *mode = *pmode =
-		kzalloc(sizeof(struct synaptics_dsx_patchset), GFP_KERNEL);
-	if (!mode)
-		return -ENOMEM;
-
-	mode->patch_num = MAX_NUM_STATES;
-	for (i = 0; i < mode->patch_num; i++) {
-		struct synaptics_dsx_patch *patch;
-		patch = synaptics_dsx_init_patch("dts");
-		if (!patch) {
-			kfree(mode);
-			return -ENOMEM;
-		}
-		mode->patch_data[i] = patch;
-	}
-	return 0;
-}
-
-static int synaptics_dsx_free_modes(struct synaptics_rmi4_data *data)
-{
-	int m, i;
-	struct synaptics_dsx_patchset *mode;
-
-	for (m = 0; m < 2; m++) {
-		switch (m) {
-		case 0:
-			mode = data->default_mode;
-			break;
-		case 1:
-			/* If alt mode was not present, and set to default
-			 * mode, don't double free it.
-			 */
-			if (data->default_mode == data->alternate_mode)
-				continue;
-			mode = data->alternate_mode;
-			break;
-		}
-		if (!mode)
-			continue;
-		for (i = 0; i < mode->patch_num; i++) {
-			struct synaptics_dsx_patch *patch = mode->patch_data[i];
-			synaptics_dsx_free_patch(patch);
-		}
-		kfree(mode);
-	}
-	data->current_mode = NULL;
-	data->default_mode = NULL;
-	data->alternate_mode = NULL;
-	return 0;
-}
-
 static void synaptics_dsx_queued_resume(struct work_struct *w)
 {
 	struct synaptics_rmi4_data *rmi4_data =
@@ -6063,20 +6602,6 @@ static int rmi_reboot(struct notifier_block *nb,
 }
 
 #if defined(USB_CHARGER_DETECTION)
-static void synaptics_dsx_modify_patch(struct synaptics_dsx_patch *patch_set,
-	struct synaptics_dsx_func_patch *patch, bool remove)
-{
-	down(&patch_set->list_sema);
-	if (!remove) {
-		list_add_tail(&patch->link, &patch_set->cfg_head);
-		patch_set->cfg_num++;
-	} else {
-		list_del(&patch->link);
-		patch_set->cfg_num--;
-	}
-	up(&patch_set->list_sema);
-}
-
 /***************************************************************/
 /* USB charging source info from power_supply driver directly  */
 /***************************************************************/
@@ -6087,59 +6612,12 @@ static enum power_supply_property ps_props[] = {
 
 static const char * const ps_usb_supply[] = { "usb", };
 static bool ps_usb_present;
-static unsigned char ps_data[2] = { 0x20, 0 };
-/* need separate copies of the same patch, since it has */
-/* to be added into active and suspended configurations */
-static struct synaptics_dsx_func_patch ps_on[MAX_NUM_STATES] = {
-	{
-		.func = 1,
-		.regstr = 0,
-		.subpkt = 0,
-		.size = 1,
-		.bitmask = 0x20,
-		.data = &ps_data[0],
-	},
-	{
-		.func = 1,
-		.regstr = 0,
-		.subpkt = 0,
-		.size = 1,
-		.bitmask = 0x20,
-		.data = &ps_data[0],
-	},
-};
-static struct synaptics_dsx_func_patch ps_set = {
-	.func = 1,
-	.regstr = 0,
-	.subpkt = 0,
-	.size = 1,
-	.bitmask = 0x20,
-	.data = &ps_data[0],
-};
-static struct synaptics_dsx_func_patch ps_clear = {
-	.func = 1,
-	.regstr = 0,
-	.subpkt = 0,
-	.size = 1,
-	.bitmask = 0x20,
-	.data = &ps_data[1],
-};
 static int ps_get_property(struct power_supply *psy,
 	enum power_supply_property psp, union power_supply_propval *val)
 {
 	val->intval = 0;
 	return 0;
 }
-static struct synaptics_dsx_patch ps_patch[] = {
-	{
-		.name = "ps_clear",
-		.cfg_num = 1,
-	},
-	{
-		.name = "ps_set",
-		.cfg_num = 1,
-	},
-};
 
 static void ps_external_power_changed(struct power_supply *psy)
 {
@@ -6148,7 +6626,8 @@ static void ps_external_power_changed(struct power_supply *psy)
 	struct synaptics_rmi4_data *rmi4_data = container_of(psy,
 				struct synaptics_rmi4_data, psy);
 	struct device *dev = &rmi4_data->i2c_client->dev;
-	int state;
+	struct config_modifier *cm;
+	int is_plugged, state;
 
 	if (!usb_psy || !usb_psy->get_property)
 		return;
@@ -6156,44 +6635,44 @@ static void ps_external_power_changed(struct power_supply *psy)
 	usb_psy->get_property(usb_psy, POWER_SUPPLY_PROP_PRESENT, &pval);
 	dev_dbg(dev, "external_power_changed: %d\n", pval.intval);
 
-	if (ps_usb_present != (pval.intval == 1)) {
-		int i, index = !!pval.intval;
-
-		/* charging patch has to be added into */
-		/* both patch sets: active and suspend */
-		for (i = 0; i < MAX_NUM_STATES; i++)
-			synaptics_dsx_modify_patch(
-				rmi4_data->default_mode->patch_data[i],
-				&ps_on[i], index == 0);
+	if (ps_usb_present == (pval.intval == 1)) {
+		ps_usb_present = pval.intval == 1;
+		return;
+	}
 
-		state = synaptics_dsx_get_state_safe(rmi4_data);
-		dev_info(dev, "power supply presence %d in state %d\n",
-			pval.intval, state);
-
-		if (state == STATE_ACTIVE) {
-			/* reset touch ic on charging source removal */
-			/* to kick it off FNM mode */
-			if (index == 0) {
-				int retval;
-				/* set unknown state to ensure IRQ gets */
-				/* enabled on state transition to active */
-				synaptics_dsx_sensor_state(
-						rmi4_data, STATE_UNKNOWN);
-				/* disable IRQ to handle reset */
-				synaptics_rmi4_irq_enable(rmi4_data, false);
-				/* perform SW reset to restore defaults */
-				retval = synaptics_dsx_ic_reset(
-						rmi4_data, RMI4_SW_RESET);
-				if (retval < 0)
-					dev_err(&rmi4_data->i2c_client->dev,
-						"folio: sw reset failed %d\n",
-						retval);
-				synaptics_dsx_sensor_ready_state(
-							rmi4_data, false);
-			} else /* on insertion only apply charging bit */
-				synaptics_dsx_patch_func(rmi4_data,
-					SYNAPTICS_RMI4_F01, &ps_patch[index]);
+	is_plugged = !!pval.intval;
+	down(&rmi4_data->modifiers.list_sema);
+	list_for_each_entry(cm, &rmi4_data->modifiers.mod_head, link) {
+		if (cm->id == SYNA_MOD_CHARGER) {
+			cm->effective = is_plugged;
+			break;
+		}
+	}
+	up(&rmi4_data->modifiers.list_sema);
+	/* in case there is no patch required */
+	if (!cm)
+		return;
+	state = synaptics_dsx_get_state_safe(rmi4_data);
+	dev_info(dev, "power supply presence %d in state %d\n",
+			is_plugged, state);
+	/* reset touch ic on power supply presence change */
+	if (state == STATE_ACTIVE) {
+		/* set unknown state to ensure IRQ gets */
+		/* enabled on state transition to active */
+		synaptics_dsx_sensor_state(rmi4_data, STATE_UNKNOWN);
+		/* disable IRQ to handle reset */
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+		if (!is_plugged) {
+			int retval;
+			/* perform SW reset to restore defaults */
+			retval = synaptics_dsx_ic_reset(
+				rmi4_data, RMI4_SW_RESET);
+			if (retval < 0)
+				dev_err(dev, "power supply: sw reset"\
+					" failed %d\n", retval);
 		}
+		synaptics_dsx_sensor_ready_state(rmi4_data, false);
+		/* TODO: just apply a single patch on insertion??? */
 	}
 	ps_usb_present = pval.intval == 1;
 }
@@ -6214,14 +6693,6 @@ static int ps_notifier_register(struct synaptics_rmi4_data *rmi4_data)
 	rmi4_data->psy.get_property = ps_get_property;
 	rmi4_data->psy.external_power_changed = ps_external_power_changed;
 
-	INIT_LIST_HEAD(&ps_patch[0].cfg_head);
-	sema_init(&ps_patch[0].list_sema, 1);
-	list_add_tail(&ps_clear.link, &ps_patch[0].cfg_head);
-
-	INIT_LIST_HEAD(&ps_patch[1].cfg_head);
-	sema_init(&ps_patch[1].list_sema, 1);
-	list_add_tail(&ps_set.link, &ps_patch[1].cfg_head);
-
 	error = power_supply_register(dev, &rmi4_data->psy);
 	if (error < 0) {
 		dev_err(dev, "power_supply_register failed rc=%d\n", error);
@@ -6405,21 +6876,6 @@ static int synaptics_rmi4_probe(struct i2c_client *client,
 
 	/* assign pointer to client structure right away for further use */
 	rmi4_data->i2c_client = client;
-
-	retval = synaptics_dsx_init_mode(rmi4_data, &rmi4_data->default_mode);
-	if (retval) {
-		dev_err(&client->dev, "%s: Failed to alloc dflt mode mem\n",
-				__func__);
-		return retval;
-	}
-
-	retval = synaptics_dsx_init_mode(rmi4_data, &rmi4_data->alternate_mode);
-	if (retval) {
-		dev_err(&client->dev, "%s: Failed to alloc alt mode mem\n",
-				__func__);
-		return retval;
-	}
-
 	rmi4_data->event_blank = FB_EARLY_EVENT_BLANK;
 
 	if (client->dev.of_node)
@@ -6435,8 +6891,6 @@ static int synaptics_rmi4_probe(struct i2c_client *client,
 		return -EINVAL;
 	}
 
-	rmi4_data->current_mode = rmi4_data->default_mode;
-
 	rmi = &(rmi4_data->rmi4_mod_info);
 
 	rmi4_data->current_page = MASK_8BIT;
@@ -6635,40 +7089,47 @@ static int synaptics_rmi4_probe(struct i2c_client *client,
 	exp_fn_ctrl.rmi4_data_ptr = rmi4_data;
 	mutex_unlock(&exp_fn_ctrl_mutex);
 
+
 #ifdef CONFIG_MMI_HALL_NOTIFICATIONS
-	/* register notifier at the end of probe to */
-	/* avoid unnecessary reset in STANDBY state */
-	rmi4_data->folio_notif.notifier_call = folio_notifier_callback;
-	dev_dbg(&client->dev, "registering folio notifier\n");
-	retval = mmi_hall_register_notifier(&rmi4_data->folio_notif,
-				MMI_HALL_FOLIO, true);
-	if (retval) {
-		dev_err(&client->dev,
-			"Error registering folio_notifier: %d\n", retval);
-		/* inability to register folio notifications handler */
-		/* is not fatal, thus reset return value to success */
-		retval = 0;
+	if (rmi4_data->folio_detection_enabled) {
+		/* register notifier at the end of probe to */
+		/* avoid unnecessary reset in STANDBY state */
+		rmi4_data->folio_notif.notifier_call = folio_notifier_callback;
+		dev_dbg(&client->dev, "registering folio notifier\n");
+		retval = mmi_hall_register_notifier(&rmi4_data->folio_notif,
+					MMI_HALL_FOLIO, true);
+		if (retval) {
+			dev_err(&client->dev,
+				"Error registering folio_notifier: %d\n",
+				retval);
+			/* inability to register folio notifications handler */
+			/* is not fatal, thus reset return value to success */
+			retval = 0;
+		}
 	}
 #endif
-
 	synaptics_dsx_sysfs_touchscreen(rmi4_data, true);
 
-	if (rmi4_data->charger_detection)
+	if (rmi4_data->charger_detection_enabled)
 		ps_notifier_register(rmi4_data);
 
-	rmi4_data->fps_notif.notifier_call = fps_notifier_callback;
-	dev_dbg(&client->dev, "registering FPS notifier\n");
-	retval = FPS_register_notifier(&rmi4_data->fps_notif, 0xBEEF, false);
-	if (retval) {
-		if (exp_fn_ctrl.det_workqueue)
-			queue_delayed_work(exp_fn_ctrl.det_workqueue,
-				&exp_fn_ctrl.det_work,
-				msecs_to_jiffies(EXP_FN_DET_INTERVAL));
-		dev_err(&client->dev,
-			"Failed to register fps_notifier: %d\n", retval);
-		retval = 0;
-	} else
-		rmi4_data->is_fps_registered = true;
+	if (rmi4_data->fps_detection_enabled) {
+		rmi4_data->fps_notif.notifier_call = fps_notifier_callback;
+		dev_dbg(&client->dev, "registering FPS notifier\n");
+		retval = FPS_register_notifier(
+				&rmi4_data->fps_notif, 0xBEEF, false);
+		if (retval) {
+			if (exp_fn_ctrl.det_workqueue)
+				queue_delayed_work(exp_fn_ctrl.det_workqueue,
+					&exp_fn_ctrl.det_work,
+					msecs_to_jiffies(EXP_FN_DET_INTERVAL));
+			dev_err(&client->dev,
+				"Failed to register fps_notifier: %d\n",
+				retval);
+			retval = 0;
+		} else
+			rmi4_data->is_fps_registered = true;
+	}
 
 	return retval;
 
@@ -6710,7 +7171,6 @@ err_free_gpio:
 	gpio_set_value(platform_data->reset_gpio, 0);
 	gpio_free(platform_data->reset_gpio);
 err_input_device:
-	synaptics_dsx_free_modes(rmi4_data);
 	kfree(rmi4_data);
 
 	return retval;
@@ -6773,13 +7233,17 @@ static int synaptics_rmi4_remove(struct i2c_client *client)
 
 	synaptics_dsx_sysfs_touchscreen(rmi4_data, false);
 	synaptics_rmi4_cleanup(rmi4_data);
-	synaptics_dsx_free_modes(rmi4_data);
-	if (rmi4_data->charger_detection)
+
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+	if (rmi4_data->folio_detection_enabled)
+		mmi_hall_unregister_notifier(rmi4_data);
+#endif
+	if (rmi4_data->charger_detection_enabled)
 		ps_notifier_unregister(rmi4_data);
 	if (rmi4_data->is_fps_registered)
 		FPS_unregister_notifier(&rmi4_data->fps_notif, 0xBEEF);
-	kfree(rmi4_data);
 
+	kfree(rmi4_data);
 	return 0;
 }
 
@@ -6850,6 +7314,13 @@ static int folio_notifier_callback(struct notifier_block *self,
 
 	if (rmi4_data && event == MMI_HALL_FOLIO &&
 			rmi4_data && rmi4_data->i2c_client) {
+		struct config_modifier *cm =
+				modifier_by_id(rmi4_data, SYNA_MOD_FOLIO);
+		if (!cm) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"No FOLIO modifier found\n");
+			goto done;
+		}
 
 		state = synaptics_dsx_get_state_safe(rmi4_data);
 		dev_dbg(&rmi4_data->i2c_client->dev,
@@ -6858,12 +7329,13 @@ static int folio_notifier_callback(struct notifier_block *self,
 			atomic_read(&rmi4_data->touch_stopped),
 			rmi4_data->in_bootloader);
 		if (folio_state) {/* close */
+			rmi4_data->clipa = cm->clipa;
 			rmi4_data->clipping_on = true;
-			synaptics_dsx_set_alternate_mode(rmi4_data,
-				rmi4_data->alternate_mode, false, true);
+			cm->effective = true;
 		} else {/* open */
+			rmi4_data->clipa = NULL;
 			rmi4_data->clipping_on = false;
-			synaptics_dsx_restore_default_mode(rmi4_data);
+			cm->effective = false;
 		}
 
 		if (control_access_block_get())
@@ -6877,30 +7349,8 @@ static int folio_notifier_callback(struct notifier_block *self,
 			goto done;
 		}
 
-		if (!rmi4_data->in_bootloader) {
-			if (state == STATE_ACTIVE) {
-				int retval;
-				/* set unknown state to ensure IRQ gets */
-				/* enabled on state transition to active */
-				synaptics_dsx_sensor_state(
-						rmi4_data, STATE_UNKNOWN);
-				/* disable IRQ to handle reset */
-				synaptics_rmi4_irq_enable(rmi4_data, false);
-				/* perform SW reset to restore defaults */
-				retval = synaptics_dsx_ic_reset(
-						rmi4_data, RMI4_SW_RESET);
-				if (retval < 0)
-					dev_err(&rmi4_data->i2c_client->dev,
-						"folio: sw reset failed %d\n",
-						retval);
-				synaptics_dsx_sensor_ready_state(
-							rmi4_data, false);
-			}
-
-			synaptics_dsx_state_config(rmi4_data,
-					(state == STATE_SUSPEND) ?
-					SUSPEND_IDX : ACTIVE_IDX);
-		}
+		if (!rmi4_data->in_bootloader)
+			synaptics_dsx_enforce_modifiers(rmi4_data, cm);
 	}
 done:
 	return 0;
@@ -7093,6 +7543,8 @@ static int synaptics_rmi4_resume(struct device *dev)
 		pr_debug("reset gpio state: %d\n", retval);
 		if (retval == 0)
 			reset = RMI4_WAIT_READY;
+		else	/* if not in reset, IRQ might be enabled */
+			synaptics_rmi4_irq_enable(rmi4_data, false);
 
 		pinctrl = devm_pinctrl_get_select(&rmi4_data->i2c_client->dev,
 			"active");
diff --git a/drivers/input/touchscreen/synaptics_dsx_i2c.h b/drivers/input/touchscreen/synaptics_dsx_i2c.h
index 37a7e8c26e3..9323a3e5281 100644
--- a/drivers/input/touchscreen/synaptics_dsx_i2c.h
+++ b/drivers/input/touchscreen/synaptics_dsx_i2c.h
@@ -244,20 +244,50 @@ struct synaptics_dsx_func_patch {
 	struct list_head link;
 };
 
+struct synaptics_clip_area {
+	unsigned xul_clip, yul_clip, xbr_clip, ybr_clip;
+	unsigned inversion; /* clip inside (when 1) or outside otherwise */
+};
+
+enum {
+	SYNA_MOD_AOD,
+	SYNA_MOD_STATS,
+	SYNA_MOD_FOLIO,
+	SYNA_MOD_CHARGER,
+	SYNA_MOD_WAKEUP,
+	SYNA_MOD_FPS,
+	SYNA_MOD_QUERY,	/* run time query; active only */
+	SYNA_MOD_RT,	/* run time patch; active only; always effective */
+	SYNA_MOD_MAX
+};
+
+#define FLAG_FORCE_UPDATE	1
+#define FLAG_WAKEABLE		2
+#define FLAG_POWER_SLEEP	4
+
 struct synaptics_dsx_patch {
 	const char *name;
 	int	cfg_num;
+	unsigned int flags;
 	struct semaphore list_sema;
 	struct list_head cfg_head;
 };
 
-#define ACTIVE_IDX	0
-#define SUSPEND_IDX	1
-#define MAX_NUM_STATES	2
+struct config_modifier {
+	const char *name;
+	int id;
+	bool effective;
+	struct synaptics_dsx_patch *active;
+	struct synaptics_dsx_patch *suspended;
+	struct synaptics_clip_area *clipa;
+	struct list_head link;
+};
+
+struct synaptics_dsx_modifiers {
+	int	mods_num;
+	struct semaphore list_sema;
+	struct list_head mod_head;
 
-struct synaptics_dsx_patchset {
-	int	patch_num;
-	struct synaptics_dsx_patch *patch_data[MAX_NUM_STATES];
 };
 
 struct f34_properties {
@@ -426,10 +456,6 @@ struct synaptics_rmi4_func_packet_regs {
 	struct synaptics_rmi4_packet_reg *regs;
 };
 
-struct synaptics_clip_area {
-	unsigned xul_clip, yul_clip, xbr_clip, ybr_clip;
-};
-
 /*
  * struct synaptics_rmi4_data - rmi4 device instance data
  * @i2c_client: pointer to associated i2c client
@@ -486,8 +512,6 @@ struct synaptics_rmi4_data {
 #ifdef CONFIG_MMI_HALL_NOTIFICATIONS
 	struct notifier_block folio_notif;
 #endif
-	struct notifier_block fps_notif;
-	bool is_fps_registered;
 	atomic_t panel_off_flag;
 	unsigned char current_page;
 	unsigned char button_0d_enabled;
@@ -514,8 +538,6 @@ struct synaptics_rmi4_data {
 	bool fingers_on_2d;
 	bool input_registered;
 	bool in_bootloader;
-	bool purge_enabled;
-	bool charger_detection;
 	wait_queue_head_t wait;
 	int (*i2c_read)(struct synaptics_rmi4_data *pdata, unsigned short addr,
 			unsigned char *data, unsigned short length);
@@ -532,23 +554,31 @@ struct synaptics_rmi4_data {
 	int last_irq;
 	struct synaptics_rmi4_irq_info *irq_info;
 
-	bool mode_is_wakeable;
-	bool mode_is_persistent;
-
+	/* features enablers */
+	bool charger_detection_enabled;
+	bool folio_detection_enabled;
+	bool fps_detection_enabled;
+	bool wakeup_detection_enabled;
 	bool patching_enabled;
-	struct synaptics_dsx_patchset *default_mode;
-	struct synaptics_dsx_patchset *alternate_mode;
-	struct synaptics_dsx_patchset *current_mode;
+	bool purge_enabled;
 
-	struct work_struct resume_work;
+	bool suspend_is_wakeable;
+	bool clipping_on;
+	struct synaptics_clip_area *clipa;
+	struct synaptics_dsx_modifiers modifiers;
 
+	struct work_struct resume_work;
 	struct synaptics_rmi4_func_packet_regs *f12_data_registers_ptr;
 	struct notifier_block rmi_reboot;
 #if defined(USB_CHARGER_DETECTION)
 	struct power_supply psy;
 #endif
-	bool clipping_on;
-	struct synaptics_clip_area *clipa;
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+	struct notifier_block folio_notif;
+#endif
+	bool is_fps_registered;	/* FPS notif registration might be delayed */
+	struct notifier_block fps_notif;
+
 	struct mutex rmi4_exp_init_mutex;
 	unsigned long event_blank;
 };
@@ -650,6 +680,10 @@ static inline int synaptics_rmi4_reg_write(
 	return rmi4_data->i2c_write(rmi4_data, addr, data, len);
 }
 
+extern int FPS_register_notifier(struct notifier_block *nb,
+				unsigned long stype, bool report);
+extern int FPS_unregister_notifier(struct notifier_block *nb,
+				unsigned long stype);
 
 #if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING)
 int synaptics_rmi4_scan_f54_ctrl_reg_info(
-- 
2.11.0

