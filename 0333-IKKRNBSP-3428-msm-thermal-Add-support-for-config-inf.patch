From f2cc1cc5f21863899c8de4f999f25e55618ba19c Mon Sep 17 00:00:00 2001
From: Jason Knopsnyder <jasonk@motorola.com>
Date: Fri, 12 Jun 2015 12:32:44 -0500
Subject: [PATCH 333/959] IKKRNBSP-3428: msm: thermal: Add support for
 config-info

Create a new optional sysfs property that will supply a unique
ID to user space based thermal management. This ID can be
used to understand the hardware thermal configuration.

Change-Id: Ib928149a934cf8621622a840932623b55b7eadc4
Signed-off-by: Jason Knopsnyder <jasonk@motorola.com>
Reviewed-on: http://gerrit.mot.com/756887
SLTApproved: Slta Waiver <sltawvr@motorola.com>
SME-Granted: SME Approvals Granted
Tested-by: Jira Key <jirakey@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
Reviewed-on: http://gerrit.mot.com/783604
Reviewed-on: http://gerrit.mot.com/787999
---
 .../devicetree/bindings/arm/msm/msm_thermal.txt    |  2 +
 drivers/thermal/msm_thermal.c                      | 66 ++++++++++++++++++++++
 2 files changed, 68 insertions(+)

diff --git a/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt b/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt
index 561852926af..3d9c7a4cc40 100644
--- a/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt
+++ b/Documentation/devicetree/bindings/arm/msm/msm_thermal.txt
@@ -252,6 +252,8 @@ Optional child nodes
 			tsens temperature reaches this threshold. This reset helps in
 			generating more informative crash dumps opposed to the crash dump
 			generated by the hardware reset.
+- qcom,config-info:     Specify a thermal revision name for the native space thermal manager
+                        to choose at init.
 
 Example:
 
diff --git a/drivers/thermal/msm_thermal.c b/drivers/thermal/msm_thermal.c
index f4f73201538..738b4caa215 100644
--- a/drivers/thermal/msm_thermal.c
+++ b/drivers/thermal/msm_thermal.c
@@ -162,6 +162,9 @@ static bool vdd_rstr_nodes_called;
 static bool vdd_rstr_probed;
 static bool sensor_info_nodes_called;
 static bool sensor_info_probed;
+static bool config_info_nodes_called;
+static bool config_info_probed;
+static char *config_info;
 static bool psm_enabled;
 static bool psm_nodes_called;
 static bool psm_probed;
@@ -5671,6 +5674,43 @@ static int msm_thermal_add_sensor_info_nodes(void)
 	return ret;
 }
 
+static ssize_t config_info_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%s\n", config_info);
+}
+
+static struct kobj_attribute config_info_attr =
+		__ATTR_RO(config_info);
+static int msm_thermal_add_config_info_nodes(void)
+{
+	struct kobject *module_kobj = NULL;
+	int ret = 0;
+
+	if (!config_info_probed) {
+		config_info_nodes_called = true;
+		return ret;
+	}
+
+	if (config_info == NULL)
+		return ret;
+
+	module_kobj = kset_find_obj(module_kset, KBUILD_MODNAME);
+	if (!module_kobj) {
+		pr_err("cannot find kobject\n");
+		return -ENOENT;
+	}
+	sysfs_attr_init(&config_info_attr.attr);
+	ret = sysfs_create_file(module_kobj, &config_info_attr.attr);
+	if (ret) {
+		pr_err(
+		"cannot create config_info kobject attribute. err:%d\n",
+		ret);
+		return ret;
+	}
+	return ret;
+}
+
 static int msm_thermal_add_vdd_rstr_nodes(void)
 {
 	struct kobject *module_kobj = NULL;
@@ -6623,6 +6663,24 @@ read_node_fail:
 	}
 }
 
+static void probe_config_info(struct device_node *node,
+		struct msm_thermal_data *data, struct platform_device *pdev)
+{
+	int ret;
+	int size;
+	const char *tmp_str = NULL;
+
+	config_info_probed = true;
+	ret = of_property_read_string(node, "qcom,config-info", &tmp_str);
+	if (ret)
+		return;
+
+	size = strlen(tmp_str)+1;
+	config_info = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if (config_info)
+		snprintf(config_info, size, "%s", tmp_str);
+}
+
 static int probe_ocr(struct device_node *node, struct msm_thermal_data *data,
 		struct platform_device *pdev)
 {
@@ -7575,6 +7633,7 @@ static int msm_thermal_dev_probe(struct platform_device *pdev)
 	ret = probe_vdd_rstr(node, &data, pdev);
 	if (ret == -EPROBE_DEFER)
 		goto fail;
+	probe_config_info(node, &data, pdev);
 	ret = probe_ocr(node, &data, pdev);
 
 	update_cpu_topology(&pdev->dev);
@@ -7604,6 +7663,10 @@ static int msm_thermal_dev_probe(struct platform_device *pdev)
 		msm_thermal_add_sensor_info_nodes();
 		sensor_info_nodes_called = false;
 	}
+	if (config_info_nodes_called) {
+		msm_thermal_add_config_info_nodes();
+		config_info_nodes_called = false;
+	}
 	if (ocr_nodes_called) {
 		msm_thermal_add_ocr_nodes();
 		ocr_nodes_called = false;
@@ -7678,6 +7741,8 @@ static int msm_thermal_dev_exit(struct platform_device *inp_dev)
 		}
 		kfree(thresh);
 		thresh = NULL;
+
+		devm_kfree(&inp_dev->dev, config_info);
 	}
 
 	if (ktm_prog_thresh_enabled) {
@@ -7743,6 +7808,7 @@ int __init msm_thermal_late_init(void)
 	msm_thermal_add_psm_nodes();
 	msm_thermal_add_vdd_rstr_nodes();
 	msm_thermal_add_sensor_info_nodes();
+	msm_thermal_add_config_info_nodes();
 	if (ocr_reg_init_defer) {
 		if (!ocr_reg_init(msm_thermal_info.pdev)) {
 			ocr_enabled = true;
-- 
2.11.0

