From 3fa866cd1b242e10b952d50d79b78dd83fea0a39 Mon Sep 17 00:00:00 2001
From: Teresa TAO <teresa.tao@st.com>
Date: Fri, 9 Oct 2015 17:30:13 -0500
Subject: [PATCH 395/959] IKQCOMSD1-2951: input misc vl53l0:add ST  driver code

ST clean driver code,with some fix

Add ST Laser driver
Driver version 0.0.3
- Coding style clean up

Driver version 0.0.2
- Interrupt support
- IOCTL for calibration and register tool

Driver version 0.0.1
- Base ST laser driver

Change-Id: Id389261198cb905823f71a4aa344c9147914cd90
Signed-off-by: Teresa TAO <teresa.tao@st.com>
Reviewed-on: http://gerrit.mot.com/790387
SLTApproved: Slta Waiver <sltawvr@motorola.com>
SME-Granted: SME Approvals Granted
Tested-by: Jira Key <jirakey@motorola.com>
Reviewed-by: Sumit Jamadar <xkbr38@motorola.com>
Reviewed-by: Satya Prasad Kottisa <fvgm76@motorola.com>
Reviewed-by: Christopher Fries <cfries@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
---
 drivers/input/misc/vl53L0/Makefile                 |   20 +
 drivers/input/misc/vl53L0/inc/vl53l0_api.h         | 1731 ++++++++
 drivers/input/misc/vl53L0/inc/vl53l0_def.h         |  439 ++
 drivers/input/misc/vl53L0/inc/vl53l0_device.h      |  261 ++
 .../input/misc/vl53L0/inc/vl53l0_i2c_platform.h    |  398 ++
 drivers/input/misc/vl53L0/inc/vl53l0_platform.h    |  228 ++
 .../input/misc/vl53L0/inc/vl53l0_platform_log.h    |  112 +
 drivers/input/misc/vl53L0/inc/vl53l0_strings.h     |  138 +
 drivers/input/misc/vl53L0/inc/vl53l0_tuning.h      |   65 +
 drivers/input/misc/vl53L0/inc/vl53l0_types.h       |   68 +
 drivers/input/misc/vl53L0/src/vl53l0_api.c         | 4283 ++++++++++++++++++++
 .../input/misc/vl53L0/src/vl53l0_i2c_platform.c    |  377 ++
 drivers/input/misc/vl53L0/src/vl53l0_platform.c    |  248 ++
 drivers/input/misc/vl53L0/src/vl53l0_port_i2c.c    |  147 +
 drivers/input/misc/vl53L0/src/vl53l0_tuning.c      |  138 +
 drivers/input/misc/vl53L0/stmvl53l0-cci.h          |   61 +
 drivers/input/misc/vl53L0/stmvl53l0-i2c.h          |   39 +
 drivers/input/misc/vl53L0/stmvl53l0.h              |  149 +
 drivers/input/misc/vl53L0/stmvl53l0_module-cci.c   |  402 ++
 drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c   |  256 ++
 drivers/input/misc/vl53L0/stmvl53l0_module.c       | 1224 ++++++
 21 files changed, 10784 insertions(+)
 create mode 100644 drivers/input/misc/vl53L0/Makefile
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_api.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_def.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_device.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_i2c_platform.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_platform.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_platform_log.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_strings.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_tuning.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l0_types.h
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l0_api.c
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l0_i2c_platform.c
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l0_platform.c
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l0_port_i2c.c
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l0_tuning.c
 create mode 100644 drivers/input/misc/vl53L0/stmvl53l0-cci.h
 create mode 100644 drivers/input/misc/vl53L0/stmvl53l0-i2c.h
 create mode 100644 drivers/input/misc/vl53L0/stmvl53l0.h
 create mode 100644 drivers/input/misc/vl53L0/stmvl53l0_module-cci.c
 create mode 100644 drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c
 create mode 100644 drivers/input/misc/vl53L0/stmvl53l0_module.c

diff --git a/drivers/input/misc/vl53L0/Makefile b/drivers/input/misc/vl53L0/Makefile
new file mode 100644
index 00000000000..2f885d8f898
--- /dev/null
+++ b/drivers/input/misc/vl53L0/Makefile
@@ -0,0 +1,20 @@
+#
+# Makefile for the vl53L0 drivers.
+#
+
+# Each configuration option enables a list of files.
+FEATURE_USE_CCI := false
+#FEATURE_USE_CCI := true
+
+ifeq ($(FEATURE_USE_CCI), true)
+ccflags-y	+= -Idrivers/input/misc/vl53L0/inc -DCAMERA_CCI
+else
+ccflags-y	+= -Idrivers/input/misc/vl53L0/inc -DSTM_TEST
+endif
+
+ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
+ccflags-y += -Idrivers/media/platform/msm/camera_v2
+ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
+obj-$(CONFIG_STMVL53L0)			+= stmvl53l0.o
+stmvl53l0-objs				:= stmvl53l0_module.o stmvl53l0_module-i2c.o stmvl53l0_module-cci.o src/vl53l0_api.o src/vl53l0_tuning.o src/vl53l0_platform.o src/vl53l0_i2c_platform.o src/vl53l0_port_i2c.o
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_api.h b/drivers/input/misc/vl53L0/inc/vl53l0_api.h
new file mode 100644
index 00000000000..28e9bdb3793
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_api.h
@@ -0,0 +1,1731 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+/*
+ * @file vl53l0_api.h
+ * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * $Revision: 1906 $
+ */
+
+
+
+#ifndef _VL53L0_API_H_
+#define _VL53L0_API_H_
+
+#include "vl53l0_strings.h"
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef _MSC_VER
+#   ifdef VL53L0_API_EXPORTS
+#       define VL53L0_API  __declspec(dllexport)
+#   else
+#       define VL53L0_API
+#   endif
+#else
+#   define VL53L0_API
+#endif
+
+
+/** @defgroup VL53L0_general_group VL53L0 General Functions
+ *  @brief    General functions and definitions
+ *  @{
+ */
+
+/**
+ * @brief Return the VL53L0 PAL Implementation Version
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   pVersion              Pointer to current PAL Implementation Version
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetVersion(VL53L0_Version_t *pVersion);
+
+/**
+ * @brief Return the PAL Specification Version used for the current
+ * implementation.
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   pPalSpecVersion       Pointer to current PAL Specification Version
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetPalSpecVersion(
+			VL53L0_Version_t *pPalSpecVersion);
+
+
+/**
+ * @brief Reads the Device information for given Device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                 Device Handle
+ * @param   pVL53L0_DeviceInfo     Pointer to current device info for a given
+ * Device
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"  See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetDeviceInfo(VL53L0_DEV Dev,
+			VL53L0_DeviceInfo_t *pVL53L0_DeviceInfo);
+
+
+/**
+ * @brief Read current status of the error register for the selected device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceErrorStatus    Pointer to current error code of the device
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetDeviceErrorStatus(VL53L0_DEV Dev,
+			VL53L0_DeviceError * pDeviceErrorStatus);
+
+/**
+ * @brief Human readable error string for a given Error Code
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   ErrorCode             The error code as stored on
+ * ::VL53L0_DeviceError
+ * @param   pDeviceErrorString    The error string corresponding to the
+ * ErrorCode
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetDeviceErrorString(
+			VL53L0_DeviceError ErrorCode, char *pDeviceErrorString);
+
+
+/**
+ * @brief Human readable error string for current PAL error status
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   PalErrorCode          The error code as stored on @a VL53L0_Error
+ * @param   pPalErrorString       The error string corresponding to the
+ * PalErrorCode
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetPalErrorString(VL53L0_Error PalErrorCode,
+			char *pPalErrorString);
+
+
+/**
+ * @brief Reads the internal state of the PAL for a given Device
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pPalState             Pointer to current state of the PAL for a
+ * given Device
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetPalState(VL53L0_DEV Dev,
+			VL53L0_State * pPalState);
+
+
+/**
+ * @brief Set the power mode for a given Device
+ * The power mode can be Standby or Idle. Different level of both Standby and
+ * Idle can exists.
+ * This function should not be used when device is in Ranging state.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   PowerMode             The value of the power mode to set.
+ * see ::VL53L0_PowerModes Valid values are:
+ * VL53L0_POWERMODE_STANDBY_LEVEL1, VL53L0_POWERMODE_IDLE_LEVEL1
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED    This error occurs when PowerMode
+ * is not in the supported list
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetPowerMode(VL53L0_DEV Dev,
+			VL53L0_PowerModes PowerMode);
+
+/**
+ * @brief Get the power mode for a given Device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pPowerMode            Pointer to the current value of the power
+ * mode. see ::VL53L0_PowerModes. Valid values are:
+ * VL53L0_POWERMODE_STANDBY_LEVEL1, VL53L0_POWERMODE_IDLE_LEVEL1
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetPowerMode(VL53L0_DEV Dev,
+			VL53L0_PowerModes * pPowerMode);
+
+
+/**
+ * Set or over-hide part to part calibration offset
+ * \sa VL53L0_DataInit()   VL53L0_GetOffsetCalibrationDataMicroMeter()
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                Device Handle
+ * @param   OffsetCalibrationDataMicroMeter    Offset (in micrometer)
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  "Other error code"                 See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetOffsetCalibrationDataMicroMeter(
+			VL53L0_DEV Dev,
+			int32_t OffsetCalibrationDataMicroMeter);
+
+/**
+ * @brief Get part to part calibration offset
+ *
+ * @par Function Description
+ * Should only be used after a successful call to @a VL53L0_DataInit to backup
+ * device NVM value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                Device Handle
+ * @param   pOffsetCalibrationDataMicroMeter   Return part to part calibration
+ * offset from device (in micro meter)
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  "Other error code"                 See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetOffsetCalibrationDataMicroMeter(
+			VL53L0_DEV Dev,
+			int32_t *pOffsetCalibrationDataMicroMeter);
+
+/**
+ * Set Group parameter Hold state
+ *
+ * @par Function Description
+ * Set or remove device internal group parameter hold
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @param   GroupParamHold   Group parameter Hold state to be set (on/off)
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ */
+VL53L0_API VL53L0_Error VL53L0_SetGroupParamHold(VL53L0_DEV Dev,
+			uint8_t GroupParamHold);
+
+/**
+ * @brief Get the maximal distance for actual setup
+ * @par Function Description
+ * Device must be initialized through @a VL53L0_SetParameters() prior calling
+ * this function.
+ *
+ * Any range value more than the value returned is to be considered as "no
+ * target detected"
+ * or "no target in detectable range"\n
+ * @warning The maximal distance depends on the setup
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @param   pUpperLimitMilliMeter   The maximal range limit for actual setup
+ * (in millimeter)
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ */
+VL53L0_API VL53L0_Error VL53L0_GetUpperLimitMilliMeter(VL53L0_DEV Dev,
+			uint16_t *pUpperLimitMilliMeter);
+
+/** @} VL53L0_general_group */
+
+
+/** @defgroup VL53L0_init_group VL53L0 Init Functions
+ *  @brief    VL53L0 Init Functions
+ *  @{
+ */
+
+/**
+ * @brief Set new device address
+ *
+ * After completion the device will answer to the new address programmed. This
+ * function should be called when several devices are used in parallel
+ * before start programming the sensor.
+ * When a single device us used, there is no need to call this function.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   DeviceAddress         The new Device address
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetDeviceAddress(VL53L0_DEV Dev,
+			uint8_t DeviceAddress);
+
+/**
+ *
+ * @brief One time device initialization
+ *
+ * To be called once and only once after device is brought out of reset (Chip
+ * enable) and booted see @a VL53L0_WaitDeviceBooted()
+ *
+ * @par Function Description
+ * When not used after a fresh device "power up" or reset, it may return @a
+ * #VL53L0_ERROR_CALIBRATION_WARNING
+ * meaning wrong calibration data may have been fetched from device that can
+ * result in ranging offset error\n
+ * If application cannot execute device reset or need to run VL53L0_DataInit
+ * multiple time
+ * then it  must ensure proper offset calibration saving and restore on its own
+ * by using @a VL53L0_GetOffsetCalibrationData() on first power up and then @a
+ * VL53L0_SetOffsetCalibrationData() in all subsequent init
+ * This function will change the VL53L0_State from VL53L0_STATE_POWERDOWN to
+ * VL53L0_STATE_WAIT_STATICINIT.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_DataInit(VL53L0_DEV Dev);
+
+/**
+ * @brief Do basic device init (and eventually patch loading)
+ * This function will change the VL53L0_State from VL53L0_STATE_WAIT_STATICINIT
+ * to VL53L0_STATE_IDLE.
+ * In this stage all defalut setting will be applied.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_StaticInit(VL53L0_DEV Dev);
+
+/**
+ * @brief Wait for device booted after chip enable (hardware standby)
+ * This function can be run only when VL53L0_State is VL53L0_STATE_POWERDOWN.
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ *
+ */
+VL53L0_API VL53L0_Error VL53L0_WaitDeviceBooted(VL53L0_DEV Dev);
+
+/**
+ * @brief Do an hard reset or soft reset (depending on implementation) of the
+ * device \n
+ * After call of this function, device must be in same state as right after a
+ * power-up sequence.
+ * This function will change the VL53L0_State to VL53L0_STATE_POWERDOWN.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_ResetDevice(VL53L0_DEV Dev);
+
+/** @} VL53L0_init_group */
+
+
+/** @defgroup VL53L0_parameters_group VL53L0 Parameters Functions
+ *  @brief    Functions used to prepare and setup the device
+ *  @{
+ */
+
+/**
+ * @brief  Prepare device for operation
+ * @par Function Description
+ * Update device with provided parameters
+ * @li Then start ranging operation.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceParameters     Pointer to store current device parameters.
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetDeviceParameters(VL53L0_DEV Dev,
+			const VL53L0_DeviceParameters_t *pDeviceParameters);
+
+/**
+ * @brief  Retrieve current device parameters
+ * @par Function Description
+ * Get actual parameters of the device
+ * @li Then start ranging operation.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceParameters     Pointer to store current device parameters.
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetDeviceParameters(VL53L0_DEV Dev,
+			VL53L0_DeviceParameters_t *pDeviceParameters);
+
+/**
+ * @brief  Set a new device mode
+ * @par Function Description
+ * Set device to a new mode (ranging, histogram ...)
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   DeviceMode            New device mode to apply
+ *                                Valid values are:
+ *                                VL53L0_DEVICEMODE_SINGLE_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
+ * (functionality not available)
+ *
+ * @return  VL53L0_ERROR_NONE                   Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
+ * DeviceMode is not in the supported list
+ */
+VL53L0_API VL53L0_Error VL53L0_SetDeviceMode(VL53L0_DEV Dev,
+			VL53L0_DeviceModes DeviceMode);
+
+/**
+ * @brief  Get current new device mode
+ * @par Function Description
+ * Get actual mode of the device(ranging, histogram ...)
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceMode           Pointer to current apply mode value
+ *                                Valid values are:
+ *                                VL53L0_DEVICEMODE_SINGLE_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
+ * (functionality not available)
+ *
+ * @return  VL53L0_ERROR_NONE                   Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
+ * DeviceMode is not in the supported list
+ */
+VL53L0_API VL53L0_Error VL53L0_GetDeviceMode(VL53L0_DEV Dev,
+			VL53L0_DeviceModes * pDeviceMode);
+
+/**
+ * @brief  Set a new Histogram mode
+ * @par Function Description
+ * Set device to a new Histogram mode
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   HistogramMode         New device mode to apply
+ *                                Valid values are:
+ *                                VL53L0_HISTOGRAMMODE_DISABLED
+ * @return  VL53L0_ERROR_NONE                   Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
+ * HistogramMode is not in the supported list
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetHistogramMode(VL53L0_DEV Dev,
+			VL53L0_HistogramModes HistogramMode);
+
+/**
+ * @brief  Get current new device mode
+ * @par Function Description
+ * Get current Histogram mode of a Device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pHistogramMode        Pointer to current Histogram Mode value
+ *                                Valid values are:
+ *                                VL53L0_HISTOGRAMMODE_DISABLED
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetHistogramMode(VL53L0_DEV Dev,
+			VL53L0_HistogramModes * pHistogramMode);
+
+/**
+ * @brief Set Ranging Timing Budget in microseconds
+ *
+ * @par Function Description
+ * Defines the maximum time allowed by the user to the device to run a full
+ * ranging sequence
+ * for the current mode (ranging, histogram, ASL ...)
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                Device Handle
+ * @param MeasurementTimingBudgetMicroSeconds  Max measurement time in
+ * microseconds.
+ *                                             Valid values are:
+ *                                             >= 17000 microseconds when
+ * wraparound is enabled
+ *                                             >= 12000 microseconds when
+ * wraparound is disabled
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS        This error is returned if
+ * MeasurementTimingBudgetMicroSeconds is out of range
+ * @return  "Other error code"                 See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetMeasurementTimingBudgetMicroSeconds(
+			VL53L0_DEV Dev,
+			uint32_t MeasurementTimingBudgetMicroSeconds);
+
+/**
+ * @brief Get Ranging Timing Budget in microseconds
+ *
+ * @par Function Description
+ * Returns the programmed the maximum time allowed by the user to the device to
+ * run a full ranging sequence
+ * for the current mode (ranging, histogram, ASL ...)
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                    Device Handle
+ * @param   pMeasurementTimingBudgetMicroSeconds   Max measurement time in
+ * microseconds.
+ *                                                 Valid values are:
+ *                                                 >= 17000 microseconds when
+ * wraparound is enabled
+ *                                                 >= 12000 microseconds when
+ * wraparound is disabled
+ * @return  VL53L0_ERROR_NONE                      Success
+ * @return  "Other error code"                     See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetMeasurementTimingBudgetMicroSeconds(
+			VL53L0_DEV Dev,
+			uint32_t *pMeasurementTimingBudgetMicroSeconds);
+
+/**
+ * Program continuous mode Inter-Measurement period in milliseconds
+ *
+ * @par Function Description
+ * When trying to set too short time return  INVALID_PARAMS minimal value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                  Device Handle
+ * @param   InterMeasurementPeriodMilliSeconds   Requires Inter-Measurement
+ * Period in milliseconds.
+ * @return  VL53L0_ERROR_NONE                    Success
+ * @return  "Other error code"                   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetInterMeasurementPeriodMilliSeconds(
+			VL53L0_DEV Dev,
+			uint32_t InterMeasurementPeriodMilliSeconds);
+
+/**
+ * Get continuous mode Inter-Measurement period in milliseconds
+ *
+ * @par Function Description
+ * When trying to set too short time return  INVALID_PARAMS minimal value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                  Device Handle
+ * @param   pInterMeasurementPeriodMilliSeconds  Pointer to programmed
+ * Inter-Measurement Period in milliseconds.
+ * @return  VL53L0_ERROR_NONE                    Success
+ * @return  "Other error code"                   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetInterMeasurementPeriodMilliSeconds(
+			VL53L0_DEV Dev,
+			uint32_t *pInterMeasurementPeriodMilliSeconds);
+
+/**
+ * @brief Enable/Disable Cross talk compensation feature
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                       Device Handle
+ * @param   XTalkCompensationEnable   Cross talk compensation to be set
+ * 0=disabled else = enabled
+ * @return  VL53L0_ERROR_NONE         Success
+ * @return  "Other error code"        See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetXTalkCompensationEnable(
+			VL53L0_DEV Dev, uint8_t XTalkCompensationEnable);
+
+/**
+ * @brief Get Cross talk compensation rate
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                        Device Handle
+ * @param   pXTalkCompensationEnable   Pointer to the Cross talk compensation
+ * state 0=disabled or 1 = enabled
+ * @return  VL53L0_ERROR_NONE          Success
+ * @return  "Other error code"         See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetXTalkCompensationEnable(
+			VL53L0_DEV Dev, uint8_t *pXTalkCompensationEnable);
+
+/**
+ * @brief Set Cross talk compensation rate
+ *
+ * @par Function Description
+ * Set Cross talk compensation rate.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                            Device Handle
+ * @param   XTalkCompensationRateMegaCps   Compensation rate in Mega counts per
+ * second (16.16 fix point) see datasheet for details
+ * @return  VL53L0_ERROR_NONE              Success
+ * @return  "Other error code"             See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetXTalkCompensationRateMegaCps(
+			VL53L0_DEV Dev,
+			FixPoint1616_t XTalkCompensationRateMegaCps);
+
+/**
+ * @brief Get Cross talk compensation rate
+ *
+ * @par Function Description
+ * Get Cross talk compensation rate.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                            Device Handle
+ * @param   pXTalkCompensationRateMegaCps  Pointer to Compensation rate in Mega
+ * counts per second (16.16 fix point) see datasheet for details
+ * @return  VL53L0_ERROR_NONE              Success
+ * @return  "Other error code"             See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetXTalkCompensationRateMegaCps(
+			VL53L0_DEV Dev,
+			FixPoint1616_t *pXTalkCompensationRateMegaCps);
+
+
+/**
+ * @brief  Get the number of the check limit managed by a given Device
+ *
+ * @par Function Description
+ * This function give the number of the check limit managed by the Device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   pNumberOfLimitCheck           Pointer to the number of check limit.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetNumberOfLimitCheck(
+			uint16_t *pNumberOfLimitCheck);
+
+/**
+ * @brief  Return a description string for a given limit check number
+ *
+ * @par Function Description
+ * This function returns a description string for a given limit check number.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckString             Pointer to the description string of
+ * the given check limit.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetLimitCheckInfo(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, char *pLimitCheckString);
+
+
+/**
+ * @brief  Enable/Disable a specific limit check
+ *
+ * @par Function Description
+ * This function Enable/Disable a specific limit check.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckEnable              if 1 the check limit corresponding to
+ * LimitCheckId is Enabled
+ *                                        if 0 the check limit corresponding to
+ * LimitCheckId is disabled
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetLimitCheckEnable(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, uint8_t LimitCheckEnable);
+
+
+/**
+ * @brief  Get specific limit check enable state
+ *
+ * @par Function Description
+ * This function get the enable state of a specific limit check.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckEnable             Pointer to the check limit enable
+ * value.
+ *                                        if 1 the check limit corresponding to
+ * LimitCheckId is Enabled
+ *                                        if 0 the check limit corresponding to
+ * LimitCheckId is disabled
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetLimitCheckEnable(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, uint8_t *pLimitCheckEnable);
+
+/**
+ * @brief  Set a specific limit check value
+ *
+ * @par Function Description
+ * This function set a specific limit check value.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckValue               Limit check Value for a given
+ * LimitCheckId
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when either
+ * LimitCheckId or LimitCheckValue value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetLimitCheckValue(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, FixPoint1616_t LimitCheckValue);
+
+/**
+ * @brief  Get a specific limit check value
+ *
+ * @par Function Description
+ * This function get a specific limit check value from device then it updates
+ * internal values and check enables.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckValue              Pointer to Limit check Value for a
+ * given LimitCheckId.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetLimitCheckValue(VL53L0_DEV Dev,
+			uint16_t LimitCheckId,
+			FixPoint1616_t *pLimitCheckValue);
+
+
+/**
+ * @brief  Enable/disable Snr check for a given Device
+ *
+ * @par Function Description
+ * This function set the Snr check Enable for a given position and for a given
+ * device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Position              Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   SnrLimitCheckEnable   if 1 = SnrLimit Check is Enabled ; 0 =
+ * SnrLimit Check is disabled
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSnrLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			uint8_t SnrLimitCheckEnable);
+
+
+/**
+ * @brief  Get Snr Limit check enable value for a given position and for a
+ * given Device
+ *
+ * @par Function Description
+ * This function get the Snr Limit check Enable for a given position and for a
+ * given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Position              Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   pSnrLimitCheckEnable  Pointer to programmed SnrLimit Check Enable
+ * value.
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSnrLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			uint8_t *pSnrLimitCheckEnable);
+
+/**
+ * @brief Set SNR limit value for a given position and for a given Device
+ *
+ * @par Function Description
+ * Set SNR limit value for a given position and for a given device.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   SnrLimitValue        SNR limit value to validate the measurement
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSnrLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			FixPoint1616_t SnrLimitValue);
+
+
+/**
+ * @brief Get SNR limit value
+ *
+ * @par Function Description
+ * Get SNR limit value for a given position and for a given device.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   pSnrLimitValue       Pointer to current SNR limit value to validate
+ * the measurement
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSnrLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			FixPoint1616_t *pSnrLimitValue);
+
+/**
+ * @brief  Enable/disable Signal check for a given Device
+ *
+ * @par Function Description
+ * This function set the Signal check Enable for a given position and for a
+ * given device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   Position                Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   SignalLimitCheckEnable   if 1 = SignalLimit Check is Enabled ; 0 =
+ * SignalLimit Check is disabled
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSignalLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			uint8_t SignalLimitCheckEnable);
+
+
+/**
+ * @brief  Get Signal Limit check enable value for a given position and for a
+ * given Device
+ *
+ * @par Function Description
+ * This function get the Signal Limit check Enable for a given position and for
+ * a given device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   Position                Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   pSignalLimitCheckEnable  Pointer to programmed SignalLimit Check
+ * Enable value.
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSignalLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			uint8_t *pSignalLimitCheckEnable);
+
+/**
+ * @brief Set Signal limit value for a given position and for a given Device
+ *
+ * @par Function Description
+ * Set Signal limit value for a given position and for a given device.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   SignalLimitValue     Signal limit value to validate the measurement
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSignalLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, FixPoint1616_t
+SignalLimitValue);
+
+
+/**
+ * @brief Get Signal limit value
+ *
+ * @par Function Description
+ * Get Signal limit value for a given position and for a given device.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   pSignalLimitValue    Pointer to current Signal limit value to
+ * validate the measurement
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSignalLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, FixPoint1616_t
+*pSignalLimitValue);
+
+
+/**
+ * @brief  Enable/disable Sigma check for a given Device
+ *
+ * @par Function Description
+ * This function set the Sigma check Enable for a given position and for a
+ * given device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   Position                Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   SigmaLimitCheckEnable   if 1 = SigmaLimit Check is Enabled ; 0 =
+ * SigmaLimit Check is disabled
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSigmaLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, uint8_t
+SigmaLimitCheckEnable);
+
+
+/**
+ * @brief  Get Sigma Limit check enable value for a given position and for a
+ * given Device
+ *
+ * @par Function Description
+ * This function get the Sigma Limit check Enable for a given position and for
+ * a given device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   Position                Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   pSigmaLimitCheckEnable  Pointer to programmed SigmaLimit Check
+ * Enable value.
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSigmaLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, uint8_t
+*pSigmaLimitCheckEnable);
+
+/**
+ * @brief Set Sigma limit value for a given position and for a given Device
+ *
+ * @par Function Description
+ * Set Sigma limit value for a given position and for a given device.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   SigmaLimitValue      Sigma limit value to validate the measurement
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSigmaLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, FixPoint1616_t
+SigmaLimitValue);
+
+
+/**
+ * @brief Get Sigma limit value
+ *
+ * @par Function Description
+ * Get Sigma limit value for a given position and for a given device.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position of the check in the
+ * sequence, it could be for example EARLY or FINAL.
+ * @param   pSigmaLimitValue     Pointer to current Sigma limit value to
+ * validate the measurement
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSigmaLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, FixPoint1616_t
+*pSigmaLimitValue);
+
+/**
+ * @brief  Set Enable/disable Rate check Limit for a given position and for a
+ * given device
+ *
+ * @par Function Description
+ * This function set the Rate Limit check Enable for a given position and for a
+ * given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Position              Indicate the position in the sequence it
+ * could be for example EARLY or FINAL.
+ * @param   RateLimitCheckEnable  if 1 = Rate Limit Check is Enabled ; 0 = Rate
+ * Limit Check is disabled
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetRateLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, uint8_t
+RateLimitCheckEnable);
+
+
+/**
+ * @brief  Get Rate Limit check Enable for a given position and for a given
+ * device
+ *
+ * @par Function Description
+ * This function get the Rate Limit check Enable for a given position and for a
+ * given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   Position                Indicate the position in the sequence it
+ * could be for example EARLY or FINAL.
+ * @param   pRateLimitCheckEnable   Pointer to programmed Rate Limit Check
+ * Enable value.
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetRateLimitCheckEnable(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position, uint8_t
+*pRateLimitCheckEnable);
+
+/**
+ * @brief Set Rate limit value for a given position and for a given device
+ *
+ * @par Function Description
+ * Set Rate limit value for a given position and for a given device.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position in the sequence it could
+ * be for example EARLY or FINAL.
+ * @param   RateLimitValue       Rate limit value
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetRateLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			FixPoint1616_t RateLimitValue);
+
+/**
+ * @brief Get Rate limit value for a given position and for a given device
+ *
+ * @par Function Description
+ * Get Rate limit value for a given position and for a given device.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle.
+ * @param   Position             Indicate the position in the sequence it could
+ * be for example EARLY or FINAL.
+ * @param   pRateLimitValue      Pointer to current Rate limit value
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
+ * Position value is out of range.
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetRateLimitValue(VL53L0_DEV Dev,
+			VL53L0_CheckPosition Position,
+			FixPoint1616_t *pRateLimitValue);
+
+/**
+ * @brief  Enable (or disable) Wrap around Check
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                    Device Handle
+ * @param   WrapAroundCheckEnable  Wrap around Check to be set 0=disabled,
+ * other = enabled
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"     See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetWrapAroundCheckEnable(VL53L0_DEV Dev,
+			uint8_t WrapAroundCheckEnable);
+
+/**
+ * @brief  Get setup of Wrap around Check
+ *
+ * @par Function Description
+ * This function get the wrapAround check enable parameters
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   pWrapAroundCheckEnable  Pointer to the Wrap around Check state
+ * 0=disabled or 1 = enabled
+ * @return  VL53L0_ERROR_NONE       Success
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetWrapAroundCheckEnable(VL53L0_DEV Dev,
+			uint8_t *pWrapAroundCheckEnable);
+
+/** @} VL53L0_parameters_group */
+
+
+/** @defgroup VL53L0_measurement_group VL53L0 Measurement Functions
+ *  @brief    Functions used for the measurements
+ *  @{
+ */
+
+/**
+ * @brief Single shot measurement.
+ *
+ * @par Function Description
+ * Perform simple measurement sequence (Start measure, Wait measure to end, and
+ * returns when measurement is done).
+ * Once function returns, user can get valid data by calling
+ * VL53L0_GetRangingMeasurement or VL53L0_GetHistogramMeasurement depending on
+ * defined measurement mode
+ * User should Clear the interrupt in case this are enabled by using the
+ * function VL53L0_ClearInterruptMask().
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformSingleMeasurement(VL53L0_DEV Dev);
+
+/**
+ * @brief Perform Reference Calibration
+ *
+ * @details Perform a reference calibration of the Device.
+ * This function should be run from time to time before doing a ranging
+ * measurement.
+ * This function will launch a special ranging measurement, so if interrupt are
+ * enable an interrupt will be done.
+ * This function will clear the interrupt generated automatically.
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformRefCalibration(VL53L0_DEV Dev);
+
+/**
+ * @brief Perform XTalk Calibration
+ *
+ * @details Perform a XTalk calibration of the Device.
+ * This function will launch a ranging measurement, if interrupts are enabled
+ * an interrupt will be done.
+ * This function will clear the interrupt generated automatically.
+ * This function will program a new value for the XTalk compensation and it
+ * will enable the cross talk before exit.
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @note This function change the device mode to
+ * VL53L0_DEVICEMODE_SINGLE_RANGING
+ *
+ * @param   Dev                  Device Handle
+ * @param   XTalkCalDistance               XTalkCalDistance value used for the
+ * XTalk computation.
+ * @param   pXTalkCompensationRateMegaCps  Pointer to new XTalkCompensation
+ * value.
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformXTalkCalibration(VL53L0_DEV Dev,
+			FixPoint1616_t XTalkCalDistance,
+			FixPoint1616_t *pXTalkCompensationRateMegaCps);
+
+/**
+ * @brief Start device measurement
+ *
+ * @details Started measurement will depend on device parameters set through @a
+ * VL53L0_SetParameters()
+ * This is a non-blocking function
+ * This function will change the VL53L0_State from VL53L0_STATE_IDLE to
+ * VL53L0_STATE_RUNNING.
+ *
+ * @note This function Access to the device
+ *
+
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED    This error occurs when
+ * DeviceMode programmed with @a VL53L0_SetDeviceMode is not in the supported
+ * list:
+ *                                             Supported mode are:
+ * VL53L0_DEVICEMODE_SINGLE_RANGING, VL53L0_DEVICEMODE_CONTINUOUS_RANGING,
+ * VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ * @return  VL53L0_ERROR_TIME_OUT    Time out on start measurement
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_StartMeasurement(VL53L0_DEV Dev);
+
+/**
+ * @brief Stop device measurement
+ *
+ * @details Will set the device in standby mode at end of current measurement \n
+ *          Not necessary in single mode as device shall return automatically
+ * in standby mode at end of measurement.
+ *          This function will change the VL53L0_State from
+ * VL53L0_STATE_RUNNING to VL53L0_STATE_IDLE.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_StopMeasurement(VL53L0_DEV Dev);
+
+/**
+ * @brief Return Measurement Data Ready
+ *
+ * @par Function Description
+ * This function indicate that a measurement data is ready.
+ * This function check if interrupt mode is used then check is done accordingly.
+ * If perform function clear the interrupt, this function will not work, like
+ * in case of @a VL53L0_PerformSingleRangingMeasurement().
+ * The previous function is blocking function, VL53L0_GetMeasurementDataReady
+ * is used for non-blocking capture.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                    Device Handle
+ * @param   pMeasurementDataReady  Pointer to Measurement Data Ready. 0=data
+ * not ready, 1 = data ready
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"     See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetMeasurementDataReady(VL53L0_DEV Dev,
+			uint8_t *pMeasurementDataReady);
+
+/**
+ * @brief Wait for device ready for a new measurement command. Blocking
+ * function.
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @param   MaxLoop    Max Number of polling loop (timeout).
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L0_API VL53L0_Error VL53L0_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev,
+			uint32_t MaxLoop);
+
+
+/**
+ * @brief Retrieve the measurements from device for a given setup
+ *
+ * @par Function Description
+ * Get data from last successful Ranging measurement
+ * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() before
+ * get data.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure used
+ * in the measurement function.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                      Device Handle
+ * @param   pRangingMeasurementData  Pointer to the data structure to fill up.
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"       See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetRangingMeasurementData(VL53L0_DEV Dev,
+		VL53L0_RangingMeasurementData_t *pRangingMeasurementData);
+
+/**
+ * @brief Retrieve the measurements from device for a given setup
+ *
+ * @par Function Description
+ * Get data from last successful Histogram measurement
+ * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() before
+ * get data.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure used
+ * in the measurement function.
+ * @note This function is not Implemented
+ * @param	Dev							Device Handle
+ * @param	pHistogramMeasurementData	Pointer to the data structure to fill
+ * up.
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L0_API VL53L0_Error VL53L0_GetHistogramMeasurementData(VL53L0_DEV Dev,
+		VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData);
+
+/**
+ * @brief Performs a single ranging measurement and retrieve the ranging
+ * measurement data
+ *
+ * @par Function Description
+ * This function will change the device mode to
+ * VL53L0_DEVICEMODE_SINGLE_RANGING with @a VL53L0_SetDeviceMode(),
+ * It performs measurement with @a VL53L0_PerformSingleMeasurement()
+ * It get data from last successful Ranging measurement with @a
+ * VL53L0_GetRangingMeasurementData.
+ * Finally it clear the interrupt with @a VL53L0_ClearInterruptMask().
+ * @note This function Access to the device
+ *
+ * @note This function change the device mode to
+ * VL53L0_DEVICEMODE_SINGLE_RANGING
+ *
+ * @param	Dev							Device Handle
+ * @param   pRangingMeasurementData		Pointer to the data structure to fill up.
+ * @return  VL53L0_ERROR_NONE			Success
+ * @return  "Other error code"			See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformSingleRangingMeasurement(VL53L0_DEV Dev,
+		VL53L0_RangingMeasurementData_t *pRangingMeasurementData);
+
+/**
+ * @brief Performs a single histogram measurement and retrieve the histogram
+ * measurement data
+ *        Is equivalent to VL53L0_PerformSingleMeasurement +
+ * VL53L0_GetHistogramMeasurementData
+ *
+ * @par Function Description
+ * Get data from last successful Ranging measurement.
+ * This function will clear the interrupt in case of these are enabled.
+ *
+ * @note This function is not Implemented
+ *
+ * @param	Dev							Device Handle
+ * @param   pHistogramMeasurementData	Pointer to the data structure to fill
+ * up.
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformSingleHistogramMeasurement(
+		VL53L0_DEV Dev,
+		VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData);
+
+
+
+/**
+ * @brief Set the number of ROI Zones to be used for a specific Device
+ *
+ * @par Function Description
+ * Set the number of ROI Zones to be used for a specific Device.
+ * The programmed value should be less than the max number of ROI Zones given
+ * with  @a VL53L0_GetMaxNumberOfROIZones().
+ * This version of API manage only one zone.
+ *
+ * @param	Dev							Device Handle
+ * @param   NumberOfROIZones            Number of ROI Zones to be used for a
+ * specific Device.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned if
+ * NumberOfROIZones != 1
+ */
+VL53L0_API VL53L0_Error VL53L0_SetNumberOfROIZones(VL53L0_DEV Dev,
+			uint8_t NumberOfROIZones);
+
+/**
+ * @brief Get the number of ROI Zones managed by the Device
+ *
+ * @par Function Description
+ * Get number of ROI Zones managed by the Device
+ * USER should take care about  @a VL53L0_GetNumberOfROIZones() before get data
+ * after a perform measurement.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure used
+ * in the measurement function.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param	Dev							Device Handle
+ * @param   pNumberOfROIZones           Pointer to the Number of ROI Zones
+ * value.
+ * @return  VL53L0_ERROR_NONE           Success
+ */
+VL53L0_API VL53L0_Error VL53L0_GetNumberOfROIZones(VL53L0_DEV Dev,
+			uint8_t *pNumberOfROIZones);
+
+/**
+ * @brief Get the Maximum number of ROI Zones managed by the Device
+ *
+ * @par Function Description
+ * Get Maximum number of ROI Zones managed by the Device.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param	Dev							Device Handle
+ * @param   pMaxNumberOfROIZones        Pointer to the Maximum Number of ROI
+ * Zones value.
+ * @return  VL53L0_ERROR_NONE           Success
+ */
+VL53L0_API VL53L0_Error VL53L0_GetMaxNumberOfROIZones(VL53L0_DEV Dev,
+			uint8_t *pMaxNumberOfROIZones);
+
+
+/** @} VL53L0_measurement_group */
+
+
+/** @defgroup VL53L0_interrupt_group VL53L0 Interrupt Functions
+ *  @brief    Functions used for interrupt managements
+ *  @{
+ */
+
+/**
+ * @brief Set the configuration of GPIO pin for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Pin                   ID of the GPIO Pin
+ * @param   Functionality         Select Pin functionality. Refer to
+ * ::VL53L0_GpioFunctionality
+ * @param   DeviceMode            Device Mode associated to the Gpio.
+ * @param   Polarity              Set interrupt polarity. Active high or active
+ * low see ::VL53L0_InterruptPolarity
+ * @return  VL53L0_ERROR_NONE                                Success
+ * @return  VL53L0_ERROR_GPIO_NOT_EXISTING                   Only Pin=0 is
+ * accepted.
+ * @return  VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED    This error occurs
+ * when Functionality programmed is not in the supported list:
+ *                                                           Supported value
+ * are:
+ *
+ * VL53L0_GPIOFUNCTIONALITY_OFF, VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+ *
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT,
+ *
+ * VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+				VL53L0_DeviceModes DeviceMode,
+				VL53L0_GpioFunctionality Functionality,
+				VL53L0_InterruptPolarity Polarity);
+
+
+/**
+ * @brief Get current configuration for GPIO pin for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Pin                   ID of the GPIO Pin
+ * @param   pDeviceMode           Pointer to Device Mode associated to the Gpio.
+ * @param   pFunctionality        Pointer to Pin functionality.
+ * Refer to ::VL53L0_GpioFunctionality
+ * @param   pPolarity             Pointer to interrupt polarity. Active high or
+ * active low see ::VL53L0_InterruptPolarity
+ * @return	VL53L0_ERROR_NONE		Success
+ * @return  VL53L0_ERROR_GPIO_NOT_EXISTING  Only Pin=0 is accepted.
+ * @return  VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED    This error occurs
+ * when Functionality programmed is not in the supported list:
+ * Supported value are:
+ * VL53L0_GPIOFUNCTIONALITY_OFF, VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT,
+ * VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+			VL53L0_DeviceModes * pDeviceMode,
+			VL53L0_GpioFunctionality * pFunctionality,
+			VL53L0_InterruptPolarity * pPolarity);
+
+/**
+ * @brief Set low and high Interrupt thresholds for a given mode (ranging, ALS,
+ * ...) for a given device
+ *
+ * @par Function Description
+ * Set low and high Interrupt thresholds for a given mode (ranging, ALS, ...)
+ * for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @note DeviceMode is ignored for the current device
+ *
+ * @param   Dev                  Device Handle
+ * @param   DeviceMode           Device Mode for which change thresholds
+ * @param   ThresholdLow         Low threshold (mm, lux ..., depending on the
+ * mode)
+ * @param   ThresholdHigh        High threshold (mm, lux ..., depending on the
+ * mode)
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetInterruptThresholds(VL53L0_DEV Dev,
+			VL53L0_DeviceModes DeviceMode,
+			FixPoint1616_t ThresholdLow,
+			FixPoint1616_t ThresholdHigh);
+
+/**
+ * @brief  Get high and low Interrupt thresholds for a given mode (ranging,
+ * ALS, ...) for a given device
+ *
+ * @par Function Description
+ * Get high and low Interrupt thresholds for a given mode (ranging, ALS, ...)
+ * for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @note DeviceMode is ignored for the current device
+ *
+ * @param   Dev                 Device Handle
+ * @param   DeviceMode          Device Mode from which read thresholds
+ * @param   pThresholdLow       Low threshold (mm, lux ..., depending on the
+ * mode)
+ * @param   pThresholdHigh      High threshold (mm, lux ..., depending on the
+ * mode)
+ * @return  VL53L0_ERROR_NONE   Success
+ * @return  "Other error code"  See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetInterruptThresholds(VL53L0_DEV Dev,
+			VL53L0_DeviceModes DeviceMode,
+			FixPoint1616_t *pThresholdLow,
+			FixPoint1616_t *pThresholdHigh);
+
+/**
+ * @brief Clear given system interrupt condition
+ *
+ * @par Function Description
+ * Clear given interrupt(s).
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @param   InterruptMask        Mask of interrupts to clear
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_ClearInterruptMask(VL53L0_DEV Dev,
+			uint32_t InterruptMask);
+
+/**
+ * @brief Return device interrupt status
+ *
+ * @par Function Description
+ * Returns currently raised interrupts by the device.
+ * User shall be able to activate/deactivate interrupts through
+ * @a VL53L0_SetGpioConfig()
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                    Device Handle
+ * @param   pInterruptMaskStatus   Pointer to status variable to update
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"     See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetInterruptMaskStatus(VL53L0_DEV Dev,
+			uint32_t *pInterruptMaskStatus);
+
+
+/**
+ * @brief Configure ranging interrupt reported to system
+ *
+ * @note This function is not Implemented
+ *
+ * @param	Dev					Device Handle
+ * @param	InterruptMask		Mask of interrupt to Enable/disable
+ * (0:interrupt disabled or 1: interrupt enabled)
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L0_API VL53L0_Error VL53L0_EnableInterruptMask(VL53L0_DEV Dev,
+			uint32_t InterruptMask);
+
+
+/** @} VL53L0_interrupt_group */
+
+
+/** @defgroup VL53L0_SPADfunctions_group VL53L0 SPAD Functions
+ *  @brief    Functions used for SPAD managements
+ *  @{
+ */
+
+
+
+/**
+ * @brief  Set the SPAD Ambient Damper Threshold value
+ *
+ * @par Function Description
+ * This function set the SPAD Ambient Damper Threshold value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   SpadAmbientDamperThreshold    SPAD Ambient Damper Threshold value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSpadAmbientDamperThreshold(VL53L0_DEV Dev,
+					uint16_t SpadAmbientDamperThreshold);
+
+/**
+ * @brief  Get the current SPAD Ambient Damper Threshold value
+ *
+ * @par Function Description
+ * This function get the SPAD Ambient Damper Threshold value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   pSpadAmbientDamperThreshold   Pointer to programmed SPAD Ambient
+ * Damper Threshold value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSpadAmbientDamperThreshold(VL53L0_DEV Dev,
+					uint16_t *pSpadAmbientDamperThreshold);
+
+
+/**
+ * @brief  Set the SPAD Ambient Damper Factor value
+ *
+ * @par Function Description
+ * This function set the SPAD Ambient Damper Factor value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   SpadAmbientDamperFactor       SPAD Ambient Damper Factor value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_SetSpadAmbientDamperFactor(VL53L0_DEV Dev,
+					uint16_t SpadAmbientDamperFactor);
+
+/**
+ * @brief  Get the current SPAD Ambient Damper Factor value
+ *
+ * @par Function Description
+ * This function get the SPAD Ambient Damper Factor value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   pSpadAmbientDamperFactor      Pointer to programmed SPAD Ambient
+ * Damper Factor value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_GetSpadAmbientDamperFactor(VL53L0_DEV Dev,
+					uint16_t *pSpadAmbientDamperFactor);
+
+
+/** @} VL53L0_SPADfunctions_group */
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VL53L0_API_H_ */
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_def.h b/drivers/input/misc/vl53L0/inc/vl53l0_def.h
new file mode 100644
index 00000000000..cc394acb6e5
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_def.h
@@ -0,0 +1,439 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+/*
+ * $Date: 2014-12-05 15:06:01 +0100 (Fri, 05 Dec 2014) $
+ * $Revision: 1915 $
+ */
+
+/**
+ * @file VL53L0_def.h
+ *
+ * @brief Type definitions for VL53L0 API.
+ *
+ */
+
+
+#ifndef _VL53L0_DEF_H_
+#define _VL53L0_DEF_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** PAL SPECIFICATION major version */
+#define VL53L0_SPECIFICATION_VER_MAJOR   1
+/** PAL SPECIFICATION minor version */
+#define VL53L0_SPECIFICATION_VER_MINOR   2
+/** PAL SPECIFICATION sub version */
+#define VL53L0_SPECIFICATION_VER_SUB     7
+/** PAL SPECIFICATION sub version */
+#define VL53L0_SPECIFICATION_VER_REVISION 1440
+
+/** VL53L0 PAL IMPLEMENTATION major version */
+#define VL53L0_IMPLEMENTATION_VER_MAJOR   1
+/** VL53L0 PAL IMPLEMENTATION minor version */
+#define VL53L0_IMPLEMENTATION_VER_MINOR   0
+/** VL53L0 PAL IMPLEMENTATION sub version */
+#define VL53L0_IMPLEMENTATION_VER_SUB     5
+/** VL53L0 PAL IMPLEMENTATION sub version */
+#define VL53L0_IMPLEMENTATION_VER_REVISION    2698
+
+#define VL53L0_DEFAULT_MAX_LOOP 100
+#define VL53L0_MAX_STRING_LENGTH 32
+
+
+#include "vl53l0_device.h"
+#include "vl53l0_types.h"
+
+#ifdef PAL_EXTENDED
+/* The following include should be removed for external use */
+#include "vl53l0_extended_ewok_def.h"
+#endif
+
+/****************************************
+ * PRIVATE define do not edit
+ ****************************************/
+
+/** @brief Defines the parameters of the Get Version Functions
+ */
+typedef struct {
+	uint32_t     revision; /*!< revision number */
+	uint8_t      major;    /*!< major number */
+	uint8_t      minor;    /*!< minor number */
+	uint8_t      build;    /*!< build number */
+} VL53L0_Version_t;
+
+
+/** @brief Defines the parameters of the Get Device Info Functions
+ */
+typedef struct {
+	/*!< Name of the Device e.g. Left_Distance */
+	char Name[VL53L0_MAX_STRING_LENGTH];
+	/*!< Type of the Device e.g VL53L0 */
+	char Type[VL53L0_MAX_STRING_LENGTH];
+	/*!< Product Type, VL53L0 = 1, VL53L1 = 2 */
+	uint8_t ProductType;
+	/*!< Product revision major */
+	uint8_t ProductRevisionMajor;
+	/*!< Product revision minor */
+	uint8_t ProductRevisionMinor;
+} VL53L0_DeviceInfo_t ;
+
+
+/** @defgroup VL53L0_define_Error_group PAL Error and Warning code returned by
+ *	API
+ *  The following DEFINE are used to identify the PAL ERROR
+ *  @{
+ */
+
+typedef int8_t VL53L0_Error;
+
+#define VL53L0_ERROR_NONE                              ((VL53L0_Error)  0)
+/*!< Warning invalid calibration data may be in used
+	\a  VL53L0_InitData()
+	\a VL53L0_GetOffsetCalibrationData
+	\a VL53L0_SetOffsetCalibrationData */
+#define VL53L0_ERROR_CALIBRATION_WARNING               ((VL53L0_Error) - 1)
+/*!< Warning parameter passed was clipped to min before to be applied */
+#define VL53L0_ERROR_MIN_CLIPPED                       ((VL53L0_Error) - 2)
+/*!< Unqualified error */
+#define VL53L0_ERROR_UNDEFINED                         ((VL53L0_Error) - 3)
+/*!< Parameter passed is invalid or out of range */
+#define VL53L0_ERROR_INVALID_PARAMS                    ((VL53L0_Error) - 4)
+/*!< Function is not supported in current mode or configuration */
+#define VL53L0_ERROR_NOT_SUPPORTED                     ((VL53L0_Error) - 5)
+/*!< Device report a ranging error interrupt status */
+#define VL53L0_ERROR_RANGE_ERROR                       ((VL53L0_Error) - 6)
+/*!< Aborted due to time out */
+#define VL53L0_ERROR_TIME_OUT                          ((VL53L0_Error) - 7)
+/*!< Asked mode is not supported by the device */
+#define VL53L0_ERROR_MODE_NOT_SUPPORTED                ((VL53L0_Error) - 8)
+/*!< ... */
+#define VL53L0_ERROR_BUFFER_TOO_SMALL                  ((VL53L0_Error) - 9)
+/*!< User tried to setup a non-existing GPIO pin */
+#define VL53L0_ERROR_GPIO_NOT_EXISTING                 ((VL53L0_Error) - 10)
+/*!< unsupported GPIO functionality */
+#define VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED  ((VL53L0_Error) - 11)
+/*!< error reported from IO functions */
+#define VL53L0_ERROR_CONTROL_INTERFACE                 ((VL53L0_Error) - 20)
+/*!< The command is not allowed in the current device state (power down) */
+#define VL53L0_ERROR_INVALID_COMMAND                   ((VL53L0_Error) - 30)
+/*!< Tells requested functionality has not been implemented yet or not
+	compatible with the device */
+#define VL53L0_ERROR_NOT_IMPLEMENTED                   ((VL53L0_Error) - 99)
+/** @} */ /* end of VL53L0_define_Error_group */
+
+
+/** @defgroup VL53L0_define_DeviceModes_group Defines all possible modes for the
+ *  device
+ *  Defines all possible modes for the device
+ *  @{
+ */
+typedef uint8_t VL53L0_DeviceModes;
+
+#define VL53L0_DEVICEMODE_SINGLE_RANGING           ((VL53L0_DeviceModes)  0)
+#define VL53L0_DEVICEMODE_CONTINUOUS_RANGING       ((VL53L0_DeviceModes)  1)
+#define VL53L0_DEVICEMODE_SINGLE_HISTOGRAM         ((VL53L0_DeviceModes)  2)
+#define VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING ((VL53L0_DeviceModes)  3)
+#define VL53L0_DEVICEMODE_SINGLE_ALS               ((VL53L0_DeviceModes) 10)
+/* ... Modes to be added depending on device */
+/** @} */ /* end of VL53L0_define_DeviceModes_group */
+
+
+
+/** @defgroup VL53L0_define_HistogramModes_group Defines all possible Histogram
+ *  modes for the device
+ *  Defines all possible Histogram modes for the device
+ *  @{
+ */
+typedef uint8_t VL53L0_HistogramModes;
+
+/*!< Histogram Disabled */
+#define VL53L0_HISTOGRAMMODE_DISABLED        ((VL53L0_HistogramModes) 0)
+/*!< Histogram Reference array only */
+#define VL53L0_HISTOGRAMMODE_REFERENCE_ONLY  ((VL53L0_HistogramModes) 1)
+/*!< Histogram Return array only */
+#define VL53L0_HISTOGRAMMODE_RETURN_ONLY     ((VL53L0_HistogramModes) 2)
+/*!< Histogram both Reference and Return Arrays */
+#define VL53L0_HISTOGRAMMODE_BOTH            ((VL53L0_HistogramModes) 3)
+/* ... Modes to be added depending on device */
+/** @} */ /* end of VL53L0_define_HistogramModes_group */
+
+
+/** @defgroup VL53L0_define_PowerModes_group List of available Power Modes
+ *  List of available Power Modes
+ *  @{
+ */
+
+typedef uint8_t VL53L0_PowerModes;
+
+/*!< Standby level 1 */
+#define VL53L0_POWERMODE_STANDBY_LEVEL1 ((VL53L0_PowerModes) 0)
+/*!< Standby level 2 */
+#define VL53L0_POWERMODE_STANDBY_LEVEL2 ((VL53L0_PowerModes) 1)
+/*!< Idle level 1 */
+#define VL53L0_POWERMODE_IDLE_LEVEL1    ((VL53L0_PowerModes) 2)
+/*!< Idle level 2 */
+#define VL53L0_POWERMODE_IDLE_LEVEL2    ((VL53L0_PowerModes) 3)
+
+/** @} */ /* end of VL53L0_define_PowerModes_group */
+
+
+/** @defgroup VL53L0_define_CheckPosition_group List of available Positions to
+ *  be used in checks functions
+ *  List of available Positions to be used in checks functions
+ *  @{
+ */
+
+typedef uint8_t VL53L0_CheckPosition;
+
+
+#define VL53L0_CHECKPOSITION_EARLY           ((VL53L0_CheckPosition) 0)
+/*!< Early Position */
+#define VL53L0_CHECKPOSITION_FINAL           ((VL53L0_CheckPosition) 1)
+/*!< Final Position */
+#define VL53L0_CHECKPOSITION_NO_OF_CHECKS    ((VL53L0_CheckPosition) 2)
+/*!< Number of Checks */
+
+/** @} */ /* end of VL53L0_define_PowerModes_group */
+
+
+/** @brief Defines all parameters for the device
+ */
+typedef struct {
+	VL53L0_DeviceModes DeviceMode;
+	/*!< Defines type of measurement to be done for the next measure */
+	VL53L0_HistogramModes HistogramMode;
+	/*!< Defines type of histogram measurement to be done for the next
+		measure */
+	uint32_t MeasurementTimingBudgetMicroSeconds;
+	/*!< Defines the allowed total time for a single measurement */
+	uint32_t InterMeasurementPeriodMilliSeconds;
+	/*!< Defines time between two consecutive measurements (between two
+		measurement starts).If set to 0 means back-to-back mode */
+	uint8_t XTalkCompensationEnable;
+	/*!< Tells if Crosstalk compensation shall be enable or not  */
+	uint16_t XTalkCompensationRangeMilliMeter;
+	/*!< CrossTalk compensation range in millimeter  */
+	FixPoint1616_t XTalkCompensationRateMegaCps;
+	/*!< CrossTalk compensation rate in Mega counts per seconds.
+		Expressed in 16.16 fixed point format.  */
+	uint8_t SnrLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Tells if SNR limit Check shall be enable or not for each
+		position. */
+	FixPoint1616_t SnrLimitValue[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< SNR limit value for each position */
+	uint8_t SignalLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Tells if Signal limit Check shall be enable or not for each
+		position.*/
+	FixPoint1616_t SignalLimitValue[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Signal limit value for each position */
+	uint8_t RateLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Tells if Rate limit Check shall be enable or not for each
+		position. */
+	FixPoint1616_t RateLimitValue[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Rate limit value for each position */
+	uint8_t SigmaLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Tells if Sigma limit Check shall be enable or not for each
+		position. */
+	FixPoint1616_t SigmaLimitValue[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
+	/*!< Sigma limit value for each position */
+	uint8_t WrapAroundCheckEnable;
+	/*!< Tells if Wrap Around Check shall be enable or not */
+} VL53L0_DeviceParameters_t;
+
+
+/** @defgroup VL53L0_define_State_group Defines the current status of the device
+ *  Defines the current status of the device
+ *  @{
+ */
+
+typedef uint8_t VL53L0_State;
+
+#define VL53L0_STATE_POWERDOWN       ((VL53L0_State)  0)
+/*!< Device is in HW reset  */
+#define VL53L0_STATE_WAIT_STATICINIT ((VL53L0_State)  1)
+/*!< Device is initialized and wait for static initialization  */
+#define VL53L0_STATE_STANDBY         ((VL53L0_State)  2)
+/*!< Device is in Low power Standby mode   */
+#define VL53L0_STATE_IDLE            ((VL53L0_State)  3)
+/*!< Device has been initialized and ready to do measurements  */
+#define VL53L0_STATE_RUNNING         ((VL53L0_State)  4)
+/*!< Device is performing measurement */
+#define VL53L0_STATE_UNKNOWN         ((VL53L0_State)  98)
+/*!< Device is in unknown state and need to be rebooted  */
+#define VL53L0_STATE_ERROR           ((VL53L0_State)  99)
+/*!< Device is in error state and need to be rebooted  */
+
+/** @} */ /* end of VL53L0_define_State_group */
+
+
+/** @brief Structure containing the Dmax computation parameters and data
+ */
+typedef struct {
+	int32_t AmbTuningWindowFactor_K;
+	/*!<  internal algo tuning (*1000) */
+	int32_t RetSignalAt0mm;
+	/*!< intermediate dmax computation value caching */
+} VL53L0_DMaxData_t;
+
+/**
+ * @struct VL53L0_RangeData_t
+ * @brief Range measurement data.
+ */
+typedef struct {
+	uint32_t TimeStamp;
+	/*!< 32-bit time stamp. */
+	uint32_t MeasurementTimeUsec;
+	/*!< Give the Measurement time needed by the device to do the
+		measurement.*/
+	uint16_t RangeMilliMeter;
+	/*!< range distance in millimeter. */
+	uint16_t RangeDMaxMilliMeter;
+	/*!< Tells what is the maximum detection distance of the device in
+		current setup and environment conditions
+		(Filled when applicable) */
+	FixPoint1616_t SignalRateRtnMegaCps;
+	/*!< Return signal rate (MCPS)\n these is a 16.16 fix point value,
+		which is effectively a measure of target reflectance.*/
+	FixPoint1616_t AmbientRateRtnMegaCps;
+	/*!< Return ambient rate (MCPS)\n these is a 16.16 fix point value,
+		which is effectively a measure of the ambient light.*/
+	uint16_t EffectiveSpadRtnCount;
+	/*!< Return the effective SPAD count for the return signal.
+		To obtain Real value it should be divided by 32 */
+	uint8_t ZoneId;
+	/*!< Denotes which zone and range scheduler stage the range data
+		relates	to. */
+	uint8_t RangeFractionalPart;
+	/*!< Fractional part of range distance. Final value is a FixPoint168
+		value. */
+	uint8_t RangeStatus;
+	/*!< Range Status for the current measurement. This is device dependent.
+		Value = 11 means value is valid. */
+} VL53L0_RangingMeasurementData_t;
+
+
+#define VL53L0_HISTOGRAM_BUFFER_SIZE 38
+
+/**
+ * @struct VL53L0_HistogramData_t
+ * @brief Histogram measurement data.
+ */
+typedef struct {
+	/* Histogram Measurement data */
+	uint32_t HistogramData[VL53L0_HISTOGRAM_BUFFER_SIZE];
+	/*!< Histogram data */
+	uint8_t HistogramType;
+	/*!< Indicate the types of histogram data : Return only, Reference only,
+		both Return and Reference */
+	uint8_t FirstBin;
+	/*!< First Bin value */
+	uint8_t BufferSize;
+	/*!< Buffer Size */
+	uint8_t NumberOfBins;
+	/*!< Number of bins filled by the histogram measurement */
+	VL53L0_DeviceError ErrorStatus;
+	/*!< Error status of the current measurement.\n
+		see @a ::VL53L0_DeviceError @a VL53L0_GetStatusErrorString() */
+} VL53L0_HistogramMeasurementData_t;
+
+
+/**
+ * @struct VL53L0_DevData_t
+ *
+ * @brief VL53L0 PAL device ST private data structure \n
+ * End user should never access any of these field directly
+ *
+ * These must never access directly but only via macro
+ */
+typedef struct {
+	VL53L0_DMaxData_t DMaxData;
+	/*!< Dmax Data */
+	int16_t  Part2PartOffsetNVMMicroMeter;
+	/*!< backed up NVM value */
+	VL53L0_DeviceParameters_t CurrentParameters;
+	/*!< Current Device Parameter */
+	VL53L0_RangingMeasurementData_t LastRangeMeasure;
+	/*!< Ranging Data */
+	VL53L0_HistogramMeasurementData_t LastHistogramMeasure;
+	/*!< Histogram Data */
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	/*!< Parameters specific to the device */
+	uint8_t SequenceConfig;
+	/*!< Internal value for the sequence config */
+	VL53L0_State PalState;
+	/*!< Current state of the PAL for this device */
+	VL53L0_PowerModes PowerMode;
+	/*!< Current Power Mode  */
+	uint16_t SigmaEstRefArray;
+	/*!< Reference array sigma value in 1/100th of [mm] e.g. 100 = 1mm */
+	uint16_t SigmaEstEffPulseWidth;
+	/*!< Effective Pulse width for sigma estimate in 1/100th of ns
+		e.g. 900 = 9.0ns */
+	uint16_t SigmaEstEffAmbWidth;
+	/*!< Effective Ambient width for sigma estimate in 1/100th of ns
+		e.g. 500 = 5.0ns */
+	FixPoint1616_t SigmaEstimate;
+	/*!< Sigma Estimate - based on ambient & VCSEL rates and
+		signal_total_events */
+	FixPoint1616_t SignalEstimate;
+	/*!< Signal Estimate - based on ambient & VCSEL rates and cross talk */
+#ifdef PAL_EXTENDED
+	VL53L0_TuningDeviceParameters_t TuningDeviceParameters;
+	/*!< Tuning Device Parameters specific to the device. */
+#endif
+
+} VL53L0_DevData_t;
+
+
+
+/** @defgroup VL53L0_define_InterruptPolarity_group Defines the Polarity of the
+ *  Interrupt
+ *  Defines the Polarity of the Interrupt
+ *  @{
+ */
+typedef uint8_t VL53L0_InterruptPolarity;
+
+#define VL53L0_INTERRUPTPOLARITY_LOW       ((VL53L0_InterruptPolarity)  0)
+/*!< Set active low polarity best setup for falling edge. */
+#define VL53L0_INTERRUPTPOLARITY_HIGH      ((VL53L0_InterruptPolarity)  1)
+/*!< Set active high polarity best setup for rising edge. */
+
+/** @} */ /* end of VL53L0_define_InterruptPolarity_group */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _VL53L0_DEF_H_ */
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_device.h b/drivers/input/misc/vl53L0/inc/vl53l0_device.h
new file mode 100644
index 00000000000..447f213cf56
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_device.h
@@ -0,0 +1,261 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+/**
+ * Device specific defines. To be adapted by implementer for the targeted device.
+ */
+
+#ifndef _VL53L0_DEVICE_H_
+#define _VL53L0_DEVICE_H_
+
+#include "vl53l0_types.h"
+
+
+/** @defgroup VL53L0_DeviceError_group Device Error
+ *  @brief Device Error code
+ *
+ *  This enum is Device specific it should be updated in the implementation
+ *  Use @a VL53L0_GetStatusErrorString() to get the string.
+ *  It is related to Status Register of the Device.
+ *  @ingroup regdef
+ *  @{
+ */
+typedef uint8_t VL53L0_DeviceError;
+
+#define VL53L0_DEVICEERROR_NONE \
+	((VL53L0_DeviceError)   0) /*!< 0  0b0000 NoError  */
+#define VL53L0_DEVICEERROR_VCSELCONTINUITYTESTFAILURE \
+	((VL53L0_DeviceError)   1) /*!< 1  0b0001  */
+#define VL53L0_DEVICEERROR_VCSELWATCHDOGTESTFAILURE \
+	((VL53L0_DeviceError)   2) /*!< 2  0b0010  */
+#define VL53L0_DEVICEERROR_NOVHVVALUEFOUND \
+	((VL53L0_DeviceError)   3) /*!< 3  0b0011  */
+#define VL53L0_DEVICEERROR_MSRCNOTARGET \
+	((VL53L0_DeviceError)   4) /*!< 4  0b0100  */
+#define VL53L0_DEVICEERROR_MSRCMINIMUMSNR \
+	((VL53L0_DeviceError)   5) /*!< 5  0b0101  */
+#define VL53L0_DEVICEERROR_MSRCWRAPAROUND \
+	((VL53L0_DeviceError)   6) /*!< 6  0b0110  */
+#define VL53L0_DEVICEERROR_TCC \
+	((VL53L0_DeviceError)   7) /*!< 7  0b0111  */
+#define VL53L0_DEVICEERROR_RANGEAWRAPAROUND \
+	((VL53L0_DeviceError)   8) /*!< 8  0b1000  */
+#define VL53L0_DEVICEERROR_RANGEBWRAPAROUND \
+	((VL53L0_DeviceError)   9) /*!< 9  0b1001  */
+#define VL53L0_DEVICEERROR_MINCLIP \
+	((VL53L0_DeviceError)   10) /*!< 10 0b1010  */
+#define VL53L0_DEVICEERROR_RANGECOMPLETE \
+	((VL53L0_DeviceError)   11) /*!< 11 0b1011  */
+#define VL53L0_DEVICEERROR_ALGOUNDERFLOW \
+	((VL53L0_DeviceError)   12) /*!< 12 0b1100  */
+#define VL53L0_DEVICEERROR_ALGOOVERFLOW \
+	((VL53L0_DeviceError)   13) /*!< 13 0b1101  */
+#define VL53L0_DEVICEERROR_FINALSNRLIMIT \
+	((VL53L0_DeviceError)   14) /*!< 14 0b1110  */
+#define VL53L0_DEVICEERROR_NOTARGETIGNORE \
+	((VL53L0_DeviceError)   15) /*!< 15 0b1111  */
+
+/** @} */ /* end of VL53L0_DeviceError_group */
+
+/** @defgroup VL53L0_CheckEnable_group Check Enable list
+ *  @brief Check Enable code
+ *
+ *  Define used to specify the LimitCheckId.
+ *  Use @a VL53L0_GetLimitCheckInfo() to get the string.
+ *  @ingroup regdef
+ *  @{
+ */
+
+#define VL53L0_CHECKENABLE_SNR                    0
+#define VL53L0_CHECKENABLE_SIGMA                  1
+#define VL53L0_CHECKENABLE_RANGE                  2
+#define VL53L0_CHECKENABLE_SIGNAL_RATE            3
+
+#define VL53L0_CHECKENABLE_NUMBER_OF_CHECKS       4
+
+/** @} */ /* end of VL53L0_CheckEnable_group */
+
+
+/** @defgroup VL53L0_GpioFunctionality_group Gpio Functionality
+ *  @brief Defines the different functionalities for the device GPIO(s)
+ *  @ingroup regdef
+ *  @{
+ */
+typedef uint8_t VL53L0_GpioFunctionality;
+
+#define VL53L0_GPIOFUNCTIONALITY_OFF \
+	((VL53L0_GpioFunctionality)  0) /*!< NO Interrupt  */
+#define VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW \
+	((VL53L0_GpioFunctionality)  1) /*!< Level Low (value < thresh_low)  */
+#define VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH \
+	((VL53L0_GpioFunctionality)  2) /*!< Level High (value > thresh_high) */
+#define VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT \
+	((VL53L0_GpioFunctionality)  3) /*!< Out Of Window (value < thresh_low
+						OR value > thresh_high) */
+#define VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY \
+	((VL53L0_GpioFunctionality)  4) /*!< New Sample Ready  */
+
+/** @} */ /* end of VL53L0_GpioFunctionality_group */
+
+
+typedef struct {
+	FixPoint1616_t OscFrequencyMHz;
+
+	uint16_t LastEncodedTimeout;
+
+	VL53L0_GpioFunctionality Pin0GpioFunctionality;
+
+} VL53L0_DeviceSpecificParameters_t;
+
+
+/* Device register map */
+
+/** @defgroup VL53L0_DefineRegisters_group Define Registers
+ *  @brief List of all the defined registers
+ *  @ingroup regdef
+ *  @{
+ */
+#define VL53L0_REG_SYSRANGE_START                  0x000
+    /** mask existing bit in #VL53L0_REG_SYSRANGE_START*/
+    #define VL53L0_REG_SYSRANGE_MODE_MASK          0x0F
+    /** bit 0 in #VL53L0_REG_SYSRANGE_START write 1 toggle state in
+		continuous mode and arm next shot in single shot mode */
+    #define VL53L0_REG_SYSRANGE_MODE_START_STOP    0x01
+    /** bit 1 write 0 in #VL53L0_REG_SYSRANGE_START set single shot mode */
+    #define VL53L0_REG_SYSRANGE_MODE_SINGLESHOT    0x00
+	/** bit 1 write 1 in #VL53L0_REG_SYSRANGE_START set back-to-back
+		operation mode */
+    #define VL53L0_REG_SYSRANGE_MODE_BACKTOBACK    0x02
+	/** bit 2 write 1 in #VL53L0_REG_SYSRANGE_START set timed operation
+		mode */
+	#define VL53L0_REG_SYSRANGE_MODE_TIMED         0x04
+	/** bit 3 write 1 in #VL53L0_REG_SYSRANGE_START set histogram
+		operation mode */
+	#define VL53L0_REG_SYSRANGE_MODE_HISTOGRAM     0x08
+
+
+#define VL53L0_REG_SYSTEM_THRESH_HIGH               0x000C  /* NOSLC  2 bytes */
+#define VL53L0_REG_SYSTEM_THRESH_LOW                0x000E  /* NOSLC  2 bytes */
+
+
+/* FPGA bitstream */
+#define VL53L0_REG_SYSTEM_SEQUENCE_CONFIG			0x0001
+#define VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD	0x0004
+
+#define VL53L0_REG_SYSTEM_REPORT_REQUEST	        0x0009
+	#define	VL53L0_REG_SYSTEM_RANGEA_DATA			0x04
+	#define	VL53L0_REG_SYSTEM_RANGEB_DATA			0x05
+
+#define VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO     0x000A
+	#define VL53L0_REG_SYSTEM_INTERRUPT_GPIO_DISABLED		0x00
+	#define VL53L0_REG_SYSTEM_INTERRUPT_GPIO_LEVEL_LOW		0x01
+	#define VL53L0_REG_SYSTEM_INTERRUPT_GPIO_LEVEL_HIGH	0x02
+	#define VL53L0_REG_SYSTEM_INTERRUPT_GPIO_OUT_OF_WINDOW	0x03
+	#define VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY	0x04
+
+#define VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH          0x0084
+
+#define VL53L0_REG_SYSTEM_INTERRUPT_CLEAR	0x000B
+
+/* Result registers */
+#define VL53L0_REG_RESULT_INTERRUPT_STATUS		    0x0013
+#define VL53L0_REG_RESULT_RANGE_STATUS		        0x0014
+
+#define VL53L0_REG_RESULT_SIGNAL_COUNT_RATE_RET     0x001A
+#define VL53L0_REG_RESULT_AMBIENT_COUNT_RATE_RET    0x001C
+#define VL53L0_REG_RESULT_FINAL_RANGE		        0x001E
+
+/* Algo register */
+#define VL53L0_REG_ALGO_CROSSTALK_COMPENSATION_RATE	0x0020
+#define VL53L0_REG_ALGO_RANGE_IGNORE_VALID_HEIGHT	0x0025
+#define VL53L0_REG_ALGO_RANGE_IGNORE_THRESHOLD		0x0026
+#define VL53L0_REG_ALGO_SNR_RATIO					0x0027
+#define VL53L0_REG_ALGO_RANGE_CHECK_ENABLES		    0x0028
+
+#define VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET	0x0029
+
+#define VL53L0_REG_I2C_SLAVE_DEVICE_ADDRESS	        0x008a
+
+/* MSRC registers */
+#define VL53L0_REG_MSRC_CONFIG_COUNT		        0x0044
+#define VL53L0_REG_MSRC_CONFIG_TIMEOUT		        0x0046
+#define VL53L0_REG_MSRC_CONFIG_MIN_SNR		        0x0055
+#define VL53L0_REG_MSRC_CONFIG_VALID_PHASE_LOW	    0x0047
+#define VL53L0_REG_MSRC_CONFIG_VALID_PHASE_HIGH     0x0048
+
+/* RANGE A registers */
+#define VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD	0x0050
+#define VL53L0_REG_RNGA_TIMEOUT_MSB			0x0051
+#define VL53L0_REG_RNGA_TIMEOUT_LSB			0x0052
+#define VL53L0_REG_RNGA_CONFIG_VALID_PHASE_LOW	0x0056
+#define VL53L0_REG_RNGA_CONFIG_VALID_PHASE_HIGH	0x0057
+
+/* RANGE B1 registers */
+#define VL53L0_REG_RNGB1_CONFIG_VCSEL_PERIOD	0x0060
+#define VL53L0_REG_RNGB1_TIMEOUT_MSB			0x0061
+#define VL53L0_REG_RNGB1_TIMEOUT_LSB			0x0062
+#define VL53L0_REG_RNGB1_CONFIG_VALID_PHASE_LOW	0x0066
+#define VL53L0_REG_RNGB1_CONFIG_VALID_PHASE_HIGH	0x0067
+
+/* RANGE B2 registers */
+#define VL53L0_REG_RNGB2_CONFIG_VCSEL_PERIOD	0x0070
+#define VL53L0_REG_RNGB2_TIMEOUT_MSB			0x0071
+#define VL53L0_REG_RNGB2_TIMEOUT_LSB			0x0072
+#define VL53L0_REG_RNGB2_CONFIG_VALID_PHASE_LOW	0x0076
+#define VL53L0_REG_RNGB2_CONFIG_VALID_PHASE_HIGH	0x0077
+
+
+#define VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N	  0x00bf
+#define VL53L0_REG_IDENTIFICATION_MODEL_ID        0x00c0
+#define VL53L0_REG_IDENTIFICATION_MODEL_TYPE      0x00c1
+#define VL53L0_REG_IDENTIFICATION_REVISION_ID     0x00c2
+#define VL53L0_REG_IDENTIFICATION_MODULE_ID       0x00c3
+
+#define VL53L0_REG_OSC_CALIBRATE_VAL              0x00f8
+
+#define VL53L0_REG_FIRMWARE_MODE_STATUS		           0x00C5
+
+#define VL53L0_REG_DYNAMIC_SPAD_ACTUAL_RTN_SPADS_INT   0x0016
+
+#define VL53L0_SIGMA_ESTIMATE_MAX_VALUE                65535
+/*equivalent to a range sigma of 655.35mm */
+
+/*
+ * Speed of light in um per 1E-10 Seconds
+ */
+
+#define VL53L0_SPEED_OF_LIGHT_IN_AIR 2997
+
+
+/** @} */ /* end of VL53L0_DefineRegisters_group */
+
+#endif
+
+/* _VL53L0_DEVICE_H_ */
+
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_i2c_platform.h b/drivers/input/misc/vl53L0/inc/vl53l0_i2c_platform.h
new file mode 100644
index 00000000000..4e2f95a8982
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_i2c_platform.h
@@ -0,0 +1,398 @@
+/*
+ * COPYRIGHT (C) STMicroelectronics 2014. All rights reserved.
+ *
+ * This software is the confidential and proprietary information of
+ * STMicroelectronics ("Confidential Information").  You shall not
+ * disclose such Confidential Information and shall use it only in
+ * accordance with the terms of the license agreement you entered into
+ * with STMicroelectronics
+ *
+ * Programming Golden Rule: Keep it Simple!
+ *
+ */
+
+/**
+ * @file   VL53L0_platform.h
+ * @brief  Function prototype definitions for Doppler Testchip Platform layer.
+ *
+ */
+
+
+#ifndef _VL53L0_I2C_PLATFORM_H_
+#define _VL53L0_I2C_PLATFORM_H_
+
+#include "vl53l0_def.h"
+
+
+/** Maximum buffer size to be used in i2c */
+#define VL53L0_MAX_I2C_XFER_SIZE   64
+
+/**
+ *  @brief Typedef defining .\n
+ * The developer shoud modify this to suit the platform being deployed.
+ *
+ */
+
+/**
+ * @brief Typedef defining 8 bit unsigned char type.\n
+ * The developer shoud modify this to suit the platform being deployed.
+ *
+ */
+
+#ifndef bool_t
+typedef unsigned char bool_t;
+#endif
+
+
+#define	   I2C                0x01
+#define	   SPI                0x00
+
+#define    COMMS_BUFFER_SIZE    64
+/*MUST be the same size as the SV task buffer */
+
+#define    BYTES_PER_WORD        2
+#define    BYTES_PER_DWORD       4
+
+#define    VL53L0_MAX_STRING_LENGTH_PLT       256
+
+/**
+ * @brief  Initialise platform comms.
+ *
+ * @param  comms_type      - selects between I2C and SPI
+ * @param  comms_speed_khz - unsigned short containing the I2C speed in kHz
+ *
+ * @return status - status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_comms_initialise(uint8_t  comms_type,
+			uint16_t comms_speed_khz);
+
+/**
+ * @brief  Close platform comms.
+ *
+ * @return status - status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_comms_close(void);
+
+/**
+ * @brief  Cycle Power to Device
+ *
+ * @return status - status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_cycle_power(void);
+
+int32_t VL53L0_set_page(VL53L0_DEV dev, uint8_t page_data);
+
+/**
+ * @brief Writes the supplied byte buffer to the device
+ *
+ * Wrapper for SystemVerilog Write Multi task
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint8_t *spad_enables;
+ *
+ * int status = VL53L0_write_multi(RET_SPAD_EN_0, spad_enables, 36);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index - uint8_t register index value
+ * @param  pdata - pointer to uint8_t buffer containing the data to be written
+ * @param  count - number of bytes in the supplied byte buffer
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_write_multi(VL53L0_DEV dev, uint8_t index, uint8_t  *pdata,
+		int32_t count);
+
+
+/**
+ * @brief  Reads the requested number of bytes from the device
+ *
+ * Wrapper for SystemVerilog Read Multi task
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint8_t buffer[COMMS_BUFFER_SIZE];
+ *
+ * int status = status  = VL53L0_read_multi(DEVICE_ID, buffer, 2)
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index - uint8_t register index value
+ * @param  pdata - pointer to the uint8_t buffer to store read data
+ * @param  count - number of uint8_t's to read
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_read_multi(VL53L0_DEV dev,  uint8_t index, uint8_t  *pdata,
+		int32_t count);
+
+
+/**
+ * @brief  Writes a single byte to the device
+ *
+ * Wrapper for SystemVerilog Write Byte task
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint8_t page_number = MAIN_SELECT_PAGE;
+ *
+ * int status = VL53L0_write_byte(PAGE_SELECT, page_number);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index - uint8_t register index value
+ * @param  data  - uint8_t data value to write
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_write_byte(VL53L0_DEV dev,  uint8_t index, uint8_t   data);
+
+
+/**
+ * @brief  Writes a single word (16-bit unsigned) to the device
+ *
+ * Manages the big-endian nature of the device (first byte written is the
+ * MS byte).
+ * Uses SystemVerilog Write Multi task.
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint16_t nvm_ctrl_pulse_width = 0x0004;
+ *
+ * int status = VL53L0_write_word(NVM_CTRL__PULSE_WIDTH_MSB,
+ * nvm_ctrl_pulse_width);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index - uint8_t register index value
+ * @param  data  - uin16_t data value write
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_write_word(VL53L0_DEV dev,  uint8_t index, uint16_t  data);
+
+
+/**
+ * @brief  Writes a single dword (32-bit unsigned) to the device
+ *
+ * Manages the big-endian nature of the device (first byte written is the
+ * MS byte).
+ * Uses SystemVerilog Write Multi task.
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint32_t nvm_data = 0x0004;
+ *
+ * int status = VL53L0_write_dword(NVM_CTRL__DATAIN_MMM, nvm_data);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index - uint8_t register index value
+ * @param  data  - uint32_t data value to write
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_write_dword(VL53L0_DEV dev, uint8_t index, uint32_t  data);
+
+
+
+/**
+ * @brief  Reads a single byte from the device
+ *
+ * Uses SystemVerilog Read Byte task.
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint8_t device_status = 0;
+ *
+ * int status = VL53L0_read_byte(STATUS, &device_status);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index  - uint8_t register index value
+ * @param  pdata  - pointer to uint8_t data value
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_read_byte(VL53L0_DEV dev,  uint8_t index, uint8_t  *pdata);
+
+
+/**
+ * @brief  Reads a single word (16-bit unsigned) from the device
+ *
+ * Manages the big-endian nature of the device (first byte read is the MS byte).
+ * Uses SystemVerilog Read Multi task.
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint16_t timeout = 0;
+ *
+ * int status = VL53L0_read_word(TIMEOUT_OVERALL_PERIODS_MSB, &timeout);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index  - uint8_t register index value
+ * @param  pdata  - pointer to uint16_t data value
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_read_word(VL53L0_DEV dev,  uint8_t index, uint16_t *pdata);
+
+
+/**
+ * @brief  Reads a single dword (32-bit unsigned) from the device
+ *
+ * Manages the big-endian nature of the device (first byte read is the MS byte).
+ * Uses SystemVerilog Read Multi task.
+ *
+ * @code
+ *
+ * Example:
+ *
+ * uint32_t range_1 = 0;
+ *
+ * int status = VL53L0_read_dword(RANGE_1_MMM, &range_1);
+ *
+ * @endcode
+ *
+ * @param  address - uint8_t device address value
+ * @param  index - uint8_t register index value
+ * @param  pdata - pointer to uint32_t data value
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_read_dword(VL53L0_DEV dev, uint8_t index, uint32_t *pdata);
+
+
+/**
+ * @brief  Implements a programmable wait in us
+ *
+ * Wrapper for SystemVerilog Wait in micro seconds task
+ *
+ * @param  wait_us - integer wait in micro seconds
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_platform_wait_us(int32_t wait_us);
+
+
+/**
+ * @brief  Implements a programmable wait in ms
+ *
+ * Wrapper for SystemVerilog Wait in milli seconds task
+ *
+ * @param  wait_ms - integer wait in milli seconds
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_wait_ms(int32_t wait_ms);
+
+
+/**
+ * @brief Set GPIO value
+ *
+ * @param  level  - input  level - either 0 or 1
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_set_gpio(uint8_t  level);
+
+
+/**
+ * @brief Get GPIO value
+ *
+ * @param  plevel - uint8_t pointer to store GPIO level (0 or 1)
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_get_gpio(uint8_t *plevel);
+
+/**
+ * @brief Release force on GPIO
+ *
+ * @return status - SystemVerilog status 0 = ok, 1 = error
+ *
+ */
+
+int32_t VL53L0_release_gpio(void);
+
+
+/**
+* @brief Get the frequency of the timer used for ranging results time stamps
+*
+* @param[out] ptimer_freq_hz : pointer for timer frequency
+*
+* @return status : 0 = ok, 1 = error
+*
+*/
+
+int32_t VL53L0_get_timer_frequency(int32_t *ptimer_freq_hz);
+
+/**
+* @brief Get the timer value in units of timer_freq_hz
+* (see VL53L0_get_timestamp_frequency())
+*
+* @param[out] ptimer_count : pointer for timer count value
+*
+* @return status : 0 = ok, 1 = error
+*
+*/
+
+int32_t VL53L0_get_timer_value(int32_t *ptimer_count);
+int VL53L0_I2CWrite(VL53L0_DEV dev, uint8_t *buff, uint8_t len);
+int VL53L0_I2CRead(VL53L0_DEV dev, uint8_t *buff, uint8_t len);
+
+#endif /* _VL53L0_I2C_PLATFORM_H_ */
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_platform.h b/drivers/input/misc/vl53L0/inc/vl53l0_platform.h
new file mode 100644
index 00000000000..5122c88163d
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_platform.h
@@ -0,0 +1,228 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+
+#ifndef _VL53L0_PLATFORM_H_
+#define _VL53L0_PLATFORM_H_
+
+#include <linux/delay.h>
+#include "vl53l0_def.h"
+#include "vl53l0_platform_log.h"
+
+#include "stmvl53l0-i2c.h"
+#include "stmvl53l0-cci.h"
+#include "stmvl53l0.h"
+
+/**
+ * @file vl53l0_platform.h
+ *
+ * @brief All end user OS/platform/application porting
+ */
+
+/**
+ * @defgroup VL53L0_platform_group VL53L0 Platform Functions
+ * @brief    VL53L0 Platform Functions
+ *  @{
+ */
+
+/**
+ * @struct  VL53L0_Dev_t
+ * @brief    Generic PAL device type that does link between API and platform abstraction layer
+ *
+ */
+typedef struct stmvl53l0_data *VL53L0_DEV;
+
+/**
+ * @def PALDevDataGet
+ * @brief Get ST private structure @a VL53L0_DevData_t data access
+ *
+ * @param Dev       Device Handle
+ * @param field     ST structure field name
+ * It maybe used and as real data "ref" not just as "get" for sub-structure item
+ * like PALDevDataGet(FilterData.field)[i] or
+ * PALDevDataGet(FilterData.MeasurementIndex)++
+ */
+#define PALDevDataGet(Dev, field) (Dev->Data.field)
+
+/**
+ * @def PALDevDataSet(Dev, field, data)
+ * @brief  Set ST private structure @a VL53L0_DevData_t data field
+ * @param Dev       Device Handle
+ * @param field     ST structure field na*me
+ * @param data      Data to be set
+ */
+#define PALDevDataSet(Dev, field, data) (Dev->Data.field) = (data)
+
+
+/**
+ * @defgroup VL53L0_registerAccess_group PAL Register Access Functions
+ * @brief    PAL Register Access Functions
+ *  @{
+ */
+
+/**
+ * Lock comms interface to serialize all commands to a shared I2C interface for a specific device
+ * @param   Dev       Device Handle
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_LockSequenceAccess(VL53L0_DEV Dev);
+
+/**
+ * Unlock comms interface to serialize all commands to a shared I2C interface for a specific device
+ * @param   Dev       Device Handle
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_UnlockSequenceAccess(VL53L0_DEV Dev);
+
+
+/**
+ * Writes the supplied byte buffer to the device
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   pdata     Pointer to uint8_t buffer containing the data to be written
+ * @param   count     Number of bytes in the supplied byte buffer
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_WriteMulti(VL53L0_DEV Dev, uint8_t index,
+		uint8_t *pdata, uint32_t count);
+
+/**
+ * Reads the requested number of bytes from the device
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   pdata     Pointer to the uint8_t buffer to store read data
+ * @param   count     Number of uint8_t's to read
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_ReadMulti(VL53L0_DEV Dev, uint8_t index,
+		uint8_t *pdata, uint32_t count);
+
+/**
+ * Write single byte register
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   data      8 bit register data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_WrByte(VL53L0_DEV Dev, uint8_t index, uint8_t data);
+
+/**
+ * Write word register
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   data      16 bit register data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_WrWord(VL53L0_DEV Dev, uint8_t index, uint16_t data);
+
+/**
+ * Write double word (4 byte) register
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   data      32 bit register data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_WrDWord(VL53L0_DEV Dev, uint8_t index, uint32_t data);
+
+/**
+ * Read single byte register
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   data      pointer to 8 bit data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_RdByte(VL53L0_DEV Dev, uint8_t index, uint8_t *data);
+
+/**
+ * Read word (2byte) register
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   data      pointer to 16 bit data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_RdWord(VL53L0_DEV Dev, uint8_t index, uint16_t *data);
+
+/**
+ * Read dword (4byte) register
+ * @param   Dev       Device Handle
+ * @param   index     The register index
+ * @param   data      pointer to 32 bit data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_RdDWord(VL53L0_DEV Dev, uint8_t index, uint32_t *data);
+
+/**
+ * Threat safe Update (read/modify/write) single byte register
+ *
+ * Final_reg = (Initial_reg & and_data) |or_data
+ *
+ * @param   Dev        Device Handle
+ * @param   index      The register index
+ * @param   AndData    8 bit and data
+ * @param   OrData     8 bit or data
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_UpdateByte(VL53L0_DEV Dev, uint8_t index,
+		uint8_t AndData, uint8_t OrData);
+
+/** @} end of VL53L0_registerAccess_group */
+
+
+/**
+ * @brief execute delay in all polling API call
+ *
+ * A typical multi-thread or RTOs implementation is to sleep the task for
+ * some 5ms (with 100Hz max rate faster polling is not needed)
+ * if nothing specific is need you can define it as an empty/void macro
+ * @code
+ * #define VL53L0_PollingDelay(...) (void)0
+ * @endcode
+ * @param Dev       Device Handle
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_PollingDelay(VL53L0_DEV Dev);
+/* usually best implemented as a real function */
+
+/** @} end of VL53L0_platform_group */
+
+#endif  /* _VL53L0_PLATFORM_H_ */
+
+
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_platform_log.h b/drivers/input/misc/vl53L0/inc/vl53l0_platform_log.h
new file mode 100644
index 00000000000..aab1e60e252
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_platform_log.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+
+#ifndef _VL53L0_PLATFORM_LOG_H_
+#define _VL53L0_PLATFORM_LOG_H_
+
+#include <linux/string.h>
+/* LOG Functions */
+
+
+/**
+ * @file vl53l0_platform_log.h
+ *
+ * @brief platform log function definition
+ */
+
+/*#define VL53L0_LOG_ENABLE 0*/
+
+enum {
+	TRACE_LEVEL_NONE,
+	TRACE_LEVEL_ERRORS,
+	TRACE_LEVEL_WARNING,
+	TRACE_LEVEL_INFO,
+	TRACE_LEVEL_DEBUG,
+	TRACE_LEVEL_ALL,
+	TRACE_LEVEL_IGNORE
+};
+
+enum {
+	TRACE_FUNCTION_NONE = 0,
+	TRACE_FUNCTION_I2C  = 1,
+	TRACE_FUNCTION_ALL  = 0x7fffffff /* all bits except sign */
+};
+
+enum {
+	TRACE_MODULE_NONE              = 0x0,
+	TRACE_MODULE_API               = 0x1,
+	TRACE_MODULE_PLATFORM          = 0x2,
+	TRACE_MODULE_ALL               = 0x7fffffff /* all bits except sign */
+};
+
+
+#ifdef VL53L0_LOG_ENABLE
+
+#include <linux/module.h>
+
+
+extern uint32_t _trace_level;
+
+
+
+int32_t VL53L0_trace_config(char *filename, uint32_t modules,
+			uint32_t level, uint32_t functions);
+
+void trace_print_module_function(uint32_t module, uint32_t level,
+			uint32_t function, const char *format, ...);
+
+
+#define LOG_GET_TIME() (int)0
+
+#define _LOG_FUNCTION_START(module, fmt, ...) \
+		printk(KERN_INFO"beg %s start @%d\t" fmt "\n", \
+		__func__, LOG_GET_TIME(), ##__VA_ARGS__)
+
+#define _LOG_FUNCTION_END(module, status, ...)\
+		printk(KERN_INFO"end %s @%d %d\n", \
+		 __func__, LOG_GET_TIME(), (int)status)
+
+#define _LOG_FUNCTION_END_FMT(module, status, fmt, ...)\
+		printk(KERN_INFO"End %s @%d %d\t"fmt"\n" , \
+		__func__, LOG_GET_TIME(), (int)status, ##__VA_ARGS__)
+
+#else /* VL53L0_LOG_ENABLE no logging */
+	#define VL53L0_ErrLog(...) (void)0
+	#define _LOG_FUNCTION_START(module, fmt, ...) (void)0
+	#define _LOG_FUNCTION_END(module, status, ...) (void)0
+	#define _LOG_FUNCTION_END_FMT(module, status, fmt, ...) (void)0
+#endif /* else */
+
+#define VL53L0_COPYSTRING(str, ...) strcpy(str, ##__VA_ARGS__)
+
+
+#endif  /* _VL53L0_PLATFORM_LOG_H_ */
+
+
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_strings.h b/drivers/input/misc/vl53L0/inc/vl53l0_strings.h
new file mode 100644
index 00000000000..3e93720097d
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_strings.h
@@ -0,0 +1,138 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+/*
+ * @file vl53l0_string.h
+ * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * $Revision: 1906 $
+ */
+
+#ifndef VL53L0_STRINGS_H_
+#define VL53L0_STRINGS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define  VL53L0_STRING_DEVICE_INFO_NAME		"VL53L0 cut1.0"
+#define  VL53L0_STRING_DEVICE_INFO_NAME_TS0	"VL53L0 TS0"
+#define  VL53L0_STRING_DEVICE_INFO_NAME_TS1 "VL53L0 TS1"
+#define  VL53L0_STRING_DEVICE_INFO_NAME_TS2 "VL53L0 TS2"
+#define  VL53L0_STRING_DEVICE_INFO_NAME_ES1 \
+			"VL53L0 ES1 or later"
+#define  VL53L0_STRING_DEVICE_INFO_TYPE  "VL53L0"
+
+/* PAL ERROR strings */
+#define  VL53L0_STRING_ERROR_NONE	"No Error"
+#define  VL53L0_STRING_ERROR_CALIBRATION_WARNING \
+			"Calibration Warning Error"
+#define  VL53L0_STRING_ERROR_MIN_CLIPPED \
+			"Min clipped error"
+#define  VL53L0_STRING_ERROR_UNDEFINED \
+			"Undefined error"
+#define  VL53L0_STRING_ERROR_INVALID_PARAMS \
+			"Invalid parameters error"
+#define  VL53L0_STRING_ERROR_NOT_SUPPORTED \
+			"Not supported error"
+#define  VL53L0_STRING_ERROR_RANGE_ERROR \
+			"Range error"
+#define  VL53L0_STRING_ERROR_TIME_OUT \
+			"Time out error"
+#define  VL53L0_STRING_ERROR_MODE_NOT_SUPPORTED \
+			"Mode not supported error"
+#define  VL53L0_STRING_ERROR_NOT_IMPLEMENTED \
+			"Not implemented error"
+
+#define  VL53L0_STRING_UNKNOW_ERROR_CODE \
+			"Unknow Error Code"
+#define  VL53L0_STRING_ERROR_BUFFER_TOO_SMALL \
+			"Buffer too small"
+
+#define  VL53L0_STRING_ERROR_GPIO_NOT_EXISTING \
+			"GPIO not existing"
+#define  VL53L0_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED \
+			"GPIO functionality not supported"
+#define  VL53L0_STRING_ERROR_CONTROL_INTERFACE \
+			"Control Interface Error"
+
+
+/* Device Specific */
+#define  VL53L0_STRING_DEVICEERROR_NONE \
+			"No Update"
+#define  VL53L0_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE \
+			"VCSEL Continuity Test Failure"
+#define  VL53L0_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE \
+			"VCSEL Watchdog Test Failure"
+#define  VL53L0_STRING_DEVICEERROR_NOVHVVALUEFOUND \
+			"No VHV Value found"
+#define  VL53L0_STRING_DEVICEERROR_MSRCNOTARGET \
+			"MSRC No Target Error"
+#define  VL53L0_STRING_DEVICEERROR_MSRCMINIMUMSNR \
+			"MSRC Minimum SNR Error"
+#define  VL53L0_STRING_DEVICEERROR_MSRCWRAPAROUND \
+			"MSRC Wraparound Error"
+#define  VL53L0_STRING_DEVICEERROR_TCC \
+			"TCC Error"
+#define  VL53L0_STRING_DEVICEERROR_RANGEAWRAPAROUND \
+			"Range A Wraparound Error"
+#define  VL53L0_STRING_DEVICEERROR_RANGEBWRAPAROUND \
+			"Range B Wraparound Error"
+#define  VL53L0_STRING_DEVICEERROR_MINCLIP \
+			"Min Clip Error"
+#define  VL53L0_STRING_DEVICEERROR_RANGECOMPLETE \
+			"Range Complete"
+#define  VL53L0_STRING_DEVICEERROR_ALGOUNDERFLOW \
+			"Range Algo Underflow Error"
+#define  VL53L0_STRING_DEVICEERROR_ALGOOVERFLOW \
+			"Range Algo Overlow Error"
+#define  VL53L0_STRING_DEVICEERROR_FINALSNRLIMIT \
+			"Final Minimum SNR Error"
+#define  VL53L0_STRING_DEVICEERROR_NOTARGETIGNORE \
+			"No Target Ignore Error"
+#define  VL53L0_STRING_DEVICEERROR_UNKNOWN \
+			"Unknown error code"
+
+
+/* Check Enable */
+#define  VL53L0_STRING_CHECKENABLE_SNR \
+			"SNR"
+#define  VL53L0_STRING_CHECKENABLE_SIGMA \
+			"SIGMA"
+#define  VL53L0_STRING_CHECKENABLE_RANGE \
+			"RANGE"
+#define  VL53L0_STRING_CHECKENABLE_SIGNAL_RATE \
+			"SIGNAL RATE"
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h b/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h
new file mode 100644
index 00000000000..2066712822d
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h
@@ -0,0 +1,65 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+/*
+ * @file vl53l0_api.h
+ * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * $Revision: 1906 $
+ */
+
+
+
+#ifndef _VL53L0_TUNING_H_
+#define _VL53L0_TUNING_H_
+
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * @brief Internal function used to Program the default tuning settings
+ *
+ * @ingroup VL53L0_general_group
+ * @note This function access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VL53L0_TUNING_H_ */
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_types.h b/drivers/input/misc/vl53L0/inc/vl53l0_types.h
new file mode 100644
index 00000000000..a644c154481
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_types.h
@@ -0,0 +1,68 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+#ifndef VL6180x_TYPES_H_
+#define VL6180x_TYPES_H_
+
+#include <linux/types.h>
+
+#ifndef NULL
+#error "TODO review  NULL definition or add required include "
+#define NULL 0
+#endif
+/** use where fractional values are expected
+ *
+ * Given a floating point value f it's .16 bit point is (int)(f*(1<<16))*/
+typedef unsigned int FixPoint1616_t;
+
+#if !defined(STDINT_H) &&  !defined(_GCC_STDINT_H) \
+	&& !defined(_STDINT_H) && !defined(_LINUX_TYPES_H)
+
+#pragma message("Please review type definition of STDINT define for \
+	 your platform and add to list above ")
+
+/*
+*  target platform do not provide stdint or use a different #define than above
+*  to avoid seeing the message below addapt the #define list above or implement
+*  all type and delete these pragma
+*/
+
+typedef unsigned int uint32_t;
+typedef int int32_t;
+
+typedef unsigned short uint16_t;
+typedef short int16_t;
+
+typedef unsigned char uint8_t;
+
+typedef signed char int8_t;
+
+
+#endif /* _STDINT_H */
+
+#endif /* VL6180x_TYPES_H_ */
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_api.c b/drivers/input/misc/vl53L0/src/vl53l0_api.c
new file mode 100644
index 00000000000..1e94d664ec4
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l0_api.c
@@ -0,0 +1,4283 @@
+/*******************************************************************************
+ Copyright © 2015, STMicroelectronics International N.V.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in the
+ documentation and/or other materials provided with the distribution.
+ * Neither the name of STMicroelectronics nor the
+ names of its contributors may be used to endorse or promote products
+ derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+ NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+ IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+#include "vl53l0_api.h"
+#include "vl53l0_tuning.h"
+#ifndef __KERNEL__
+#include <stdlib.h>
+#endif
+
+#define LOG_FUNCTION_START(fmt, ...) \
+	_LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
+#define LOG_FUNCTION_END(status, ...) \
+	_LOG_FUNCTION_END(TRACE_MODULE_API, status, ##__VA_ARGS__)
+#define LOG_FUNCTION_END_FMT(status, fmt, ...) \
+	_LOG_FUNCTION_END_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)
+
+#ifdef VL53L0_LOG_ENABLE
+#define trace_print(level, ...) trace_print_module_function(TRACE_MODULE_API, \
+	level, TRACE_FUNCTION_NONE, ##__VA_ARGS__)
+#endif
+
+
+/* Defines */
+#define VL53L0_SETPARAMETERFIELD(Dev, field, value) \
+	if (Status == VL53L0_ERROR_NONE) { \
+		CurrentParameters = PALDevDataGet(Dev, CurrentParameters); \
+		CurrentParameters.field = value; \
+		CurrentParameters =	\
+		PALDevDataSet(Dev, CurrentParameters, \
+		CurrentParameters); }
+#define VL53L0_SETARRAYPARAMETERFIELD(Dev, field, index, value) \
+	if (Status == VL53L0_ERROR_NONE) { \
+		CurrentParameters = PALDevDataGet(Dev, CurrentParameters); \
+		CurrentParameters.field[index] = value; \
+		CurrentParameters = \
+			PALDevDataSet(Dev, CurrentParameters, \
+		CurrentParameters); }
+
+#define VL53L0_GETPARAMETERFIELD(Dev, field, variable) \
+	if (Status == VL53L0_ERROR_NONE) { \
+		CurrentParameters = PALDevDataGet(Dev, CurrentParameters); \
+		variable = CurrentParameters.field; }
+
+#define VL53L0_GETARRAYPARAMETERFIELD(Dev, field, index, variable) \
+	if (Status == VL53L0_ERROR_NONE) { \
+		CurrentParameters = PALDevDataGet(Dev, CurrentParameters); \
+		variable = CurrentParameters.field[index]; }
+
+#define VL53L0_SETDEVICESPECIFICPARAMETER(Dev, field, value) \
+	if (Status == VL53L0_ERROR_NONE) { \
+		DeviceSpecificParameters = \
+			PALDevDataGet(Dev, DeviceSpecificParameters); \
+		DeviceSpecificParameters.field = value; \
+		DeviceSpecificParameters = \
+			PALDevDataSet(Dev, \
+			DeviceSpecificParameters, \
+			DeviceSpecificParameters); }
+
+#define VL53L0_GETDEVICESPECIFICPARAMETER(Dev, field) \
+		PALDevDataGet(Dev, DeviceSpecificParameters).field
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT97(Value) \
+			(uint16_t)((Value >> 9) & 0xFFFF)
+#define VL53L0_FIXPOINT97TOFIXPOINT1616(Value) \
+			(FixPoint1616_t)(Value << 9)
+#define VL53L0_FIXPOINT1616TOFIXPOINT412(Value) \
+			(uint16_t)((Value >> 4) & 0xFFFF)
+#define VL53L0_FIXPOINT412TOFIXPOINT1616(Value) \
+			(FixPoint1616_t)(Value << 4)
+#define VL53L0_FIXPOINT1616TOFIXPOINT08(Value) \
+			(uint8_t)((Value >> 8) & 0x00FF)
+#define VL53L0_FIXPOINT08TOFIXPOINT1616(Value) \
+			(FixPoint1616_t)(Value << 8)
+#define VL53L0_MAKEUINT16(lsb, msb) \
+			(uint16_t)((((uint16_t)msb) << 8) + (uint16_t)lsb)
+
+/* Internal functions declaration */
+static VL53L0_Error VL53L0_set_vcsel_pulse_period(VL53L0_DEV Dev,
+				uint8_t VCSELPulsePeriod);
+static VL53L0_Error VL53L0_get_vcsel_pulse_period(VL53L0_DEV Dev,
+				uint8_t *pVCSELPulsePeriod, uint8_t RangeIndex);
+static uint8_t VL53L0_encode_vcsel_period(uint8_t vcsel_period_pclks);
+static uint8_t VL53L0_decode_vcsel_period(uint8_t vcsel_period_reg);
+static uint16_t VL53L0_calc_encoded_timeout(VL53L0_DEV Dev,
+			uint32_t timeout_period_us, uint8_t vcsel_period);
+static uint32_t VL53L0_calc_ranging_wait_us(VL53L0_DEV Dev,
+			uint16_t timeout_overall_periods, uint8_t vcsel_period);
+static VL53L0_Error VL53L0_load_additional_settings1(VL53L0_DEV Dev);
+static VL53L0_Error VL53L0_load_additional_settings3(VL53L0_DEV Dev);
+static VL53L0_Error VL53L0_check_part_used(VL53L0_DEV Dev, uint8_t *Revision);
+static VL53L0_Error VL53L0_get_info_from_device(VL53L0_DEV Dev,
+				uint8_t *Revision);
+static VL53L0_Error VL53L0_get_pal_range_status(VL53L0_DEV Dev,
+				uint8_t DeviceRangeStatus,
+				FixPoint1616_t SignalRate,
+				FixPoint1616_t CrosstalkCompensation,
+				uint16_t EffectiveSpadRtnCount,
+				VL53L0_RangingMeasurementData_t
+					*pRangingMeasurementData,
+				uint8_t *pPalRangeStatus);
+
+/* Group PAL General Functions */
+VL53L0_Error VL53L0_GetVersion(VL53L0_Version_t *pVersion)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	pVersion->major = VL53L0_IMPLEMENTATION_VER_MAJOR;
+	pVersion->minor = VL53L0_IMPLEMENTATION_VER_MINOR;
+	pVersion->build = VL53L0_IMPLEMENTATION_VER_SUB;
+
+	pVersion->revision = VL53L0_IMPLEMENTATION_VER_REVISION;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetPalSpecVersion(VL53L0_Version_t *pPalSpecVersion)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	pPalSpecVersion->major = VL53L0_SPECIFICATION_VER_MAJOR;
+	pPalSpecVersion->minor = VL53L0_SPECIFICATION_VER_MINOR;
+	pPalSpecVersion->build = VL53L0_SPECIFICATION_VER_SUB;
+
+	pPalSpecVersion->revision = VL53L0_SPECIFICATION_VER_REVISION;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceInfo(VL53L0_DEV Dev,
+				VL53L0_DeviceInfo_t *pVL53L0_DeviceInfo)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t model_id;
+	uint8_t Revision;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_check_part_used(Dev, &Revision);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Revision == 0) {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L0_STRING_DEVICE_INFO_NAME_TS0);
+		} else if ((Revision <= 34) && (Revision != 32)) {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L0_STRING_DEVICE_INFO_NAME_TS1);
+		} else if (Revision < 39) {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L0_STRING_DEVICE_INFO_NAME_TS2);
+		} else {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L0_STRING_DEVICE_INFO_NAME_ES1);
+		}
+
+		VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Type,
+			VL53L0_STRING_DEVICE_INFO_TYPE);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODEL_ID,
+					&pVL53L0_DeviceInfo->ProductType);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODEL_ID,
+					&model_id);
+		pVL53L0_DeviceInfo->ProductRevisionMajor =
+			(model_id & 0xE0) >> 5;
+		pVL53L0_DeviceInfo->ProductRevisionMinor =
+			(model_id + 9) & 0x1F;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceErrorStatus(VL53L0_DEV Dev,
+				VL53L0_DeviceError *pDeviceErrorStatus)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t RangeStatus;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_RANGE_STATUS,
+		&RangeStatus);
+
+	*pDeviceErrorStatus = (VL53L0_DeviceError)((RangeStatus & 0x78) >> 3);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+#define VL53L0_BUILDSTATUSERRORSTRING(BUFFER, ERRORCODE, STRINGVALUE) \
+		do {\
+			case ERRORCODE: \
+				VL53L0_COPYSTRING(BUFFER, STRINGVALUE);\
+				break;\
+		} while (0)
+
+VL53L0_Error VL53L0_GetDeviceErrorString(VL53L0_DeviceError ErrorCode,
+				char *pDeviceErrorString)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	switch (ErrorCode) {
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_NONE,
+			VL53L0_STRING_DEVICEERROR_NONE);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_VCSELCONTINUITYTESTFAILURE,
+			VL53L0_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_VCSELWATCHDOGTESTFAILURE,
+			VL53L0_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_NOVHVVALUEFOUND,
+			VL53L0_STRING_DEVICEERROR_NOVHVVALUEFOUND);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_MSRCNOTARGET,
+			VL53L0_STRING_DEVICEERROR_MSRCNOTARGET);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_MSRCMINIMUMSNR,
+			VL53L0_STRING_DEVICEERROR_MSRCMINIMUMSNR);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_MSRCWRAPAROUND,
+			VL53L0_STRING_DEVICEERROR_MSRCWRAPAROUND);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_TCC, VL53L0_STRING_DEVICEERROR_TCC);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_RANGEAWRAPAROUND,
+			VL53L0_STRING_DEVICEERROR_RANGEAWRAPAROUND);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_RANGEBWRAPAROUND,
+			VL53L0_STRING_DEVICEERROR_RANGEBWRAPAROUND);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_MINCLIP,
+			VL53L0_STRING_DEVICEERROR_MINCLIP);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_RANGECOMPLETE,
+			VL53L0_STRING_DEVICEERROR_RANGECOMPLETE);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_ALGOUNDERFLOW,
+			VL53L0_STRING_DEVICEERROR_ALGOUNDERFLOW);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_ALGOOVERFLOW,
+			VL53L0_STRING_DEVICEERROR_ALGOOVERFLOW);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_FINALSNRLIMIT,
+			VL53L0_STRING_DEVICEERROR_FINALSNRLIMIT);
+	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L0_DEVICEERROR_NOTARGETIGNORE,
+			VL53L0_STRING_DEVICEERROR_NOTARGETIGNORE);
+	default:
+		VL53L0_COPYSTRING(pDeviceErrorString,
+			VL53L0_STRING_UNKNOW_ERROR_CODE);
+
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetPalErrorString(VL53L0_Error PalErrorCode,
+				char *pPalErrorString)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	switch (PalErrorCode) {
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_NONE, VL53L0_STRING_ERROR_NONE);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_CALIBRATION_WARNING,
+			VL53L0_STRING_ERROR_CALIBRATION_WARNING);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_MIN_CLIPPED,
+			VL53L0_STRING_ERROR_MIN_CLIPPED);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_UNDEFINED, VL53L0_STRING_ERROR_UNDEFINED);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_INVALID_PARAMS,
+			VL53L0_STRING_ERROR_INVALID_PARAMS);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_NOT_SUPPORTED,
+			VL53L0_STRING_ERROR_NOT_SUPPORTED);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_RANGE_ERROR,
+			VL53L0_STRING_ERROR_RANGE_ERROR);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_TIME_OUT,
+			VL53L0_STRING_ERROR_TIME_OUT);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_MODE_NOT_SUPPORTED,
+			VL53L0_STRING_ERROR_MODE_NOT_SUPPORTED);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_NOT_IMPLEMENTED,
+			VL53L0_STRING_ERROR_NOT_IMPLEMENTED);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_BUFFER_TOO_SMALL,
+			VL53L0_STRING_ERROR_BUFFER_TOO_SMALL);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_GPIO_NOT_EXISTING,
+			VL53L0_STRING_ERROR_GPIO_NOT_EXISTING);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED,
+			VL53L0_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED);
+	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_CONTROL_INTERFACE,
+			VL53L0_STRING_ERROR_CONTROL_INTERFACE);
+	default:
+		VL53L0_COPYSTRING(pPalErrorString,
+			VL53L0_STRING_UNKNOW_ERROR_CODE);
+		break;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_GetPalState(VL53L0_DEV Dev, VL53L0_State *pPalState)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	*pPalState = PALDevDataGet(Dev, PalState);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes PowerMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	/* Only level1 of Power mode exists */
+	if ((PowerMode != VL53L0_POWERMODE_STANDBY_LEVEL1) &&
+		(PowerMode != VL53L0_POWERMODE_IDLE_LEVEL1)) {
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	} else if (PowerMode == VL53L0_POWERMODE_STANDBY_LEVEL1) {
+		/* set the standby level1 of power mode */
+		Status = VL53L0_WrByte(Dev, 0x80, 0x00);
+		if (Status == VL53L0_ERROR_NONE) {
+			/* Set PAL State to standby */
+			PALDevDataSet(Dev, PalState, VL53L0_STATE_STANDBY);
+			PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_STANDBY_LEVEL1);
+		}
+
+	} else {
+		/* VL53L0_POWERMODE_IDLE_LEVEL1 */
+		Status = VL53L0_WrByte(Dev, 0x80, 0x01);
+		if (Status == VL53L0_ERROR_NONE)
+			Status = VL53L0_StaticInit(Dev);
+		if (Status == VL53L0_ERROR_NONE)
+			PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_IDLE_LEVEL1);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes *pPowerMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	/* Only level1 of Power mode exists */
+	Status = VL53L0_RdByte(Dev, 0x80, &Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Byte == 1)
+			PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_IDLE_LEVEL1);
+		else
+		    PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_STANDBY_LEVEL1);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
+				int32_t OffsetCalibrationDataMicroMeter)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t OffsetCalibrationData;
+	LOG_FUNCTION_START("");
+
+	OffsetCalibrationData = (uint8_t) (OffsetCalibrationDataMicroMeter
+							/ 1000);
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET,
+				*(uint8_t *) &OffsetCalibrationData);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
+				int32_t *pOffsetCalibrationDataMicroMeter)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t RangeOffsetRegister;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET,
+				&RangeOffsetRegister);
+	if (Status == VL53L0_ERROR_NONE) {
+		*pOffsetCalibrationDataMicroMeter =
+				(*((int8_t *) (&RangeOffsetRegister))) * 1000;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetGroupParamHold(VL53L0_DEV Dev, uint8_t GroupParamHold)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	/* not implemented on VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetUpperLimitMilliMeter(VL53L0_DEV Dev,
+				uint16_t *pUpperLimitMilliMeter)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	/* not implemented on VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+/* End Group PAL General Functions */
+
+/* Group PAL Init Functions */
+VL53L0_Error VL53L0_SetDeviceAddress(VL53L0_DEV Dev, uint8_t DeviceAddress)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_I2C_SLAVE_DEVICE_ADDRESS,
+				DeviceAddress / 2);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_DataInit(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	int32_t OffsetCalibrationData;
+	LOG_FUNCTION_START("");
+
+	/* Set Default static parameters */
+	/* set first temporary values */
+	VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 748421);
+	/* 11.3999MHz * 65536 = 748421 */
+
+	/* Get default parameters */
+	Status = VL53L0_GetDeviceParameters(Dev, &CurrentParameters);
+	if (Status == VL53L0_ERROR_NONE) {
+		/* initialize PAL values */
+		CurrentParameters.DeviceMode = VL53L0_DEVICEMODE_SINGLE_RANGING;
+		CurrentParameters.HistogramMode = VL53L0_HISTOGRAMMODE_DISABLED;
+		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
+	}
+
+	/* Sigma estimator variable */
+	PALDevDataSet(Dev, SigmaEstRefArray, 100);
+	PALDevDataSet(Dev, SigmaEstEffPulseWidth, 900);
+	PALDevDataSet(Dev, SigmaEstEffAmbWidth, 500);
+
+	/* Set Signal and Sigma check */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_SetSigmaLimitCheckEnable(Dev, 0, 0);
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_SetSignalLimitCheckEnable(Dev, 0, 0);
+
+
+	if (Status == VL53L0_ERROR_NONE)
+		VL53L0_SetSigmaLimitValue(Dev, 0, (FixPoint1616_t)(7<<16));
+
+	if (Status == VL53L0_ERROR_NONE)
+		VL53L0_SetSignalLimitValue(Dev, 0, (FixPoint1616_t)(7<<16));
+
+	/* Read back NVM offset */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetOffsetCalibrationDataMicroMeter(Dev,
+			&OffsetCalibrationData);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, Part2PartOffsetNVMMicroMeter,
+			OffsetCalibrationData);
+
+		PALDevDataSet(Dev, SequenceConfig, 0xFF);
+
+		/* Set PAL state to tell that we are waiting for call
+		to VL53L0_StaticInit */
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_WAIT_STATICINIT);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_StaticInit(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint16_t TempWord;
+	uint8_t TempByte;
+	uint8_t localBuffer[32];
+	uint8_t i;
+	uint8_t Revision;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_check_part_used(Dev, &Revision);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Revision == 0)
+			Status = VL53L0_load_additional_settings1(Dev);
+	}
+
+    /* update13_05_15 */
+	if (Status == VL53L0_ERROR_NONE) {
+		if ((Revision <= 34) && (Revision != 32)) {
+
+			for (i = 0; i < 32; i++)
+				localBuffer[i] = 0xff;
+
+			Status = VL53L0_WriteMulti(Dev, 0x90, localBuffer, 32);
+
+			Status |= VL53L0_WrByte(Dev, 0xb6, 16);
+			Status |= VL53L0_WrByte(Dev, 0xb0, 0x0);
+			Status |= VL53L0_WrByte(Dev, 0xb1, 0x0);
+			Status |= VL53L0_WrByte(Dev, 0xb2, 0xE0);
+			Status |= VL53L0_WrByte(Dev, 0xb3, 0xE0);
+			Status |= VL53L0_WrByte(Dev, 0xb4, 0xE0);
+			Status |= VL53L0_WrByte(Dev, 0xb5, 0xE0);
+		}
+	}
+
+    /* update 17_06_15_v10 */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_load_tuning_settings(Dev);
+
+    /* check if GO1 power is ON after load default tuning */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, 0x80, &TempByte);
+		if ((TempByte != 0) && (Status == VL53L0_ERROR_NONE)) {
+			/* update 07_05_15 */
+			Status = VL53L0_load_additional_settings3(Dev);
+		}
+	}
+
+    /* Set interrupt config to new sample ready */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetGpioConfig(Dev, 0, 0,
+			VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+		Status |= VL53L0_RdWord(Dev, 0x84, &TempWord);
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz,
+			VL53L0_FIXPOINT412TOFIXPOINT1616(TempWord));
+	}
+
+	/* After static init, some device parameters may be changed,
+	so update them */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_GetDeviceParameters(Dev, &CurrentParameters);
+
+	if (Status == VL53L0_ERROR_NONE)
+		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
+
+
+	/* read the sequence config and save it */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG,
+					&TempByte);
+		if (Status == VL53L0_ERROR_NONE)
+			PALDevDataSet(Dev, SequenceConfig, TempByte);
+
+	}
+
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_PerformRefCalibration(Dev);
+
+	/* Set PAL State to standby */
+	if (Status == VL53L0_ERROR_NONE)
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_WaitDeviceBooted(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	/* not implemented on VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_ResetDevice(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	/* Set reset bit */
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N,
+				0x00);
+
+	/* Wait for some time */
+	if (Status == VL53L0_ERROR_NONE) {
+		do {
+			Status = VL53L0_RdByte(Dev,
+				VL53L0_REG_IDENTIFICATION_MODEL_ID,	&Byte);
+		} while (Byte != 0x00);
+	}
+
+	/* Release reset */
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N,
+		0x01);
+
+	/* Wait until correct boot-up of the device */
+	if (Status == VL53L0_ERROR_NONE) {
+		do {
+			Status = VL53L0_RdByte(Dev,
+				VL53L0_REG_IDENTIFICATION_MODEL_ID,	&Byte);
+		} while (Byte == 0x00);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+/* End Group PAL Init Functions */
+
+/* Group PAL Parameters Functions */
+VL53L0_Error VL53L0_SetDeviceParameters(VL53L0_DEV Dev,
+	const VL53L0_DeviceParameters_t*
+	pDeviceParameters)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int i;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_SetDeviceMode(Dev, pDeviceParameters->DeviceMode);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetHistogramMode(Dev,
+			pDeviceParameters->HistogramMode);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetInterMeasurementPeriodMilliSeconds(Dev,
+
+			pDeviceParameters->InterMeasurementPeriodMilliSeconds);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetXTalkCompensationEnable(Dev,
+
+			pDeviceParameters->XTalkCompensationEnable);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetXTalkCompensationRateMegaCps(Dev,
+
+			pDeviceParameters->XTalkCompensationRateMegaCps);
+	}
+
+	for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetSnrLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition) i,
+
+				pDeviceParameters->SnrLimitCheckEnable[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetSnrLimitValue(Dev,
+				(VL53L0_CheckPosition) i,
+
+				pDeviceParameters->SnrLimitValue[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetSignalLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition) i,
+
+				pDeviceParameters->SignalLimitCheckEnable[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetSignalLimitValue(Dev,
+				(VL53L0_CheckPosition) i,
+				pDeviceParameters->SignalLimitValue[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetRateLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition) i,
+
+				pDeviceParameters->RateLimitCheckEnable[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetRateLimitValue(Dev,
+					(VL53L0_CheckPosition) i,
+					pDeviceParameters->RateLimitValue[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetSigmaLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition) i,
+
+				pDeviceParameters->SigmaLimitCheckEnable[i]);
+		}
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetSigmaLimitValue(Dev,
+				(VL53L0_CheckPosition) i,
+
+				pDeviceParameters->SigmaLimitValue[i]);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetWrapAroundCheckEnable(Dev,
+
+			pDeviceParameters->WrapAroundCheckEnable);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_SetMeasurementTimingBudgetMicroSeconds(Dev,
+
+			pDeviceParameters->MeasurementTimingBudgetMicroSeconds);
+	}
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceParameters(VL53L0_DEV Dev,
+				VL53L0_DeviceParameters_t *pDeviceParameters)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int i;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_GetDeviceMode(Dev, &(pDeviceParameters->DeviceMode));
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetHistogramMode(Dev,
+			&(pDeviceParameters->HistogramMode));
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetInterMeasurementPeriodMilliSeconds(Dev,
+		&(pDeviceParameters->InterMeasurementPeriodMilliSeconds));
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetXTalkCompensationEnable(Dev,
+		&(pDeviceParameters->XTalkCompensationEnable));
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetXTalkCompensationRateMegaCps(Dev,
+
+			&(pDeviceParameters->XTalkCompensationRateMegaCps));
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetSnrLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->SnrLimitCheckEnable[i]));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetSnrLimitValue(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->SnrLimitValue[i]));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetSignalLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->SignalLimitCheckEnable[i]
+				));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetSignalLimitValue(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->SignalLimitValue[i]));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetRateLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->RateLimitCheckEnable[i]));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetRateLimitValue(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->RateLimitValue[i]));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetSigmaLimitCheckEnable(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->SigmaLimitCheckEnable[i]));
+			}
+			if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_GetSigmaLimitValue(Dev,
+				(VL53L0_CheckPosition)
+				i,
+				&(pDeviceParameters->SigmaLimitValue[i]));
+			}
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetWrapAroundCheckEnable(Dev,
+			&(pDeviceParameters->WrapAroundCheckEnable));
+	}
+
+    /* Need to be done at the end as it uses VCSELPulsePeriod */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetMeasurementTimingBudgetMicroSeconds(Dev,
+		&(pDeviceParameters->MeasurementTimingBudgetMicroSeconds));
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetDeviceMode(VL53L0_DEV Dev,
+				VL53L0_DeviceModes DeviceMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("%d", (int)DeviceMode);
+
+	switch (DeviceMode) {
+	case VL53L0_DEVICEMODE_SINGLE_RANGING:
+	case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
+	case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
+	case VL53L0_DEVICEMODE_SINGLE_HISTOGRAM:
+		/* Supported mode */
+		VL53L0_SETPARAMETERFIELD(Dev, DeviceMode, DeviceMode);
+		break;
+	default:
+		/* Unsupported mode */
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceMode(VL53L0_DEV Dev,
+				VL53L0_DeviceModes *pDeviceMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	VL53L0_GETPARAMETERFIELD(Dev, DeviceMode, *pDeviceMode);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetHistogramMode(VL53L0_DEV Dev,
+				VL53L0_HistogramModes HistogramMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("%d", (int)HistogramMode);
+
+	switch (HistogramMode) {
+	case VL53L0_HISTOGRAMMODE_DISABLED:
+		/* Supported mode */
+		VL53L0_SETPARAMETERFIELD(Dev, HistogramMode,
+			HistogramMode);
+		break;
+	case VL53L0_HISTOGRAMMODE_REFERENCE_ONLY:
+	case VL53L0_HISTOGRAMMODE_RETURN_ONLY:
+	case VL53L0_HISTOGRAMMODE_BOTH:
+	default:
+		/* Unsupported mode */
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetHistogramMode(VL53L0_DEV Dev,
+				VL53L0_HistogramModes *pHistogramMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	VL53L0_GETPARAMETERFIELD(Dev, HistogramMode, *pHistogramMode);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
+				uint32_t MeasurementTimingBudgetMicroSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	uint8_t CurrentVCSELPulsePeriod;
+	uint8_t CurrentVCSELPulsePeriodPClk;
+	uint8_t Byte;
+	uint32_t NewTimingBudgetMicroSeconds;
+	uint16_t encodedTimeOut;
+	LOG_FUNCTION_START("");
+
+	/* check if rangeB is done: */
+	Status = VL53L0_GetWrapAroundCheckEnable(Dev, &Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (((Byte == 1) && (MeasurementTimingBudgetMicroSeconds <
+17000)) ||
+			((Byte == 0) && (MeasurementTimingBudgetMicroSeconds <
+12000))) {
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		NewTimingBudgetMicroSeconds =
+MeasurementTimingBudgetMicroSeconds -
+								7000;
+		if (Byte == 1) {
+			NewTimingBudgetMicroSeconds =
+				(uint32_t)(NewTimingBudgetMicroSeconds >> 1);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 0);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
+			CurrentVCSELPulsePeriodPClk);
+		encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
+			NewTimingBudgetMicroSeconds,
+			(uint8_t)
+			CurrentVCSELPulsePeriod);
+		VL53L0_SETPARAMETERFIELD(Dev,
+MeasurementTimingBudgetMicroSeconds,
+			MeasurementTimingBudgetMicroSeconds);
+		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, LastEncodedTimeout,
+			encodedTimeOut);
+	}
+
+	/* Program in register */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrWord(Dev, VL53L0_REG_RNGA_TIMEOUT_MSB,
+			encodedTimeOut);
+	}
+
+	/* Temp: program same value for rangeB1 and rangeB2 */
+	/* Range B1 */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 1);
+		if (Status == VL53L0_ERROR_NONE) {
+			CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
+				CurrentVCSELPulsePeriodPClk);
+			encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
+				NewTimingBudgetMicroSeconds,
+				(uint8_t)
+				CurrentVCSELPulsePeriod);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrWord(Dev, VL53L0_REG_RNGB1_TIMEOUT_MSB,
+			encodedTimeOut);
+	}
+
+	/* Range B2 */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 2);
+		if (Status == VL53L0_ERROR_NONE) {
+			CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
+				CurrentVCSELPulsePeriodPClk);
+			encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
+				NewTimingBudgetMicroSeconds,
+				(uint8_t)
+				CurrentVCSELPulsePeriod);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrWord(Dev, VL53L0_REG_RNGB2_TIMEOUT_MSB,
+			encodedTimeOut);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
+				uint32_t *pMeasurementTimingBudgetMicroSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t CurrentVCSELPulsePeriod;
+	uint8_t CurrentVCSELPulsePeriodPClk;
+	uint16_t encodedTimeOut;
+	uint32_t RangATimingBudgetMicroSeconds;
+	uint32_t RangBTimingBudgetMicroSeconds;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	/* check if rangeB is done: */
+	Status = VL53L0_GetWrapAroundCheckEnable(Dev, &Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_get_vcsel_pulse_period(Dev,
+		&CurrentVCSELPulsePeriodPClk, 0);
+		CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
+			CurrentVCSELPulsePeriodPClk);
+
+		/* Read from register */
+		Status = VL53L0_RdWord(Dev, VL53L0_REG_RNGA_TIMEOUT_MSB,
+			&encodedTimeOut);
+		if (Status == VL53L0_ERROR_NONE) {
+			RangATimingBudgetMicroSeconds =
+			VL53L0_calc_ranging_wait_us(Dev,
+				encodedTimeOut,
+				CurrentVCSELPulsePeriod);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Byte == 0) {
+			*pMeasurementTimingBudgetMicroSeconds =
+				RangATimingBudgetMicroSeconds + 7000;
+			VL53L0_SETPARAMETERFIELD(Dev,
+			MeasurementTimingBudgetMicroSeconds,
+				*pMeasurementTimingBudgetMicroSeconds);
+		} else {
+			VL53L0_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 1);
+			CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
+				CurrentVCSELPulsePeriodPClk);
+
+			/* Read from register */
+			Status = VL53L0_RdWord(Dev,
+			VL53L0_REG_RNGB1_TIMEOUT_MSB,
+						&encodedTimeOut);
+			if (Status == VL53L0_ERROR_NONE) {
+				RangBTimingBudgetMicroSeconds =
+				VL53L0_calc_ranging_wait_us(
+					Dev, encodedTimeOut,
+					CurrentVCSELPulsePeriod);
+			}
+
+			*pMeasurementTimingBudgetMicroSeconds =
+				RangATimingBudgetMicroSeconds +
+				RangBTimingBudgetMicroSeconds +
+				7000;
+			VL53L0_SETPARAMETERFIELD(Dev,
+			MeasurementTimingBudgetMicroSeconds,
+				*pMeasurementTimingBudgetMicroSeconds);
+		}
+	}
+
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
+				uint32_t InterMeasurementPeriodMilliSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint16_t osc_calibrate_val;
+	uint32_t IMPeriodMilliSeconds;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdWord(Dev, VL53L0_REG_OSC_CALIBRATE_VAL,
+		&osc_calibrate_val);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (osc_calibrate_val != 0) {
+			IMPeriodMilliSeconds =
+			InterMeasurementPeriodMilliSeconds *
+				osc_calibrate_val;
+		} else {
+			IMPeriodMilliSeconds =
+			InterMeasurementPeriodMilliSeconds;
+		}
+		Status = VL53L0_WrDWord(Dev,
+		VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
+			IMPeriodMilliSeconds);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETPARAMETERFIELD(Dev,
+		InterMeasurementPeriodMilliSeconds,
+			InterMeasurementPeriodMilliSeconds);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
+				uint32_t *pInterMeasurementPeriodMilliSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint16_t osc_calibrate_val;
+	uint32_t IMPeriodMilliSeconds;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdWord(Dev, VL53L0_REG_OSC_CALIBRATE_VAL,
+				&osc_calibrate_val);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdDWord(Dev,
+		VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
+			&IMPeriodMilliSeconds);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (osc_calibrate_val != 0)
+			*pInterMeasurementPeriodMilliSeconds =
+				IMPeriodMilliSeconds /
+				osc_calibrate_val;
+
+		VL53L0_SETPARAMETERFIELD(Dev,
+		InterMeasurementPeriodMilliSeconds,
+			*pInterMeasurementPeriodMilliSeconds);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetXTalkCompensationEnable(VL53L0_DEV Dev,
+		uint8_t XTalkCompensationEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t XTalkCompensationEnableValue;
+	LOG_FUNCTION_START("");
+
+	if (XTalkCompensationEnable == 0) {
+		/* Disable the crosstalk compensation */
+		XTalkCompensationEnableValue = 0x00;
+	} else {
+		/* Enable the crosstalk compensation */
+		XTalkCompensationEnableValue = 0x01;
+	}
+	Status = VL53L0_UpdateByte(Dev, VL53L0_REG_ALGO_RANGE_CHECK_ENABLES,
+		0xFE,
+		XTalkCompensationEnableValue);
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
+			XTalkCompensationEnableValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetXTalkCompensationEnable(VL53L0_DEV Dev, uint8_t*
+	pXTalkCompensationEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t data;
+	uint8_t Temp;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_ALGO_RANGE_CHECK_ENABLES, &data);
+	if (Status == VL53L0_ERROR_NONE) {
+		if (data & 0x01)
+			Temp = 0x01;
+		else
+			Temp = 0x00;
+
+		*pXTalkCompensationEnable = Temp;
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
+	FixPoint1616_t XTalkCompensationRateMegaCps)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_WrWord(Dev, VL53L0_REG_ALGO_CROSSTALK_COMPENSATION_RATE,
+		VL53L0_FIXPOINT1616TOFIXPOINT412(XTalkCompensationRateMegaCps));
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+			XTalkCompensationRateMegaCps);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
+	FixPoint1616_t *pXTalkCompensationRateMegaCps)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t Value;
+	FixPoint1616_t TempFix1616;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdWord(Dev, VL53L0_REG_ALGO_CROSSTALK_COMPENSATION_RATE,
+		(uint16_t *) &Value);
+	if (Status == VL53L0_ERROR_NONE) {
+		TempFix1616 = VL53L0_FIXPOINT412TOFIXPOINT1616(Value);
+		*pXTalkCompensationRateMegaCps = TempFix1616;
+		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+			TempFix1616);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/*
+ * SNR LIMIT
+ */
+VL53L0_Error VL53L0_SetSnrLimitCheckEnable(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, uint8_t SnrLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t tmp8;
+	uint8_t SnrLimitCheckEnableInt;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+	if (SnrLimitCheckEnable == 0) {
+		/* Disable the SNR check */
+		SnrLimitCheckEnableInt = 0;
+	} else {
+		/* Enable the SNR check */
+		SnrLimitCheckEnableInt = 1;
+	}
+
+	tmp8 = (uint8_t)(SnrLimitCheckEnableInt << 3);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_UpdateByte(Dev,
+			VL53L0_REG_ALGO_RANGE_CHECK_ENABLES,
+			0xF7, tmp8);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, SnrLimitCheckEnable,
+			Position,
+			SnrLimitCheckEnableInt);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSnrLimitCheckEnable(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, uint8_t *pSnrLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t data;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_ALGO_RANGE_CHECK_ENABLES, &data);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (data & (0x01 << 3))
+			*pSnrLimitCheckEnable = 0x01;
+		else
+			*pSnrLimitCheckEnable = 0x00;
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		VL53L0_SETARRAYPARAMETERFIELD(Dev,
+			SnrLimitCheckEnable, Position,
+			*pSnrLimitCheckEnable);
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetSnrLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t SnrLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_ALGO_SNR_RATIO,
+		VL53L0_FIXPOINT1616TOFIXPOINT08(SnrLimitValue));
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, SnrLimitValue, Position,
+			SnrLimitValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSnrLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t *pSnrLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Value;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_ALGO_SNR_RATIO,
+			(uint8_t *)&Value);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		*pSnrLimitValue = VL53L0_FIXPOINT08TOFIXPOINT1616(Value);
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, SnrLimitValue, Position,
+			*pSnrLimitValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/*
+ * SIGNAL LIMIT
+ */
+VL53L0_Error VL53L0_SetSignalLimitCheckEnable(VL53L0_DEV Dev,
+	VL53L0_CheckPosition Position, uint8_t SignalLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t i;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
+			VL53L0_SETARRAYPARAMETERFIELD(Dev,
+				SignalLimitCheckEnable,
+				(VL53L0_CheckPosition) i,
+				SignalLimitCheckEnable);
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSignalLimitCheckEnable(VL53L0_DEV Dev,
+	VL53L0_CheckPosition Position, uint8_t *pSignalLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS) {
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	} else {
+		VL53L0_GETARRAYPARAMETERFIELD(Dev, SignalLimitCheckEnable,
+			Position,
+			*pSignalLimitCheckEnable);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetSignalLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t SignalLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t i;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored, set is done on all
+	positions */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
+			VL53L0_SETARRAYPARAMETERFIELD(Dev,
+				SignalLimitValue,
+				(VL53L0_CheckPosition) i,
+				SignalLimitValue);
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSignalLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t *pSignalLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_GETARRAYPARAMETERFIELD(Dev, SignalLimitValue, Position,
+			*pSignalLimitValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/*
+ * SIGMA LIMIT
+ */
+VL53L0_Error VL53L0_SetSigmaLimitCheckEnable(VL53L0_DEV Dev,
+	VL53L0_CheckPosition Position, uint8_t SigmaLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t i;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored, set is done on all
+	positions */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
+			VL53L0_SETARRAYPARAMETERFIELD(Dev,
+				SigmaLimitCheckEnable,
+				(VL53L0_CheckPosition) i,
+				SigmaLimitCheckEnable);
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSigmaLimitCheckEnable(VL53L0_DEV Dev,
+	VL53L0_CheckPosition Position, uint8_t *pSigmaLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS) {
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	} else {
+		VL53L0_GETARRAYPARAMETERFIELD(Dev, SigmaLimitCheckEnable,
+			Position,
+			*pSigmaLimitCheckEnable);
+	}
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetSigmaLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t SigmaLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t i;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored, set is done on all
+	positions */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
+			VL53L0_SETARRAYPARAMETERFIELD(Dev, SigmaLimitValue,
+				(VL53L0_CheckPosition) i, SigmaLimitValue);
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSigmaLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t *pSigmaLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_GETARRAYPARAMETERFIELD(Dev, SigmaLimitValue, Position,
+			*pSigmaLimitValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/*
+ * RATE LIMIT
+ */
+
+VL53L0_Error VL53L0_SetRateLimitCheckEnable(VL53L0_DEV Dev,
+	VL53L0_CheckPosition Position, uint8_t RateLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t tmp8;
+	uint8_t RateLimitCheckEnableInt;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (RateLimitCheckEnable == 0) {
+		/* Disable the Rate Limit Check */
+		RateLimitCheckEnableInt = 0;
+	} else {
+		/* Enable the Rate Limit Check */
+		RateLimitCheckEnableInt = 1;
+	}
+
+	tmp8 = (uint8_t)(RateLimitCheckEnableInt << 1);
+
+	Status = VL53L0_UpdateByte(Dev, VL53L0_REG_ALGO_RANGE_CHECK_ENABLES,
+				0xFD,
+				tmp8);
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, RateLimitCheckEnable,
+			Position,
+			RateLimitCheckEnableInt);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetRateLimitCheckEnable(VL53L0_DEV Dev,
+	VL53L0_CheckPosition Position, uint8_t *pRateLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t data;
+	LOG_FUNCTION_START("");
+
+	/* In this function VL53L0_CheckPosition is ignored */
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_ALGO_RANGE_CHECK_ENABLES, &data);
+	if (Status == VL53L0_ERROR_NONE) {
+		if (data & (0x02))
+			*pRateLimitCheckEnable = 0x01;
+		else
+			*pRateLimitCheckEnable = 0x00;
+
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, RateLimitCheckEnable,
+			Position,
+			*pRateLimitCheckEnable);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetRateLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t RateLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrByte(Dev,
+			VL53L0_REG_ALGO_RANGE_IGNORE_THRESHOLD,
+			VL53L0_FIXPOINT1616TOFIXPOINT08(RateLimitValue));
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, RateLimitValue, Position,
+			RateLimitValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetRateLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
+	Position, FixPoint1616_t *pRateLimitValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Value;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_ALGO_RANGE_IGNORE_THRESHOLD,
+			(uint8_t *) &Value);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		*pRateLimitValue = VL53L0_FIXPOINT08TOFIXPOINT1616(Value);
+		VL53L0_SETARRAYPARAMETERFIELD(Dev, RateLimitValue, Position,
+			*pRateLimitValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+
+/*
+ * CHECK LIMIT FUNCTIONS
+ */
+
+VL53L0_Error VL53L0_GetNumberOfLimitCheck(uint16_t *pNumberOfLimitCheck)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	*pNumberOfLimitCheck = VL53L0_CHECKENABLE_NUMBER_OF_CHECKS;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+#define VL53L0_BUILDCASESTRING(BUFFER, CODE, STRINGVALUE) \
+	do { \
+		case CODE: \
+			VL53L0_COPYSTRING(BUFFER, STRINGVALUE); \
+			break; \
+	} while (0)
+
+VL53L0_Error VL53L0_GetLimitCheckInfo(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	char *pLimitCheckString)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	switch (LimitCheckId) {
+	VL53L0_BUILDCASESTRING(pLimitCheckString,
+			VL53L0_CHECKENABLE_SNR,
+			VL53L0_STRING_CHECKENABLE_SNR);
+	VL53L0_BUILDCASESTRING(pLimitCheckString,
+			VL53L0_CHECKENABLE_SIGMA,
+			VL53L0_STRING_CHECKENABLE_SIGMA);
+	VL53L0_BUILDCASESTRING(pLimitCheckString,
+			VL53L0_CHECKENABLE_RANGE,
+			VL53L0_STRING_CHECKENABLE_RANGE);
+	VL53L0_BUILDCASESTRING(pLimitCheckString,
+			VL53L0_CHECKENABLE_SIGNAL_RATE,
+			VL53L0_STRING_CHECKENABLE_SIGNAL_RATE);
+		break;
+	default:
+		VL53L0_COPYSTRING(pLimitCheckString,
+			VL53L0_STRING_UNKNOW_ERROR_CODE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	uint8_t LimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	switch (LimitCheckId) {
+	case VL53L0_CHECKENABLE_SNR:
+		Status = VL53L0_SetSnrLimitCheckEnable(Dev, 0,
+			LimitCheckEnable);
+		break;
+
+	case VL53L0_CHECKENABLE_SIGMA:
+		Status = VL53L0_SetSigmaLimitCheckEnable(Dev, 0,
+			LimitCheckEnable);
+		break;
+
+	case VL53L0_CHECKENABLE_RANGE:
+		Status = VL53L0_SetRateLimitCheckEnable(Dev, 0,
+			LimitCheckEnable);
+		break;
+
+	case VL53L0_CHECKENABLE_SIGNAL_RATE:
+		Status = VL53L0_SetSignalLimitCheckEnable(Dev, 0,
+			LimitCheckEnable);
+		break;
+
+	default:
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_GetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	uint8_t *pLimitCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	switch (LimitCheckId) {
+	case VL53L0_CHECKENABLE_SNR:
+		Status = VL53L0_GetSnrLimitCheckEnable(Dev, 0,
+			pLimitCheckEnable);
+		break;
+
+	case VL53L0_CHECKENABLE_SIGMA:
+		Status = VL53L0_GetSigmaLimitCheckEnable(Dev, 0,
+			pLimitCheckEnable);
+		break;
+
+	case VL53L0_CHECKENABLE_RANGE:
+		Status = VL53L0_GetRateLimitCheckEnable(Dev, 0,
+			pLimitCheckEnable);
+		break;
+
+	case VL53L0_CHECKENABLE_SIGNAL_RATE:
+		Status = VL53L0_GetSignalLimitCheckEnable(Dev, 0,
+			pLimitCheckEnable);
+		break;
+
+	default:
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+
+VL53L0_Error VL53L0_SetLimitCheckValue(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	FixPoint1616_t LimitCheckValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+
+	switch (LimitCheckId) {
+	case VL53L0_CHECKENABLE_SNR:
+		Status = VL53L0_SetSnrLimitValue(Dev, 0, LimitCheckValue);
+		break;
+
+	case VL53L0_CHECKENABLE_SIGMA:
+		Status = VL53L0_SetSigmaLimitValue(Dev, 0, LimitCheckValue);
+		break;
+
+	case VL53L0_CHECKENABLE_RANGE:
+		Status = VL53L0_SetRateLimitValue(Dev, 0, LimitCheckValue);
+		break;
+
+	case VL53L0_CHECKENABLE_SIGNAL_RATE:
+		Status = VL53L0_SetSignalLimitValue(Dev, 0, LimitCheckValue);
+		break;
+
+	default:
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_GetLimitCheckValue(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	FixPoint1616_t *pLimitCheckValue)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	if (LimitCheckId >= VL53L0_CHECKENABLE_NUMBER_OF_CHECKS) {
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	} else {
+		switch (LimitCheckId) {
+		case VL53L0_CHECKENABLE_SNR:
+			Status = VL53L0_GetSnrLimitValue(Dev, 0,
+				pLimitCheckValue);
+			break;
+
+		case VL53L0_CHECKENABLE_SIGMA:
+			Status = VL53L0_GetSigmaLimitValue(Dev, 0,
+				pLimitCheckValue);
+			break;
+
+		case VL53L0_CHECKENABLE_RANGE:
+			Status = VL53L0_GetRateLimitValue(Dev, 0,
+				pLimitCheckValue);
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_RATE:
+			Status = VL53L0_GetSignalLimitValue(Dev, 0,
+				pLimitCheckValue);
+			break;
+
+		default:
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
+
+
+
+
+/*
+ * WRAPAROUND LIMIT
+ */
+VL53L0_Error VL53L0_SetWrapAroundCheckEnable(VL53L0_DEV Dev, uint8_t
+	WrapAroundCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	uint8_t WrapAroundCheckEnableInt;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &Byte);
+	if (WrapAroundCheckEnable == 0) {
+		/* Disable wraparound */
+		Byte = Byte & 0x7F;
+		WrapAroundCheckEnableInt = 0;
+	} else {
+		/* Enable wraparound */
+		Byte = Byte | 0x80;
+		WrapAroundCheckEnableInt = 1;
+	}
+
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, SequenceConfig, Byte);
+		VL53L0_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
+			WrapAroundCheckEnableInt);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetWrapAroundCheckEnable(VL53L0_DEV Dev, uint8_t
+	*pWrapAroundCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t data;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &data);
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, SequenceConfig, data);
+		if (data & (0x01 << 7))
+			*pWrapAroundCheckEnable = 0x01;
+		else
+			*pWrapAroundCheckEnable = 0x00;
+
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
+			*pWrapAroundCheckEnable);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/*  End Group PAL Parameters Functions */
+
+/* Group PAL Measurement Functions */
+VL53L0_Error VL53L0_PerformSingleMeasurement(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceModes DeviceMode;
+	uint8_t NewDatReady = 0;
+	uint32_t LoopNb;
+	LOG_FUNCTION_START("");
+
+	/* Get Current DeviceMode */
+	Status = VL53L0_GetDeviceMode(Dev, &DeviceMode);
+
+	/* Start immediately to run a single ranging measurement in case of
+	single ranging or single histogram */
+	if ((Status == VL53L0_ERROR_NONE) &&
+		((DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING) ||
+		(DeviceMode ==
+		VL53L0_DEVICEMODE_SINGLE_HISTOGRAM))) {
+		Status = VL53L0_StartMeasurement(Dev);
+	}
+
+	/* Wait until it finished
+	use timeout to avoid deadlock
+	*/
+	if (Status == VL53L0_ERROR_NONE) {
+		LoopNb = 0;
+		do {
+			Status = VL53L0_GetMeasurementDataReady(Dev,
+				&NewDatReady);
+			if ((NewDatReady == 0x01) || Status !=
+				VL53L0_ERROR_NONE) {
+				break;
+			}
+			LoopNb = LoopNb + 1;
+			VL53L0_PollingDelay(Dev);
+		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	/* Change PAL State in case of single ranging or single histogram
+	*/
+	if ((Status == VL53L0_ERROR_NONE) &&
+		((DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING) ||
+			(DeviceMode ==
+			VL53L0_DEVICEMODE_SINGLE_HISTOGRAM))) {
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_PerformRefCalibration(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t NewDatReady = 0;
+	uint8_t Byte = 0;
+	uint8_t SequenceConfig = 0;
+	uint32_t LoopNb;
+	LOG_FUNCTION_START("");
+
+	/* store the value of the sequence config,
+	 * this will be reset before the end of the function
+	 */
+
+	SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
+
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, 0x03);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, SequenceConfig, 0x03);
+		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
+			VL53L0_REG_SYSRANGE_MODE_START_STOP);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Wait until start bit has been cleared */
+		LoopNb = 0;
+		do {
+			if (LoopNb > 0)
+				Status = VL53L0_RdByte(Dev,
+					VL53L0_REG_SYSRANGE_START, &Byte);
+			LoopNb = LoopNb + 1;
+		} while (((Byte & VL53L0_REG_SYSRANGE_MODE_START_STOP) ==
+			VL53L0_REG_SYSRANGE_MODE_START_STOP) &&
+			(Status == VL53L0_ERROR_NONE) &&
+			(LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+	}
+
+	/* Wait until it finished
+	use timeout to avoid deadlock
+	*/
+	if (Status == VL53L0_ERROR_NONE) {
+		LoopNb = 0;
+		do {
+			Status = VL53L0_GetMeasurementDataReady(Dev,
+				&NewDatReady);
+			if ((NewDatReady == 0x01) || Status !=
+				VL53L0_ERROR_NONE) {
+				break;
+			}
+			LoopNb = LoopNb + 1;
+			VL53L0_PollingDelay(Dev);
+		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+		Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x04);
+		Status |= VL53L0_RdByte(Dev, 0x30, &Byte);
+
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+		Status |= VL53L0_WrByte(Dev, 0x31, Byte);
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+		Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_ClearInterruptMask(Dev, 0);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* restore the previous Sequence Config */
+		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG,
+			SequenceConfig);
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_API VL53L0_Error VL53L0_PerformXTalkCalibration(VL53L0_DEV Dev,
+	FixPoint1616_t XTalkCalDistance, FixPoint1616_t
+	*pXTalkCompensationRateMegaCps)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t sum_ranging = 0;
+	uint16_t sum_spads = 0;
+	FixPoint1616_t sum_signalRate = 0;
+	FixPoint1616_t total_count = 0;
+	uint8_t xtalk_meas = 0;
+	VL53L0_RangingMeasurementData_t RangingMeasurementData;
+	FixPoint1616_t xTalkStoredMeanSignalRate;
+	FixPoint1616_t xTalkStoredMeanRange;
+	FixPoint1616_t xTalkStoredMeanRtnSpads;
+	uint32_t signalXTalkTotalPerSpad;
+	uint32_t xTalkStoredMeanRtnSpadsAsInt;
+	uint32_t xTalkCalDistanceAsInt;
+	FixPoint1616_t XTalkCompensationRateMegaCps;
+	LOG_FUNCTION_START("");
+
+	if (XTalkCalDistance <= 0)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	/* Disable the XTalk compensation */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_SetXTalkCompensationEnable(Dev, 0);
+
+
+	/* Perform 50 measurements and compute the averages */
+	if (Status == VL53L0_ERROR_NONE) {
+		sum_ranging = 0;
+		sum_spads = 0;
+		sum_signalRate = 0;
+		total_count = 0;
+		for (xtalk_meas = 0; xtalk_meas < 50; xtalk_meas++) {
+			Status = VL53L0_PerformSingleRangingMeasurement(Dev,
+				&RangingMeasurementData);
+
+			if (Status != VL53L0_ERROR_NONE)
+				break;
+
+
+			if (RangingMeasurementData.RangeMilliMeter < 8000) {
+				sum_ranging = sum_ranging +
+				RangingMeasurementData.RangeMilliMeter;
+				sum_signalRate = sum_signalRate +
+				RangingMeasurementData.SignalRateRtnMegaCps;
+				sum_spads = sum_spads +
+				RangingMeasurementData.EffectiveSpadRtnCount
+				/ 32;
+				total_count = total_count + 1;
+			}
+		}
+
+		if (total_count == 0) {
+			/* no valid values found */
+			Status = VL53L0_ERROR_RANGE_ERROR;
+		}
+	}
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* FixPoint1616_t / uint16_t = FixPoint1616_t */
+		xTalkStoredMeanSignalRate = sum_signalRate / total_count;
+		xTalkStoredMeanRange =
+			(FixPoint1616_t)((uint32_t)(sum_ranging << 16) /
+			total_count);
+		xTalkStoredMeanRtnSpads =
+			(FixPoint1616_t)((uint32_t)(sum_spads<<16) /
+			total_count);
+
+		/* Round Mean Spads to Whole Number.
+		Typically the calculated mean SPAD count is a whole number or
+		very close to a whole
+		number, therefore any truncation will not result in a
+		significant	loss in accuracy.
+		Also, for a grey target at a typical distance of around 400mm,
+		around 220 SPADs will
+		be enabled, therefore, any truncation will result in a loss of
+		accuracy of less than 0.5%.
+		*/
+		xTalkStoredMeanRtnSpadsAsInt = (xTalkStoredMeanRtnSpads +
+			0x8000) >> 16;
+
+		/* Round Cal Distance to Whole Number.
+		Note that the cal distance is in mm, therefore no resolution is
+		lost.
+		*/
+		xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >> 16;
+
+		if (xTalkStoredMeanRtnSpadsAsInt == 0 || xTalkCalDistanceAsInt
+			== 0 ||
+			xTalkStoredMeanRange >= XTalkCalDistance) {
+			XTalkCompensationRateMegaCps = 0;
+		} else {
+			/* Round Cal Distance to Whole Number.
+			Note that the cal distance is in mm, therefore no
+			resolution is lost.
+			*/
+			xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >>
+				16;
+
+			/* Apply division by mean spad count early in the
+			calculation to keep the numbers small.
+			This ensures we can maintain a 32bit calculation.
+			Fixed1616 / int := Fixed1616
+			*/
+			signalXTalkTotalPerSpad =
+				(xTalkStoredMeanSignalRate) /
+				xTalkStoredMeanRtnSpadsAsInt;
+
+			/* Complete the calculation for total Signal XTalk per
+			SPAD Fixed1616 * (Fixed1616 - Fixed1616/int)
+			:= (2^16 * Fixed1616)
+			*/
+			signalXTalkTotalPerSpad *= ((1<<16) -
+				(xTalkStoredMeanRange/xTalkCalDistanceAsInt));
+
+			/* Round from 2^16 * Fixed1616, to Fixed1616. */
+			XTalkCompensationRateMegaCps = (signalXTalkTotalPerSpad
+				+ 0x8000) >> 16;
+		}
+
+		*pXTalkCompensationRateMegaCps = XTalkCompensationRateMegaCps;
+
+		/* Enable the XTalk compensation */
+		if (Status == VL53L0_ERROR_NONE)
+			Status = VL53L0_SetXTalkCompensationEnable(Dev, 1);
+
+
+		/* Enable the XTalk compensation */
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_SetXTalkCompensationRateMegaCps(Dev,
+				XTalkCompensationRateMegaCps);
+		}
+
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_StartMeasurement(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceModes DeviceMode;
+	uint8_t Byte = 0;
+	uint32_t LoopNb;
+	LOG_FUNCTION_START("");
+
+	/* Get Current DeviceMode */
+	VL53L0_GetDeviceMode(Dev, &DeviceMode);
+
+	switch (DeviceMode) {
+	case VL53L0_DEVICEMODE_SINGLE_RANGING:
+		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
+			VL53L0_REG_SYSRANGE_MODE_SINGLESHOT |
+			VL53L0_REG_SYSRANGE_MODE_START_STOP);
+		break;
+	case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
+		/* Back-to-back mode */
+		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
+			VL53L0_REG_SYSRANGE_MODE_BACKTOBACK |
+			VL53L0_REG_SYSRANGE_MODE_START_STOP);
+		if (Status == VL53L0_ERROR_NONE) {
+			/* Set PAL State to Running */
+			PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+		}
+		break;
+	case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
+		/* Continuous mode */
+		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
+			VL53L0_REG_SYSRANGE_MODE_TIMED |
+			VL53L0_REG_SYSRANGE_MODE_START_STOP);
+		if (Status == VL53L0_ERROR_NONE) {
+			/* Set PAL State to Running */
+			PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+		}
+		break;
+	default:
+		/* Selected mode not supported */
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Wait until start bit has been cleared */
+		LoopNb = 0;
+		do {
+			if (LoopNb > 0)
+				Status = VL53L0_RdByte(Dev,
+					VL53L0_REG_SYSRANGE_START, &Byte);
+			LoopNb = LoopNb + 1;
+		} while (((Byte & VL53L0_REG_SYSRANGE_MODE_START_STOP) ==
+			VL53L0_REG_SYSRANGE_MODE_START_STOP) &&
+			(Status == VL53L0_ERROR_NONE) &&
+			(LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_StopMeasurement(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
+		VL53L0_REG_SYSRANGE_MODE_SINGLESHOT);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Set PAL State to Idle */
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetMeasurementDataReady(VL53L0_DEV Dev, uint8_t
+	*pMeasurementDataReady)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t SysRangeStatusRegister;
+	uint8_t InterruptConfig;
+	uint32_t InterruptMask;
+	LOG_FUNCTION_START("");
+
+	InterruptConfig = VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
+		Pin0GpioFunctionality);
+
+	if (InterruptConfig ==
+	VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY) {
+		VL53L0_GetInterruptMaskStatus(Dev, &InterruptMask);
+		if (InterruptMask ==
+		VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY){
+			*pMeasurementDataReady = 1;
+		} else {
+			*pMeasurementDataReady = 0;
+		}
+	} else {
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_RANGE_STATUS,
+			&SysRangeStatusRegister);
+		if (Status == VL53L0_ERROR_NONE) {
+			if (SysRangeStatusRegister & 0x01)
+				*pMeasurementDataReady = 1;
+			else
+				*pMeasurementDataReady = 0;
+
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev, uint32_t
+	MaxLoop)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	/* not implemented for VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetRangingMeasurementData(VL53L0_DEV Dev,
+	VL53L0_RangingMeasurementData_t *pRangingMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t DeviceRangeStatus;
+	uint8_t PalRangeStatus;
+	uint16_t AmbientRate;
+	FixPoint1616_t SignalRate;
+	FixPoint1616_t CrosstalkCompensation;
+	uint16_t EffectiveSpadRtnCount;
+	uint8_t localBuffer[14];
+	VL53L0_RangingMeasurementData_t LastRangeDataBuffer;
+	LOG_FUNCTION_START("");
+
+	/* use multi read even if some registers are not useful, result will be
+	more efficient
+	start reading at 0x14 dec20
+	end reading at 0x21 dec33 total 14 bytes to read
+	*/
+	Status = VL53L0_ReadMulti(Dev, 0x14, localBuffer, 14);
+
+	if (Status == VL53L0_ERROR_NONE) {
+
+		pRangingMeasurementData->ZoneId = 0; /* Only one zone */
+		pRangingMeasurementData->TimeStamp = 0; /* Not Implemented */
+
+		pRangingMeasurementData->RangeMilliMeter =
+			VL53L0_MAKEUINT16(localBuffer[11], localBuffer[10]);
+
+		pRangingMeasurementData->RangeDMaxMilliMeter = 0;
+		pRangingMeasurementData->RangeFractionalPart = 0;
+		pRangingMeasurementData->MeasurementTimeUsec = 0;
+
+		SignalRate =
+			VL53L0_FIXPOINT97TOFIXPOINT1616(
+			VL53L0_MAKEUINT16(localBuffer[7], localBuffer[6]));
+		pRangingMeasurementData->SignalRateRtnMegaCps = SignalRate;
+
+		AmbientRate = VL53L0_MAKEUINT16(localBuffer[9], localBuffer[8]);
+		pRangingMeasurementData->AmbientRateRtnMegaCps =
+			VL53L0_FIXPOINT97TOFIXPOINT1616(AmbientRate);
+
+		EffectiveSpadRtnCount = VL53L0_MAKEUINT16(localBuffer[3],
+			localBuffer[2]);
+		pRangingMeasurementData->EffectiveSpadRtnCount =
+			EffectiveSpadRtnCount;
+
+		DeviceRangeStatus = localBuffer[0];
+
+		/* initial format = 4.12, when pass to 16.16 from 9.7 we shift
+		5 bit more this will be absorbed in the further computation
+		*/
+		CrosstalkCompensation =
+			VL53L0_FIXPOINT97TOFIXPOINT1616(
+			VL53L0_MAKEUINT16(localBuffer[13], localBuffer[12]));
+
+		/*
+		 * For a standard definition of RangeStatus, this should return
+		 * 0 in case of good result after a ranging
+		 * The range status depends on the device so call a device
+		 * specific	function to obtain the right Status.
+		 */
+		Status = VL53L0_get_pal_range_status(Dev, DeviceRangeStatus,
+			SignalRate, CrosstalkCompensation,
+			EffectiveSpadRtnCount,
+			pRangingMeasurementData, &PalRangeStatus);
+
+		if (Status == VL53L0_ERROR_NONE)
+			pRangingMeasurementData->RangeStatus = PalRangeStatus;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Copy last read data into Dev buffer */
+		LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
+
+		LastRangeDataBuffer.RangeMilliMeter =
+			pRangingMeasurementData->RangeMilliMeter;
+		LastRangeDataBuffer.RangeFractionalPart =
+			pRangingMeasurementData->RangeFractionalPart;
+		LastRangeDataBuffer.RangeDMaxMilliMeter =
+			pRangingMeasurementData->RangeDMaxMilliMeter;
+		LastRangeDataBuffer.MeasurementTimeUsec =
+			pRangingMeasurementData->MeasurementTimeUsec;
+		LastRangeDataBuffer.SignalRateRtnMegaCps =
+			pRangingMeasurementData->SignalRateRtnMegaCps;
+		LastRangeDataBuffer.AmbientRateRtnMegaCps =
+			pRangingMeasurementData->AmbientRateRtnMegaCps;
+		LastRangeDataBuffer.EffectiveSpadRtnCount =
+			pRangingMeasurementData->EffectiveSpadRtnCount;
+		LastRangeDataBuffer.RangeStatus =
+			pRangingMeasurementData->RangeStatus;
+
+		PALDevDataSet(Dev, LastRangeMeasure, LastRangeDataBuffer);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetHistogramMeasurementData(VL53L0_DEV Dev,
+	VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_PerformSingleRangingMeasurement(VL53L0_DEV Dev,
+	VL53L0_RangingMeasurementData_t *pRangingMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	/*	This function will do a complete single ranging
+	*	Here we fix the mode!
+	*/
+	Status = VL53L0_SetDeviceMode(Dev, VL53L0_DEVICEMODE_SINGLE_RANGING);
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_PerformSingleMeasurement(Dev);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_GetRangingMeasurementData(Dev,
+			pRangingMeasurementData);
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_ClearInterruptMask(Dev, 0);
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_PerformSingleHistogramMeasurement(VL53L0_DEV Dev,
+	VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetNumberOfROIZones(VL53L0_DEV Dev, uint8_t
+	NumberOfROIZones)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	if (NumberOfROIZones != 1)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetNumberOfROIZones(VL53L0_DEV Dev, uint8_t*
+	pNumberOfROIZones)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	*pNumberOfROIZones = 1;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetMaxNumberOfROIZones(VL53L0_DEV Dev, uint8_t
+	*pMaxNumberOfROIZones)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	*pMaxNumberOfROIZones = 1;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* End Group PAL Measurement Functions */
+
+
+VL53L0_Error VL53L0_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+	VL53L0_DeviceModes DeviceMode, VL53L0_GpioFunctionality Functionality,
+	VL53L0_InterruptPolarity Polarity)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	uint8_t data;
+	LOG_FUNCTION_START("");
+
+	if (Pin != 0)
+		Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		switch (Functionality) {
+		case VL53L0_GPIOFUNCTIONALITY_OFF:
+			data = 0x00;
+			break;
+		case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW:
+			data = 0x01;
+			break;
+		case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH:
+			data = 0x02;
+			break;
+		case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT:
+			data = 0x03;
+			break;
+		case VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY:
+			data = 0x04;
+			break;
+		default:
+			Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrByte(Dev,
+			VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,
+			data);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW)
+			data = 0;
+		else
+			data = (uint8_t)(1<<4);
+
+		Status = VL53L0_UpdateByte(Dev,
+			VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH,
+			0xEF, data);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality,
+			Functionality);
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_ClearInterruptMask(Dev, 0);
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+	VL53L0_DeviceModes *DeviceMode,
+	VL53L0_GpioFunctionality *pFunctionality,
+	VL53L0_InterruptPolarity *pPolarity)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	VL53L0_GpioFunctionality GpioFunctionality;
+	uint8_t data;
+	LOG_FUNCTION_START("");
+
+	if (Pin != 0) {
+		Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
+	} else {
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,
+			&data);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		switch (data&0x07) {
+		case 0x00:
+		    GpioFunctionality = VL53L0_GPIOFUNCTIONALITY_OFF;
+		    break;
+		case 0x01:
+			GpioFunctionality =
+				VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW;
+		    break;
+		case 0x02:
+			GpioFunctionality =
+				VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH;
+		    break;
+		case 0x03:
+			GpioFunctionality =
+				VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT;
+		    break;
+		case 0x04:
+		    GpioFunctionality =
+				VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY;
+		    break;
+		default:
+		    Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		*pFunctionality = GpioFunctionality;
+		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality,
+			GpioFunctionality);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetInterruptThresholds(VL53L0_DEV Dev, VL53L0_DeviceModes
+	DeviceMode, FixPoint1616_t ThresholdLow, FixPoint1616_t ThresholdHigh)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t Threshold16;
+	LOG_FUNCTION_START("");
+
+	/* no dependency on DeviceMode for Ewok */
+
+	Threshold16 = (uint16_t)((ThresholdLow >> 16) & 0x00fff);
+	Status = VL53L0_WrWord(Dev, VL53L0_REG_SYSTEM_THRESH_LOW, Threshold16);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Threshold16 = (uint16_t)((ThresholdHigh >> 16) & 0x00fff);
+		Status = VL53L0_WrWord(Dev, VL53L0_REG_SYSTEM_THRESH_HIGH,
+			Threshold16);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetInterruptThresholds(VL53L0_DEV Dev, VL53L0_DeviceModes
+	DeviceMode, FixPoint1616_t *pThresholdLow,
+	FixPoint1616_t *pThresholdHigh)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t Threshold16;
+	LOG_FUNCTION_START("");
+
+	/* no dependency on DeviceMode for Ewok */
+
+	Status = VL53L0_RdWord(Dev, VL53L0_REG_SYSTEM_THRESH_LOW, &Threshold16);
+	*pThresholdLow = (FixPoint1616_t)((0x00fff & Threshold16)<<16);
+	/* 12 bit */
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdWord(Dev, VL53L0_REG_SYSTEM_THRESH_HIGH,
+			&Threshold16);
+		*pThresholdHigh = (FixPoint1616_t)(
+			(0x00fff & Threshold16) << 16); /* 12 bit */
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* Group PAL Interrupt Functions */
+VL53L0_Error VL53L0_ClearInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t LoopCount;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	/* clear bit 0 range interrupt, bit 1 error interrupt */
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_INTERRUPT_CLEAR, 0x01);
+	LoopCount = 0;
+	do {
+		VL53L0_RdByte(Dev, VL53L0_REG_RESULT_INTERRUPT_STATUS, &Byte);
+		LoopCount++;
+	} while (((Byte & 0x07) != 0x00) && (LoopCount < 8));
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_INTERRUPT_CLEAR, 0x00);
+	/* clear all */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetInterruptMaskStatus(VL53L0_DEV Dev, uint32_t
+	*pInterruptMaskStatus)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_INTERRUPT_STATUS, &Byte);
+	*pInterruptMaskStatus = Byte & 0x07;
+
+	if (Byte & 0x18) {
+		Status = VL53L0_ERROR_RANGE_ERROR; /* check if some error
+		occurs */
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_EnableInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+	LOG_FUNCTION_START("");
+
+	/* not implemented for VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* End Group PAL Interrupt Functions */
+
+/* Group SPAD functions */
+
+VL53L0_Error VL53L0_SetSpadAmbientDamperThreshold(VL53L0_DEV Dev, uint16_t
+	SpadAmbientDamperThreshold)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_WrWord(Dev, 0x40, SpadAmbientDamperThreshold);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSpadAmbientDamperThreshold(VL53L0_DEV Dev, uint16_t
+	*pSpadAmbientDamperThreshold)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_RdWord(Dev, 0x40, pSpadAmbientDamperThreshold);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_SetSpadAmbientDamperFactor(VL53L0_DEV Dev, uint16_t
+	SpadAmbientDamperFactor)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	Byte = (uint8_t) (SpadAmbientDamperFactor & 0x00FF);
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_WrByte(Dev, 0x42, Byte);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L0_GetSpadAmbientDamperFactor(VL53L0_DEV Dev, uint16_t
+	*pSpadAmbientDamperFactor)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	LOG_FUNCTION_START("");
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_RdByte(Dev, 0x42, &Byte);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+	*pSpadAmbientDamperFactor = (uint16_t) Byte;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* END Group SPAD functions */
+
+/*//////////////////////////////////////////////////////////////////////////////
+//
+//////////////////////////////////
+// Internal functions
+////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////
+*/
+static uint32_t VL53L0_calc_macro_period_ps(VL53L0_DEV Dev,
+		uint8_t vcsel_period);
+static uint16_t VL53L0_encode_timeout(uint32_t timeout_mclks);
+static uint32_t VL53L0_decode_timeout(uint16_t encoded_timeout);
+
+static VL53L0_Error VL53L0_set_vcsel_pulse_period(VL53L0_DEV Dev, uint8_t
+	VCSELPulsePeriod)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t vcsel_period_reg;
+	LOG_FUNCTION_START("");
+
+	vcsel_period_reg = VL53L0_encode_vcsel_period((uint8_t)
+		VCSELPulsePeriod);
+	Status = VL53L0_WrByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
+		vcsel_period_reg);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+static VL53L0_Error VL53L0_get_vcsel_pulse_period(VL53L0_DEV Dev, uint8_t
+	*pVCSELPulsePeriod, uint8_t RangeIndex)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t vcsel_period_reg;
+	LOG_FUNCTION_START("");
+
+	switch (RangeIndex) {
+	case 0:
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+		break;
+	case 1:
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_RNGB1_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+		break;
+	case 2:
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_RNGB2_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+		break;
+	default:
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		*pVCSELPulsePeriod =
+			VL53L0_decode_vcsel_period(vcsel_period_reg);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* To convert ms into register value */
+static uint16_t VL53L0_calc_encoded_timeout(VL53L0_DEV Dev, uint32_t
+	timeout_period_us, uint8_t vcsel_period)
+{
+	uint32_t macro_period_ps;
+	uint32_t macro_period_ns;
+	uint32_t timeout_period_mclks = 0;
+	uint16_t timeout_overall_periods = 0;
+
+	macro_period_ps = VL53L0_calc_macro_period_ps(Dev, vcsel_period);
+	macro_period_ns = macro_period_ps / 1000;
+
+	timeout_period_mclks = (uint32_t) (((timeout_period_us * 1000) +
+		(macro_period_ns / 2)) / macro_period_ns);
+	timeout_overall_periods = VL53L0_encode_timeout(timeout_period_mclks);
+
+	return timeout_overall_periods;
+}
+
+/* To convert register value into us */
+static uint32_t VL53L0_calc_ranging_wait_us(VL53L0_DEV Dev, uint16_t
+	timeout_overall_periods, uint8_t vcsel_period)
+{
+	uint32_t macro_period_ps;
+	uint32_t macro_period_ns;
+	uint32_t timeout_period_mclks = 0;
+	uint32_t actual_timeout_period_us = 0;
+
+	macro_period_ps = VL53L0_calc_macro_period_ps(Dev, vcsel_period);
+	macro_period_ns = macro_period_ps / 1000;
+
+	timeout_period_mclks = VL53L0_decode_timeout(timeout_overall_periods);
+	actual_timeout_period_us = ((timeout_period_mclks * macro_period_ns) +
+		(macro_period_ns / 2)) / 1000;
+
+	return actual_timeout_period_us;
+}
+
+static uint32_t VL53L0_calc_macro_period_ps(VL53L0_DEV Dev,
+		uint8_t vcsel_period)
+{
+	uint32_t PLL_multiplier;
+	uint64_t PLL_period_ps;
+	uint8_t vcsel_period_pclks;
+	uint32_t macro_period_vclks;
+	uint32_t macro_period_ps;
+
+	LOG_FUNCTION_START("");
+
+	PLL_multiplier = 65536 / 64; /* PLL multiplier is 64 */
+	PLL_period_ps = (1000 * 1000 * PLL_multiplier) /
+		VL53L0_GETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz);
+
+	vcsel_period_pclks = VL53L0_decode_vcsel_period(vcsel_period);
+
+	macro_period_vclks = 2304;
+	macro_period_ps = (uint32_t)(macro_period_vclks * vcsel_period_pclks *
+		PLL_period_ps);
+
+	LOG_FUNCTION_END("");
+	return macro_period_ps;
+}
+
+static uint8_t VL53L0_decode_vcsel_period(uint8_t vcsel_period_reg)
+{
+
+	/*!
+	 * Converts the encoded VCSEL period register value into the real
+	 * period in PLL clocks
+	 */
+
+	uint8_t vcsel_period_pclks = 0;
+
+	vcsel_period_pclks = (vcsel_period_reg + 1) << 1;
+
+	return vcsel_period_pclks;
+}
+
+static uint8_t VL53L0_encode_vcsel_period(uint8_t vcsel_period_pclks)
+{
+
+	/*!
+	 * Converts the encoded VCSEL period register value into the real
+	 * period in PLL clocks
+	 */
+
+	uint8_t vcsel_period_reg = 0;
+
+	vcsel_period_reg = (vcsel_period_pclks >> 1) - 1;
+
+	return vcsel_period_reg;
+}
+
+static uint16_t VL53L0_encode_timeout(uint32_t timeout_mclks)
+{
+    /*!
+     * Encode timeout in macro periods in (LSByte * 2^MSByte) + 1 format
+     *
+     */
+
+	uint16_t encoded_timeout = 0;
+	uint32_t ls_byte = 0;
+	uint16_t ms_byte = 0;
+
+	if (timeout_mclks > 0) {
+		ls_byte = timeout_mclks - 1;
+
+		while ((ls_byte & 0xFFFFFF00) > 0) {
+			ls_byte = ls_byte >> 1;
+			ms_byte++;
+		}
+
+		encoded_timeout = (ms_byte << 8) + (uint16_t) (ls_byte &
+			0x000000FF);
+
+	}
+
+	return encoded_timeout;
+
+}
+
+static uint32_t VL53L0_decode_timeout(uint16_t encoded_timeout)
+{
+	/*!
+	 * Decode 16-bit timeout register value - format (LSByte * 2^MSByte) + 1
+	 *
+	 */
+
+	uint32_t timeout_mclks = 0;
+
+	timeout_mclks = ((uint32_t) (encoded_timeout & 0x00FF) << (uint32_t)
+		((encoded_timeout & 0xFF00) >> 8)) + 1;
+
+	return timeout_mclks;
+
+}
+
+
+static VL53L0_Error VL53L0_load_additional_settings1(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	/* update 12_05_15_v6 */
+	/* OSCT */
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x14, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCD, 0x6C);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x86, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	/* update 12_05_15_v6 */
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xcd, 0x6c);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x3f);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x3f);
+	Status |= VL53L0_WrByte(Dev, 0x88, 0x2b);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xcd, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	/* update 12_05_15 */
+	Status |= VL53L0_WrByte(Dev, 0xb0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb1, 0xfc);
+	Status |= VL53L0_WrByte(Dev, 0xb2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb3, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb5, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb6, 0xb0);
+
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x03);
+
+	Status |= VL53L0_WrByte(Dev, 0x41, 0xff);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0x01, 0x01);
+
+	if (Status != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+static VL53L0_Error VL53L0_load_additional_settings3(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	/* update 150624_b */
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x4f, 0x0B);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x0E);
+
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x01, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x02, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x03, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x04, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x05, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x06, 0x06);
+	Status |= VL53L0_WrByte(Dev, 0x07, 0x47);
+	Status |= VL53L0_WrByte(Dev, 0x08, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x09, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x0A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x0B, 0x49);
+	Status |= VL53L0_WrByte(Dev, 0x0C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x0D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x0E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x0F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x10, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x11, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x12, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x13, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x14, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x15, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x16, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x17, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x18, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x19, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x1A, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x1B, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x1C, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x1D, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x1E, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x1F, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x20, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x21, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x22, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x23, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x24, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x25, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x26, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x27, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x28, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x29, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x2A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2B, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x2C, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x2D, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x2E, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x2F, 0x92);
+	Status |= VL53L0_WrByte(Dev, 0x30, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x31, 0x64);
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x33, 0x8A);
+	Status |= VL53L0_WrByte(Dev, 0x34, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x35, 0xE0);
+	Status |= VL53L0_WrByte(Dev, 0x36, 0x0F);
+	Status |= VL53L0_WrByte(Dev, 0x37, 0xAA);
+	Status |= VL53L0_WrByte(Dev, 0x38, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x39, 0xE4);
+	Status |= VL53L0_WrByte(Dev, 0x3A, 0x0F);
+	Status |= VL53L0_WrByte(Dev, 0x3B, 0xAE);
+	Status |= VL53L0_WrByte(Dev, 0x3C, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x3D, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x3E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x3F, 0x54);
+	Status |= VL53L0_WrByte(Dev, 0x40, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x41, 0x88);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x44, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x45, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x46, 0x06);
+	Status |= VL53L0_WrByte(Dev, 0x47, 0x87);
+	Status |= VL53L0_WrByte(Dev, 0x48, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x49, 0x38);
+	Status |= VL53L0_WrByte(Dev, 0x4A, 0x2B);
+	Status |= VL53L0_WrByte(Dev, 0x4B, 0x89);
+	Status |= VL53L0_WrByte(Dev, 0x4C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x4D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x4E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x4F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x50, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x51, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x52, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x53, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x54, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x55, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x56, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x57, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x58, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x59, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x5A, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x5B, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x5C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x5D, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x5E, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x5F, 0x67);
+	Status |= VL53L0_WrByte(Dev, 0x60, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x61, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x62, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x63, 0xB0);
+	Status |= VL53L0_WrByte(Dev, 0x64, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x65, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x66, 0x29);
+	Status |= VL53L0_WrByte(Dev, 0x67, 0xC1);
+	Status |= VL53L0_WrByte(Dev, 0x68, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x69, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x6B, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x6D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x6F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x71, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x72, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x73, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x74, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x75, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x76, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x77, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x78, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x79, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x7A, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x7B, 0x1B);
+	Status |= VL53L0_WrByte(Dev, 0x7C, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x7D, 0x82);
+	Status |= VL53L0_WrByte(Dev, 0x7E, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x7F, 0x24);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x82, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x84, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x85, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x86, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0x21);
+	Status |= VL53L0_WrByte(Dev, 0x88, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x58);
+	Status |= VL53L0_WrByte(Dev, 0x8A, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x8B, 0xCC);
+	Status |= VL53L0_WrByte(Dev, 0x8C, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x8D, 0xC3);
+	Status |= VL53L0_WrByte(Dev, 0x8E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x8F, 0x94);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x53);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x1E);
+	Status |= VL53L0_WrByte(Dev, 0x93, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x95, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x96, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x97, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x98, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x99, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x9A, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x9B, 0x10);
+	Status |= VL53L0_WrByte(Dev, 0x9C, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x9D, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x9E, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x9F, 0x50);
+	Status |= VL53L0_WrByte(Dev, 0xA0, 0x2B);
+	Status |= VL53L0_WrByte(Dev, 0xA1, 0xB1);
+	Status |= VL53L0_WrByte(Dev, 0xA2, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xA3, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0xA4, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xA5, 0x50);
+	Status |= VL53L0_WrByte(Dev, 0xA6, 0x2C);
+	Status |= VL53L0_WrByte(Dev, 0xA7, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0xA8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xA9, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xAA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xAB, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xAC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xAD, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xAE, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xAF, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xB0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xB1, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xB2, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xB3, 0x4E);
+	Status |= VL53L0_WrByte(Dev, 0xB4, 0x2D);
+	Status |= VL53L0_WrByte(Dev, 0xB5, 0x47);
+	Status |= VL53L0_WrByte(Dev, 0xB6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xB7, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xB8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xB9, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xBA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xBB, 0xA7);
+	Status |= VL53L0_WrByte(Dev, 0xBC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xBD, 0xA6);
+	Status |= VL53L0_WrByte(Dev, 0xBE, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xBF, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0xC0, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xC1, 0x30);
+	Status |= VL53L0_WrByte(Dev, 0xC2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xC3, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xC4, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xC5, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0xC6, 0x2D);
+	Status |= VL53L0_WrByte(Dev, 0xC7, 0x89);
+	Status |= VL53L0_WrByte(Dev, 0xC8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xC9, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xCA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCB, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xCC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCD, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xCE, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCF, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xD0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD1, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xD2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD3, 0x25);
+	Status |= VL53L0_WrByte(Dev, 0xD4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD5, 0x2E);
+	Status |= VL53L0_WrByte(Dev, 0xD6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD7, 0x25);
+	Status |= VL53L0_WrByte(Dev, 0xD8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD9, 0x2E);
+	Status |= VL53L0_WrByte(Dev, 0xDA, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xDB, 0xF3);
+	Status |= VL53L0_WrByte(Dev, 0xDC, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xDD, 0xEA);
+	Status |= VL53L0_WrByte(Dev, 0xDE, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xDF, 0x58);
+	Status |= VL53L0_WrByte(Dev, 0xE0, 0x2C);
+	Status |= VL53L0_WrByte(Dev, 0xE1, 0xD9);
+	Status |= VL53L0_WrByte(Dev, 0xE2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE3, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xE4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE5, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xE6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE7, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xE8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE9, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xEA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xEB, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xEC, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xED, 0x26);
+	Status |= VL53L0_WrByte(Dev, 0xEE, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xEF, 0xDC);
+	Status |= VL53L0_WrByte(Dev, 0xF0, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xF1, 0x58);
+	Status |= VL53L0_WrByte(Dev, 0xF2, 0x2F);
+	Status |= VL53L0_WrByte(Dev, 0xF3, 0x21);
+	Status |= VL53L0_WrByte(Dev, 0xF4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xF5, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xF6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xF7, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xF8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xF9, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xFA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFB, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xFC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFD, 0x04);
+	Status |= VL53L0_WrWord(Dev, 0xFE, 0x01E3);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x0F);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x01, 0x48);
+	Status |= VL53L0_WrByte(Dev, 0x02, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x03, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x04, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x05, 0xA4);
+	Status |= VL53L0_WrByte(Dev, 0x06, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x07, 0xB8);
+	Status |= VL53L0_WrByte(Dev, 0x08, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x09, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x0A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x0B, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x0C, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x0D, 0x6B);
+	Status |= VL53L0_WrByte(Dev, 0x0E, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x0F, 0x64);
+	Status |= VL53L0_WrByte(Dev, 0x10, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x11, 0x3C);
+	Status |= VL53L0_WrByte(Dev, 0x12, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x13, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x14, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x15, 0x74);
+	Status |= VL53L0_WrByte(Dev, 0x16, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x17, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x18, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x19, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x1A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x1B, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x1C, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x1D, 0xA2);
+	Status |= VL53L0_WrByte(Dev, 0x1E, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x1F, 0x8E);
+	Status |= VL53L0_WrByte(Dev, 0x20, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x21, 0x50);
+	Status |= VL53L0_WrByte(Dev, 0x22, 0x2E);
+	Status |= VL53L0_WrByte(Dev, 0x23, 0xC9);
+	Status |= VL53L0_WrByte(Dev, 0x24, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x25, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x26, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x27, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x28, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x29, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x2A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2B, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x2C, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x2D, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2F, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x30, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x31, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x33, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x34, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x35, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x36, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x37, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x38, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x39, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x3A, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x3B, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x3C, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x3D, 0x18);
+	Status |= VL53L0_WrByte(Dev, 0x3E, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x3F, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x40, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x41, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x44, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x45, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x46, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x47, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x48, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x49, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x4A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x4B, 0x40);
+	Status |= VL53L0_WrByte(Dev, 0x4C, 0x2F);
+	Status |= VL53L0_WrByte(Dev, 0x4D, 0xD1);
+	Status |= VL53L0_WrByte(Dev, 0x4E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x4F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x50, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x51, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x52, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x53, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x54, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x55, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x56, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x57, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x58, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x59, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x5A, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x5B, 0x48);
+	Status |= VL53L0_WrByte(Dev, 0x5C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x5D, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x5E, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x5F, 0xA2);
+	Status |= VL53L0_WrByte(Dev, 0x60, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x61, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x62, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x63, 0x3E);
+	Status |= VL53L0_WrByte(Dev, 0x64, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x65, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x66, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x67, 0x54);
+	Status |= VL53L0_WrByte(Dev, 0x68, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x69, 0x80);
+	Status |= VL53L0_WrByte(Dev, 0x6A, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6B, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x6C, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x6D, 0x38);
+	Status |= VL53L0_WrByte(Dev, 0x6E, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x6F, 0xE1);
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x71, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x72, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x73, 0x38);
+	Status |= VL53L0_WrByte(Dev, 0x74, 0x29);
+	Status |= VL53L0_WrByte(Dev, 0x75, 0x21);
+	Status |= VL53L0_WrByte(Dev, 0x76, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x77, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x78, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x79, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x7A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x7B, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x7C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x7D, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x7E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x7F, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x33);
+	Status |= VL53L0_WrByte(Dev, 0x82, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x6A);
+	Status |= VL53L0_WrByte(Dev, 0x84, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x85, 0x61);
+	Status |= VL53L0_WrByte(Dev, 0x86, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0xF9);
+	Status |= VL53L0_WrByte(Dev, 0x88, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x8A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x8B, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x8C, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x8D, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x8E, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x8F, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x66);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x2A);
+	Status |= VL53L0_WrByte(Dev, 0x93, 0x67);
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x95, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x96, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x97, 0x66);
+	Status |= VL53L0_WrByte(Dev, 0x98, 0x2A);
+	Status |= VL53L0_WrByte(Dev, 0x99, 0xAF);
+	Status |= VL53L0_WrByte(Dev, 0x9A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x9B, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x9C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x9D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x9E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x9F, 0xA7);
+	Status |= VL53L0_WrByte(Dev, 0xA0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xA1, 0xA6);
+	Status |= VL53L0_WrByte(Dev, 0xA2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xA3, 0x04);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x04);
+
+	Status |= VL53L0_WrByte(Dev, 0x79, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x7B, 0x16);
+	Status |= VL53L0_WrByte(Dev, 0x7D, 0x2B);
+	Status |= VL53L0_WrByte(Dev, 0x7F, 0x3B);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x59);
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x62);
+	Status |= VL53L0_WrByte(Dev, 0x85, 0x69);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0x76);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x7F);
+	Status |= VL53L0_WrByte(Dev, 0x8B, 0x98);
+	Status |= VL53L0_WrByte(Dev, 0x8D, 0xAC);
+	Status |= VL53L0_WrByte(Dev, 0x8F, 0xC0);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x30);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x93, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x37);
+	Status |= VL53L0_WrByte(Dev, 0x95, 0x62);
+
+	Status |= VL53L0_WrByte(Dev, 0x96, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x97, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x98, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x99, 0x18);
+	Status |= VL53L0_WrByte(Dev, 0x9A, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x9B, 0x6F);
+	Status |= VL53L0_WrByte(Dev, 0x9C, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x9D, 0xD4);
+	Status |= VL53L0_WrByte(Dev, 0x9E, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x9F, 0x6E);
+	Status |= VL53L0_WrByte(Dev, 0xA0, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0xA1, 0xA2);
+	Status |= VL53L0_WrByte(Dev, 0xA2, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0xA3, 0xAA);
+	Status |= VL53L0_WrByte(Dev, 0xA4, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xA5, 0x97);
+	Status |= VL53L0_WrByte(Dev, 0xA6, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xA7, 0xD8);
+	Status |= VL53L0_WrByte(Dev, 0xA8, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0xA9, 0xD7);
+	Status |= VL53L0_WrByte(Dev, 0xAA, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0xAB, 0xF6);
+	Status |= VL53L0_WrByte(Dev, 0xAC, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0xAD, 0x1A);
+	Status |= VL53L0_WrByte(Dev, 0xAE, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0xAF, 0x49);
+	Status |= VL53L0_WrByte(Dev, 0xB0, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0xB1, 0x17);
+	Status |= VL53L0_WrByte(Dev, 0xB2, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xB3, 0xCD);
+	Status |= VL53L0_WrByte(Dev, 0xB4, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xB5, 0x55);
+
+	Status |= VL53L0_WrByte(Dev, 0x72, 0xFF);
+	Status |= VL53L0_WrByte(Dev, 0x73, 0xFF);
+
+	Status |= VL53L0_WrByte(Dev, 0x74, 0xE0);
+
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+
+	if (Status != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+static VL53L0_Error VL53L0_check_part_used(VL53L0_DEV Dev, uint8_t *Revision)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t ModuleIdInt;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODULE_ID,
+		&ModuleIdInt);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (ModuleIdInt == 0)
+			Revision = 0;
+		else
+			Status = VL53L0_get_info_from_device(Dev, Revision);
+
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+static VL53L0_Error VL53L0_get_info_from_device(VL53L0_DEV Dev,
+		uint8_t *Revision)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t strobe;
+	uint8_t byte;
+	uint32_t LoopNb;
+
+	LOG_FUNCTION_START("");
+
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
+	Status |= VL53L0_RdByte(Dev, 0x83, &byte);
+	Status |= VL53L0_WrByte(Dev, 0x83, byte|4);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x01);
+
+	Status |= VL53L0_PollingDelay(Dev);
+
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x7B);
+
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
+
+	/*	polling
+	*	use timeout to avoid deadlock
+	*/
+	if (Status == VL53L0_ERROR_NONE) {
+		LoopNb = 0;
+		do {
+			Status = VL53L0_RdByte(Dev, 0x83, &strobe);
+			if ((strobe != 0x00) || Status != VL53L0_ERROR_NONE)
+				break;
+
+			LoopNb = LoopNb + 1;
+		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x01);
+	Status |= VL53L0_RdByte(Dev, 0x90, Revision);
+
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
+	Status |= VL53L0_RdByte(Dev, 0x83, &byte);
+	Status |= VL53L0_WrByte(Dev, 0x83, byte&0xfb);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+uint32_t VL53L0_isqrt(uint32_t num)
+{
+
+    /*
+     * Implements an integer square root
+     *
+     * From: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
+     */
+
+	uint32_t  res = 0;
+	uint32_t  bit = 1 << 30;
+	/* The second-to-top bit is set: 1 << 14 for
+	16-bits, 1 << 30 for 32 bits
+	*/
+    /* "bit" starts at the highest power of four <= the argument.*/
+	while (bit > num)
+		bit >>= 2;
+
+
+	while (bit != 0) {
+		if (num >= res + bit) {
+			num -= res + bit;
+			res = (res >> 1) + bit;
+		} else
+			res >>= 1;
+
+		bit >>= 2;
+	}
+
+	return res;
+}
+
+uint32_t VL53L0_quadrature_sum(uint32_t a,
+	uint32_t b)
+{
+	/*
+	* Implements a quadrature sum
+	*
+	* rea = sqrt(a^2 + b^2)
+	*
+	* Trap overflow case max input value is 65535 (16-bit value)
+	* as internal calc are 32-bit wide
+	*
+	* If overflow then seta output to maximum
+	*/
+	uint32_t  res = 0;
+
+	if (a > 65535 || b > 65535)
+		res = 65535;
+	else
+		res = VL53L0_isqrt(a*a + b*b);
+
+
+	return res;
+}
+
+
+
+VL53L0_Error VL53L0_get_jmp_vcsel_ambient_rate(VL53L0_DEV Dev,
+	uint32_t *pAmbient_rate_kcps,
+	uint32_t *pVcsel_rate_kcps,
+	uint32_t *pSignalTotalEventsRtn)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t encodedTimeOut;
+
+	uint32_t    total_periods_elapsed_rtn__macrop  = 0;
+	uint32_t    result_core__total_periods_elapsed_rtn  = 0;
+	uint32_t    rngb1_config__timeout__macrop = 0;
+	uint32_t    rngb2_config__timeout__macrop = 0;
+	uint32_t    result_core__ambient_window_events_rtn = 0;
+	uint32_t     result_core__signal_total_events_rtn = 0;
+	uint8_t     last_woi_period;
+	uint8_t     rnga_config__vcsel_period;
+	uint8_t     rngb1_config__vcsel_period;
+	uint8_t     rngb2_config__vcsel_period;
+	uint8_t     global_config__vcsel_width;
+
+	uint32_t    ambient_duration_us = 0;
+	uint32_t    vcsel_duration_us = 0;
+
+	uint32_t    pll_period_us  = 0;
+
+	LOG_FUNCTION_START("");
+
+	/* read the following */
+	Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_RdDWord(Dev, 0xC8,
+		&result_core__total_periods_elapsed_rtn);
+	Status |= VL53L0_RdDWord(Dev, 0xF0, &pll_period_us);
+	Status |= VL53L0_RdDWord(Dev, 0xbc,
+		&result_core__ambient_window_events_rtn);
+	Status |= VL53L0_RdDWord(Dev, 0xc4,
+		&result_core__signal_total_events_rtn);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		result_core__total_periods_elapsed_rtn =
+			(int32_t)(result_core__total_periods_elapsed_rtn &
+			0x00ffffff);
+		pll_period_us = (int32_t)(pll_period_us & 0x3ffff);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdWord(Dev, VL53L0_REG_RNGB1_TIMEOUT_MSB,
+			&encodedTimeOut);
+	if (Status == VL53L0_ERROR_NONE)
+		rngb1_config__timeout__macrop =
+			VL53L0_decode_timeout(encodedTimeOut) - 1;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
+			&rnga_config__vcsel_period);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_RNGB1_CONFIG_VCSEL_PERIOD,
+			&rngb1_config__vcsel_period);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev,
+			VL53L0_REG_RNGB2_CONFIG_VCSEL_PERIOD,
+			&rngb2_config__vcsel_period);
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_RdByte(Dev, 0x32, &global_config__vcsel_width);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdWord(Dev, VL53L0_REG_RNGB2_TIMEOUT_MSB,
+			&encodedTimeOut);
+		if (Status == VL53L0_ERROR_NONE)
+			rngb2_config__timeout__macrop =
+				VL53L0_decode_timeout(encodedTimeOut) - 1;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		total_periods_elapsed_rtn__macrop =
+			result_core__total_periods_elapsed_rtn + 1;
+
+		if (result_core__total_periods_elapsed_rtn ==
+			rngb1_config__timeout__macrop) {
+			last_woi_period = rngb1_config__vcsel_period;
+		} else if (result_core__total_periods_elapsed_rtn ==
+			rngb2_config__timeout__macrop) {
+			last_woi_period = rngb2_config__vcsel_period;
+		} else {
+			last_woi_period = rnga_config__vcsel_period;
+
+		}
+		/* 512 = 1<<9  ==> 24-9=15 */
+		ambient_duration_us = last_woi_period *
+			total_periods_elapsed_rtn__macrop * pll_period_us;
+		ambient_duration_us = ambient_duration_us / 1000;
+
+		*pAmbient_rate_kcps = ((1 << 15) *
+			result_core__ambient_window_events_rtn) /
+			ambient_duration_us;
+
+		/* 2048 = 1<<11  ==> 24-11=13 */
+		vcsel_duration_us = (10*global_config__vcsel_width + 4) *
+			total_periods_elapsed_rtn__macrop * pll_period_us ;
+		vcsel_duration_us = vcsel_duration_us / 10000 ;
+
+		*pVcsel_rate_kcps = ((1 << 13) *
+			result_core__signal_total_events_rtn)
+			/ vcsel_duration_us;
+		*pSignalTotalEventsRtn = result_core__signal_total_events_rtn;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
+
+VL53L0_Error VL53L0_calc_sigma_estimate(VL53L0_DEV Dev,
+	VL53L0_RangingMeasurementData_t
+	*pRangingMeasurementData,
+	FixPoint1616_t *pSigmaEstimate)
+{
+	const uint32_t cPulseEffectiveWidth_centi_ns   = 800;
+	/* Expressed in 100ths of a ns, i.e. centi-ns */
+	const uint32_t cAmbientEffectiveWidth_centi_ns = 600;
+	/* Expressed in 100ths of a ns, i.e. centi-ns */
+	const FixPoint1616_t cSigmaEstRef              = 0x00000042;
+	const uint32_t cVcselPulseWidth_ps             = 4700;
+	/* pico secs */
+	const FixPoint1616_t cSigmaEstMax              = 0x028F87AE;
+	const FixPoint1616_t cTOF_per_mm_ps            = 0x0006999A;
+	/* Time Of Flight per mm (6.6 pico secs) */
+	const uint32_t c16BitRoundingParam             = 0x00008000;
+	const FixPoint1616_t cMaxXTalk_kcps            = 0x00320000;
+
+	uint32_t signalTotalEventsRtn;
+	FixPoint1616_t sigmaEstimateP1;
+	FixPoint1616_t sigmaEstimateP2;
+	FixPoint1616_t sigmaEstimateP3;
+	FixPoint1616_t deltaT_ps;
+	FixPoint1616_t pwMult;
+	FixPoint1616_t sigmaEstRtn;
+	FixPoint1616_t sigmaEstimate;
+	FixPoint1616_t xTalkCorrection;
+	uint32_t signalTotalEventsRtnRawVal;
+	FixPoint1616_t ambientRate_kcps;
+	FixPoint1616_t vcselRate_kcps;
+	FixPoint1616_t xTalkCompRate_mcps;
+	uint32_t xTalkCompRate_kcps;
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	FixPoint1616_t diff1_mcps;
+	FixPoint1616_t diff2_mcps;
+	FixPoint1616_t sqr1;
+	FixPoint1616_t sqr2;
+	FixPoint1616_t sqrSum;
+	FixPoint1616_t sqrtResult_centi_ns;
+	FixPoint1616_t sqrtResult;
+
+    /*! \addtogroup calc_sigma_estimate
+	* @{
+	*
+	* Estimates the range sigma based on the
+	*
+	*  - vcsel_rate_kcps
+	*  - ambient_rate_kcps
+	*  - signal_total_events
+	*  - xtalk_rate
+	*
+	* and the following parameters
+	*
+	*  - SigmaEstRefArray
+	*  - SigmaEstEffPulseWidth
+	*  - SigmaEstEffAmbWidth
+	*/
+
+	LOG_FUNCTION_START("");
+
+	VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+		xTalkCompRate_mcps);
+
+    /*
+	* We work in kcps rather than mcps as this helps keep within the
+	* confines of the 32 Fix1616 type.
+	*/
+
+	xTalkCompRate_kcps = xTalkCompRate_mcps * 1000;
+	if (xTalkCompRate_kcps > cMaxXTalk_kcps)
+		xTalkCompRate_kcps = cMaxXTalk_kcps;
+
+	VL53L0_get_jmp_vcsel_ambient_rate(Dev,
+		&ambientRate_kcps,
+		&vcselRate_kcps,
+		&signalTotalEventsRtnRawVal);
+
+	signalTotalEventsRtn = signalTotalEventsRtnRawVal;
+	if (signalTotalEventsRtn < 1)
+		signalTotalEventsRtn = 1;
+
+
+    /*
+	* Calculate individual components of the main equation - replicating
+	* the equation implemented in the script OpenAll_Ewok_ranging_data.jsl.
+	*
+	* sigmaEstimateP1 represents the effective pulse width, which is a
+	* tuning parameter, rather than a real value.
+	*
+	* sigmaEstimateP2 represents the ambient/signal rate ratio expressed as
+	* a multiple of the effective ambient width (tuning parameter).
+	*
+	* sigmaEstimateP3 provides the signal event component, with the
+	* knowledge that
+	*  - Noise of a square pulse is 1/sqrt(12) of the pulse width.
+	*  - at 0Lux, sigma is proportional to effectiveVcselPulseWidth/
+	*    sqrt(12 * signalTotalEvents)
+	*
+	* deltaT_ps represents the time of flight in pico secs for the current
+	* range measurement,
+	* using the "TOF per mm" constant (in ps).
+	*/
+
+	sigmaEstimateP1 = cPulseEffectiveWidth_centi_ns;
+
+	/* ((FixPoint1616 << 16)* uint32)/FixPoint1616 = FixPoint1616 */
+	sigmaEstimateP2 = (ambientRate_kcps << 16)/vcselRate_kcps;
+	sigmaEstimateP2 *= cAmbientEffectiveWidth_centi_ns;
+
+	sigmaEstimateP3 = 2 * VL53L0_isqrt(signalTotalEventsRtn * 12);
+
+    /* uint32 * FixPoint1616 = FixPoint1616 */
+	deltaT_ps = pRangingMeasurementData->RangeMilliMeter * cTOF_per_mm_ps;
+
+    /*
+	* vcselRate - xtalkCompRate
+	* (uint32 << 16) - FixPoint1616 = FixPoint1616.
+	* Divide result by 1000 to convert to mcps.
+	* 500 is added to ensure rounding when integer division truncates.
+	*/
+	diff1_mcps = (((vcselRate_kcps << 16) - xTalkCompRate_kcps) + 500)/1000;
+	/* vcselRate + xtalkCompRate */
+	diff2_mcps = (((vcselRate_kcps << 16) + xTalkCompRate_kcps) + 500)/1000;
+
+	/* Shift by 12 bits to increase resolution prior to the division */
+	diff1_mcps <<= 12;
+
+	/* FixPoint0428/FixPoint1616 = FixPoint2012 */
+	xTalkCorrection  = abs(diff1_mcps/diff2_mcps);
+
+	/* FixPoint2012 << 4 = FixPoint1616 */
+	xTalkCorrection <<= 4;
+
+	/* FixPoint1616/uint32 = FixPoint1616 */
+	pwMult = deltaT_ps/cVcselPulseWidth_ps; /* smaller than 1.0f */
+
+	/*
+	* FixPoint1616 * FixPoint1616 = FixPoint3232, however both values are
+	* small enough such that32 bits will not be exceeded.
+	*/
+	pwMult *= ((1 << 16) - xTalkCorrection);
+
+	/* (FixPoint3232 >> 16) = FixPoint1616 */
+	pwMult =  (pwMult + c16BitRoundingParam) >> 16;
+
+	/* FixPoint1616 + FixPoint1616 = FixPoint1616 */
+	pwMult += (1 << 16);
+
+	/*
+	* At this point the value will be 1.xx, therefore if we square the value
+	* this will exceed
+	* 32 bits. To address this perform a single shift to the right before
+	* the multiplication.
+	*/
+	pwMult >>= 1;
+	/* FixPoint1715 * FixPoint1715 = FixPoint3430 */
+	pwMult = pwMult * pwMult;
+
+	/* (FixPoint3430 >> 14) = Fix1616 */
+	pwMult >>= 14;
+
+	/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+	sqr1 = pwMult * sigmaEstimateP1;
+
+	/* (FixPoint1616 >> 12) = FixPoint2804 */
+	sqr1 = (sqr1 + 0x800) >> 12;
+
+	/* FixPoint2804 * FixPoint2804 = FixPoint5608 */
+	sqr1 *= sqr1;
+
+	sqr2 = sigmaEstimateP2;
+
+	/* (FixPoint1616 >> 12) = FixPoint2804 */
+	sqr2 = (sqr2 + 0x800) >> 12;
+
+	/* FixPoint2804 * FixPoint2804 = FixPoint5608 */
+	sqr2 *= sqr2;
+
+	/* FixPoint5608 + FixPoint5608 = FixPoint5608 */
+	sqrSum = sqr1 + sqr2;
+
+	/* SQRT(FixPoint5608) = FixPoint2804 */
+	sqrtResult_centi_ns = VL53L0_isqrt(sqrSum);
+
+	/* (FixPoint2804 << 12) = FixPoint1616 */
+	sqrtResult_centi_ns <<= 12;
+
+	/*
+	* Note that the Speed Of Light is expressed in um per 1E-10 seconds
+	* (2997)
+	* Therefore to get mm/ns we have to divide by 10000
+	*/
+	sigmaEstRtn      = ((sqrtResult_centi_ns+50)/100 *
+		VL53L0_SPEED_OF_LIGHT_IN_AIR);
+	sigmaEstRtn      /= (sigmaEstimateP3);
+	sigmaEstRtn      += 5000; /* Add 5000 before dividing by 10000 to ensure
+	rounding. */
+	sigmaEstRtn      /= 10000;
+
+	/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+	sqr1 = sigmaEstRtn * sigmaEstRtn;
+	/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+	sqr2 = cSigmaEstRef * cSigmaEstRef;
+
+	/* sqrt(FixPoint3232 << 12) = FixPoint1022 */
+	sqrtResult = VL53L0_isqrt((sqr1 + sqr2) << 12);
+	sqrtResult = (sqrtResult + 0x20) >> 6;
+	/*
+	* Note that the Shift by 12bits increases resolution prior to the sqrt,
+	* therefore the result must be shifted by 6bits to the right to revert
+	* back to the FixPoint1616 format.
+	*/
+
+	sigmaEstimate    = 1000 * sqrtResult;
+
+	if ((vcselRate_kcps < 1) || (signalTotalEventsRtn < 1) ||
+		(sigmaEstimate > cSigmaEstMax)) {
+		sigmaEstimate = cSigmaEstMax;
+	}
+
+	*pSigmaEstimate = (uint32_t)(sigmaEstimate);
+	PALDevDataSet(Dev, SigmaEstimate, *pSigmaEstimate);
+
+	LOG_FUNCTION_END(Status);
+
+	return Status;
+}
+
+static VL53L0_Error VL53L0_get_pal_range_status(VL53L0_DEV Dev,
+	uint8_t DeviceRangeStatus,
+	FixPoint1616_t SignalRate,
+	FixPoint1616_t CrosstalkCompensation,
+	uint16_t EffectiveSpadRtnCount,
+	VL53L0_RangingMeasurementData_t
+	*pRangingMeasurementData,
+	uint8_t *pPalRangeStatus)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t tmpByte;
+	uint8_t SigmaLimitCheckEnable;
+	uint8_t SignalLimitCheckEnable;
+	FixPoint1616_t SigmaEstimate;
+	FixPoint1616_t SignalEstimate;
+	FixPoint1616_t SigmaLimitValue;
+	FixPoint1616_t SignalLimitValue;
+	uint8_t DeviceRangeStatusInternal = 0;
+	LOG_FUNCTION_START("");
+
+	/*
+	* VL53L0 has a good ranging when the value of the DeviceRangeStatus
+	* = 11.
+	* This function will replace the value 0 with the value 11 in the
+	* DeviceRangeStatus.
+	* In addition, the SigmaEstimator is not included in the VL53L0
+	* DeviceRangeStatus, this will be added in the PalRangeStatus.
+	*/
+
+	DeviceRangeStatusInternal = ((DeviceRangeStatus & 0x78) >> 3);
+
+	if (DeviceRangeStatusInternal == 11)
+		tmpByte = 0;
+	else if (DeviceRangeStatusInternal == 0)
+		tmpByte = 11;
+	else
+		tmpByte = DeviceRangeStatusInternal;
+
+
+	/*
+	* Check if Sigma limit is enabled, if yes then do comparison with limit
+	* value and put the result back into pPalRangeStatus.
+	*/
+	Status =  VL53L0_GetSigmaLimitCheckEnable(Dev,
+		VL53L0_CHECKPOSITION_EARLY,
+		&SigmaLimitCheckEnable);
+
+	if ((SigmaLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
+		/*
+		* compute the Sigma and check with limit
+		*/
+		Status = VL53L0_calc_sigma_estimate(Dev,
+			pRangingMeasurementData,
+			&SigmaEstimate);
+
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_GetSigmaLimitValue(Dev,
+				VL53L0_CHECKPOSITION_EARLY,
+				&SigmaLimitValue);
+
+			if ((SigmaLimitValue > 0) && (SigmaEstimate >
+				SigmaLimitValue)) {
+				/* Limit Fail add 2^4 to range status */
+				tmpByte += 16;
+			}
+		}
+	}
+
+	/*
+	* Check if Signal limit is enabled, if yes then do comparison with
+	* limit value and put the result back into pPalRangeStatus.
+	*/
+	Status =  VL53L0_GetSignalLimitCheckEnable(Dev,
+		VL53L0_CHECKPOSITION_EARLY,	&SignalLimitCheckEnable);
+
+	if ((SignalLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
+		/*
+		* compute the Signal and check with limit
+		*/
+
+		SignalEstimate  = (FixPoint1616_t)(SignalRate -
+			(FixPoint1616_t)((EffectiveSpadRtnCount *
+			CrosstalkCompensation) >> 1));
+
+		PALDevDataSet(Dev, SignalEstimate, SignalEstimate);
+
+		Status = VL53L0_GetSignalLimitValue(Dev,
+			VL53L0_CHECKPOSITION_EARLY, &SignalLimitValue);
+
+		if ((SignalLimitValue > 0) && (SignalEstimate <
+			SignalLimitValue)) {
+			/* Limit Fail add 2^5 to range status */
+			tmpByte += 32;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		*pPalRangeStatus = tmpByte;
+
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_i2c_platform.c b/drivers/input/misc/vl53L0/src/vl53l0_i2c_platform.c
new file mode 100644
index 00000000000..145db4adb50
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l0_i2c_platform.c
@@ -0,0 +1,377 @@
+/*
+ * COPYRIGHT (C) STMicroelectronics 2015. All rights reserved.
+ *
+ * This software is the confidential and proprietary information of
+ * STMicroelectronics ("Confidential Information").  You shall not
+ * disclose such Confidential Information and shall use it only in
+ * accordance with the terms of the license agreement you entered into
+ * with STMicroelectronics
+ *
+ * Programming Golden Rule: Keep it Simple!
+ *
+ */
+
+/*!
+ * \file   VL53L0_platform.c
+ * \brief  Code function defintions for EWOK Platform Layer
+ *
+ */
+
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include "stmvl53l0-i2c.h"
+#include "stmvl53l0-cci.h"
+
+#include "vl53l0_platform.h"
+#include "vl53l0_i2c_platform.h"
+#include "vl53l0_def.h"
+
+#include "vl53l0_platform_log.h"
+
+#ifdef VL53L0_LOG_ENABLE
+#define trace_print(level, ...) \
+	trace_print_module_function(TRACE_MODULE_PLATFORM, level,\
+	TRACE_FUNCTION_NONE, ##__VA_ARGS__)
+#define trace_i2c(...) \
+	trace_print_module_function(TRACE_MODULE_NONE, \
+	TRACE_LEVEL_NONE, TRACE_FUNCTION_I2C, ##__VA_ARGS__)
+#endif
+
+/**
+ * @def I2C_BUFFER_CONFIG
+ *
+ * @brief Configure Device register I2C access
+ *
+ * @li 0 : one GLOBAL buffer \n
+ *   Use one global buffer of MAX_I2C_XFER_SIZE byte in data space \n
+ *   This solution is not multi-Device compliant nor multi-thread cpu safe \n
+ *   It can be the best option for small 8/16 bit MCU without stack and limited
+ *   ram  (STM8s, 80C51 ...)
+ *
+ * @li 1 : ON_STACK/local \n
+ *   Use local variable (on stack) buffer \n
+ *   This solution is multi-thread with use of i2c resource lock or mutex see
+ *   VL6180x_GetI2CAccess() \n
+ *
+ * @li 2 : User defined \n
+ *    Per Device potentially dynamic allocated. Requires VL6180x_GetI2cBuffer()
+ *    to be implemented.
+ * @ingroup Configuration
+ */
+#define I2C_BUFFER_CONFIG 1
+
+#if I2C_BUFFER_CONFIG == 0
+    /* GLOBAL config buffer */
+	uint8_t i2c_global_buffer[VL53L0_MAX_I2C_XFER_SIZE];
+
+    #define DECL_I2C_BUFFER
+    #define VL53L0_GetLocalBuffer(Dev, n_byte)  i2c_global_buffer
+
+#elif I2C_BUFFER_CONFIG == 1
+    /* ON STACK */
+	uint8_t LocBuffer[VL53L0_MAX_I2C_XFER_SIZE];
+    #define VL53L0_GetLocalBuffer(Dev, n_byte)  LocBuffer
+#elif I2C_BUFFER_CONFIG == 2
+    /* user define buffer type declare DECL_I2C_BUFFER  as access  via
+	VL53L0_GetLocalBuffer */
+    #define DECL_I2C_BUFFER
+#else
+#error "invalid I2C_BUFFER_CONFIG "
+#endif
+
+
+#define VL53L0_I2C_USER_VAR         /* none but could be for a flag var to
+		get/pass to mutex interruptible  return flags and try again */
+#define VL53L0_GetI2CAccess(Dev)    /* todo mutex acquire */
+#define VL53L0_DoneI2CAcces(Dev)    /* todo mutex release */
+
+
+char  debug_string[VL53L0_MAX_STRING_LENGTH_PLT];
+
+
+#define MIN_COMMS_VERSION_MAJOR     1
+#define MIN_COMMS_VERSION_MINOR     8
+#define MIN_COMMS_VERSION_BUILD     1
+#define MIN_COMMS_VERSION_REVISION  0
+
+#define STATUS_OK              0x00
+#define STATUS_FAIL            0x01
+
+bool_t _check_min_version(void)
+{
+	bool_t min_version_comms_dll = false;
+
+	min_version_comms_dll = true;
+
+	return min_version_comms_dll;
+}
+
+int32_t VL53L0_comms_initialise(uint8_t comms_type, uint16_t comms_speed_khz)
+{
+	int32_t status   = STATUS_OK;
+
+	return status;
+}
+
+int32_t VL53L0_comms_close(void)
+{
+	int32_t status = STATUS_OK;
+
+
+	return status;
+}
+
+int32_t VL53L0_set_page(VL53L0_DEV dev, uint8_t page_data)
+{
+	int32_t status = STATUS_OK;
+	uint16_t page_index = 0xFF;
+	uint8_t *buffer;
+
+	buffer =  VL53L0_GetLocalBuffer(dev, 3);
+	buffer[0] = page_index >> 8;
+	buffer[1] = page_index & 0xff;
+	buffer[2] = page_data;
+
+	status = VL53L0_I2CWrite(dev, buffer, (uint8_t) 3);
+	return status;
+}
+
+int32_t VL53L0_write_multi(VL53L0_DEV dev, uint8_t index, uint8_t *pdata,
+			int32_t count)
+{
+	int32_t status = STATUS_OK;
+	uint8_t *buffer;
+
+#ifdef VL53L0_LOG_ENABLE
+	int32_t i = 0;
+	char value_as_str[VL53L0_MAX_STRING_LENGTH_PLT];
+	char *pvalue_as_str;
+
+	pvalue_as_str =  value_as_str;
+
+	for (i = 0 ; i < count ; i++) {
+		sprintf(pvalue_as_str, "%02X", *(pdata + i));
+
+		pvalue_as_str += 2;
+	}
+	trace_i2c("Write reg : 0x%04X, Val : 0x%s\n", index, value_as_str);
+#endif
+	if ((count + 1) > VL53L0_MAX_I2C_XFER_SIZE)
+		return -1;
+	buffer =  VL53L0_GetLocalBuffer(dev, (count+1));
+	buffer[0] = index;
+	memcpy(&buffer[1], pdata, count);
+	status = VL53L0_I2CWrite(dev, buffer, (count+1));
+
+	return status;
+}
+
+int32_t VL53L0_read_multi(VL53L0_DEV dev, uint8_t index, uint8_t *pdata,
+			int32_t count)
+{
+	int32_t status = STATUS_OK;
+	uint8_t *buffer;
+
+#ifdef VL53L0_LOG_ENABLE
+	int32_t      i = 0;
+	char   value_as_str[VL53L0_MAX_STRING_LENGTH_PLT];
+	char *pvalue_as_str;
+#endif
+
+	if ((count + 1) > VL53L0_MAX_I2C_XFER_SIZE)
+		return -1;
+
+	buffer =  VL53L0_GetLocalBuffer(dev, 1);
+	buffer[0] = index;
+	status = VL53L0_I2CWrite(dev, (uint8_t *)buffer, (uint8_t)1);
+	if (!status) {
+		pdata[0] = index ;
+		status = VL53L0_I2CRead(dev, pdata, count);
+	}
+
+#ifdef VL53L0_LOG_ENABLE
+	pvalue_as_str =  value_as_str;
+
+	for (i = 0 ; i < count ; i++) {
+		sprintf(pvalue_as_str, "%02X", *(pdata+i));
+		pvalue_as_str += 2;
+	}
+
+	trace_i2c("Read  reg : 0x%04X, Val : 0x%s\n", index, value_as_str);
+#endif
+
+	return status;
+}
+
+
+int32_t VL53L0_write_byte(VL53L0_DEV dev, uint8_t index, uint8_t data)
+{
+	int32_t status = STATUS_OK;
+	const int32_t cbyte_count = 1;
+
+	status = VL53L0_write_multi(dev, index, &data, cbyte_count);
+
+	return status;
+
+}
+
+
+int32_t VL53L0_write_word(VL53L0_DEV dev, uint8_t index, uint16_t data)
+{
+	int32_t status = STATUS_OK;
+
+	uint8_t  buffer[BYTES_PER_WORD];
+
+	/* Split 16-bit word into MS and LS uint8_t */
+	buffer[0] = (uint8_t)(data >> 8);
+	buffer[1] = (uint8_t)(data &  0x00FF);
+
+	status = VL53L0_write_multi(dev, index, buffer, BYTES_PER_WORD);
+
+	return status;
+
+}
+
+
+int32_t VL53L0_write_dword(VL53L0_DEV dev, uint8_t index, uint32_t data)
+{
+	int32_t status = STATUS_OK;
+	uint8_t  buffer[BYTES_PER_DWORD];
+
+	/* Split 32-bit word into MS ... LS bytes */
+	buffer[0] = (uint8_t) (data >> 24);
+	buffer[1] = (uint8_t)((data &  0x00FF0000) >> 16);
+	buffer[2] = (uint8_t)((data &  0x0000FF00) >> 8);
+	buffer[3] = (uint8_t) (data &  0x000000FF);
+
+	status = VL53L0_write_multi(dev, index, buffer, BYTES_PER_DWORD);
+
+	return status;
+
+}
+
+
+int32_t VL53L0_read_byte(VL53L0_DEV dev, uint8_t index, uint8_t *pdata)
+{
+	int32_t status = STATUS_OK;
+	int32_t cbyte_count = 1;
+
+	status = VL53L0_read_multi(dev, index, pdata, cbyte_count);
+
+	return status;
+
+}
+
+
+int32_t VL53L0_read_word(VL53L0_DEV dev, uint8_t index, uint16_t *pdata)
+{
+	int32_t  status = STATUS_OK;
+	uint8_t  buffer[BYTES_PER_WORD];
+
+	status = VL53L0_read_multi(dev, index, buffer, BYTES_PER_WORD);
+	*pdata = ((uint16_t)buffer[0]<<8) + (uint16_t)buffer[1];
+
+	return status;
+
+}
+
+int32_t VL53L0_read_dword(VL53L0_DEV dev, uint8_t index, uint32_t *pdata)
+{
+	int32_t status = STATUS_OK;
+	uint8_t  buffer[BYTES_PER_DWORD];
+
+	status = VL53L0_read_multi(dev, index, buffer, BYTES_PER_DWORD);
+	*pdata = ((uint32_t)buffer[0]<<24) + ((uint32_t)buffer[1]<<16) +
+			((uint32_t)buffer[2]<<8) + (uint32_t)buffer[3];
+
+	return status;
+
+}
+
+int32_t VL53L0_platform_wait_us(int32_t wait_us)
+{
+	int32_t status = STATUS_OK;
+
+	msleep((wait_us/1000));
+
+#ifdef VL53L0_LOG_ENABLE
+	trace_i2c("Wait us : %6d\n", wait_us);
+#endif
+
+	return status;
+
+}
+
+
+int32_t VL53L0_wait_ms(int32_t wait_ms)
+{
+	int32_t status = STATUS_OK;
+
+	msleep(wait_ms);
+
+#ifdef VL53L0_LOG_ENABLE
+	trace_i2c("Wait ms : %6d\n", wait_ms);
+#endif
+
+	return status;
+
+}
+
+
+int32_t VL53L0_set_gpio(uint8_t level)
+{
+	int32_t status = STATUS_OK;
+#ifdef VL53L0_LOG_ENABLE
+	trace_i2c("// Set GPIO = %d;\n", level);
+#endif
+
+	return status;
+
+}
+
+
+int32_t VL53L0_get_gpio(uint8_t *plevel)
+{
+	int32_t status = STATUS_OK;
+#ifdef VL53L0_LOG_ENABLE
+	trace_i2c("// Get GPIO = %d;\n", *plevel);
+#endif
+	return status;
+}
+
+
+int32_t VL53L0_release_gpio(void)
+{
+	int32_t status = STATUS_OK;
+#ifdef VL53L0_LOG_ENABLE
+	trace_i2c("// Releasing force on GPIO\n");
+#endif
+	return status;
+
+}
+
+int32_t VL53L0_cycle_power(void)
+{
+	int32_t status = STATUS_OK;
+#ifdef VL53L0_LOG_ENABLE
+	trace_i2c("// cycle sensor power\n");
+#endif
+
+	return status;
+}
+
+
+int32_t VL53L0_get_timer_frequency(int32_t *ptimer_freq_hz)
+{
+	*ptimer_freq_hz = 0;
+	return STATUS_FAIL;
+}
+
+
+int32_t VL53L0_get_timer_value(int32_t *ptimer_count)
+{
+	*ptimer_count = 0;
+	return STATUS_FAIL;
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_platform.c b/drivers/input/misc/vl53L0/src/vl53l0_platform.c
new file mode 100644
index 00000000000..0f9e6860a1e
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l0_platform.c
@@ -0,0 +1,248 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+/**
+ * @file VL53L0_i2c.c
+ *
+ * Copyright (C) 2014 ST MicroElectronics
+ *
+ * provide variable word size byte/Word/dword VL6180x register access via i2c
+ *
+ */
+#include "vl53l0_platform.h"
+#include "vl53l0_i2c_platform.h"
+#include "vl53l0_api.h"
+
+#define LOG_FUNCTION_START(fmt, ...) \
+		_LOG_FUNCTION_START(TRACE_MODULE_PLATFORM, fmt, ##__VA_ARGS__)
+#define LOG_FUNCTION_END(status, ...) \
+		_LOG_FUNCTION_END(TRACE_MODULE_PLATFORM, status, ##__VA_ARGS__)
+#define LOG_FUNCTION_END_FMT(status, fmt, ...)\
+		_LOG_FUNCTION_END_FMT(TRACE_MODULE_PLATFORM, status,\
+		fmt, ##__VA_ARGS__)
+
+
+
+VL53L0_Error VL53L0_LockSequenceAccess(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	return Status;
+}
+
+VL53L0_Error VL53L0_UnlockSequenceAccess(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	return Status;
+}
+
+/* the ranging_sensor_comms.dll will take care of the page selection */
+VL53L0_Error VL53L0_WriteMulti(VL53L0_DEV Dev, uint8_t index,
+				uint8_t *pdata, uint32_t count)
+{
+
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int = 0;
+	uint8_t deviceAddress;
+
+	if (count >= VL53L0_MAX_I2C_XFER_SIZE)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_write_multi(Dev, index, pdata, count);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+/* the ranging_sensor_comms.dll will take care of the page selection */
+VL53L0_Error VL53L0_ReadMulti(VL53L0_DEV Dev, uint8_t index,
+				uint8_t *pdata, uint32_t count)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	if (count >= VL53L0_MAX_I2C_XFER_SIZE)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_read_multi(Dev, index, pdata, count);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+
+VL53L0_Error VL53L0_WrByte(VL53L0_DEV Dev, uint8_t index, uint8_t data)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_write_byte(Dev, index, data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+VL53L0_Error VL53L0_WrWord(VL53L0_DEV Dev, uint8_t index, uint16_t data)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_write_word(Dev, index, data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+VL53L0_Error VL53L0_WrDWord(VL53L0_DEV Dev, uint8_t index, uint32_t data)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_write_dword(Dev, index, data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+VL53L0_Error VL53L0_UpdateByte(VL53L0_DEV Dev, uint8_t index,
+				uint8_t AndData, uint8_t OrData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+	uint8_t data;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_read_byte(Dev, index, &data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	if (Status == VL53L0_ERROR_NONE) {
+		data = (data & AndData) | OrData;
+		status_int = VL53L0_write_byte(Dev, index, data);
+
+		if (status_int != 0)
+			Status = VL53L0_ERROR_CONTROL_INTERFACE;
+	}
+
+	return Status;
+}
+
+VL53L0_Error VL53L0_RdByte(VL53L0_DEV Dev, uint8_t index, uint8_t *data)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_read_byte(Dev, index, data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+VL53L0_Error VL53L0_RdWord(VL53L0_DEV Dev, uint8_t index, uint16_t *data)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_read_word(Dev, index, data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+VL53L0_Error  VL53L0_RdDWord(VL53L0_DEV Dev, uint8_t index, uint32_t *data)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int32_t status_int;
+	uint8_t deviceAddress;
+
+	deviceAddress = Dev->I2cDevAddr;
+
+	status_int = VL53L0_read_dword(Dev, index, data);
+
+	if (status_int != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	return Status;
+}
+
+#define VL53L0_POLLINGDELAY_LOOPNB  250
+VL53L0_Error VL53L0_PollingDelay(VL53L0_DEV Dev)
+{
+	VL53L0_Error status = VL53L0_ERROR_NONE;
+	volatile uint32_t i;
+	LOG_FUNCTION_START("");
+	/*
+	for(i=0;i<VL53L0_POLLINGDELAY_LOOPNB;i++){
+		//Do nothing
+		asm("nop");
+	}
+	*/
+	msleep(5);
+	LOG_FUNCTION_END(status);
+	return status;
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_port_i2c.c b/drivers/input/misc/vl53L0/src/vl53l0_port_i2c.c
new file mode 100644
index 00000000000..499048128f3
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l0_port_i2c.c
@@ -0,0 +1,147 @@
+/*
+ * vl53l0_port_i2c.c
+ *
+ *  Created on: July, 2015
+ *      Author:  Teresa Tao
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include "stmvl53l0-i2c.h"
+#include "stmvl53l0-cci.h"
+#include "vl53l0_platform.h"
+#include "vl53l0_i2c_platform.h"
+
+#define I2C_M_WR			0x00
+#if 0
+#ifdef CAMERA_CCI
+static struct msm_camera_i2c_client *pclient;
+#else
+static struct i2c_client *pclient;
+#endif
+
+void i2c_setclient(void *client)
+{
+#ifdef CAMERA_CCI
+	pclient = (struct msm_camera_i2c_client *)client;
+#else
+	pclient = (struct i2c_client *)client;
+#endif
+
+}
+
+void *i2c_getclient(void)
+{
+	return (void *)pclient;
+}
+#endif
+/** int  VL6180x_I2CWrite(VL53L0_Dev_t dev, void *buff, uint8_t len);
+ * @brief       Write data buffer to VL6180x device via i2c
+ * @param dev   The device to write to
+ * @param buff  The data buffer
+ * @param len   The length of the transaction in byte
+ * @return      0 on success
+ */
+int VL53L0_I2CWrite(VL53L0_DEV dev, uint8_t *buff, uint8_t len)
+{
+
+
+	int err = 0;
+#ifdef CAMERA_CCI
+	uint16_t index;
+
+	index = buff[0];
+	/*pr_err("%s: index: %d len: %d\n", __func__, index, len); */
+
+	if (len == 2) {
+		uint8_t data;
+		data = buff[1];
+		/* for byte access */
+		err = pclient->i2c_func_tbl->i2c_write(pclient, index,
+				data, MSM_CAMERA_I2C_BYTE_DATA);
+		if (err < 0) {
+			pr_err("%s:%d failed status=%d\n",
+				__func__, __LINE__, err);
+			return err;
+		}
+	} else if (len == 3) {
+		uint16_t data;
+		data = ((uint16_t)buff[1] << 8) | (uint16_t)buff[2];
+		err = pclient->i2c_func_tbl->i2c_write(pclient, index,
+				data, MSM_CAMERA_I2C_WORD_DATA);
+		if (err < 0) {
+			pr_err("%s:%d failed status=%d\n",
+				__func__, __LINE__, err);
+			return err;
+		}
+	} else if (len == 5) {
+		err = pclient->i2c_func_tbl->i2c_write_seq(pclient,
+				index, &buff[1], 4);
+		if (err < 0) {
+			pr_err("%s:%d failed status=%d\n",
+				__func__, __LINE__, err);
+			return err;
+		}
+
+	}
+	#else
+	struct i2c_msg msg[1];
+	struct i2c_client *client = dev->client_object.client;
+	msg[0].addr = client->addr;
+	msg[0].flags = I2C_M_WR;
+	msg[0].buf = buff;
+	msg[0].len = len;
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	/* return the actual messages transfer */
+	if (err != 1) {
+		pr_err("%s: i2c_transfer err:%d, addr:0x%x, reg:0x%x\n",
+			__func__, err, client->addr, (buff[0] << 8 | buff[1]));
+		return -1;
+	}
+	#endif
+
+	return 0;
+}
+
+
+/** int VL6180x_I2CRead(VL53L0_Dev_t dev, void *buff, uint8_t len);
+ * @brief       Read data buffer from VL6180x device via i2c
+ * @param dev   The device to read from
+ * @param buff  The data buffer to fill
+ * @param len   The length of the transaction in byte
+ * @return      transaction status
+ */
+int VL53L0_I2CRead(VL53L0_DEV dev, uint8_t *buff, uint8_t len)
+{
+
+	int err = 0;
+#ifdef CAMERA_CCI
+	uint16_t index;
+	index = buff[0];
+	/* pr_err("%s: index: %d\n", __func__, index); */
+	err = pclient->i2c_func_tbl->i2c_read_seq(pclient, index, buff, len);
+	if (err < 0) {
+		pr_err("%s:%d failed status=%d\n", __func__, __LINE__, err);
+		return err;
+	}
+#else
+	struct i2c_msg msg[1];
+	struct i2c_client *client = dev->client_object.client;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = I2C_M_RD|client->flags;
+	msg[0].buf = buff;
+	msg[0].len = len;
+
+	err = i2c_transfer(client->adapter, &msg[0], 1);
+	/* return the actual mesage transfer */
+	if (err != 1) {
+		pr_err("%s: Read i2c_transfer err:%d, addr:0x%x\n",
+			__func__, err, client->addr);
+		return -1;
+	}
+#endif
+
+	return 0;
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_tuning.c b/drivers/input/misc/vl53L0/src/vl53l0_tuning.c
new file mode 100644
index 00000000000..d3a16b7145b
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l0_tuning.c
@@ -0,0 +1,138 @@
+/*******************************************************************************
+ Copyright © 2015, STMicroelectronics International N.V.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in the
+ documentation and/or other materials provided with the distribution.
+ * Neither the name of STMicroelectronics nor the
+ names of its contributors may be used to endorse or promote products
+ derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+ NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+ IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+#include "vl53l0_tuning.h"
+
+#define LOG_FUNCTION_START(fmt, ...) \
+	_LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
+#define LOG_FUNCTION_END(status, ...) \
+	_LOG_FUNCTION_END(TRACE_MODULE_API, status, ##__VA_ARGS__)
+#define LOG_FUNCTION_END_FMT(status, fmt, ...) \
+	_LOG_FUNCTION_END_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)
+
+#ifdef VL53L0_LOG_ENABLE
+#define trace_print(level, ...) \
+	trace_print_module_function(TRACE_MODULE_API,\
+	level, TRACE_FUNCTION_NONE, ##__VA_ARGS__)
+#endif
+
+/*
+//////////////////////////////////////////////////////
+////       DEFAULT TUNING SETTINGS                ////
+//////////////////////////////////////////////////////
+*/
+VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	LOG_FUNCTION_START("");
+
+	/* update 17_06_15_v10 */
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x3C);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x54, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x33, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x30, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x50, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x60, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x06);
+
+	Status |= VL53L0_WrByte(Dev, 0x46, 0x1a);
+	Status |= VL53L0_WrWord(Dev, 0x51, 0x01a3);
+	Status |= VL53L0_WrWord(Dev, 0x61, 0x01c4);
+	Status |= VL53L0_WrWord(Dev, 0x71, 0x018c);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x31, 0x0f);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x66, 0x38);
+
+	Status |= VL53L0_WrByte(Dev, 0x47, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x48, 0xff);
+	Status |= VL53L0_WrByte(Dev, 0x57, 0x4c);
+	Status |= VL53L0_WrByte(Dev, 0x67, 0x3c);
+	Status |= VL53L0_WrByte(Dev, 0x77, 0x5c);
+
+	Status |= VL53L0_WrWord(Dev, 0x44, 0x0000);
+
+	Status |= VL53L0_WrByte(Dev, 0x27, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x55, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x30, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0x10, 0x0f);
+	Status |= VL53L0_WrByte(Dev, 0x11, 0xff);
+	Status |= VL53L0_WrByte(Dev, 0x41, 0xff);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x12);
+
+	Status |= VL53L0_WrByte(Dev, 0x20, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x21, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0x28, 0x06);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x48, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0x7a, 0x0a);
+	Status |= VL53L0_WrByte(Dev, 0x7b, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x78, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x44, 0xff);
+	Status |= VL53L0_WrByte(Dev, 0x45, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x46, 0x10);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0x04, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x05, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x06, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x07, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x0d, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x01, 0xF8);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x8e, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+
+	if (Status != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
diff --git a/drivers/input/misc/vl53L0/stmvl53l0-cci.h b/drivers/input/misc/vl53L0/stmvl53l0-cci.h
new file mode 100644
index 00000000000..7dc1e26dece
--- /dev/null
+++ b/drivers/input/misc/vl53L0/stmvl53l0-cci.h
@@ -0,0 +1,61 @@
+/*
+ *  stmvl53l0-cci.h - Linux kernel modules for STM VL53L0 FlightSense TOF sensor
+ *
+ *  Copyright (C) 2015 STMicroelectronics Imaging Division
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/*
+ * Defines
+ */
+#ifndef STMVL53L0_CCI_H
+#define STMVL53L0_CCI_H
+#include <linux/types.h>
+
+#ifdef CAMERA_CCI
+#include <soc/qcom/camera2.h>
+#include "msm_camera_i2c.h"
+#include "msm_camera_dt_util.h"
+#include "msm_camera_io_util.h"
+#include "msm_cci.h"
+
+#define	MSM_TOF_MAX_VREGS (10)
+
+struct msm_tof_vreg {
+	struct camera_vreg_t *cam_vreg;
+	void *data[MSM_TOF_MAX_VREGS];
+	int num_vreg;
+};
+
+struct cci_data {
+	struct msm_camera_i2c_client g_client;
+	struct msm_camera_i2c_client *client;
+	struct platform_device *pdev;
+	enum msm_camera_device_type_t device_type;
+	enum cci_i2c_master_t cci_master;
+	struct msm_tof_vreg vreg_cfg;
+	struct msm_sd_subdev msm_sd;
+	struct v4l2_subdev sdev;
+	struct v4l2_subdev_ops *subdev_ops;
+	char subdev_initialized;
+	uint32_t subdev_id;
+	uint8_t power_up;
+};
+int stmvl53l0_init_cci(void);
+void stmvl53l0_exit_cci(void *);
+int stmvl53l0_power_down_cci(void *);
+int stmvl53l0_power_up_cci(void *, unsigned int *);
+#endif /* CAMERA_CCI */
+#endif /* STMVL53L0_CCI_H */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0-i2c.h b/drivers/input/misc/vl53L0/stmvl53l0-i2c.h
new file mode 100644
index 00000000000..64fefb1f29c
--- /dev/null
+++ b/drivers/input/misc/vl53L0/stmvl53l0-i2c.h
@@ -0,0 +1,39 @@
+/*
+ *  stmvl53l0-i2c.h - Linux kernel modules for STM VL53L0 FlightSense TOF sensor
+ *
+ *  Copyright (C) 2015 STMicroelectronics Imaging Division
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/*
+ * Defines
+ */
+#ifndef STMVL53L0_I2C_H
+#define STMVL53L0_I2C_H
+#include <linux/types.h>
+
+#ifndef CAMERA_CCI
+struct i2c_data {
+	struct i2c_client *client;
+	struct regulator *vana;
+	uint8_t power_up;
+};
+int stmvl53l0_init_i2c(void);
+void stmvl53l0_exit_i2c(void *);
+int stmvl53l0_power_up_i2c(void *, unsigned int *);
+int stmvl53l0_power_down_i2c(void *);
+
+#endif /* NOT CAMERA_CCI */
+#endif /* STMVL53L0_I2C_H */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0.h b/drivers/input/misc/vl53L0/stmvl53l0.h
new file mode 100644
index 00000000000..54db94fbd08
--- /dev/null
+++ b/drivers/input/misc/vl53L0/stmvl53l0.h
@@ -0,0 +1,149 @@
+/*
+ *  stmvl53l0.h - Linux kernel modules for STM VL53L0 FlightSense TOF sensor
+ *
+ *  Copyright (C) 2015 STMicroelectronics Imaging Division
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/*
+ * Defines
+ */
+#ifndef STMVL53L0_H
+#define STMVL53L0_H
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/miscdevice.h>
+
+#define STMVL53L0_DRV_NAME	"stmvl53l0"
+#define STMVL53L0_SLAVE_ADDR	(0x52>>1)
+
+#define DRIVER_VERSION		"0.0.3"
+#define I2C_M_WR			0x00
+/* #define INT_POLLING_DELAY	20 */
+
+/* if don't want to have output from vl6180_dbgmsg, comment out #DEBUG macro */
+#define DEBUG
+/* #define vl6180_dbgmsg(str, args...) pr_debug("%s: " str, __func__, ##args) */
+#define vl53l0_dbgmsg(str, args...)	\
+	printk(KERN_INFO "%s: " str, __func__, ##args)
+/* #define vl6180_errmsg(str, args...) pr_err("%s: " str, __func__, ##args) */
+#define vl53l0_errmsg(str, args...) \
+	printk(KERN_ERR "%s: " str, __func__, ##args)
+
+#define VL53L0_VDD_MIN      2600000
+#define VL53L0_VDD_MAX      3000000
+
+typedef enum {
+	NORMAL_MODE = 0,
+	OFFSETCALIB_MODE = 1,
+	XTALKCALIB_MODE = 2,
+} init_mode_e;
+
+typedef enum {
+	OFFSET_PAR = 0,
+	XTALKRATE_PAR = 1,
+	XTALKENABLE_PAR = 2,
+} parameter_name_e;
+
+/*
+ *  IOCTL register data structs
+ */
+struct stmvl53l0_register {
+	uint32_t is_read; /*1: read 0: write*/
+	uint32_t reg_index;
+	uint32_t reg_bytes;
+	uint32_t reg_data;
+	int32_t status;
+};
+
+/*
+ *  IOCTL parameter structs
+ */
+struct stmvl53l0_parameter {
+	uint32_t is_read; /*1: Get 0: Set*/
+	parameter_name_e name;
+	int32_t value;
+	int32_t status;
+};
+
+/*
+ *  driver data structs
+ */
+struct stmvl53l0_data {
+
+	VL53L0_DevData_t Data;	/* !<embed ST VL53L0 Dev data as
+								"dev_data" */
+	uint8_t   I2cDevAddr;	/*!< i2c device address user specific field
+							*/
+	uint8_t   comms_type;	/*!< Type of comms : VL53L0_COMMS_I2C
+							or VL53L0_COMMS_SPI */
+	uint16_t  comms_speed_khz;	/*!< Comms speed [kHz] :
+						typically 400kHz for I2C */
+#ifdef CAMERA_CCI
+	struct cci_data client_object;
+#else
+	struct i2c_data client_object;
+#endif
+	struct mutex update_lock;
+	struct delayed_work	dwork;		/* for PS  work handler */
+	struct input_dev *input_dev_ps;
+	struct kobject *range_kobj;
+
+	const char *dev_name;
+	/* function pointer */
+
+	/* misc device */
+	struct miscdevice miscdev;
+
+	int irq;
+	unsigned int reset;
+
+	/* control flag from HAL */
+	unsigned int enable_ps_sensor;
+
+	/* PS parameters */
+	unsigned int ps_is_singleshot;
+	unsigned int ps_is_started;
+	unsigned int ps_data;			/* to store PS data */
+
+	/* Range Data */
+	VL53L0_RangingMeasurementData_t rangeData;
+
+
+	/* delay time in miniseconds*/
+	uint8_t delay_ms;
+
+	struct mutex work_mutex;
+
+	/* Debug */
+	unsigned int enableDebug;
+	uint8_t interrupt_received;
+};
+
+/*
+ *  funtion pointer structs
+ */
+struct stmvl53l0_module_fn_t {
+	int (*init)(void);
+	void (*deinit)(void *);
+	int (*power_up)(void *, unsigned int *);
+	int (*power_down)(void *);
+};
+
+int stmvl53l0_setup(struct stmvl53l0_data *data);
+
+#endif /* STMVL53L0_H */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c b/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c
new file mode 100644
index 00000000000..de97d0426d7
--- /dev/null
+++ b/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c
@@ -0,0 +1,402 @@
+/*
+ *  stmvl53l0_module-cci.c - Linux kernel modules for STM VL53L0 FlightSense TOF
+ *							sensor
+ *
+ *  Copyright (C) 2015 STMicroelectronics Imaging Division.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/miscdevice.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+/*
+ * power specific includes
+ */
+#include <linux/pwm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+/*
+ * API includes
+ */
+#include "vl53l0_api.h"
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+#include "stmvl53l0-cci.h"
+#include "stmvl53l0-i2c.h"
+#include "stmvl53l0.h"
+
+#ifdef CAMERA_CCI
+/*
+ * Global data
+ */
+static struct v4l2_file_operations msm_tof_v4l2_subdev_fops;
+static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
+	.i2c_read = msm_camera_cci_i2c_read,
+	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
+	.i2c_write = msm_camera_cci_i2c_write,
+	.i2c_write_seq = msm_camera_cci_i2c_write_seq,
+	.i2c_write_table = msm_camera_cci_i2c_write_table,
+	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
+	.i2c_write_table_w_microdelay =
+		msm_camera_cci_i2c_write_table_w_microdelay,
+	.i2c_util = msm_sensor_cci_i2c_util,
+	.i2c_poll =  msm_camera_cci_i2c_poll,
+};
+static int stmvl53l0_get_dt_data(struct device *dev, struct cci_data *data);
+
+/*
+ * QCOM specific functions
+ */
+static int stmvl53l0_get_dt_data(struct device *dev, struct cci_data *data)
+{
+	int rc = 0;
+	vl53l0_dbgmsg("Enter\n");
+
+	if (dev->of_node) {
+		struct device_node *of_node = dev->of_node;
+		struct msm_tof_vreg *vreg_cfg;
+
+		if (!of_node) {
+			vl53l0_errmsg("failed %d\n", __LINE__);
+			return -EINVAL;
+		}
+
+		rc = of_property_read_u32(of_node,
+				"cell-index", &data->pdev->id);
+		if (rc < 0) {
+			vl53l0_errmsg("failed %d\n", __LINE__);
+			return rc;
+		}
+		vl53l0_dbgmsg("cell-index: %d\n", data->pdev->id);
+		rc = of_property_read_u32(of_node, "qcom,cci-master",
+				&data->cci_master);
+		if (rc < 0) {
+			vl53l0_errmsg("failed %d\n", __LINE__);
+			/* Set default master 0 */
+			data->cci_master = MASTER_0;
+			rc = 0;
+		}
+		vl53l0_dbgmsg("cci_master: %d\n", data->cci_master);
+		if (of_find_property(of_node, "qcom,cam-vreg-name", NULL)) {
+			vreg_cfg = &data->vreg_cfg;
+			rc = msm_camera_get_dt_vreg_data(of_node,
+				&vreg_cfg->cam_vreg, &vreg_cfg->num_vreg);
+			if (rc < 0) {
+				vl53l0_errmsg("failed %d\n", __LINE__);
+				return rc;
+			}
+		}
+		vl53l0_dbgmsg("vreg-name: %s min_volt: %d max_volt: %d",
+			vreg_cfg->cam_vreg->reg_name,
+			vreg_cfg->cam_vreg->min_voltage,
+			vreg_cfg->cam_vreg->max_voltage);
+	}
+	vl53l0_dbgmsg("End rc =%d\n", rc);
+
+	return rc;
+}
+
+static int32_t stmvl53l0_vreg_control(struct cci_data *data, int config)
+{
+	int rc = 0, i, cnt;
+	struct msm_tof_vreg *vreg_cfg;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	vreg_cfg = &data->vreg_cfg;
+	cnt = vreg_cfg->num_vreg;
+	vl53l0_dbgmsg("num_vreg: %d\n", cnt);
+	if (!cnt) {
+		vl53l0_errmsg("failed %d\n", __LINE__);
+		return 0;
+	}
+
+	if (cnt >= MSM_TOF_MAX_VREGS) {
+		vl53l0_errmsg("failed %d cnt %d\n", __LINE__, cnt);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		rc = msm_camera_config_single_vreg(&(data->pdev->dev),
+				&vreg_cfg->cam_vreg[i],
+				(struct regulator **)&vreg_cfg->data[i],
+				config);
+	}
+
+	vl53l0_dbgmsg("EXIT rc =%d\n", rc);
+	return rc;
+}
+
+
+static int msm_tof_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	int rc = 0;
+/*
+	struct msm_tof_ctrl_t *tof_ctrl =  v4l2_get_subdevdata(sd);
+	if (!tof_ctrl) {
+		pr_err("failed\n");
+		return -EINVAL;
+	}
+	if (tof_ctrl->tof_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		rc = tof_ctrl->i2c_client.i2c_func_tbl->i2c_util(
+			&tof_ctrl->i2c_client, MSM_CCI_RELEASE);
+		if (rc < 0)
+			pr_err("cci_init failed\n");
+	}
+    tof_ctrl->i2c_state = TOF_I2C_RELEASE;
+*/
+	return rc;
+}
+
+
+static const struct v4l2_subdev_internal_ops msm_tof_internal_ops = {
+	.close = msm_tof_close,
+};
+
+static long msm_tof_subdev_ioctl(struct v4l2_subdev *sd,
+			unsigned int cmd, void *arg)
+{
+	vl53l0_dbgmsg("Subdev_ioctl not handled\n");
+	return 0;
+}
+
+static int32_t msm_tof_power(struct v4l2_subdev *sd, int on)
+{
+	vl53l0_dbgmsg("TOF power called\n");
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops msm_tof_subdev_core_ops = {
+	.ioctl = msm_tof_subdev_ioctl,
+	.s_power = msm_tof_power,
+};
+
+static struct v4l2_subdev_ops msm_tof_subdev_ops = {
+	.core = &msm_tof_subdev_core_ops,
+};
+
+static int stmvl53l0_cci_init(struct cci_data *data)
+{
+	int rc = 0;
+	struct msm_camera_cci_client *cci_client = data->client->cci_client;
+
+	if (FALSE == data->subdev_initialized) {
+		data->client->i2c_func_tbl = &msm_sensor_cci_func_tbl;
+		data->client->cci_client =
+			kzalloc(sizeof(struct msm_camera_cci_client),
+			GFP_KERNEL);
+		if (!data->client->cci_client) {
+			vl53l0_errmsg("%d, failed no memory\n", __LINE__);
+			return -ENOMEM;
+		}
+		cci_client = data->client->cci_client;
+		cci_client->cci_subdev = msm_cci_get_subdev();
+		cci_client->cci_i2c_master = data->cci_master;
+		v4l2_subdev_init(&data->msm_sd.sd, data->subdev_ops);
+		v4l2_set_subdevdata(&data->msm_sd.sd, data);
+		data->msm_sd.sd.internal_ops = &msm_tof_internal_ops;
+		data->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+		snprintf(data->msm_sd.sd.name, ARRAY_SIZE(data->msm_sd.sd.name),
+			"msm_tof");
+		media_entity_init(&data->msm_sd.sd.entity, 0, NULL, 0);
+		data->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
+		data->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_TOF;
+		data->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
+		msm_sd_register(&data->msm_sd);
+		msm_tof_v4l2_subdev_fops = v4l2_subdev_fops;
+		data->msm_sd.sd.devnode->fops = &msm_tof_v4l2_subdev_fops;
+		data->subdev_initialized = TRUE;
+	}
+
+	cci_client->sid = 0x29;
+	cci_client->retries = 3;
+	cci_client->id_map = 0;
+	cci_client->cci_i2c_master = data->cci_master;
+	rc = data->client->i2c_func_tbl->i2c_util(data->client, MSM_CCI_INIT);
+	if (rc < 0) {
+		vl53l0_errmsg("%d: CCI Init failed\n", __LINE__);
+		return rc;
+	}
+	vl53l0_dbgmsg("CCI Init Succeeded\n");
+
+	data->client->addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
+
+	return 0;
+}
+
+static int32_t stmvl53l0_platform_probe(struct platform_device *pdev)
+{
+	struct stmvl53l0_data *vl53l0_data = NULL;
+	struct cci_data *data = NULL;
+	int32_t rc = 0;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	if (!pdev->dev.of_node) {
+		vl53l0_errmsg("of_node NULL\n");
+		return -EINVAL;
+	}
+
+	vl53l0_data = stmvl53l0_getobject();
+	if (NULL == vl53l0_data) {
+		vl53l0_errmsg("Object not found!\n");
+		return -EINVAL;
+	}
+
+	data = &(vl53l0_data->client_object);
+	if (!data) {
+		vl53l0_errmsg("data NULL\n");
+		return -EINVAL;
+	}
+
+	data->client = (struct msm_camera_i2c_client *)&data->g_client;
+
+	/* setup platform i2c client */
+	i2c_setclient((void *)data->client);
+
+	/* Set platform device handle */
+	data->subdev_ops = &msm_tof_subdev_ops;
+	data->pdev = pdev;
+	rc = stmvl53l0_get_dt_data(&pdev->dev, data);
+	if (rc < 0) {
+		vl53l0_errmsg("%d, failed rc %d\n", __LINE__, rc);
+		return rc;
+	}
+	data->subdev_id = pdev->id;
+
+	/* Set device type as platform device */
+	data->device_type = MSM_CAMERA_PLATFORM_DEVICE;
+	data->subdev_initialized = FALSE;
+
+	vl53l0_dbgmsg("End\n");
+
+	return rc;
+
+}
+
+
+static const struct of_device_id st_stmvl53l0_dt_match[] = {
+	{ .compatible = "st,stmvl53l0", },
+	{ },
+};
+
+static struct platform_driver stmvl53l0_platform_driver = {
+	.probe = stmvl53l0_platform_probe,
+	.driver = {
+		.name = STMVL53L0_DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = st_stmvl53l0_dt_match,
+	},
+};
+
+int stmvl53l0_power_up_cci(void *cci_object, unsigned int *preset_flag)
+{
+	int ret = 0;
+	struct cci_data *data = (struct cci_data *)cci_object;
+
+	vl53l0_dbgmsg("Enter");
+
+	/* need to init cci first */
+	ret = stmvl53l0_cci_init(data);
+	if (ret) {
+		vl53l0_errmsg("stmvl53l0_cci_init failed %d\n", __LINE__);
+		return ret;
+	}
+	/* actual power up */
+	if (data && data->device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+		ret = stmvl53l0_vreg_control(data, 1);
+		if (ret < 0) {
+			vl53l0_errmsg("stmvl53l0_vreg_control failed %d\n",
+				__LINE__);
+			return ret;
+		}
+	}
+	data->power_up = 1;
+	*preset_flag = 1;
+	vl53l0_dbgmsg("End\n");
+
+	return ret;
+}
+
+int stmvl53l0_power_down_cci(void *cci_object)
+{
+	int ret = 0;
+	struct cci_data *data = (struct cci_data *)cci_object;
+
+	vl53l0_dbgmsg("Enter\n");
+	if (data->power_up) {
+		/* need to release cci first */
+		ret = data->client->i2c_func_tbl->i2c_util(data->client,
+				MSM_CCI_RELEASE);
+		if (ret < 0)
+			vl53l0_errmsg("CCI Release failed rc %d\n", ret);
+
+		/* actual power down */
+		if (data->device_type == MSM_CAMERA_PLATFORM_DEVICE) {
+			ret = stmvl53l0_vreg_control(data, 0);
+			if (ret < 0) {
+				vl53l0_errmsg(
+					"stmvl53l0_vreg_control failed %d\n",
+					__LINE__);
+				return ret;
+			}
+		}
+	}
+	data->power_up = 0;
+	vl53l0_dbgmsg("End\n");
+	return ret;
+}
+
+int stmvl53l0_init_cci(void)
+{
+	int ret = 0;
+	vl53l0_dbgmsg("Enter\n");
+
+	/* register as a platform device */
+	ret = platform_driver_register(&stmvl53l0_platform_driver);
+	if (ret)
+		vl53l0_errmsg("%d, error ret:%d\n", __LINE__, ret);
+
+	vl53l0_dbgmsg("End\n");
+
+	return ret;
+}
+
+void stmvl53l0_exit_cci(void *cci_object)
+{
+	struct cci_data *data = (struct cci_data *)cci_object;
+	vl53l0_dbgmsg("Enter\n");
+
+	if (data && data->client->cci_client)
+		kfree(data->client->cci_client);
+
+	vl53l0_dbgmsg("End\n");
+}
+#endif /* end of CAMERA_CCI */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c b/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c
new file mode 100644
index 00000000000..f0c5ed74827
--- /dev/null
+++ b/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c
@@ -0,0 +1,256 @@
+/*
+ *  stmvl53l0_module-i2c.c - Linux kernel modules for STM VL53L0 FlightSense TOF
+ *							sensor
+ *
+ *  Copyright (C) 2015 STMicroelectronics Imaging Division.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/miscdevice.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+/*
+ * power specific includes
+ */
+#include <linux/pwm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+/*
+ * API includes
+ */
+#include "vl53l0_api.h"
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+#include "stmvl53l0-i2c.h"
+#include "stmvl53l0-cci.h"
+#include "stmvl53l0.h"
+#ifndef CAMERA_CCI
+
+/*
+ * Global data
+ */
+static int stmvl53l0_parse_vdd(struct device *dev, struct i2c_data *data);
+
+/*
+ * QCOM specific functions
+ */
+static int stmvl53l0_parse_vdd(struct device *dev, struct i2c_data *data)
+{
+	int ret = 0;
+	vl53l0_dbgmsg("Enter\n");
+
+	if (dev->of_node) {
+		data->vana = regulator_get(dev, "vdd");
+		if (IS_ERR(data->vana)) {
+			vl53l0_errmsg("vdd supply is not provided\n");
+			ret = -1;
+		}
+	}
+	vl53l0_dbgmsg("End\n");
+
+	return ret;
+}
+
+static int stmvl53l0_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int rc = 0;
+	struct stmvl53l0_data *vl53l0_data = NULL;
+	struct i2c_data *i2c_object = NULL;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
+		rc = -EIO;
+		return rc;
+	}
+
+	vl53l0_data = kzalloc(sizeof(struct stmvl53l0_data), GFP_KERNEL);
+	if (!vl53l0_data) {
+		rc = -ENOMEM;
+		return rc;
+	}
+	if (vl53l0_data)
+		i2c_object = &(vl53l0_data->client_object);
+	i2c_object->client = client;
+
+	/* setup regulator */
+	stmvl53l0_parse_vdd(&i2c_object->client->dev, i2c_object);
+
+	/* setup device name */
+	vl53l0_data->dev_name = dev_name(&client->dev);
+
+	/* setup device data */
+	dev_set_drvdata(&client->dev, vl53l0_data);
+
+	/* setup client data */
+	i2c_set_clientdata(client, vl53l0_data);
+
+
+	/* setup other stuff */
+	rc = stmvl53l0_setup(vl53l0_data);
+
+	vl53l0_dbgmsg("End\n");
+	return rc;
+}
+
+static int stmvl53l0_remove(struct i2c_client *client)
+{
+	struct stmvl53l0_data *data = i2c_get_clientdata(client);
+
+	vl53l0_dbgmsg("Enter\n");
+
+	/* Power down the device */
+	stmvl53l0_power_down_i2c((void *)&data->client_object);
+
+	vl53l0_dbgmsg("End\n");
+	return 0;
+}
+
+static const struct i2c_device_id stmvl53l0_id[] = {
+	{ STMVL53L0_DRV_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, stmvl53l0_id);
+
+static const struct of_device_id st_stmvl53l0_dt_match[] = {
+	{ .compatible = "st,stmvl53l0", },
+	{ },
+};
+
+static struct i2c_driver stmvl6180_driver = {
+	.driver = {
+		.name	= STMVL53L0_DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = st_stmvl53l0_dt_match,
+	},
+	.probe	= stmvl53l0_probe,
+	.remove	= stmvl53l0_remove,
+	.id_table = stmvl53l0_id,
+
+};
+
+int stmvl53l0_power_up_i2c(void *i2c_object, unsigned int *preset_flag)
+{
+	int ret = 0;
+#ifndef STM_TEST
+	struct i2c_data *data = (struct i2c_data *)i2c_object;
+#endif
+	vl53l0_dbgmsg("Enter\n");
+
+	/* actual power on */
+#ifndef STM_TEST
+	ret = regulator_set_voltage(data->vana,	VL53L0_VDD_MIN, VL53L0_VDD_MAX);
+	if (ret < 0) {
+		vl53l0_errmsg("set_vol(%p) fail %d\n", data->vana , ret);
+		return ret;
+	}
+	ret = regulator_enable(data->vana);
+	msleep(3);
+	if (ret < 0) {
+		vl53l0_errmsg("reg enable(%p) failed.rc=%d\n", data->vana, ret);
+		return ret;
+	}
+	data->power_up = 1;
+	*preset_flag = 1;
+#endif
+
+	vl53l0_dbgmsg("End\n");
+	return ret;
+}
+
+int stmvl53l0_power_down_i2c(void *i2c_object)
+{
+	int ret = 0;
+#ifndef STM_TEST
+	struct i2c_data *data = (struct i2c_data *)i2c_object;
+#endif
+
+	vl53l0_dbgmsg("Enter\n");
+#ifndef STM_TEST
+	msleep(3);
+	ret = regulator_disable(data->vana);
+	if (ret < 0)
+		vl53l0_errmsg("reg disable(%p) failed.rc=%d\n",
+			data->vana, ret);
+
+	data->power_up = 0;
+#endif
+
+	vl53l0_dbgmsg("End\n");
+	return ret;
+}
+
+int stmvl53l0_init_i2c(void)
+{
+	int ret = 0;
+
+#ifdef STM_TEST
+	struct i2c_client *client = NULL;
+	struct i2c_adapter *adapter;
+	struct i2c_board_info info = {
+		.type = "stmvl53l0",
+		.addr = STMVL53L0_SLAVE_ADDR,
+	};
+#endif
+
+	vl53l0_dbgmsg("Enter\n");
+
+	/* register as a i2c client device */
+	ret = i2c_add_driver(&stmvl6180_driver);
+	if (ret)
+		vl53l0_errmsg("%d erro ret:%d\n", __LINE__, ret);
+
+#ifdef STM_TEST
+	if (!ret) {
+		adapter = i2c_get_adapter(4);
+		if (!adapter)
+			ret = -EINVAL;
+		else
+			client = i2c_new_device(adapter, &info);
+		if (!client)
+			ret = -EINVAL;
+	}
+#endif
+
+	vl53l0_dbgmsg("End with rc:%d\n", ret);
+
+	return ret;
+}
+
+void stmvl53l0_exit_i2c(void *i2c_object)
+{
+	vl53l0_dbgmsg("Enter\n");
+	i2c_del_driver(&stmvl6180_driver);
+
+	vl53l0_dbgmsg("End\n");
+}
+
+#endif /* end of NOT CAMERA_CCI */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0_module.c b/drivers/input/misc/vl53L0/stmvl53l0_module.c
new file mode 100644
index 00000000000..f0343d15845
--- /dev/null
+++ b/drivers/input/misc/vl53L0/stmvl53l0_module.c
@@ -0,0 +1,1224 @@
+/*
+ *  stmvl53l0_module.c - Linux kernel modules for STM VL53L0 FlightSense TOF
+ *						 sensor
+ *
+ *  Copyright (C) 2015 STMicroelectronics Imaging Division.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/miscdevice.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <linux/kobject.h>
+/*
+ * API includes
+ */
+#include "vl53l0_api.h"
+/*
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+#include "stmvl53l0-i2c.h"
+#include "stmvl53l0-cci.h"
+#include "stmvl53l0.h"
+*/
+
+#define USE_INT
+#define IRQ_NUM	   59
+/*#define DEBUG_TIME_LOG*/
+#ifdef DEBUG_TIME_LOG
+struct timeval start_tv, stop_tv;
+#endif
+
+/*
+ * Global data
+ */
+
+#ifdef CAMERA_CCI
+static struct stmvl53l0_module_fn_t stmvl53l0_module_func_tbl = {
+	.init = stmvl53l0_init_cci,
+	.deinit = stmvl53l0_exit_cci,
+	.power_up = stmvl53l0_power_up_cci,
+	.power_down = stmvl53l0_power_down_cci,
+};
+#else
+static struct stmvl53l0_module_fn_t stmvl53l0_module_func_tbl = {
+	.init = stmvl53l0_init_i2c,
+	.deinit = stmvl53l0_exit_i2c,
+	.power_up = stmvl53l0_power_up_i2c,
+	.power_down = stmvl53l0_power_down_i2c,
+};
+#endif
+struct stmvl53l0_module_fn_t *pmodule_func_tbl;
+
+/*
+ * IOCTL definitions
+ */
+#define VL53L0_IOCTL_INIT			_IO('p', 0x01)
+#define VL53L0_IOCTL_XTALKCALB		_IO('p', 0x02)
+#define VL53L0_IOCTL_OFFCALB		_IO('p', 0x03)
+#define VL53L0_IOCTL_STOP			_IO('p', 0x05)
+#define VL53L0_IOCTL_SETXTALK		_IOW('p', 0x06, unsigned int)
+#define VL53L0_IOCTL_SETOFFSET		_IOW('p', 0x07, int8_t)
+#define VL53L0_IOCTL_GETDATAS \
+			_IOR('p', 0x0b, VL53L0_RangingMeasurementData_t)
+#define VL53L0_IOCTL_REGISTER \
+			_IOWR('p', 0x0c, struct stmvl53l0_register)
+#define VL53L0_IOCTL_PARAMETER \
+			_IOWR('p', 0x0d, struct stmvl53l0_parameter)
+
+#define CALIBRATION_FILE 1
+#ifdef CALIBRATION_FILE
+int8_t offset_calib;
+int16_t xtalk_calib;
+#endif
+
+static long stmvl53l0_ioctl(struct file *file,
+							unsigned int cmd,
+							unsigned long arg);
+/*static int stmvl53l0_flush(struct file *file, fl_owner_t id);*/
+static int stmvl53l0_open(struct inode *inode, struct file *file);
+static int stmvl53l0_init_client(struct stmvl53l0_data *data);
+static int stmvl53l0_start(struct stmvl53l0_data *data, uint8_t scaling,
+			init_mode_e mode);
+static int stmvl53l0_stop(struct stmvl53l0_data *data);
+
+#ifdef CALIBRATION_FILE
+static void stmvl53l0_read_calibration_file(struct stmvl53l0_data *data)
+{
+	struct file *f;
+	char buf[8];
+	mm_segment_t fs;
+	int i, is_sign = 0;
+
+	f = filp_open("/data/calibration/offset", O_RDONLY, 0);
+	if (f != NULL && !IS_ERR(f) && f->f_dentry != NULL) {
+		fs = get_fs();
+		set_fs(get_ds());
+		/* init the buffer with 0 */
+		for (i = 0; i < 8; i++)
+			buf[i] = 0;
+		f->f_op->read(f, buf, 8, &f->f_pos);
+		set_fs(fs);
+		vl53l0_dbgmsg("offset as:%s, buf[0]:%c\n", buf, buf[0]);
+		offset_calib = 0;
+		for (i = 0; i < 8; i++) {
+			if (i == 0 && buf[0] == '-')
+				is_sign = 1;
+			else if (buf[i] >= '0' && buf[i] <= '9')
+				offset_calib = offset_calib * 10 +
+					(buf[i] - '0');
+			else
+				break;
+		}
+		if (is_sign == 1)
+			offset_calib = -offset_calib;
+		vl53l0_dbgmsg("offset_calib as %d\n", offset_calib);
+/*later
+		VL6180x_SetOffsetCalibrationData(vl53l0_dev, offset_calib);
+*/
+		filp_close(f, NULL);
+	} else {
+		vl53l0_errmsg("no offset calibration file exist!\n");
+	}
+
+	is_sign = 0;
+	f = filp_open("/data/calibration/xtalk", O_RDONLY, 0);
+	if (f != NULL && !IS_ERR(f) && f->f_dentry != NULL) {
+		fs = get_fs();
+		set_fs(get_ds());
+		/* init the buffer with 0 */
+		for (i = 0; i < 8; i++)
+			buf[i] = 0;
+		f->f_op->read(f, buf, 8, &f->f_pos);
+		set_fs(fs);
+		vl53l0_dbgmsg("xtalk as:%s, buf[0]:%c\n", buf, buf[0]);
+		xtalk_calib = 0;
+		for (i = 0; i < 8; i++) {
+			if (i == 0 && buf[0] == '-')
+				is_sign = 1;
+			else if (buf[i] >= '0' && buf[i] <= '9')
+				xtalk_calib = xtalk_calib * 10 + (buf[i] - '0');
+			else
+				break;
+		}
+		if (is_sign == 1)
+			xtalk_calib = -xtalk_calib;
+		vl53l0_dbgmsg("xtalk_calib as %d\n", xtalk_calib);
+/* later
+		VL6180x_SetXTalkCompensationRate(vl53l0_dev, xtalk_calib);
+*/
+		filp_close(f, NULL);
+	} else {
+		vl53l0_errmsg("no xtalk calibration file exist!\n");
+	}
+	return;
+}
+
+static void stmvl53l0_write_offset_calibration_file(void)
+{
+	struct file *f;
+	char buf[8];
+	mm_segment_t fs;
+
+	f = filp_open("/data/calibration/offset", O_WRONLY|O_CREAT, 0644);
+	if (f != NULL) {
+		fs = get_fs();
+		set_fs(get_ds());
+		sprintf(buf, "%d", offset_calib);
+		vl53l0_dbgmsg("write offset as:%s, buf[0]:%c\n", buf, buf[0]);
+		f->f_op->write(f, buf, 8, &f->f_pos);
+		set_fs(fs);
+	}
+	filp_close(f, NULL);
+
+	return;
+}
+
+static void stmvl53l0_write_xtalk_calibration_file(void)
+{
+	struct file *f;
+	char buf[8];
+	mm_segment_t fs;
+
+	f = filp_open("/data/calibration/xtalk", O_WRONLY|O_CREAT, 0644);
+	if (f != NULL) {
+		fs = get_fs();
+		set_fs(get_ds());
+		sprintf(buf, "%d", xtalk_calib);
+		vl53l0_dbgmsg("write xtalk as:%s, buf[0]:%c\n", buf, buf[0]);
+		f->f_op->write(f, buf, 8, &f->f_pos);
+		set_fs(fs);
+	}
+	filp_close(f, NULL);
+
+	return;
+}
+#endif
+
+
+static void stmvl53l0_ps_read_measurement(struct stmvl53l0_data *data)
+{
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+
+	data->ps_data = data->rangeData.RangeMilliMeter;
+	input_report_abs(data->input_dev_ps, ABS_DISTANCE,
+		(int)(data->ps_data + 5) / 10);
+	input_report_abs(data->input_dev_ps, ABS_HAT0X, tv.tv_sec);
+	input_report_abs(data->input_dev_ps, ABS_HAT0Y, tv.tv_usec);
+	input_report_abs(data->input_dev_ps, ABS_HAT1X,
+		data->rangeData.RangeMilliMeter);
+	input_report_abs(data->input_dev_ps, ABS_HAT1Y,
+		data->rangeData.RangeStatus);
+	input_report_abs(data->input_dev_ps, ABS_HAT2X,
+		data->rangeData.SignalRateRtnMegaCps);
+	input_report_abs(data->input_dev_ps, ABS_HAT2Y,
+		data->rangeData.AmbientRateRtnMegaCps);
+	input_report_abs(data->input_dev_ps, ABS_HAT3X,
+		data->rangeData.MeasurementTimeUsec);
+	input_report_abs(data->input_dev_ps, ABS_HAT3Y,
+		data->rangeData.RangeDMaxMilliMeter);
+	input_sync(data->input_dev_ps);
+
+	if (data->enableDebug)
+		vl53l0_errmsg("range:%d, signalRateRtnMegaCps:%d, \
+				error:0x%x,rtnambrate:%u,measuretime:%u\n",
+			data->rangeData.RangeMilliMeter,
+			data->rangeData.SignalRateRtnMegaCps,
+			data->rangeData.RangeStatus,
+			data->rangeData.AmbientRateRtnMegaCps,
+			data->rangeData.MeasurementTimeUsec);
+
+
+}
+
+static void stmvl53l0_cancel_handler(struct stmvl53l0_data *data)
+{
+	unsigned long flags;
+	bool ret;
+
+	spin_lock_irqsave(&data->update_lock.wait_lock, flags);
+	/*
+	 * If work is already scheduled then subsequent schedules will not
+	 * change the scheduled time that's why we have to cancel it first.
+	 */
+	ret = cancel_delayed_work(&data->dwork);
+	if (ret == 0)
+		vl53l0_errmsg("cancel_delayed_work return FALSE\n");
+
+	spin_unlock_irqrestore(&data->update_lock.wait_lock, flags);
+
+	return;
+}
+
+static void stmvl53l0_schedule_handler(struct stmvl53l0_data *data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&data->update_lock.wait_lock, flags);
+	/*
+	 * If work is already scheduled then subsequent schedules will not
+	 * change the scheduled time that's why we have to cancel it first.
+	 */
+	cancel_delayed_work(&data->dwork);
+	schedule_delayed_work(&data->dwork, msecs_to_jiffies(data->delay_ms));
+	spin_unlock_irqrestore(&data->update_lock.wait_lock, flags);
+
+	return;
+}
+
+/* interrupt work handler */
+static void stmvl53l0_work_handler(struct work_struct *work)
+{
+	struct stmvl53l0_data *data = container_of(work, struct stmvl53l0_data,
+				dwork.work);
+	VL53L0_DEV vl53l0_dev = data;
+	uint8_t reg_val;
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+#ifdef DEBUG_TIME_LOG
+	long total_sec, total_msec;
+#endif
+
+	mutex_lock(&data->work_mutex);
+
+	if (data->enable_ps_sensor == 1) {
+#ifdef USE_INT
+		VL53L0_RdByte(vl53l0_dev, VL53L0_REG_RESULT_INTERRUPT_STATUS,
+			&reg_val);
+		if (data->enableDebug)
+			pr_err("interrupt status reg as:0x%x, \
+				interrupt_received:%d\n",
+				reg_val, data->interrupt_received);
+
+		if (data->interrupt_received == 1) {
+
+			data->interrupt_received = 0;
+			if ((reg_val & 0x07) > 0) {
+				Status = VL53L0_ClearInterruptMask(vl53l0_dev,
+						0);
+				Status = VL53L0_GetRangingMeasurementData(
+						vl53l0_dev, &(data->rangeData));
+				if (data->enableDebug)
+					pr_err("Measured range:%d\n",
+					data->rangeData.RangeMilliMeter);
+			}
+		}
+
+
+		if (data->ps_is_singleshot == 1) {
+			VL53L0_SetDeviceMode(vl53l0_dev,
+				VL53L0_DEVICEMODE_SINGLE_RANGING);
+		    Status = VL53L0_StartMeasurement(vl53l0_dev);
+		} else if (data->ps_is_started == 0) { /*this is for continuous
+			mode  */
+			/*VL53L0_SetDeviceMode(vl53l0_dev,
+				VL53L0_DEVICEMODE_CONTINUOUS_RANGING); */
+			VL53L0_SetDeviceMode(vl53l0_dev,
+				VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING);
+
+			VL53L0_SetInterMeasurementPeriodMilliSeconds(vl53l0_dev,
+				20);
+		    Status = VL53L0_StartMeasurement(vl53l0_dev);
+			data->ps_is_started = 1;
+		}
+
+#else
+		/* vl53l0_dbgmsg("Enter\n"); */
+#ifdef DEBUG_TIME_LOG
+		do_gettimeofday(&start_tv);
+#endif
+		Status = VL53L0_PerformSingleRangingMeasurement(vl53l0_dev,
+			&(data->rangeData));
+#ifdef DEBUG_TIME_LOG
+		do_gettimeofday(&stop_tv);
+		total_sec = stop_tv.tv_sec - start_tv.tv_sec;
+		total_msec = (stop_tv.tv_usec - start_tv.tv_usec)/1000;
+		total_msec += total_sec * 1000;
+		pr_err("VL6180x_RangeGetMeasurement,\
+			elapsedTime:%ld\n", total_msec);
+#endif
+		/* to push the measurement *
+		if (RangingMeasurementData.status not equal NOT VALID)
+			stmvl53l0_ps_read_measurement(data);
+		*/
+		pr_err("Measured range:%d\n",\
+			data->rangeData.RangeMilliMeter);
+
+		/* restart timer */
+		schedule_delayed_work(&data->dwork,
+			msecs_to_jiffies((data->delay_ms)));
+#endif
+	    /* vl53l0_dbgmsg("End\n"); */
+	}
+
+	mutex_unlock(&data->work_mutex);
+
+	return;
+}
+
+#ifdef USE_INT
+static irqreturn_t stmvl53l0_interrupt_handler(int vec, void *info)
+{
+
+	struct stmvl53l0_data *data = (struct stmvl53l0_data *)info;
+
+	if (data->irq == vec) {
+		data->interrupt_received = 1;
+		schedule_delayed_work(&data->dwork, 0);
+	}
+	return IRQ_HANDLED;
+}
+#endif
+
+/*
+ * SysFS support
+ */
+static ssize_t stmvl53l0_show_enable_ps_sensor(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->enable_ps_sensor);
+}
+
+static ssize_t stmvl53l0_store_enable_ps_sensor(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	if ((val != 0) && (val != 1)) {
+		vl53l0_errmsg("store unvalid value=%ld\n", val);
+		return count;
+	}
+	mutex_lock(&data->work_mutex);
+	vl53l0_dbgmsg("Enter, enable_ps_sensor flag:%d\n",
+		data->enable_ps_sensor);
+	vl53l0_dbgmsg("enable ps senosr ( %ld)\n", val);
+
+	if (val == 1) {
+		/* turn on tof sensor */
+		if (data->enable_ps_sensor == 0) {
+			/* to start */
+			stmvl53l0_start(data, 3, NORMAL_MODE);
+		} else {
+			vl53l0_errmsg("Already enabled. Skip !");
+		}
+	} else {
+		/* turn off tof sensor */
+		if (data->enable_ps_sensor == 1) {
+			data->enable_ps_sensor = 0;
+			/* to stop */
+			stmvl53l0_stop(data);
+		}
+	}
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(enable_ps_sensor, S_IWUGO | S_IRUGO,
+				   stmvl53l0_show_enable_ps_sensor,
+					stmvl53l0_store_enable_ps_sensor);
+
+static ssize_t stmvl53l0_show_enable_debug(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->enableDebug);
+}
+
+/* for debug */
+static ssize_t stmvl53l0_store_enable_debug(struct device *dev,
+					struct device_attribute *attr, const
+					char *buf, size_t count)
+{
+	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+	long on = simple_strtoul(buf, NULL, 10);
+
+	if ((on != 0) &&  (on != 1)) {
+		vl53l0_errmsg("set debug=%ld\n", on);
+		return count;
+	}
+	data->enableDebug = on;
+
+	return count;
+}
+
+/* DEVICE_ATTR(name,mode,show,store) */
+static DEVICE_ATTR(enable_debug, S_IWUSR | S_IRUGO,
+				   stmvl53l0_show_enable_debug,
+					stmvl53l0_store_enable_debug);
+
+static ssize_t stmvl53l0_show_set_delay_ms(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->delay_ms);
+}
+
+/* for work handler scheduler time */
+static ssize_t stmvl53l0_store_set_delay_ms(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+	long delay_ms = simple_strtoul(buf, NULL, 10);
+
+	if (delay_ms == 0) {
+		vl53l0_errmsg("set delay_ms=%ld\n", delay_ms);
+		return count;
+	}
+	mutex_lock(&data->work_mutex);
+	data->delay_ms = delay_ms;
+	mutex_unlock(&data->work_mutex);
+
+	return count;
+}
+
+/* DEVICE_ATTR(name,mode,show,store) */
+static DEVICE_ATTR(set_delay_ms, S_IWUGO | S_IRUGO,
+				   stmvl53l0_show_set_delay_ms,
+					stmvl53l0_store_set_delay_ms);
+
+static struct attribute *stmvl53l0_attributes[] = {
+	&dev_attr_enable_ps_sensor.attr,
+	&dev_attr_enable_debug.attr,
+	&dev_attr_set_delay_ms.attr ,
+	NULL
+};
+
+
+static const struct attribute_group stmvl53l0_attr_group = {
+	.attrs = stmvl53l0_attributes,
+};
+
+/*
+ * misc device file operation functions
+ */
+static int stmvl53l0_ioctl_handler(struct file *file,
+			unsigned int cmd, unsigned long arg,
+			void __user *p)
+{
+	int rc = 0;
+	unsigned int xtalkint = 0;
+	int8_t offsetint = 0;
+	struct stmvl53l0_data *data =
+			container_of(file->private_data,
+				struct stmvl53l0_data, miscdev);
+	struct stmvl53l0_register reg;
+	struct stmvl53l0_parameter parameter;
+	VL53L0_DEV vl53l0_dev = data;
+	uint8_t page_num = 0;
+	if (!data)
+		return -EINVAL;
+
+	vl53l0_dbgmsg("Enter enable_ps_sensor:%d\n", data->enable_ps_sensor);
+	switch (cmd) {
+	/* enable */
+	case VL53L0_IOCTL_INIT:
+		vl53l0_dbgmsg("VL53L0_IOCTL_INIT\n");
+		/* turn on tof sensor only if it's not enabled by other
+		client */
+		if (data->enable_ps_sensor == 0) {
+			/* to start */
+			stmvl53l0_start(data, 3, NORMAL_MODE);
+		} else
+			rc = -EINVAL;
+		break;
+	/* crosstalk calibration */
+	case VL53L0_IOCTL_XTALKCALB:
+		vl53l0_dbgmsg("VL53L0_IOCTL_XTALKCALB\n");
+		/* turn on tof sensor only if it's not enabled by other
+		client */
+		if (data->enable_ps_sensor == 0) {
+			/* to start */
+			stmvl53l0_start(data, 3, XTALKCALIB_MODE);
+		} else
+			rc = -EINVAL;
+		break;
+	/* set up Xtalk value */
+	case VL53L0_IOCTL_SETXTALK:
+		vl53l0_dbgmsg("VL53L0_IOCTL_SETXTALK\n");
+		if (copy_from_user(&xtalkint, (unsigned int *)p,
+			sizeof(unsigned int))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		vl53l0_dbgmsg("SETXTALK as 0x%x\n", xtalkint);
+#ifdef CALIBRATION_FILE
+		xtalk_calib = xtalkint;
+		stmvl53l0_write_xtalk_calibration_file();
+#endif
+/* later
+		VL6180x_SetXTalkCompensationRate(vl53l0_dev, xtalkint);
+*/
+		break;
+	/* offset calibration */
+	case VL53L0_IOCTL_OFFCALB:
+		vl53l0_dbgmsg("VL53L0_IOCTL_OFFCALB\n");
+		if (data->enable_ps_sensor == 0) {
+			/* to start */
+			stmvl53l0_start(data, 3, OFFSETCALIB_MODE);
+		} else
+			rc = -EINVAL;
+		break;
+	/* set up offset value */
+	case VL53L0_IOCTL_SETOFFSET:
+		vl53l0_dbgmsg("VL53L0_IOCTL_SETOFFSET\n");
+		if (copy_from_user(&offsetint, (int8_t *)p, sizeof(int8_t))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		vl53l0_dbgmsg("SETOFFSET as %d\n", offsetint);
+#ifdef CALIBRATION_FILE
+		offset_calib = offsetint;
+		stmvl53l0_write_offset_calibration_file();
+#endif
+/* later
+		VL6180x_SetOffsetCalibrationData(vl53l0_dev, offsetint);
+*/
+		break;
+	/* disable */
+	case VL53L0_IOCTL_STOP:
+		vl53l0_dbgmsg("VL53L0_IOCTL_STOP\n");
+		/* turn off tof sensor only if it's enabled by other client */
+		if (data->enable_ps_sensor == 1) {
+			data->enable_ps_sensor = 0;
+			/* to stop */
+			stmvl53l0_stop(data);
+		}
+		break;
+	/* Get all range data */
+	case VL53L0_IOCTL_GETDATAS:
+		vl53l0_dbgmsg("VL53L0_IOCTL_GETDATAS\n");
+		if (copy_to_user((VL53L0_RangingMeasurementData_t *)p,
+			&(data->rangeData),
+			sizeof(VL53L0_RangingMeasurementData_t))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		break;
+	/* Register tool */
+	case VL53L0_IOCTL_REGISTER:
+		vl53l0_dbgmsg("VL53L0_IOCTL_REGISTER\n");
+		if (copy_from_user(&reg, (struct stmvl53l0_register *)p,
+			sizeof(struct stmvl53l0_register))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		reg.status = 0;
+		page_num = (uint8_t)((reg.reg_index & 0x0000ff00) >> 8);
+		vl53l0_dbgmsg("VL53L0_IOCTL_REGISTER,\
+			page number:%d\n", page_num);
+		if (page_num != 0)
+			reg.status = VL53L0_WrByte(vl53l0_dev, 0xFF, page_num);
+
+		switch (reg.reg_bytes) {
+		case(4):
+			if (reg.is_read)
+				reg.status = VL53L0_RdDWord(vl53l0_dev,
+					(uint8_t)reg.reg_index,
+					&reg.reg_data);
+			else
+				reg.status = VL53L0_WrDWord(vl53l0_dev,
+					(uint8_t)reg.reg_index,
+					reg.reg_data);
+			break;
+		case(2):
+			if (reg.is_read)
+				reg.status = VL53L0_RdWord(vl53l0_dev,
+					(uint8_t)reg.reg_index,
+					(uint16_t *)&reg.reg_data);
+			else
+				reg.status = VL53L0_WrWord(vl53l0_dev,
+					(uint8_t)reg.reg_index,
+					(uint16_t)reg.reg_data);
+			break;
+		case(1):
+			if (reg.is_read)
+				reg.status = VL53L0_RdByte(vl53l0_dev,
+					(uint8_t)reg.reg_index,
+					(uint8_t *)&reg.reg_data);
+			else
+				reg.status = VL53L0_WrByte(vl53l0_dev,
+					(uint8_t)reg.reg_index,
+					(uint8_t)reg.reg_data);
+			break;
+		default:
+			reg.status = -1;
+
+		}
+		if (page_num != 0)
+			reg.status = VL53L0_WrByte(vl53l0_dev, 0xFF, 0);
+
+
+		if (copy_to_user((struct stmvl53l0_register *)p, &reg,
+				sizeof(struct stmvl53l0_register))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		break;
+	/* parameter access */
+	case VL53L0_IOCTL_PARAMETER:
+		vl53l0_dbgmsg("VL53L0_IOCTL_PARAMETER\n");
+		if (copy_from_user(&parameter, (struct stmvl53l0_parameter *)p,
+				sizeof(struct stmvl53l0_parameter))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		parameter.status = 0;
+		switch (parameter.name) {
+		case (OFFSET_PAR):
+			if (parameter.is_read)
+				parameter.status =
+				VL53L0_GetOffsetCalibrationDataMicroMeter(
+						vl53l0_dev, &parameter.value);
+			else
+				parameter.status =
+				VL53L0_SetOffsetCalibrationDataMicroMeter(
+						vl53l0_dev, parameter.value);
+			break;
+		case (XTALKRATE_PAR):
+			if (parameter.is_read)
+				parameter.status =
+					VL53L0_GetXTalkCompensationRateMegaCps(
+						vl53l0_dev, (FixPoint1616_t *)
+						&parameter.value);
+			else
+				parameter.status =
+					VL53L0_SetXTalkCompensationRateMegaCps(
+						vl53l0_dev,
+						(FixPoint1616_t)
+							parameter.value);
+
+			break;
+		case (XTALKENABLE_PAR):
+			if (parameter.is_read)
+				parameter.status =
+					VL53L0_GetXTalkCompensationEnable(
+						vl53l0_dev,
+						(uint8_t *) &parameter.value);
+			else
+				parameter.status =
+					VL53L0_SetXTalkCompensationEnable(
+						vl53l0_dev,
+						(uint8_t) parameter.value);
+			break;
+
+		}
+		if (copy_to_user((struct stmvl53l0_parameter *)p, &reg,
+				sizeof(struct stmvl53l0_register))) {
+			vl53l0_errmsg("%d, fail\n", __LINE__);
+			return -EFAULT;
+		}
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	return rc;
+}
+
+static int stmvl53l0_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+#if 0
+static int stmvl53l0_flush(struct file *file, fl_owner_t id)
+{
+	struct stmvl53l0_data *data = container_of(file->private_data,
+						struct stmvl53l0_data, miscdev);
+	(void) file;
+	(void) id;
+
+	if (data) {
+		if (data->enable_ps_sensor == 1) {
+			/* turn off tof sensor if it's enabled */
+			data->enable_ps_sensor = 0;
+			/* to stop */
+			stmvl53l0_stop(data);
+		}
+	}
+	return 0;
+}
+#endif
+static long stmvl53l0_ioctl(struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	struct stmvl53l0_data *data =
+			container_of(file->private_data,
+					struct stmvl53l0_data, miscdev);
+	mutex_lock(&data->work_mutex);
+	ret = stmvl53l0_ioctl_handler(file, cmd, arg, (void __user *)arg);
+	mutex_unlock(&data->work_mutex);
+
+	return ret;
+}
+
+/*
+ * Initialization function
+ */
+static int stmvl53l0_init_client(struct stmvl53l0_data *data)
+{
+	uint8_t id = 0, type = 0;
+	uint8_t revision = 0, module_id = 0;
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceInfo_t DeviceInfo;
+	VL53L0_DEV vl53l0_dev = data;
+
+	vl53l0_dbgmsg("Enter\n");
+
+
+	/* Read Model ID */
+	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_MODEL_ID, &id);
+	vl53l0_errmsg("read MODLE_ID: 0x%x\n", id);
+	if (id == 0xee) {
+		vl53l0_errmsg("STM VL53L0 Found\n");
+	} else if (id == 0) {
+		vl53l0_errmsg("Not found STM VL53L0\n");
+		return -EIO;
+	}
+	VL53L0_RdByte(vl53l0_dev, 0xc1, &id);
+	vl53l0_errmsg("read 0xc1: 0x%x\n", id);
+	VL53L0_RdByte(vl53l0_dev, 0xc2, &id);
+	vl53l0_errmsg("read 0xc2: 0x%x\n", id);
+	VL53L0_RdByte(vl53l0_dev, 0xc3, &id);
+	vl53l0_errmsg("read 0xc3: 0x%x\n", id);
+
+	/* Read Model Version */
+	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_MODEL_TYPE, &type);
+	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_REVISION_ID,
+		&revision);
+	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_MODULE_ID,
+		&module_id);
+	vl53l0_errmsg("STM VL53L0 Model type : %d. rev:%d. module:%d\n", type,
+		revision, module_id);
+
+	vl53l0_dev->I2cDevAddr      = 0x52;
+	vl53l0_dev->comms_type      =  1;
+	vl53l0_dev->comms_speed_khz =  400;
+
+	if (Status == VL53L0_ERROR_NONE && data->reset) {
+		pr_err("Call of VL53L0_DataInit\n");
+		Status = VL53L0_DataInit(vl53l0_dev); /* Data initialization */
+		data->reset = 0;
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		pr_err("VL53L0_GetDeviceInfo:\n");
+		Status = VL53L0_GetDeviceInfo(vl53l0_dev, &DeviceInfo);
+		if (Status == VL53L0_ERROR_NONE) {
+			pr_err("Device Name : %s\n", DeviceInfo.Name);
+			pr_err("Device Type : %s\n", DeviceInfo.Type);
+			pr_err("ProductType : %d\n", DeviceInfo.ProductType);
+			pr_err("ProductRevisionMajor : %d\n",
+				DeviceInfo.ProductRevisionMajor);
+			pr_err("ProductRevisionMinor : %d\n",
+				DeviceInfo.ProductRevisionMinor);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		pr_err("Call of VL53L0_StaticInit\n");
+		Status = VL53L0_StaticInit(vl53l0_dev);
+		/* Device Initialization */
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+
+		pr_err("Call of VL53L0_SetDeviceMode\n");
+		Status = VL53L0_SetDeviceMode(vl53l0_dev,
+					VL53L0_DEVICEMODE_SINGLE_RANGING);
+		/* Setup in	single ranging mode */
+	}
+	/*  Enable/Disable Sigma and Signal check */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_SetSigmaLimitCheckEnable(vl53l0_dev, 0, 1);
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_SetSignalLimitCheckEnable(vl53l0_dev, 0, 1);
+
+	/* set user calibration data - need to be called after
+	VL6180x_InitData
+	*/
+#ifdef CALIBRATION_FILE
+	/*stmvl53l0_read_calibration_file(data);*/
+#endif
+
+	vl53l0_dbgmsg("End\n");
+
+	return 0;
+}
+
+static int stmvl53l0_start(struct stmvl53l0_data *data, uint8_t scaling,
+	init_mode_e mode)
+{
+	int rc = 0;
+	VL53L0_DEV vl53l0_dev = data;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	/* Power up */
+	rc = pmodule_func_tbl->power_up(&data->client_object, &data->reset);
+	if (rc) {
+		vl53l0_errmsg("%d,error rc %d\n", __LINE__, rc);
+		return rc;
+	}
+	/* init */
+	rc = stmvl53l0_init_client(data);
+	if (rc) {
+		vl53l0_errmsg("%d, error rc %d\n", __LINE__, rc);
+		pmodule_func_tbl->power_down(&data->client_object);
+		return -EINVAL;
+	}
+
+	/* check mode */
+	if (mode != NORMAL_MODE)
+		VL53L0_SetXTalkCompensationEnable(vl53l0_dev, 0);
+
+	if (mode == OFFSETCALIB_MODE)
+		VL53L0_SetOffsetCalibrationDataMicroMeter(vl53l0_dev, 0);
+	else if (mode == XTALKCALIB_MODE) {
+		FixPoint1616_t XTalkCompensationRateMegaCps;
+		/*caltarget distance : 100mm and convert to
+		* fixed point 16 16 format
+		*/
+		VL53L0_PerformXTalkCalibration(vl53l0_dev, (100<<16),
+			&XTalkCompensationRateMegaCps);
+		pr_err("Xtalk comensation:%u\n", XTalkCompensationRateMegaCps);
+	}
+
+	VL53L0_SetGpioConfig(vl53l0_dev, 0, 0,
+		VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+		VL53L0_INTERRUPTPOLARITY_LOW);
+	VL53L0_SetInterruptThresholds(vl53l0_dev, 0, (100<<16), 0);
+
+	/* ps_is_singleshot:	1-> for single shot mode
+	*						0-> for continus mode
+	*/
+	data->ps_is_singleshot = 0;
+	data->ps_is_started = 0; /* mainly for continuous mode*/
+	data->enable_ps_sensor = 1;
+
+	/* enable work handler */
+	stmvl53l0_schedule_handler(data);
+
+	vl53l0_dbgmsg("End\n");
+
+	return rc;
+}
+
+static int stmvl53l0_stop(struct stmvl53l0_data *data)
+{
+	int rc = 0;
+	VL53L0_DEV vl53l0_dev = data;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	/* stop - if continuous mode */
+	if (data->ps_is_singleshot == 0)
+		VL53L0_StopMeasurement(vl53l0_dev);
+
+	/* clean interrupt */
+	VL53L0_ClearInterruptMask(vl53l0_dev, 0);
+
+	/* cancel work handler */
+	stmvl53l0_cancel_handler(data);
+	/* power down */
+	rc = pmodule_func_tbl->power_down(&data->client_object);
+	if (rc) {
+		vl53l0_errmsg("%d, error rc %d\n", __LINE__, rc);
+		return rc;
+	}
+	vl53l0_dbgmsg("End\n");
+
+	return rc;
+}
+
+/*
+ * I2C init/probing/exit functions
+ */
+static const struct file_operations stmvl53l0_ranging_fops = {
+	.owner =			THIS_MODULE,
+	.unlocked_ioctl =	stmvl53l0_ioctl,
+	.open =				stmvl53l0_open,
+	/*.flush =			stmvl53l0_flush,*/
+};
+
+/*
+static struct miscdevice stmvl53l0_ranging_dev = {
+	.minor =	MISC_DYNAMIC_MINOR,
+	.name =		"stmvl53l0_ranging",
+	.fops =		&stmvl53l0_ranging_fops
+};
+*/
+
+int stmvl53l0_setup(struct stmvl53l0_data *data)
+{
+	int rc = 0;
+#ifdef USE_INT
+	int irq = 0;
+#endif
+
+	vl53l0_dbgmsg("Enter\n");
+
+	/* init mutex */
+	mutex_init(&data->update_lock);
+	mutex_init(&data->work_mutex);
+
+#ifdef USE_INT
+	/* init interrupt */
+	gpio_request(IRQ_NUM, "vl53l0_gpio_int");
+	gpio_direction_input(IRQ_NUM);
+	irq = gpio_to_irq(IRQ_NUM);
+	if (irq < 0) {
+		vl53l0_errmsg("filed to map GPIO: %d to interrupt:%d\n",
+			IRQ_NUM, irq);
+	} else {
+		vl53l0_dbgmsg("register_irq:%d\n", irq);
+		/* IRQF_TRIGGER_FALLING- poliarity:0 IRQF_TRIGGER_RISNG -
+		poliarty:1 */
+		rc = request_threaded_irq(irq, NULL,
+				stmvl53l0_interrupt_handler,
+				IRQF_TRIGGER_FALLING,
+				"vl53l0_interrupt",
+				(void *)data);
+		if (rc) {
+			vl53l0_errmsg("%d, Could not allocate STMVL53L0_INT !\
+				result:%d\n",  __LINE__, rc);
+#ifdef USE_INT
+			free_irq(irq, data);
+#endif
+			goto exit_free_irq;
+		}
+	}
+	data->irq = irq;
+	vl53l0_errmsg("interrupt is hooked\n");
+#endif
+
+	/* init work handler */
+	INIT_DELAYED_WORK(&data->dwork, stmvl53l0_work_handler);
+
+	/* Register to Input Device */
+	data->input_dev_ps = input_allocate_device();
+	if (!data->input_dev_ps) {
+		rc = -ENOMEM;
+		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
+/*
+#ifdef USE_INT
+		free_irq(irq, data);
+#endif
+*/
+		goto exit_free_irq;
+	}
+	set_bit(EV_ABS, data->input_dev_ps->evbit);
+	/* range in cm*/
+	input_set_abs_params(data->input_dev_ps, ABS_DISTANCE, 0, 76, 0, 0);
+	/* tv_sec */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT0X, 0, 0xffffffff,
+		0, 0);
+	/* tv_usec */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT0Y, 0, 0xffffffff,
+		0, 0);
+	/* range in_mm */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT1X, 0, 765, 0, 0);
+	/* error code change maximum to 0xff for more flexibility */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT1Y, 0, 0xff, 0, 0);
+	/* rtnRate */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT2X, 0, 0xffffffff,
+		0, 0);
+	/* rtn_amb_rate */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT2Y, 0, 0xffffffff,
+		0, 0);
+	/* rtn_conv_time */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT3X, 0, 0xffffffff,
+		0, 0);
+	/* dmax */
+	input_set_abs_params(data->input_dev_ps, ABS_HAT3Y, 0, 0xffffffff,
+		0, 0);
+	data->input_dev_ps->name = "STM VL53L0 proximity sensor";
+
+	rc = input_register_device(data->input_dev_ps);
+	if (rc) {
+		rc = -ENOMEM;
+		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
+/*
+#ifdef USE_INT
+		free_irq(irq, data);
+#endif
+		input_free_device(data->input_dev_ps);
+		return rc;
+*/
+		goto exit_free_dev_ps;
+	}
+	/* setup drv data */
+	input_set_drvdata(data->input_dev_ps, data);
+
+	/* Register sysfs hooks */
+	data->range_kobj = kobject_create_and_add("range", kernel_kobj);
+	if (!data->range_kobj) {
+		rc = -ENOMEM;
+		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
+/*
+#ifdef USE_INT
+		free_irq(irq, data);
+#endif
+
+		input_unregister_device(data->input_dev_ps);
+		input_free_device(data->input_dev_ps);
+		return rc;
+*/
+		goto exit_unregister_dev_ps;
+	}
+	/*rc = sysfs_create_group(data->range_kobj, &stmvl53l0_attr_group);
+	 rc = sysfs_create_group(&data->client_object.client->dev.kobj,
+			&stmvl53l0_attr_group);
+	*/
+	rc = sysfs_create_group(&data->input_dev_ps->dev.kobj,
+			&stmvl53l0_attr_group);
+	if (rc) {
+		rc = -ENOMEM;
+		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
+/*
+#ifdef USE_INT
+		free_irq(irq, data);
+#endif
+		kobject_put(data->range_kobj);
+		input_unregister_device(data->input_dev_ps);
+		input_free_device(data->input_dev_ps);
+		return rc;
+*/
+		goto exit_unregister_dev_ps_1;
+	}
+
+	/* to register as a misc device */
+	data->miscdev.minor = MISC_DYNAMIC_MINOR;
+	data->miscdev.name = "stmvl53l0_ranging";
+	data->miscdev.fops = &stmvl53l0_ranging_fops;
+	vl53l0_errmsg("Misc device registration name:%s\n", data->dev_name);
+	if (misc_register(&data->miscdev) != 0)
+		vl53l0_errmsg("Could not register misc. dev for stmvl53l0\
+				ranging\n");
+
+	/* init default value */
+	data->enable_ps_sensor = 0;
+	data->reset = 1;
+	data->delay_ms = 30;	/* delay time to 30ms */
+	data->enableDebug = 0;
+	data->client_object.power_up = 0;
+	/* for those one-the-fly power on/off flag */
+
+	vl53l0_dbgmsg("support ver. %s enabled\n", DRIVER_VERSION);
+	vl53l0_dbgmsg("End");
+
+	return 0;
+exit_unregister_dev_ps_1:
+	kobject_put(data->range_kobj);
+exit_unregister_dev_ps:
+	input_unregister_device(data->input_dev_ps);
+exit_free_dev_ps:
+	input_free_device(data->input_dev_ps);
+exit_free_irq:
+#ifdef USE_INT
+	free_irq(irq, data);
+#endif
+	kfree(data);
+	return rc;
+}
+
+static int __init stmvl53l0_init(void)
+{
+	int ret = -1;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	/* assign function table */
+	pmodule_func_tbl = &stmvl53l0_module_func_tbl;
+#if 0
+	vl53l0_data = kzalloc(sizeof(struct stmvl53l0_data), GFP_KERNEL);
+	if (!vl53l0_data) {
+		vl53l0_errmsg("%d failed no memory\n", __LINE__);
+		return -ENOMEM;
+	}
+	/* assign to global variable */
+	gp_vl53l0_data = vl53l0_data;
+	/* assign function table */
+	vl53l0_data->pmodule_func_tbl = &stmvl53l0_module_func_tbl;
+#endif
+	/* client specific init function */
+	ret = pmodule_func_tbl->init();
+#if 0
+	if (!ret)
+		ret = stmvl53l0_setup(vl53l0_data);
+#endif
+	if (ret)
+		vl53l0_errmsg("%d failed with %d\n", __LINE__, ret);
+
+	vl53l0_dbgmsg("End\n");
+
+	return ret;
+}
+
+static void __exit stmvl53l0_exit(void)
+{
+	vl53l0_dbgmsg("Enter\n");
+#if 0
+	if (gp_vl53l0_data) {
+		input_unregister_device(gp_vl53l0_data->input_dev_ps);
+		input_free_device(gp_vl53l0_data->input_dev_ps);
+#ifdef USE_INT
+		free_irq(data->irq, gp_vl53l0_data);
+#endif
+		sysfs_remove_group(gp_vl53l0_data->range_kobj,
+&stmvl53l0_attr_group);
+
+gp_vl53l0_data->pmodule_func_tbl->deinit(&gp_vl53l0_data->client_object);
+		kfree(gp_vl53l0_data);
+		gp_vl53l0_data = NULL;
+	}
+#endif
+	vl53l0_dbgmsg("End\n");
+}
+
+
+MODULE_AUTHOR("STMicroelectronics Imaging Division");
+MODULE_DESCRIPTION("ST FlightSense Time-of-Flight sensor driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+module_init(stmvl53l0_init);
+module_exit(stmvl53l0_exit);
+
-- 
2.11.0

