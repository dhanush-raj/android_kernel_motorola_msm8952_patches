From b64883667233fe356287b12cdd308e184737992c Mon Sep 17 00:00:00 2001
From: Teresa TAO <teresa.tao@st.com>
Date: Mon, 16 Nov 2015 14:15:51 -0600
Subject: [PATCH 481/959] IKQCOMSD1-3057:input:misc:vl53l0: update to new ST
 driver 08 version

Version 1.0.8 for cut1,0 support and Version 1.1.7 for cut 1.1 support.
Change-Id: Ie9ed2015880687686ba1a95f07309d917d49d0b9

Signed-off-by: Teresa TAO <teresa.tao@st.com>
Change-Id: I3b90aa95718dc197e2a590c516d86ee9e4b43bef
Reviewed-on: http://gerrit.mot.com/800364
SME-Granted: SME Approvals Granted
SLTApproved: Slta Waiver <sltawvr@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
Tested-by: Jira Key <jirakey@motorola.com>
Reviewed-by: Igor Kovalenko <igork@motorola.com>
---
 drivers/input/misc/vl53L0/Makefile               |    2 +-
 drivers/input/misc/vl53L0/inc/vl53l010_api.h     | 1415 ++++
 drivers/input/misc/vl53L0/inc/vl53l010_device.h  |  226 +
 drivers/input/misc/vl53L0/inc/vl53l010_strings.h |  100 +
 drivers/input/misc/vl53L0/inc/vl53l010_tuning.h  |   65 +
 drivers/input/misc/vl53L0/inc/vl53l0_api.h       |  567 +-
 drivers/input/misc/vl53L0/inc/vl53l0_def.h       |  404 +-
 drivers/input/misc/vl53L0/inc/vl53l0_device.h    |  145 +-
 drivers/input/misc/vl53L0/inc/vl53l0_strings.h   |   44 +-
 drivers/input/misc/vl53L0/inc/vl53l0_tuning.h    |  116 +-
 drivers/input/misc/vl53L0/src/vl53l010_api.c     | 4128 +++++++++++
 drivers/input/misc/vl53L0/src/vl53l010_tuning.c  |  137 +
 drivers/input/misc/vl53L0/src/vl53l0_api.c       | 8668 +++++++++++-----------
 drivers/input/misc/vl53L0/src/vl53l0_tuning.c    |    6 +-
 14 files changed, 11197 insertions(+), 4826 deletions(-)
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l010_api.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l010_device.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l010_strings.h
 create mode 100644 drivers/input/misc/vl53L0/inc/vl53l010_tuning.h
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l010_api.c
 create mode 100644 drivers/input/misc/vl53L0/src/vl53l010_tuning.c

diff --git a/drivers/input/misc/vl53L0/Makefile b/drivers/input/misc/vl53L0/Makefile
index b29f07f24cf..aee4abf1c0e 100644
--- a/drivers/input/misc/vl53L0/Makefile
+++ b/drivers/input/misc/vl53L0/Makefile
@@ -15,5 +15,5 @@ ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
 ccflags-y += -Idrivers/media/platform/msm/camera_v2
 ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
 obj-$(CONFIG_STMVL53L0)			+= stmvl53l0.o
-stmvl53l0-objs				:= stmvl53l0_module.o stmvl53l0_module-i2c.o stmvl53l0_module-cci.o src/vl53l0_api.o src/vl53l0_tuning.o src/vl53l0_platform.o src/vl53l0_i2c_platform.o src/vl53l0_port_i2c.o
+stmvl53l0-objs				:= stmvl53l0_module.o stmvl53l0_module-i2c.o stmvl53l0_module-cci.o src/vl53l0_api.o src/vl53l010_api.o src/vl53l010_tuning.o  src/vl53l0_tuning.o src/vl53l0_platform.o src/vl53l0_i2c_platform.o src/vl53l0_port_i2c.o
 
diff --git a/drivers/input/misc/vl53L0/inc/vl53l010_api.h b/drivers/input/misc/vl53L0/inc/vl53l010_api.h
new file mode 100644
index 00000000000..bfc242bd483
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l010_api.h
@@ -0,0 +1,1415 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+/*
+ * @file vl53l0_api.h
+ * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * $Revision: 1906 $
+ */
+
+
+
+#ifndef _VL53L010_API_H_
+#define _VL53L010_API_H_
+
+#include "vl53l010_strings.h"
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef _MSC_VER
+#   ifdef VL53L0_API_EXPORTS
+#       define VL53L010_API  __declspec(dllexport)
+#   else
+#       define VL53L010_API
+#   endif
+#else
+#   define VL53L010_API
+#endif
+
+
+/** @defgroup VL53L010_general_group VL53L0 General Functions
+ *  @brief    General functions and definitions
+ *  @{
+ */
+
+/**
+ * @brief Return the VL53L0 PAL Implementation Version
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   pVersion              Pointer to current PAL Implementation Version
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetVersion(VL53L0_Version_t *pVersion);
+
+/**
+ * @brief Return the PAL Specification Version used for the current
+ * implementation.
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   pPalSpecVersion       Pointer to current PAL Specification Version
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetPalSpecVersion(
+			VL53L0_Version_t *pPalSpecVersion);
+
+
+/**
+ * @brief Reads the Device information for given Device
+ *
+ * @note This function Access to the device.\n
+ * Use ProductRevisionMajor and ProductRevisionMinor to know the cut
+ * 			of the device used.
+ *
+ * @param   Dev                 Device Handle
+ * @param   pVL53L0_DeviceInfo     Pointer to current device info for a given
+ * Device
+ *
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"  See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetDeviceInfo(VL53L0_DEV Dev,
+			VL53L0_DeviceInfo_t *pVL53L0_DeviceInfo);
+
+
+/**
+ * @brief Read current status of the error register for the selected device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceErrorStatus    Pointer to current error code of the device
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetDeviceErrorStatus(VL53L0_DEV Dev,
+			VL53L0_DeviceError * pDeviceErrorStatus);
+
+/**
+ * @brief Human readable error string for a given Error Code
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   ErrorCode             The error code as stored on
+ * ::VL53L0_DeviceError
+ * @param   pDeviceErrorString    The error string corresponding to the
+ * ErrorCode
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetDeviceErrorString(
+			VL53L0_DeviceError ErrorCode, char *pDeviceErrorString);
+
+
+/**
+ * @brief Human readable error string for current PAL error status
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   PalErrorCode          The error code as stored on @a VL53L0_Error
+ * @param   pPalErrorString       The error string corresponding to the
+ * PalErrorCode
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetPalErrorString(VL53L0_Error PalErrorCode,
+			char *pPalErrorString);
+
+
+/**
+ * @brief Reads the internal state of the PAL for a given Device
+ *
+ * @note This function doesn't access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pPalState             Pointer to current state of the PAL for a
+ * given Device
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetPalState(VL53L0_DEV Dev,
+			VL53L0_State * pPalState);
+
+
+/**
+ * @brief Set the power mode for a given Device
+ * The power mode can be Standby or Idle. Different level of both Standby and
+ * Idle can exists.
+ * This function should not be used when device is in Ranging state.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   PowerMode             The value of the power mode to set.
+ * see ::VL53L0_PowerModes Valid values are:
+ * VL53L0_POWERMODE_STANDBY_LEVEL1, VL53L0_POWERMODE_IDLE_LEVEL1
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED    This error occurs when PowerMode
+ * is not in the supported list
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetPowerMode(VL53L0_DEV Dev,
+			VL53L0_PowerModes PowerMode);
+
+/**
+ * @brief Get the power mode for a given Device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pPowerMode            Pointer to the current value of the power
+ * mode. see ::VL53L0_PowerModes. Valid values are:
+ * VL53L0_POWERMODE_STANDBY_LEVEL1, VL53L0_POWERMODE_IDLE_LEVEL1
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetPowerMode(VL53L0_DEV Dev,
+			VL53L0_PowerModes * pPowerMode);
+
+
+/**
+ * Set or over-hide part to part calibration offset
+ * \sa VL53L0_DataInit()   VL53L0_GetOffsetCalibrationDataMicroMeter()
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                Device Handle
+ * @param   OffsetCalibrationDataMicroMeter    Offset (in micrometer)
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  "Other error code"                 See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetOffsetCalibrationDataMicroMeter(
+			VL53L0_DEV Dev,
+			int32_t OffsetCalibrationDataMicroMeter);
+
+/**
+ * @brief Get part to part calibration offset
+ *
+ * @par Function Description
+ * Should only be used after a successful call to @a VL53L0_DataInit to backup
+ * device NVM value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                Device Handle
+ * @param   pOffsetCalibrationDataMicroMeter   Return part to part calibration
+ * offset from device (in micro meter)
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  "Other error code"                 See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetOffsetCalibrationDataMicroMeter(
+			VL53L0_DEV Dev,
+			int32_t *pOffsetCalibrationDataMicroMeter);
+
+/**
+ * Set Group parameter Hold state
+ *
+ * @par Function Description
+ * Set or remove device internal group parameter hold
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @param   GroupParamHold   Group parameter Hold state to be set (on/off)
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ */
+VL53L010_API VL53L0_Error VL53L010_SetGroupParamHold(VL53L0_DEV Dev,
+			uint8_t GroupParamHold);
+
+/**
+ * @brief Get the maximal distance for actual setup
+ * @par Function Description
+ * Device must be initialized through @a VL53L0_SetParameters() prior calling
+ * this function.
+ *
+ * Any range value more than the value returned is to be considered as "no
+ * target detected"
+ * or "no target in detectable range"\n
+ * @warning The maximal distance depends on the setup
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @param   pUpperLimitMilliMeter   The maximal range limit for actual setup
+ * (in millimeter)
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ */
+VL53L010_API VL53L0_Error VL53L010_GetUpperLimitMilliMeter(VL53L0_DEV Dev,
+			uint16_t *pUpperLimitMilliMeter);
+
+/** @} VL53L0_general_group */
+
+
+/** @defgroup VL53L0_init_group VL53L0 Init Functions
+ *  @brief    VL53L0 Init Functions
+ *  @{
+ */
+
+/**
+ * @brief Set new device address
+ *
+ * After completion the device will answer to the new address programmed. This
+ * function should be called when several devices are used in parallel
+ * before start programming the sensor.
+ * When a single device us used, there is no need to call this function.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   DeviceAddress         The new Device address
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetDeviceAddress(VL53L0_DEV Dev,
+			uint8_t DeviceAddress);
+
+/**
+ *
+ * @brief One time device initialization
+ *
+ * To be called once and only once after device is brought out of reset (Chip
+ * enable) and booted see @a VL53L0_WaitDeviceBooted()
+ *
+ * @par Function Description
+ * When not used after a fresh device "power up" or reset, it may return @a
+ * #VL53L0_ERROR_CALIBRATION_WARNING
+ * meaning wrong calibration data may have been fetched from device that can
+ * result in ranging offset error\n
+ * If application cannot execute device reset or need to run VL53L0_DataInit
+ * multiple time
+ * then it  must ensure proper offset calibration saving and restore on its own
+ * by using @a VL53L0_GetOffsetCalibrationData() on first power up and then @a
+ * VL53L0_SetOffsetCalibrationData() in all subsequent init
+ * This function will change the VL53L0_State from VL53L0_STATE_POWERDOWN to
+ * VL53L0_STATE_WAIT_STATICINIT.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_DataInit(VL53L0_DEV Dev);
+
+/**
+ * @brief Do basic device init (and eventually patch loading)
+ * This function will change the VL53L0_State from VL53L0_STATE_WAIT_STATICINIT
+ * to VL53L0_STATE_IDLE.
+ * In this stage all defalut setting will be applied.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_StaticInit(VL53L0_DEV Dev);
+
+/**
+ * @brief Wait for device booted after chip enable (hardware standby)
+ * This function can be run only when VL53L0_State is VL53L0_STATE_POWERDOWN.
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ *
+ */
+VL53L010_API VL53L0_Error VL53L010_WaitDeviceBooted(VL53L0_DEV Dev);
+
+/**
+ * @brief Do an hard reset or soft reset (depending on implementation) of the
+ * device \n
+ * After call of this function, device must be in same state as right after a
+ * power-up sequence.
+ * This function will change the VL53L0_State to VL53L0_STATE_POWERDOWN.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_ResetDevice(VL53L0_DEV Dev);
+
+/** @} VL53L0_init_group */
+
+
+/** @defgroup VL53L0_parameters_group VL53L0 Parameters Functions
+ *  @brief    Functions used to prepare and setup the device
+ *  @{
+ */
+
+/**
+ * @brief  Prepare device for operation
+ * @par Function Description
+ * Update device with provided parameters
+ * @li Then start ranging operation.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceParameters     Pointer to store current device parameters.
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetDeviceParameters(VL53L0_DEV Dev,
+			const VL53L0_DeviceParameters_t *pDeviceParameters);
+
+/**
+ * @brief  Retrieve current device parameters
+ * @par Function Description
+ * Get actual parameters of the device
+ * @li Then start ranging operation.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceParameters     Pointer to store current device parameters.
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetDeviceParameters(VL53L0_DEV Dev,
+			VL53L0_DeviceParameters_t *pDeviceParameters);
+
+/**
+ * @brief  Set a new device mode
+ * @par Function Description
+ * Set device to a new mode (ranging, histogram ...)
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   DeviceMode            New device mode to apply
+ *                                Valid values are:
+ *                                VL53L0_DEVICEMODE_SINGLE_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
+ * (functionality not available)
+ *
+ * @return  VL53L0_ERROR_NONE                   Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
+ * DeviceMode is not in the supported list
+ */
+VL53L010_API VL53L0_Error VL53L010_SetDeviceMode(VL53L0_DEV Dev,
+			VL53L0_DeviceModes DeviceMode);
+
+/**
+ * @brief  Get current new device mode
+ * @par Function Description
+ * Get actual mode of the device(ranging, histogram ...)
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pDeviceMode           Pointer to current apply mode value
+ *                                Valid values are:
+ *                                VL53L0_DEVICEMODE_SINGLE_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_RANGING
+ *                                VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
+ * (functionality not available)
+ *
+ * @return  VL53L0_ERROR_NONE                   Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
+ * DeviceMode is not in the supported list
+ */
+VL53L010_API VL53L0_Error VL53L010_GetDeviceMode(VL53L0_DEV Dev,
+			VL53L0_DeviceModes * pDeviceMode);
+
+/**
+ * @brief  Set a new Histogram mode
+ * @par Function Description
+ * Set device to a new Histogram mode
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   HistogramMode         New device mode to apply
+ *                                Valid values are:
+ *                                VL53L0_HISTOGRAMMODE_DISABLED
+ * @return  VL53L0_ERROR_NONE                   Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
+ * HistogramMode is not in the supported list
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetHistogramMode(VL53L0_DEV Dev,
+			VL53L0_HistogramModes HistogramMode);
+
+/**
+ * @brief  Get current new device mode
+ * @par Function Description
+ * Get current Histogram mode of a Device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   pHistogramMode        Pointer to current Histogram Mode value
+ *                                Valid values are:
+ *                                VL53L0_HISTOGRAMMODE_DISABLED
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetHistogramMode(VL53L0_DEV Dev,
+			VL53L0_HistogramModes * pHistogramMode);
+
+/**
+ * @brief Set Ranging Timing Budget in microseconds
+ *
+ * @par Function Description
+ * Defines the maximum time allowed by the user to the device to run a full
+ * ranging sequence
+ * for the current mode (ranging, histogram, ASL ...)
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                Device Handle
+ * @param MeasurementTimingBudgetMicroSeconds  Max measurement time in
+ * microseconds.
+ *                                             Valid values are:
+ *                                             >= 17000 microseconds when
+ * wraparound is enabled
+ *                                             >= 12000 microseconds when
+ * wraparound is disabled
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS        This error is returned if
+ * MeasurementTimingBudgetMicroSeconds is out of range
+ * @return  "Other error code"                 See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetMeasurementTimingBudgetMicroSeconds(
+			VL53L0_DEV Dev,
+			uint32_t MeasurementTimingBudgetMicroSeconds);
+
+/**
+ * @brief Get Ranging Timing Budget in microseconds
+ *
+ * @par Function Description
+ * Returns the programmed the maximum time allowed by the user to the device to
+ * run a full ranging sequence
+ * for the current mode (ranging, histogram, ASL ...)
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                    Device Handle
+ * @param   pMeasurementTimingBudgetMicroSeconds   Max measurement time in
+ * microseconds.
+ *                                                 Valid values are:
+ *                                                 >= 17000 microseconds when
+ * wraparound is enabled
+ *                                                 >= 12000 microseconds when
+ * wraparound is disabled
+ * @return  VL53L0_ERROR_NONE                      Success
+ * @return  "Other error code"                     See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetMeasurementTimingBudgetMicroSeconds(
+			VL53L0_DEV Dev,
+			uint32_t *pMeasurementTimingBudgetMicroSeconds);
+
+/**
+ * Program continuous mode Inter-Measurement period in milliseconds
+ *
+ * @par Function Description
+ * When trying to set too short time return  INVALID_PARAMS minimal value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                  Device Handle
+ * @param   InterMeasurementPeriodMilliSeconds   Requires Inter-Measurement
+ * Period in milliseconds.
+ * @return  VL53L0_ERROR_NONE                    Success
+ * @return  "Other error code"                   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetInterMeasurementPeriodMilliSeconds(
+			VL53L0_DEV Dev,
+			uint32_t InterMeasurementPeriodMilliSeconds);
+
+/**
+ * Get continuous mode Inter-Measurement period in milliseconds
+ *
+ * @par Function Description
+ * When trying to set too short time return  INVALID_PARAMS minimal value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                                  Device Handle
+ * @param   pInterMeasurementPeriodMilliSeconds  Pointer to programmed
+ * Inter-Measurement Period in milliseconds.
+ * @return  VL53L0_ERROR_NONE                    Success
+ * @return  "Other error code"                   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetInterMeasurementPeriodMilliSeconds(
+			VL53L0_DEV Dev,
+			uint32_t *pInterMeasurementPeriodMilliSeconds);
+
+/**
+ * @brief Enable/Disable Cross talk compensation feature
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                       Device Handle
+ * @param   XTalkCompensationEnable   Cross talk compensation to be set
+ * 0=disabled else = enabled
+ * @return  VL53L0_ERROR_NONE         Success
+ * @return  "Other error code"        See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetXTalkCompensationEnable(
+			VL53L0_DEV Dev, uint8_t XTalkCompensationEnable);
+
+/**
+ * @brief Get Cross talk compensation rate
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                        Device Handle
+ * @param   pXTalkCompensationEnable   Pointer to the Cross talk compensation
+ * state 0=disabled or 1 = enabled
+ * @return  VL53L0_ERROR_NONE          Success
+ * @return  "Other error code"         See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetXTalkCompensationEnable(
+			VL53L0_DEV Dev, uint8_t *pXTalkCompensationEnable);
+
+/**
+ * @brief Set Cross talk compensation rate
+ *
+ * @par Function Description
+ * Set Cross talk compensation rate.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                            Device Handle
+ * @param   XTalkCompensationRateMegaCps   Compensation rate in Mega counts per
+ * second (16.16 fix point) see datasheet for details
+ * @return  VL53L0_ERROR_NONE              Success
+ * @return  "Other error code"             See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetXTalkCompensationRateMegaCps(
+			VL53L0_DEV Dev,
+			FixPoint1616_t XTalkCompensationRateMegaCps);
+
+/**
+ * @brief Get Cross talk compensation rate
+ *
+ * @par Function Description
+ * Get Cross talk compensation rate.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                            Device Handle
+ * @param   pXTalkCompensationRateMegaCps  Pointer to Compensation rate in Mega
+ * counts per second (16.16 fix point) see datasheet for details
+ * @return  VL53L0_ERROR_NONE              Success
+ * @return  "Other error code"             See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetXTalkCompensationRateMegaCps(
+			VL53L0_DEV Dev,
+			FixPoint1616_t *pXTalkCompensationRateMegaCps);
+
+
+/**
+ * @brief  Get the number of the check limit managed by a given Device
+ *
+ * @par Function Description
+ * This function give the number of the check limit managed by the Device
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   pNumberOfLimitCheck           Pointer to the number of check limit.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetNumberOfLimitCheck(
+			uint16_t *pNumberOfLimitCheck);
+
+/**
+ * @brief  Return a description string for a given limit check number
+ *
+ * @par Function Description
+ * This function returns a description string for a given limit check number.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckString             Pointer to the description string of
+ * the given check limit.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetLimitCheckInfo(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, char *pLimitCheckString);
+
+
+/**
+ * @brief  Enable/Disable a specific limit check
+ *
+ * @par Function Description
+ * This function Enable/Disable a specific limit check.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckEnable              if 1 the check limit corresponding to
+ * LimitCheckId is Enabled
+ *                                        if 0 the check limit corresponding to
+ * LimitCheckId is disabled
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetLimitCheckEnable(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, uint8_t LimitCheckEnable);
+
+
+/**
+ * @brief  Get specific limit check enable state
+ *
+ * @par Function Description
+ * This function get the enable state of a specific limit check.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckEnable             Pointer to the check limit enable
+ * value.
+ *                                        if 1 the check limit corresponding to
+ * LimitCheckId is Enabled
+ *                                        if 0 the check limit corresponding to
+ * LimitCheckId is disabled
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetLimitCheckEnable(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, uint8_t *pLimitCheckEnable);
+
+/**
+ * @brief  Set a specific limit check value
+ *
+ * @par Function Description
+ * This function set a specific limit check value.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckValue               Limit check Value for a given
+ * LimitCheckId
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when either
+ * LimitCheckId or LimitCheckValue value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetLimitCheckValue(VL53L0_DEV Dev,
+			uint16_t LimitCheckId, FixPoint1616_t LimitCheckValue);
+
+/**
+ * @brief  Get a specific limit check value
+ *
+ * @par Function Description
+ * This function get a specific limit check value from device then it updates
+ * internal values and check enables.
+ * The limit check is identified with the LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckValue              Pointer to Limit check Value for a
+ * given LimitCheckId.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetLimitCheckValue(VL53L0_DEV Dev,
+			uint16_t LimitCheckId,
+			FixPoint1616_t *pLimitCheckValue);
+
+
+/**
+ * @brief  Get the current value of the signal used for the limit check
+ *
+ * @par Function Description
+ * This function get a the current value of the signal used for the limit check.
+ * To obtain the latest value you should run a ranging before.
+ * The value reported is linked to the limit check identified with the
+ * LimitCheckId.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
+ * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckCurrent            Pointer to current Value for a
+ * given LimitCheckId.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
+ * LimitCheckId value is out of range.
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetLimitCheckCurrent(VL53L0_DEV Dev,
+		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckCurrent);
+
+/**
+ * @brief  Enable (or disable) Wrap around Check
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                    Device Handle
+ * @param   WrapAroundCheckEnable  Wrap around Check to be set 0=disabled,
+ * other = enabled
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"     See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetWrapAroundCheckEnable(VL53L0_DEV Dev,
+			uint8_t WrapAroundCheckEnable);
+
+/**
+ * @brief  Get setup of Wrap around Check
+ *
+ * @par Function Description
+ * This function get the wrapAround check enable parameters
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                     Device Handle
+ * @param   pWrapAroundCheckEnable  Pointer to the Wrap around Check state
+ * 0=disabled or 1 = enabled
+ * @return  VL53L0_ERROR_NONE       Success
+ * @return  "Other error code"      See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetWrapAroundCheckEnable(VL53L0_DEV Dev,
+			uint8_t *pWrapAroundCheckEnable);
+
+/** @} VL53L0_parameters_group */
+
+
+/** @defgroup VL53L0_measurement_group VL53L0 Measurement Functions
+ *  @brief    Functions used for the measurements
+ *  @{
+ */
+
+/**
+ * @brief Single shot measurement.
+ *
+ * @par Function Description
+ * Perform simple measurement sequence (Start measure, Wait measure to end, and
+ * returns when measurement is done).
+ * Once function returns, user can get valid data by calling
+ * VL53L0_GetRangingMeasurement or VL53L0_GetHistogramMeasurement depending on
+ * defined measurement mode
+ * User should Clear the interrupt in case this are enabled by using the
+ * function VL53L0_ClearInterruptMask().
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_PerformSingleMeasurement(VL53L0_DEV Dev);
+
+/**
+ * @brief Perform Reference Calibration
+ *
+ * @details Perform a reference calibration of the Device.
+ * This function should be run from time to time before doing a ranging
+ * measurement.
+ * This function will launch a special ranging measurement, so if interrupt are
+ * enable an interrupt will be done.
+ * This function will clear the interrupt generated automatically.
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_PerformRefCalibration(VL53L0_DEV Dev);
+
+/**
+ * @brief Perform XTalk Calibration
+ *
+ * @details Perform a XTalk calibration of the Device.
+ * This function will launch a ranging measurement, if interrupts are enabled
+ * an interrupt will be done.
+ * This function will clear the interrupt generated automatically.
+ * This function will program a new value for the XTalk compensation and it
+ * will enable the cross talk before exit.
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @note This function change the device mode to
+ * VL53L0_DEVICEMODE_SINGLE_RANGING
+ *
+ * @param   Dev                  Device Handle
+ * @param   XTalkCalDistance               XTalkCalDistance value used for the
+ * XTalk computation.
+ * @param   pXTalkCompensationRateMegaCps  Pointer to new XTalkCompensation
+ * value.
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_PerformXTalkCalibration(VL53L0_DEV Dev,
+			FixPoint1616_t XTalkCalDistance,
+			FixPoint1616_t *pXTalkCompensationRateMegaCps);
+
+/**
+ * @brief Perform Offset Calibration
+ *
+ * @details Perform a Offset calibration of the Device.
+ * This function will launch a ranging measurement, if interrupts are 
+ * enabled an interrupt will be done.
+ * This function will clear the interrupt generated automatically.
+ * This function will program a new value for the Offset calibration value and
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @note This function does not change the device mode.
+ *
+ * @param   Dev                  Device Handle
+ * @param   CalDistanceMilliMeter     Calibration distance value used for the
+ * offset compensation.
+ * @param   pOffsetMicroMeter  Pointer to new Offset value computed by the
+ * function.
+ *
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,
+            FixPoint1616_t CalDistanceMilliMeter, int32_t* pOffsetMicroMeter);
+
+/**
+ * @brief Start device measurement
+ *
+ * @details Started measurement will depend on device parameters set through @a
+ * VL53L0_SetParameters()
+ * This is a non-blocking function
+ * This function will change the VL53L0_State from VL53L0_STATE_IDLE to
+ * VL53L0_STATE_RUNNING.
+ *
+ * @note This function Access to the device
+ *
+
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE                  Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED    This error occurs when
+ * DeviceMode programmed with @a VL53L0_SetDeviceMode is not in the supported
+ * list:
+ *                                             Supported mode are:
+ * VL53L0_DEVICEMODE_SINGLE_RANGING, VL53L0_DEVICEMODE_CONTINUOUS_RANGING,
+ * VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ * @return  VL53L0_ERROR_TIME_OUT    Time out on start measurement
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_StartMeasurement(VL53L0_DEV Dev);
+
+/**
+ * @brief Stop device measurement
+ *
+ * @details Will set the device in standby mode at end of current measurement \n
+ *          Not necessary in single mode as device shall return automatically
+ * in standby mode at end of measurement.
+ *          This function will change the VL53L0_State from
+ * VL53L0_STATE_RUNNING to VL53L0_STATE_IDLE.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_StopMeasurement(VL53L0_DEV Dev);
+
+/**
+ * @brief Return Measurement Data Ready
+ *
+ * @par Function Description
+ * This function indicate that a measurement data is ready.
+ * This function check if interrupt mode is used then check is done accordingly.
+ * If perform function clear the interrupt, this function will not work, like
+ * in case of @a VL53L0_PerformSingleRangingMeasurement().
+ * The previous function is blocking function, VL53L0_GetMeasurementDataReady
+ * is used for non-blocking capture.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                    Device Handle
+ * @param   pMeasurementDataReady  Pointer to Measurement Data Ready. 0=data
+ * not ready, 1 = data ready
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"     See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetMeasurementDataReady(VL53L0_DEV Dev,
+			uint8_t *pMeasurementDataReady);
+
+/**
+ * @brief Wait for device ready for a new measurement command. Blocking
+ * function.
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev      Device Handle
+ * @param   MaxLoop    Max Number of polling loop (timeout).
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L010_API VL53L0_Error VL53L010_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev,
+			uint32_t MaxLoop);
+
+
+/**
+ * @brief Retrieve the measurements from device for a given setup
+ *
+ * @par Function Description
+ * Get data from last successful Ranging measurement
+ * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() before
+ * get data.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure used
+ * in the measurement function.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                      Device Handle
+ * @param   pRangingMeasurementData  Pointer to the data structure to fill up.
+ * @return  VL53L0_ERROR_NONE        Success
+ * @return  "Other error code"       See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetRangingMeasurementData(VL53L0_DEV Dev,
+		VL53L0_RangingMeasurementData_t *pRangingMeasurementData);
+
+/**
+ * @brief Retrieve the measurements from device for a given setup
+ *
+ * @par Function Description
+ * Get data from last successful Histogram measurement
+ * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() before
+ * get data.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure used
+ * in the measurement function.
+ * @note This function is not Implemented
+ * @param   Dev    			            Device Handle
+ * @param	pHistogramMeasurementData	Pointer to the data structure to fill
+ * up.
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L010_API VL53L0_Error VL53L010_GetHistogramMeasurementData(VL53L0_DEV Dev,
+		VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData);
+
+/**
+ * @brief Performs a single ranging measurement and retrieve the ranging
+ * measurement data
+ *
+ * @par Function Description
+ * This function will change the device mode to
+ * VL53L0_DEVICEMODE_SINGLE_RANGING with @a VL53L0_SetDeviceMode(),
+ * It performs measurement with @a VL53L0_PerformSingleMeasurement()
+ * It get data from last successful Ranging measurement with @a
+ * VL53L0_GetRangingMeasurementData.
+ * Finally it clear the interrupt with @a VL53L0_ClearInterruptMask().
+ * @note This function Access to the device
+ *
+ * @note This function change the device mode to
+ * VL53L0_DEVICEMODE_SINGLE_RANGING
+ *
+ * @param   Dev    			          Device Handle
+ * @param   pRangingMeasurementData   Pointer to the data structure to fill up.
+ * @return  VL53L0_ERROR_NONE         Success
+ * @return  "Other error code"        See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_PerformSingleRangingMeasurement(VL53L0_DEV Dev,
+		VL53L0_RangingMeasurementData_t *pRangingMeasurementData);
+
+/**
+ * @brief Performs a single histogram measurement and retrieve the histogram
+ * measurement data
+ *        Is equivalent to VL53L0_PerformSingleMeasurement +
+ * VL53L0_GetHistogramMeasurementData
+ *
+ * @par Function Description
+ * Get data from last successful Ranging measurement.
+ * This function will clear the interrupt in case of these are enabled.
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev    			            Device Handle
+ * @param   pHistogramMeasurementData	Pointer to the data structure to fill
+ * up.
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L010_API VL53L0_Error VL53L010_PerformSingleHistogramMeasurement(
+		VL53L0_DEV Dev,
+		VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData);
+
+
+
+/**
+ * @brief Set the number of ROI Zones to be used for a specific Device
+ *
+ * @par Function Description
+ * Set the number of ROI Zones to be used for a specific Device.
+ * The programmed value should be less than the max number of ROI Zones given
+ * with  @a VL53L0_GetMaxNumberOfROIZones().
+ * This version of API manage only one zone.
+ *
+ * @param   Dev    			            Device Handle
+ * @param   NumberOfROIZones            Number of ROI Zones to be used for a
+ * specific Device.
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned if
+ * NumberOfROIZones != 1
+ */
+VL53L010_API VL53L0_Error VL53L010_SetNumberOfROIZones(VL53L0_DEV Dev,
+			uint8_t NumberOfROIZones);
+
+/**
+ * @brief Get the number of ROI Zones managed by the Device
+ *
+ * @par Function Description
+ * Get number of ROI Zones managed by the Device
+ * USER should take care about  @a VL53L0_GetNumberOfROIZones() before get data
+ * after a perform measurement.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure used
+ * in the measurement function.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev    			            Device Handle
+ * @param   pNumberOfROIZones           Pointer to the Number of ROI Zones
+ * value.
+ * @return  VL53L0_ERROR_NONE           Success
+ */
+VL53L010_API VL53L0_Error VL53L010_GetNumberOfROIZones(VL53L0_DEV Dev,
+			uint8_t *pNumberOfROIZones);
+
+/**
+ * @brief Get the Maximum number of ROI Zones managed by the Device
+ *
+ * @par Function Description
+ * Get Maximum number of ROI Zones managed by the Device.
+ *
+ * @note This function doesn't Access to the device
+ *
+ * @param   Dev    			            Device Handle
+ * @param   pMaxNumberOfROIZones        Pointer to the Maximum Number of ROI
+ * Zones value.
+ * @return  VL53L0_ERROR_NONE           Success
+ */
+VL53L010_API VL53L0_Error VL53L010_GetMaxNumberOfROIZones(VL53L0_DEV Dev,
+			uint8_t *pMaxNumberOfROIZones);
+
+
+/** @} VL53L0_measurement_group */
+
+
+/** @defgroup VL53L0_interrupt_group VL53L0 Interrupt Functions
+ *  @brief    Functions used for interrupt managements
+ *  @{
+ */
+
+/**
+ * @brief Set the configuration of GPIO pin for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Pin                   ID of the GPIO Pin
+ * @param   Functionality         Select Pin functionality. Refer to
+ * ::VL53L0_GpioFunctionality
+ * @param   DeviceMode            Device Mode associated to the Gpio.
+ * @param   Polarity              Set interrupt polarity. Active high or active
+ * low see ::VL53L0_InterruptPolarity
+ * @return  VL53L0_ERROR_NONE                                Success
+ * @return  VL53L0_ERROR_GPIO_NOT_EXISTING                   Only Pin=0 is
+ * accepted.
+ * @return  VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED    This error occurs
+ * when Functionality programmed is not in the supported list:
+ * Supported value
+ * are:
+ *
+ * VL53L0_GPIOFUNCTIONALITY_OFF, VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT,
+ *
+ * VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+				VL53L0_DeviceModes DeviceMode,
+				VL53L0_GpioFunctionality Functionality,
+				VL53L0_InterruptPolarity Polarity);
+
+
+/**
+ * @brief Get current configuration for GPIO pin for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @param   Pin                   ID of the GPIO Pin
+ * @param   pDeviceMode           Pointer to Device Mode associated to the Gpio.
+ * @param   pFunctionality        Pointer to Pin functionality.
+ * Refer to ::VL53L0_GpioFunctionality
+ * @param   pPolarity             Pointer to interrupt polarity. Active high or
+ * active low see ::VL53L0_InterruptPolarity
+ * @return  VL53L0_ERROR_NONE                            Success
+ * @return  VL53L0_ERROR_GPIO_NOT_EXISTING               Only Pin=0 is accepted.
+ * @return  VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED    This error occurs
+ * when Functionality programmed is not in the supported list:
+ * Supported value are:
+ * VL53L0_GPIOFUNCTIONALITY_OFF, VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+ * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT,
+ * VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+			VL53L0_DeviceModes * pDeviceMode,
+			VL53L0_GpioFunctionality * pFunctionality,
+			VL53L0_InterruptPolarity * pPolarity);
+
+/**
+ * @brief Set low and high Interrupt thresholds for a given mode (ranging, ALS,
+ * ...) for a given device
+ *
+ * @par Function Description
+ * Set low and high Interrupt thresholds for a given mode (ranging, ALS, ...)
+ * for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @note DeviceMode is ignored for the current device
+ *
+ * @param   Dev                  Device Handle
+ * @param   DeviceMode           Device Mode for which change thresholds
+ * @param   ThresholdLow         Low threshold (mm, lux ..., depending on the
+ * mode)
+ * @param   ThresholdHigh        High threshold (mm, lux ..., depending on the
+ * mode)
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetInterruptThresholds(VL53L0_DEV Dev,
+			VL53L0_DeviceModes DeviceMode,
+			FixPoint1616_t ThresholdLow,
+			FixPoint1616_t ThresholdHigh);
+
+/**
+ * @brief  Get high and low Interrupt thresholds for a given mode (ranging,
+ * ALS, ...) for a given device
+ *
+ * @par Function Description
+ * Get high and low Interrupt thresholds for a given mode (ranging, ALS, ...)
+ * for a given device
+ *
+ * @note This function Access to the device
+ *
+ * @note DeviceMode is ignored for the current device
+ *
+ * @param   Dev                 Device Handle
+ * @param   DeviceMode          Device Mode from which read thresholds
+ * @param   pThresholdLow       Low threshold (mm, lux ..., depending on the
+ * mode)
+ * @param   pThresholdHigh      High threshold (mm, lux ..., depending on the
+ * mode)
+ * @return  VL53L0_ERROR_NONE   Success
+ * @return  "Other error code"  See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetInterruptThresholds(VL53L0_DEV Dev,
+			VL53L0_DeviceModes DeviceMode,
+			FixPoint1616_t *pThresholdLow,
+			FixPoint1616_t *pThresholdHigh);
+
+/**
+ * @brief Clear given system interrupt condition
+ *
+ * @par Function Description
+ * Clear given interrupt(s).
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                  Device Handle
+ * @param   InterruptMask        Mask of interrupts to clear
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_ClearInterruptMask(VL53L0_DEV Dev,
+			uint32_t InterruptMask);
+
+/**
+ * @brief Return device interrupt status
+ *
+ * @par Function Description
+ * Returns currently raised interrupts by the device.
+ * User shall be able to activate/deactivate interrupts through
+ * @a VL53L0_SetGpioConfig()
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                    Device Handle
+ * @param   pInterruptMaskStatus   Pointer to status variable to update
+ * @return  VL53L0_ERROR_NONE      Success
+ * @return  "Other error code"     See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetInterruptMaskStatus(VL53L0_DEV Dev,
+			uint32_t *pInterruptMaskStatus);
+
+
+/**
+ * @brief Configure ranging interrupt reported to system
+ *
+ * @note This function is not Implemented
+ *
+ * @param   Dev    			     Device Handle
+ * @param	InterruptMask		Mask of interrupt to Enable/disable
+ * (0:interrupt disabled or 1: interrupt enabled)
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
+ */
+VL53L010_API VL53L0_Error VL53L010_EnableInterruptMask(VL53L0_DEV Dev,
+			uint32_t InterruptMask);
+
+
+/** @} VL53L0_interrupt_group */
+
+
+/** @defgroup VL53L0_SPADfunctions_group VL53L0 SPAD Functions
+ *  @brief    Functions used for SPAD managements
+ *  @{
+ */
+
+
+
+/**
+ * @brief  Set the SPAD Ambient Damper Threshold value
+ *
+ * @par Function Description
+ * This function set the SPAD Ambient Damper Threshold value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   SpadAmbientDamperThreshold    SPAD Ambient Damper Threshold value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetSpadAmbientDamperThreshold(VL53L0_DEV Dev,
+					uint16_t SpadAmbientDamperThreshold);
+
+/**
+ * @brief  Get the current SPAD Ambient Damper Threshold value
+ *
+ * @par Function Description
+ * This function get the SPAD Ambient Damper Threshold value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   pSpadAmbientDamperThreshold   Pointer to programmed SPAD Ambient
+ * Damper Threshold value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetSpadAmbientDamperThreshold(VL53L0_DEV Dev,
+					uint16_t *pSpadAmbientDamperThreshold);
+
+
+/**
+ * @brief  Set the SPAD Ambient Damper Factor value
+ *
+ * @par Function Description
+ * This function set the SPAD Ambient Damper Factor value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   SpadAmbientDamperFactor       SPAD Ambient Damper Factor value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_SetSpadAmbientDamperFactor(VL53L0_DEV Dev,
+					uint16_t SpadAmbientDamperFactor);
+
+/**
+ * @brief  Get the current SPAD Ambient Damper Factor value
+ *
+ * @par Function Description
+ * This function get the SPAD Ambient Damper Factor value
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                           Device Handle
+ * @param   pSpadAmbientDamperFactor      Pointer to programmed SPAD Ambient
+ * Damper Factor value
+ * @return  VL53L0_ERROR_NONE             Success
+ * @return  "Other error code"            See ::VL53L0_Error
+ */
+VL53L010_API VL53L0_Error VL53L010_GetSpadAmbientDamperFactor(VL53L0_DEV Dev,
+				   uint16_t *pSpadAmbientDamperFactor);
+
+
+/** @} VL53L0_SPADfunctions_group */
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VL53L010_API_H_ */
diff --git a/drivers/input/misc/vl53L0/inc/vl53l010_device.h b/drivers/input/misc/vl53L0/inc/vl53l010_device.h
new file mode 100644
index 00000000000..f1a9852c79b
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l010_device.h
@@ -0,0 +1,226 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+/**
+ * Device specific defines. To be adapted by implementer for the targeted device.
+ */
+
+#ifndef _VL53L010_DEVICE_H_
+#define _VL53L010_DEVICE_H_
+
+#include "vl53l0_types.h"
+
+
+/** @defgroup VL53L010_DeviceError_group Device Error
+ *  @brief Device Error code
+ *
+ *  This enum is Device specific it should be updated in the implementation
+ *  Use @a VL53L010_GetStatusErrorString() to get the string.
+ *  It is related to Status Register of the Device.
+ *  @ingroup regdef
+ *  @{
+ */
+typedef uint8_t VL53L010_DeviceError;
+
+#define VL53L010_DEVICEERROR_NONE ((VL53L010_DeviceError)   0)
+#define VL53L010_DEVICEERROR_VCSELCONTINUITYTESTFAILURE ((VL53L010_DeviceError) 1)
+#define VL53L010_DEVICEERROR_VCSELWATCHDOGTESTFAILURE ((VL53L010_DeviceError)   2)
+#define VL53L010_DEVICEERROR_NOVHVVALUEFOUND ((VL53L010_DeviceError)   3)
+#define VL53L010_DEVICEERROR_MSRCNOTARGET ((VL53L010_DeviceError)   4)
+#define VL53L010_DEVICEERROR_MSRCMINIMUMSNR  ((VL53L010_DeviceError)   5)
+#define VL53L010_DEVICEERROR_MSRCWRAPAROUND ((VL53L010_DeviceError)   6)
+#define VL53L010_DEVICEERROR_TCC ((VL53L010_DeviceError)   7)
+#define VL53L010_DEVICEERROR_RANGEAWRAPAROUND ((VL53L010_DeviceError)   8)
+#define VL53L010_DEVICEERROR_RANGEBWRAPAROUND ((VL53L010_DeviceError)   9)
+#define VL53L010_DEVICEERROR_MINCLIP ((VL53L010_DeviceError)   10)
+#define VL53L010_DEVICEERROR_RANGECOMPLETE ((VL53L010_DeviceError)   11)
+#define VL53L010_DEVICEERROR_ALGOUNDERFLOW ((VL53L010_DeviceError)   12)
+#define VL53L010_DEVICEERROR_ALGOOVERFLOW ((VL53L010_DeviceError)   13)
+#define VL53L010_DEVICEERROR_FINALSNRLIMIT ((VL53L010_DeviceError)   14)
+#define VL53L010_DEVICEERROR_NOTARGETIGNORE ((VL53L010_DeviceError)   15)
+
+/** @} */ /* end of VL53L010_DeviceError_group */
+
+/** @defgroup VL53L010_CheckEnable_group Check Enable list
+ *  @brief Check Enable code
+ *
+ *  Define used to specify the LimitCheckId.
+ *  Use @a VL53L010_GetLimitCheckInfo() to get the string.
+ *  @ingroup regdef
+ *  @{
+ */
+
+#define VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE           0
+#define VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE     1
+#define VL53L010_CHECKENABLE_NUMBER_OF_CHECKS            2
+
+/** @} */ /* end of VL53L010_CheckEnable_group */
+
+
+/** @defgroup VL53L010_GpioFunctionality_group Gpio Functionality
+ *  @brief Defines the different functionalities for the device GPIO(s)
+ *  @ingroup regdef
+ *  @{
+ */
+typedef uint8_t VL53L010_GpioFunctionality;
+
+#define VL53L010_GPIOFUNCTIONALITY_OFF                         ((VL53L010_GpioFunctionality)  0) /*!< NO Interrupt  */
+#define VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW       ((VL53L010_GpioFunctionality)  1) /*!< Level Low (value < thresh_low)  */
+#define VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH      ((VL53L010_GpioFunctionality)  2) /*!< Level High (value > thresh_high)  */
+#define VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT       ((VL53L010_GpioFunctionality)  3) /*!< Out Of Window (value < thresh_low OR value > thresh_high)  */
+#define VL53L010_GPIOFUNCTIONALITY_NEW_MEASURE_READY           ((VL53L010_GpioFunctionality)  4) /*!< New Sample Ready  */
+
+/** @} */ /* end of VL53L010_GpioFunctionality_group */
+
+
+
+/* Device register map */
+
+/** @defgroup VL53L010_DefineRegisters_group Define Registers
+ *  @brief List of all the defined registers
+ *  @ingroup regdef
+ *  @{
+ */
+#define VL53L010_REG_SYSRANGE_START                        0x000
+    /** mask existing bit in #VL53L010_REG_SYSRANGE_START*/
+    #define VL53L010_REG_SYSRANGE_MODE_MASK          0x0F
+    /** bit 0 in #VL53L010_REG_SYSRANGE_START write 1 toggle state in
+		continuous mode and arm next shot in single shot mode */
+    #define VL53L010_REG_SYSRANGE_MODE_START_STOP    0x01
+    /** bit 1 write 0 in #VL53L010_REG_SYSRANGE_START set single shot mode */
+    #define VL53L010_REG_SYSRANGE_MODE_SINGLESHOT    0x00
+	/** bit 1 write 1 in #VL53L010_REG_SYSRANGE_START set back-to-back
+		operation mode */
+    #define VL53L010_REG_SYSRANGE_MODE_BACKTOBACK    0x02
+	/** bit 2 write 1 in #VL53L010_REG_SYSRANGE_START set timed operation
+		mode */
+	#define VL53L010_REG_SYSRANGE_MODE_TIMED         0x04
+	/** bit 3 write 1 in #VL53L010_REG_SYSRANGE_START set histogram
+		operation mode */
+	#define VL53L010_REG_SYSRANGE_MODE_HISTOGRAM     0x08
+
+
+#define VL53L010_REG_SYSTEM_THRESH_HIGH               0x000C  /* NOSLC  2 bytes */
+#define VL53L010_REG_SYSTEM_THRESH_LOW                0x000E  /* NOSLC  2 bytes */
+
+
+/* FPGA bitstream */
+#define VL53L010_REG_SYSTEM_SEQUENCE_CONFIG			0x0001
+#define VL53L010_REG_SYSTEM_INTERMEASUREMENT_PERIOD	0x0004
+
+#define VL53L010_REG_SYSTEM_REPORT_REQUEST	        0x0009
+	#define	VL53L010_REG_SYSTEM_RANGEA_DATA			0x04
+	#define	VL53L010_REG_SYSTEM_RANGEB_DATA			0x05
+
+#define VL53L010_REG_SYSTEM_INTERRUPT_CONFIG_GPIO     0x000A
+	#define VL53L010_REG_SYSTEM_INTERRUPT_GPIO_DISABLED		0x00
+	#define VL53L010_REG_SYSTEM_INTERRUPT_GPIO_LEVEL_LOW		0x01
+	#define VL53L010_REG_SYSTEM_INTERRUPT_GPIO_LEVEL_HIGH	0x02
+	#define VL53L010_REG_SYSTEM_INTERRUPT_GPIO_OUT_OF_WINDOW	0x03
+	#define VL53L010_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY	0x04
+
+#define VL53L010_REG_GPIO_HV_MUX_ACTIVE_HIGH          0x0084
+
+#define VL53L010_REG_SYSTEM_INTERRUPT_CLEAR	0x000B
+
+/* Result registers */
+#define VL53L010_REG_RESULT_INTERRUPT_STATUS		    0x0013
+#define VL53L010_REG_RESULT_RANGE_STATUS		        0x0014
+
+#define VL53L010_REG_RESULT_SIGNAL_COUNT_RATE_RET     0x001A
+#define VL53L010_REG_RESULT_AMBIENT_COUNT_RATE_RET    0x001C
+#define VL53L010_REG_RESULT_FINAL_RANGE		        0x001E
+
+/* Algo register */
+#define VL53L010_REG_ALGO_CROSSTALK_COMPENSATION_RATE	0x0020
+#define VL53L010_REG_ALGO_RANGE_IGNORE_VALID_HEIGHT	0x0025
+#define VL53L010_REG_ALGO_RANGE_IGNORE_THRESHOLD		0x0026
+#define VL53L010_REG_ALGO_SNR_RATIO					0x0027
+#define VL53L010_REG_ALGO_RANGE_CHECK_ENABLES		    0x0028
+
+#define VL53L010_REG_ALGO_PART_TO_PART_RANGE_OFFSET	0x0029
+
+#define VL53L010_REG_I2C_SLAVE_DEVICE_ADDRESS	        0x008a
+
+/* MSRC registers */
+#define VL53L010_REG_MSRC_CONFIG_COUNT		        0x0044
+#define VL53L010_REG_MSRC_CONFIG_TIMEOUT		        0x0046
+#define VL53L010_REG_MSRC_CONFIG_MIN_SNR		        0x0055
+#define VL53L010_REG_MSRC_CONFIG_VALID_PHASE_LOW	    0x0047
+#define VL53L010_REG_MSRC_CONFIG_VALID_PHASE_HIGH     0x0048
+
+/* RANGE A registers */
+#define VL53L010_REG_RNGA_CONFIG_VCSEL_PERIOD	0x0050
+#define VL53L010_REG_RNGA_TIMEOUT_MSB			0x0051
+#define VL53L010_REG_RNGA_TIMEOUT_LSB			0x0052
+#define VL53L010_REG_RNGA_CONFIG_VALID_PHASE_LOW	0x0056
+#define VL53L010_REG_RNGA_CONFIG_VALID_PHASE_HIGH	0x0057
+
+/* RANGE B1 registers */
+#define VL53L010_REG_RNGB1_CONFIG_VCSEL_PERIOD	0x0060
+#define VL53L010_REG_RNGB1_TIMEOUT_MSB			0x0061
+#define VL53L010_REG_RNGB1_TIMEOUT_LSB			0x0062
+#define VL53L010_REG_RNGB1_CONFIG_VALID_PHASE_LOW	0x0066
+#define VL53L010_REG_RNGB1_CONFIG_VALID_PHASE_HIGH	0x0067
+
+/* RANGE B2 registers */
+#define VL53L010_REG_RNGB2_CONFIG_VCSEL_PERIOD	0x0070
+#define VL53L010_REG_RNGB2_TIMEOUT_MSB			0x0071
+#define VL53L010_REG_RNGB2_TIMEOUT_LSB			0x0072
+#define VL53L010_REG_RNGB2_CONFIG_VALID_PHASE_LOW	0x0076
+#define VL53L010_REG_RNGB2_CONFIG_VALID_PHASE_HIGH	0x0077
+
+
+#define VL53L010_REG_SOFT_RESET_GO2_SOFT_RESET_N	  0x00bf
+#define VL53L010_REG_IDENTIFICATION_MODEL_ID        0x00c0
+#define VL53L010_REG_IDENTIFICATION_REVISION_ID     0x00c2
+#define VL53L010_REG_IDENTIFICATION_MODULE_ID       0x00c3
+
+#define VL53L010_REG_OSC_CALIBRATE_VAL              0x00f8
+
+#define VL53L010_REG_FIRMWARE_MODE_STATUS		           0x00C5
+
+#define VL53L010_REG_DYNAMIC_SPAD_ACTUAL_RTN_SPADS_INT   0x0016
+
+#define VL53L010_SIGMA_ESTIMATE_MAX_VALUE                65535
+/*equivalent to a range sigma of 655.35mm */
+
+/*
+ * Speed of light in um per 1E-10 Seconds
+ */
+
+#define VL53L010_SPEED_OF_LIGHT_IN_AIR 2997
+
+
+/** @} */ /* end of VL53L010_DefineRegisters_group */
+
+#endif
+
+/* _VL53L010_DEVICE_H_ */
+
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l010_strings.h b/drivers/input/misc/vl53L0/inc/vl53l010_strings.h
new file mode 100644
index 00000000000..e981ea826f1
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l010_strings.h
@@ -0,0 +1,100 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+
+/*
+ * @file vl53l0_string.h
+ * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * $Revision: 1906 $
+ */
+
+#ifndef VL53L010_STRINGS_H_
+#define VL53L010_STRINGS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    #define  VL53L010_STRING_DEVICE_INFO_NAME                                 "VL53L0 cut1.0"
+    #define  VL53L010_STRING_DEVICE_INFO_NAME_TS0                             "VL53L0 TS0"
+    #define  VL53L010_STRING_DEVICE_INFO_NAME_TS1                             "VL53L0 TS1"
+    #define  VL53L010_STRING_DEVICE_INFO_NAME_TS2                             "VL53L0 TS2"
+    #define  VL53L010_STRING_DEVICE_INFO_NAME_ES1                             "VL53L0 ES1 or later"
+    #define  VL53L010_STRING_DEVICE_INFO_TYPE                                 "VL53L0"
+
+    /* PAL ERROR strings */
+    #define  VL53L010_STRING_ERROR_NONE                                       "No Error"
+    #define  VL53L010_STRING_ERROR_CALIBRATION_WARNING                        "Calibration Warning Error"
+    #define  VL53L010_STRING_ERROR_MIN_CLIPPED                                "Min clipped error"
+    #define  VL53L010_STRING_ERROR_UNDEFINED                                  "Undefined error"
+    #define  VL53L010_STRING_ERROR_INVALID_PARAMS                             "Invalid parameters error"
+    #define  VL53L010_STRING_ERROR_NOT_SUPPORTED                              "Not supported error"
+    #define  VL53L010_STRING_ERROR_RANGE_ERROR                                "Range error"
+    #define  VL53L010_STRING_ERROR_TIME_OUT                                   "Time out error"
+    #define  VL53L010_STRING_ERROR_MODE_NOT_SUPPORTED                         "Mode not supported error"
+    #define  VL53L010_STRING_ERROR_NOT_IMPLEMENTED                            "Not implemented error"
+
+    #define  VL53L010_STRING_UNKNOW_ERROR_CODE                                "Unknow Error Code"
+    #define  VL53L010_STRING_ERROR_BUFFER_TOO_SMALL                           "Buffer too small"
+
+    #define  VL53L010_STRING_ERROR_GPIO_NOT_EXISTING                          "GPIO not existing"
+    #define  VL53L010_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED           "GPIO functionality not supported"
+    #define  VL53L010_STRING_ERROR_CONTROL_INTERFACE                          "Control Interface Error"
+
+
+    /* Device Specific */
+    #define  VL53L010_STRING_DEVICEERROR_NONE                                 "No Update"
+    #define  VL53L010_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE           "VCSEL Continuity Test Failure"
+    #define  VL53L010_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE             "VCSEL Watchdog Test Failure"
+    #define  VL53L010_STRING_DEVICEERROR_NOVHVVALUEFOUND                      "No VHV Value found"
+    #define  VL53L010_STRING_DEVICEERROR_MSRCNOTARGET                         "MSRC No Target Error"
+    #define  VL53L010_STRING_DEVICEERROR_MSRCMINIMUMSNR                       "MSRC Minimum SNR Error"
+    #define  VL53L010_STRING_DEVICEERROR_MSRCWRAPAROUND                       "MSRC Wraparound Error"
+    #define  VL53L010_STRING_DEVICEERROR_TCC                                  "TCC Error"
+    #define  VL53L010_STRING_DEVICEERROR_RANGEAWRAPAROUND                     "Range A Wraparound Error"
+    #define  VL53L010_STRING_DEVICEERROR_RANGEBWRAPAROUND                     "Range B Wraparound Error"
+    #define  VL53L010_STRING_DEVICEERROR_MINCLIP                              "Min Clip Error"
+    #define  VL53L010_STRING_DEVICEERROR_RANGECOMPLETE                        "Range Complete"
+    #define  VL53L010_STRING_DEVICEERROR_ALGOUNDERFLOW                        "Range Algo Underflow Error"
+    #define  VL53L010_STRING_DEVICEERROR_ALGOOVERFLOW                         "Range Algo Overlow Error"
+    #define  VL53L010_STRING_DEVICEERROR_FINALSNRLIMIT                        "Final Minimum SNR Error"
+    #define  VL53L010_STRING_DEVICEERROR_NOTARGETIGNORE                       "No Target Ignore Error"
+    #define  VL53L010_STRING_DEVICEERROR_UNKNOWN                              "Unknown error code"
+
+
+    /* Check Enable */
+    #define  VL53L010_STRING_CHECKENABLE_SIGMA                                "SIGMA"
+    #define  VL53L010_STRING_CHECKENABLE_SIGNAL_RATE                          "SIGNAL RATE"
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/drivers/input/misc/vl53L0/inc/vl53l010_tuning.h b/drivers/input/misc/vl53L0/inc/vl53l010_tuning.h
new file mode 100644
index 00000000000..8951209f0b4
--- /dev/null
+++ b/drivers/input/misc/vl53L0/inc/vl53l010_tuning.h
@@ -0,0 +1,65 @@
+/*******************************************************************************
+Copyright © 2015, STMicroelectronics International N.V.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of STMicroelectronics nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*******************************************************************************/
+/*
+ * @file vl53l0_api.h
+ * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * $Revision: 1906 $
+ */
+
+
+
+#ifndef _VL53L010_TUNING_H_
+#define _VL53L010_TUNING_H_
+
+#include "vl53l0_def.h"
+#include "vl53l0_platform.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * @brief Internal function used to Program the default tuning settings
+ *
+ * @ingroup VL53L0_general_group
+ * @note This function access to the device
+ *
+ * @param   Dev                   Device Handle
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L010_load_tuning_settings(VL53L0_DEV Dev);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VL53L010_TUNING_H_ */
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_api.h b/drivers/input/misc/vl53L0/inc/vl53l0_api.h
index dcfa6b7d8fc..4e4ac753df8 100644
--- a/drivers/input/misc/vl53L0/inc/vl53l0_api.h
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_api.h
@@ -204,7 +204,7 @@ VL53L0_API VL53L0_Error VL53L0_GetPowerMode(VL53L0_DEV Dev,
  * @note This function Access to the device
  *
  * @param   Dev                                Device Handle
- * @param   OffsetCalibrationDataMicroMeter    Offset (in micrometer)
+ * @param   OffsetCalibrationDataMicroMeter    Offset (microns)
  * @return  VL53L0_ERROR_NONE                  Success
  * @return  "Other error code"                 See ::VL53L0_Error
  */
@@ -223,7 +223,7 @@ VL53L0_API VL53L0_Error VL53L0_SetOffsetCalibrationDataMicroMeter(
  *
  * @param   Dev                                Device Handle
  * @param   pOffsetCalibrationDataMicroMeter   Return part to part calibration
- * offset from device (in micro meter)
+ * offset from device (microns)
  * @return  VL53L0_ERROR_NONE                  Success
  * @return  "Other error code"                 See ::VL53L0_Error
  */
@@ -321,10 +321,54 @@ VL53L0_API VL53L0_Error VL53L0_SetDeviceAddress(VL53L0_DEV Dev,
  */
 VL53L0_API VL53L0_Error VL53L0_DataInit(VL53L0_DEV Dev);
 
+
+/**
+ * @brief Set the tuning settings pointer
+ *
+ * This function is used to specify the Tuning settings buffer to be used
+ * for a given device. The buffer contains all the necessary data to permit
+ * the API to write tuning settings.
+ * This function permit to force the usage of either external or internal
+ * tuning settings.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                               Device Handle
+ * @param   pTuningSettingBuffer              Pointer to tuning settings buffer.
+ * @param   UseInternalTuningSettings         Use internal tuning settings value.
+ * @return  VL53L0_ERROR_NONE     Success
+ * @return  "Other error code"    See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_SetTuningSettingBuffer(VL53L0_DEV Dev,
+              uint8_t* pTuningSettingBuffer,
+              uint8_t UseInternalTuningSettings);
+
+
+/**
+ * @brief Get the tuning settings pointer and the internal external switch value.
+ *
+ * This function is used to get the Tuning settings buffer pointer and the value.
+ * of the switch to select either external or internal tuning settings.
+ *
+ * @note This function Access to the device
+ *
+ * @param   Dev                        Device Handle
+ * @param   pTuningSettingBuffer       Pointer to tuning settings buffer.
+ * @param   pUseInternalTuningSettings Pointer to store Use internal tuning
+ *                                     settings value.
+ * @return  VL53L0_ERROR_NONE          Success
+ * @return  "Other error code"         See ::VL53L0_Error
+ */
+VL53L0_Error VL53L0_GetTuningSettingBuffer(VL53L0_DEV Dev,
+              uint8_t* pTuningSettingBuffer,
+              uint8_t* pUseInternalTuningSettings);
+
+
+
 /**
  * @brief Do basic device init (and eventually patch loading)
- * This function will change the VL53L0_State from VL53L0_STATE_WAIT_STATICINIT
- * to VL53L0_STATE_IDLE.
+ * This function will change the VL53L0_State from
+ * VL53L0_STATE_WAIT_STATICINIT to VL53L0_STATE_IDLE.
  * In this stage all defalut setting will be applied.
  *
  * @note This function Access to the device
@@ -342,7 +386,7 @@ VL53L0_API VL53L0_Error VL53L0_StaticInit(VL53L0_DEV Dev);
  * @note This function is not Implemented
  *
  * @param   Dev      Device Handle
- * @return  VL53L0_ERROR_NOT_IMPLEMENTED        Not implemented
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED Not implemented
  *
  */
 VL53L0_API VL53L0_Error VL53L0_WaitDeviceBooted(VL53L0_DEV Dev);
@@ -416,11 +460,14 @@ VL53L0_API VL53L0_Error VL53L0_GetDeviceParameters(VL53L0_DEV Dev,
  *                                VL53L0_DEVICEMODE_CONTINUOUS_RANGING
  *                                VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
  *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
- * (functionality not available)
+ *                                VL53L0_HISTOGRAMMODE_REFERENCE_ONLY
+ *                                VL53L0_HISTOGRAMMODE_RETURN_ONLY
+ *                                VL53L0_HISTOGRAMMODE_BOTH
  *
- * @return  VL53L0_ERROR_NONE                   Success
- * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
- * DeviceMode is not in the supported list
+ *
+ * @return  VL53L0_ERROR_NONE               Success
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED This error occurs when DeviceMode is
+ *                                          not in the supported list
  */
 VL53L0_API VL53L0_Error VL53L0_SetDeviceMode(VL53L0_DEV Dev,
 			VL53L0_DeviceModes DeviceMode);
@@ -439,7 +486,9 @@ VL53L0_API VL53L0_Error VL53L0_SetDeviceMode(VL53L0_DEV Dev,
  *                                VL53L0_DEVICEMODE_CONTINUOUS_RANGING
  *                                VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
  *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
- * (functionality not available)
+ *                                VL53L0_HISTOGRAMMODE_REFERENCE_ONLY
+ *                                VL53L0_HISTOGRAMMODE_RETURN_ONLY
+ *                                VL53L0_HISTOGRAMMODE_BOTH
  *
  * @return  VL53L0_ERROR_NONE                   Success
  * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
@@ -459,6 +508,11 @@ VL53L0_API VL53L0_Error VL53L0_GetDeviceMode(VL53L0_DEV Dev,
  * @param   HistogramMode         New device mode to apply
  *                                Valid values are:
  *                                VL53L0_HISTOGRAMMODE_DISABLED
+ *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
+ *                                VL53L0_HISTOGRAMMODE_REFERENCE_ONLY
+ *                                VL53L0_HISTOGRAMMODE_RETURN_ONLY
+ *                                VL53L0_HISTOGRAMMODE_BOTH
+ *
  * @return  VL53L0_ERROR_NONE                   Success
  * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED     This error occurs when
  * HistogramMode is not in the supported list
@@ -478,6 +532,10 @@ VL53L0_API VL53L0_Error VL53L0_SetHistogramMode(VL53L0_DEV Dev,
  * @param   pHistogramMode        Pointer to current Histogram Mode value
  *                                Valid values are:
  *                                VL53L0_HISTOGRAMMODE_DISABLED
+ *                                VL53L0_DEVICEMODE_SINGLE_HISTOGRAM
+ *                                VL53L0_HISTOGRAMMODE_REFERENCE_ONLY
+ *                                VL53L0_HISTOGRAMMODE_RETURN_ONLY
+ *                                VL53L0_HISTOGRAMMODE_BOTH
  * @return  VL53L0_ERROR_NONE     Success
  * @return  "Other error code"    See ::VL53L0_Error
  */
@@ -499,9 +557,9 @@ VL53L0_API VL53L0_Error VL53L0_GetHistogramMode(VL53L0_DEV Dev,
  * microseconds.
  *                                             Valid values are:
  *                                             >= 17000 microseconds when
- * wraparound is enabled
+ * wraparound enabled
  *                                             >= 12000 microseconds when
- * wraparound is disabled
+ * wraparound disabled
  * @return  VL53L0_ERROR_NONE                  Success
  * @return  VL53L0_ERROR_INVALID_PARAMS        This error is returned if
  * MeasurementTimingBudgetMicroSeconds is out of range
@@ -515,9 +573,9 @@ VL53L0_API VL53L0_Error VL53L0_SetMeasurementTimingBudgetMicroSeconds(
  * @brief Get Ranging Timing Budget in microseconds
  *
  * @par Function Description
- * Returns the programmed the maximum time allowed by the user to the device to
- * run a full ranging sequence
- * for the current mode (ranging, histogram, ASL ...)
+ * Returns the programmed the maximum time allowed by the user to the
+ * device to run a full ranging sequence for the current mode
+ * (ranging, histogram, ASL ...)
  *
  * @note This function Access to the device
  *
@@ -526,9 +584,9 @@ VL53L0_API VL53L0_Error VL53L0_SetMeasurementTimingBudgetMicroSeconds(
  * microseconds.
  *                                                 Valid values are:
  *                                                 >= 17000 microseconds when
- * wraparound is enabled
+ * wraparound enabled
  *                                                 >= 12000 microseconds when
- * wraparound is disabled
+ * wraparound disabled
  * @return  VL53L0_ERROR_NONE                      Success
  * @return  "Other error code"                     See ::VL53L0_Error
  */
@@ -545,8 +603,7 @@ VL53L0_API VL53L0_Error VL53L0_GetMeasurementTimingBudgetMicroSeconds(
  * @note This function Access to the device
  *
  * @param   Dev                                  Device Handle
- * @param   InterMeasurementPeriodMilliSeconds   Requires Inter-Measurement
- * Period in milliseconds.
+ * @param   InterMeasurementPeriodMilliSeconds   Inter-Measurement Period in ms.
  * @return  VL53L0_ERROR_NONE                    Success
  * @return  "Other error code"                   See ::VL53L0_Error
  */
@@ -574,31 +631,33 @@ VL53L0_API VL53L0_Error VL53L0_GetInterMeasurementPeriodMilliSeconds(
 
 /**
  * @brief Enable/Disable Cross talk compensation feature
- *
- * @note This function Access to the device
+ * 
+ * @note This function is not Implemented.
+ * Enable/Disable Cross Talk by set to zero the Cross Talk value
+ * by using @a VL53L0_SetXTalkCompensationRateMegaCps().
  *
  * @param   Dev                       Device Handle
- * @param   XTalkCompensationEnable   Cross talk compensation to be set
- * 0=disabled else = enabled
- * @return  VL53L0_ERROR_NONE         Success
- * @return  "Other error code"        See ::VL53L0_Error
+ * @param   XTalkCompensationEnable   Cross talk compensation
+ *  to be set 0=disabled else = enabled
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
  */
-VL53L0_API VL53L0_Error VL53L0_SetXTalkCompensationEnable(
-			VL53L0_DEV Dev, uint8_t XTalkCompensationEnable);
+VL53L0_API VL53L0_Error VL53L0_SetXTalkCompensationEnable(VL53L0_DEV Dev,
+                         uint8_t XTalkCompensationEnable);
 
 /**
  * @brief Get Cross talk compensation rate
- *
- * @note This function Access to the device
+ * 
+ * @note This function is not Implemented.
+ * Enable/Disable Cross Talk by set to zero the Cross Talk value by
+ * using @a VL53L0_SetXTalkCompensationRateMegaCps().
  *
  * @param   Dev                        Device Handle
  * @param   pXTalkCompensationEnable   Pointer to the Cross talk compensation
- * state 0=disabled or 1 = enabled
- * @return  VL53L0_ERROR_NONE          Success
- * @return  "Other error code"         See ::VL53L0_Error
+ *  state 0=disabled or 1 = enabled
+ * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
  */
-VL53L0_API VL53L0_Error VL53L0_GetXTalkCompensationEnable(
-			VL53L0_DEV Dev, uint8_t *pXTalkCompensationEnable);
+VL53L0_API VL53L0_Error VL53L0_GetXTalkCompensationEnable(VL53L0_DEV Dev,
+                         uint8_t* pXTalkCompensationEnable);
 
 /**
  * @brief Set Cross talk compensation rate
@@ -609,8 +668,8 @@ VL53L0_API VL53L0_Error VL53L0_GetXTalkCompensationEnable(
  * @note This function Access to the device
  *
  * @param   Dev                            Device Handle
- * @param   XTalkCompensationRateMegaCps   Compensation rate in Mega counts per
- * second (16.16 fix point) see datasheet for details
+ * @param   XTalkCompensationRateMegaCps   Compensation rate in
+ *  Mega counts per second (16.16 fix point) see datasheet for details
  * @return  VL53L0_ERROR_NONE              Success
  * @return  "Other error code"             See ::VL53L0_Error
  */
@@ -627,8 +686,8 @@ VL53L0_API VL53L0_Error VL53L0_SetXTalkCompensationRateMegaCps(
  * @note This function Access to the device
  *
  * @param   Dev                            Device Handle
- * @param   pXTalkCompensationRateMegaCps  Pointer to Compensation rate in Mega
- * counts per second (16.16 fix point) see datasheet for details
+ * @param   pXTalkCompensationRateMegaCps  Pointer to Compensation rate
+    in Mega counts per second (16.16 fix point) see datasheet for details
  * @return  VL53L0_ERROR_NONE              Success
  * @return  "Other error code"             See ::VL53L0_Error
  */
@@ -662,13 +721,13 @@ VL53L0_API VL53L0_Error VL53L0_GetNumberOfLimitCheck(
  * @note This function doesn't Access to the device
  *
  * @param   Dev                           Device Handle
- * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
- * VL53L0_GetNumberOfLimitCheck() ).
- * @param   pLimitCheckString             Pointer to the description string of
- * the given check limit.
+ * @param   LimitCheckId                  Limit Check ID
+    (0<= LimitCheckId < VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckString             Pointer to the
+    description string of the given check limit.
  * @return  VL53L0_ERROR_NONE             Success
- * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
- * LimitCheckId value is out of range.
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is
+    returned when LimitCheckId value is out of range.
  * @return  "Other error code"            See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_GetLimitCheckInfo(VL53L0_DEV Dev,
@@ -685,15 +744,15 @@ VL53L0_API VL53L0_Error VL53L0_GetLimitCheckInfo(VL53L0_DEV Dev,
  * @note This function doesn't Access to the device
  *
  * @param   Dev                           Device Handle
- * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
- * VL53L0_GetNumberOfLimitCheck() ).
- * @param   LimitCheckEnable              if 1 the check limit corresponding to
- * LimitCheckId is Enabled
- *                                        if 0 the check limit corresponding to
- * LimitCheckId is disabled
+ * @param   LimitCheckId                  Limit Check ID
+ *  (0<= LimitCheckId < VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckEnable              if 1 the check limit
+ *  corresponding to LimitCheckId is Enabled
+ *                                        if 0 the check limit
+ *  corresponding to LimitCheckId is disabled
  * @return  VL53L0_ERROR_NONE             Success
- * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
- * LimitCheckId value is out of range.
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned
+ *  when LimitCheckId value is out of range.
  * @return  "Other error code"            See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_SetLimitCheckEnable(VL53L0_DEV Dev,
@@ -710,17 +769,16 @@ VL53L0_API VL53L0_Error VL53L0_SetLimitCheckEnable(VL53L0_DEV Dev,
  * @note This function Access to the device
  *
  * @param   Dev                           Device Handle
- * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
- * VL53L0_GetNumberOfLimitCheck() ).
+ *  (0<= LimitCheckId < VL53L0_GetNumberOfLimitCheck() ).
  * @param   pLimitCheckEnable             Pointer to the check limit enable
  * value.
- *                                        if 1 the check limit corresponding to
- * LimitCheckId is Enabled
- *                                        if 0 the check limit corresponding to
- * LimitCheckId is disabled
+ *                                        if 1 the check limit
+ *  corresponding to LimitCheckId is Enabled
+ *                                        if 0 the check limit
+ *  corresponding to LimitCheckId is disabled
  * @return  VL53L0_ERROR_NONE             Success
- * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
- * LimitCheckId value is out of range.
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned
+ *  when LimitCheckId value is out of range.
  * @return  "Other error code"            See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_GetLimitCheckEnable(VL53L0_DEV Dev,
@@ -736,10 +794,9 @@ VL53L0_API VL53L0_Error VL53L0_GetLimitCheckEnable(VL53L0_DEV Dev,
  * @note This function Access to the device
  *
  * @param   Dev                           Device Handle
- * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
- * VL53L0_GetNumberOfLimitCheck() ).
- * @param   LimitCheckValue               Limit check Value for a given
- * LimitCheckId
+ * @param   LimitCheckId                  Limit Check ID
+ *  (0<= LimitCheckId < VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckValue               Limit check Value for a given LimitCheckId
  * @return  VL53L0_ERROR_NONE             Success
  * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when either
  * LimitCheckId or LimitCheckValue value is out of range.
@@ -759,20 +816,19 @@ VL53L0_API VL53L0_Error VL53L0_SetLimitCheckValue(VL53L0_DEV Dev,
  * @note This function Access to the device
  *
  * @param   Dev                           Device Handle
- * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
- * VL53L0_GetNumberOfLimitCheck() ).
- * @param   pLimitCheckValue              Pointer to Limit check Value for a
- * given LimitCheckId.
+ * @param   LimitCheckId                  Limit Check ID
+ *  (0<= LimitCheckId < VL53L0_GetNumberOfLimitCheck() ).
+ * @param   pLimitCheckValue              Pointer to Limit
+ *  check Value for a given LimitCheckId.
  * @return  VL53L0_ERROR_NONE             Success
- * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned when
- * LimitCheckId value is out of range.
+ * @return  VL53L0_ERROR_INVALID_PARAMS   This error is returned 
+ *  when LimitCheckId value is out of range.
  * @return  "Other error code"            See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_GetLimitCheckValue(VL53L0_DEV Dev,
 			uint16_t LimitCheckId,
 			FixPoint1616_t *pLimitCheckValue);
 
-
 /**
  * @brief  Get the current value of the signal used for the limit check
  *
@@ -785,8 +841,8 @@ VL53L0_API VL53L0_Error VL53L0_GetLimitCheckValue(VL53L0_DEV Dev,
  * @note This function Access to the device
  *
  * @param   Dev                           Device Handle
- * @param   LimitCheckId                  Limit Check ID  (0<= LimitCheckId <
- * VL53L0_GetNumberOfLimitCheck() ).
+ * @param   LimitCheckId                  Limit Check ID  
+ *  (0<= LimitCheckId < VL53L0_GetNumberOfLimitCheck() ).
  * @param   pLimitCheckCurrent            Pointer to current Value for a
  * given LimitCheckId.
  * @return  VL53L0_ERROR_NONE             Success
@@ -798,203 +854,14 @@ VL53L0_API VL53L0_Error VL53L0_GetLimitCheckCurrent(VL53L0_DEV Dev,
 		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckCurrent);
 
 
-
-
-
-/**
- * @brief  Enable/disable Signal check for a given Device
- *
- * @par Function Description
- * This function set the Signal check Enable for a given position and for a
- * given device
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                     Device Handle
- * @param   Position                Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   SignalLimitCheckEnable   if 1 = SignalLimit Check is Enabled ; 0 =
- * SignalLimit Check is disabled
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"      See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_SetSignalLimitCheckEnable(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			uint8_t SignalLimitCheckEnable);
-
-
-/**
- * @brief  Get Signal Limit check enable value for a given position and for a
- * given Device
- *
- * @par Function Description
- * This function get the Signal Limit check Enable for a given position and for
- * a given device
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                     Device Handle
- * @param   Position                Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   pSignalLimitCheckEnable  Pointer to programmed SignalLimit Check
- * Enable value.
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"      See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_GetSignalLimitCheckEnable(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			uint8_t *pSignalLimitCheckEnable);
-
-/**
- * @brief Set Signal limit value for a given position and for a given Device
- *
- * @par Function Description
- * Set Signal limit value for a given position and for a given device.
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                  Device Handle.
- * @param   Position             Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   SignalLimitValue     Signal limit value to validate the measurement
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"   See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_SetSignalLimitValue(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			FixPoint1616_t SignalLimitValue);
-
-
-/**
- * @brief Get Signal limit value
- *
- * @par Function Description
- * Get Signal limit value for a given position and for a given device.
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                  Device Handle.
- * @param   Position             Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   pSignalLimitValue    Pointer to current Signal limit value to
- * validate the measurement
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"   See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_GetSignalLimitValue(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			FixPoint1616_t *pSignalLimitValue);
-
-
-/**
- * @brief  Enable/disable Sigma check for a given Device
- *
- * @par Function Description
- * This function set the Sigma check Enable for a given position and for a
- * given device
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                     Device Handle
- * @param   Position                Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   SigmaLimitCheckEnable   if 1 = SigmaLimit Check is Enabled ; 0 =
- * SigmaLimit Check is disabled
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"      See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_SetSigmaLimitCheckEnable(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			uint8_t SigmaLimitCheckEnable);
-
-
-/**
- * @brief  Get Sigma Limit check enable value for a given position and for a
- * given Device
- *
- * @par Function Description
- * This function get the Sigma Limit check Enable for a given position and for
- * a given device
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                     Device Handle
- * @param   Position                Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   pSigmaLimitCheckEnable  Pointer to programmed SigmaLimit Check
- * Enable value.
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"      See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_GetSigmaLimitCheckEnable(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			uint8_t *pSigmaLimitCheckEnable);
-
-/**
- * @brief Set Sigma limit value for a given position and for a given Device
- *
- * @par Function Description
- * Set Sigma limit value for a given position and for a given device.
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                  Device Handle.
- * @param   Position             Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   SigmaLimitValue      Sigma limit value to validate the measurement
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"   See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_SetSigmaLimitValue(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			FixPoint1616_t SigmaLimitValue);
-
-
-/**
- * @brief Get Sigma limit value
- *
- * @par Function Description
- * Get Sigma limit value for a given position and for a given device.
- *
- * @note This function doesn't Access to the device
- *
- * @param   Dev                  Device Handle.
- * @param   Position             Indicate the position of the check in the
- * sequence, it could be for example EARLY or FINAL.
- * @param   pSigmaLimitValue     Pointer to current Sigma limit value to
- * validate the measurement
- * @return  VL53L0_ERROR_NONE               Success
- * @return  VL53L0_ERROR_INVALID_PARAMS     This error is returned when
- * Position value is out of range.
- * @return  "Other error code"   See ::VL53L0_Error
- */
-VL53L0_API VL53L0_Error VL53L0_GetSigmaLimitValue(VL53L0_DEV Dev,
-			VL53L0_CheckPosition Position,
-			FixPoint1616_t *pSigmaLimitValue);
-
-
 /**
  * @brief  Enable (or disable) Wrap around Check
  *
  * @note This function Access to the device
  *
  * @param   Dev                    Device Handle
- * @param   WrapAroundCheckEnable  Wrap around Check to be set 0=disabled,
- * other = enabled
+ * @param   WrapAroundCheckEnable  Wrap around Check to be set 
+ *                                 0=disabled, other = enabled
  * @return  VL53L0_ERROR_NONE      Success
  * @return  "Other error code"     See ::VL53L0_Error
  */
@@ -1011,7 +878,7 @@ VL53L0_API VL53L0_Error VL53L0_SetWrapAroundCheckEnable(VL53L0_DEV Dev,
  *
  * @param   Dev                     Device Handle
  * @param   pWrapAroundCheckEnable  Pointer to the Wrap around Check state
- * 0=disabled or 1 = enabled
+ *                                  0=disabled or 1 = enabled
  * @return  VL53L0_ERROR_NONE       Success
  * @return  "Other error code"      See ::VL53L0_Error
  */
@@ -1030,11 +897,11 @@ VL53L0_API VL53L0_Error VL53L0_GetWrapAroundCheckEnable(VL53L0_DEV Dev,
  * @brief Single shot measurement.
  *
  * @par Function Description
- * Perform simple measurement sequence (Start measure, Wait measure to end, and
- * returns when measurement is done).
+ * Perform simple measurement sequence (Start measure, Wait measure to end, 
+ * and returns when measurement is done).
  * Once function returns, user can get valid data by calling
- * VL53L0_GetRangingMeasurement or VL53L0_GetHistogramMeasurement depending on
- * defined measurement mode
+ * VL53L0_GetRangingMeasurement or VL53L0_GetHistogramMeasurement
+ * depending on defined measurement mode
  * User should Clear the interrupt in case this are enabled by using the
  * function VL53L0_ClearInterruptMask().
  *
@@ -1052,10 +919,10 @@ VL53L0_API VL53L0_Error VL53L0_PerformSingleMeasurement(VL53L0_DEV Dev);
  * @brief Perform Reference Calibration
  *
  * @details Perform a reference calibration of the Device.
- * This function should be run from time to time before doing a ranging
- * measurement.
- * This function will launch a special ranging measurement, so if interrupt are
- * enable an interrupt will be done.
+ * This function should be run from time to time before doing
+ * a ranging measurement.
+ * This function will launch a special ranging measurement, so 
+ * if interrupt are enable an interrupt will be done.
  * This function will clear the interrupt generated automatically.
  *
  * @warning This function is a blocking function
@@ -1072,11 +939,11 @@ VL53L0_API VL53L0_Error VL53L0_PerformRefCalibration(VL53L0_DEV Dev);
  * @brief Perform XTalk Calibration
  *
  * @details Perform a XTalk calibration of the Device.
- * This function will launch a ranging measurement, if interrupts are enabled
- * an interrupt will be done.
+ * This function will launch a ranging measurement, if interrupts 
+ * are enabled an interrupt will be done.
  * This function will clear the interrupt generated automatically.
- * This function will program a new value for the XTalk compensation and it
- * will enable the cross talk before exit.
+ * This function will program a new value for the XTalk compensation 
+ * and it will enable the cross talk before exit.
  *
  * @warning This function is a blocking function
  *
@@ -1094,15 +961,41 @@ VL53L0_API VL53L0_Error VL53L0_PerformRefCalibration(VL53L0_DEV Dev);
  * @return  "Other error code"   See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_PerformXTalkCalibration(VL53L0_DEV Dev,
-			FixPoint1616_t XTalkCalDistance,
-			FixPoint1616_t *pXTalkCompensationRateMegaCps);
+            FixPoint1616_t XTalkCalDistance, FixPoint1616_t* pXTalkCompensationRateMegaCps);
+
+/**
+ * @brief Perform Offset Calibration
+ *
+ * @details Perform a Offset calibration of the Device.
+ * This function will launch a ranging measurement, if interrupts are 
+ * enabled an interrupt will be done.
+ * This function will clear the interrupt generated automatically.
+ * This function will program a new value for the Offset calibration value and
+ *
+ * @warning This function is a blocking function
+ *
+ * @note This function Access to the device
+ *
+ * @note This function does not change the device mode.
+ *
+ * @param   Dev                  Device Handle
+ * @param   CalDistanceMilliMeter     Calibration distance value used for the
+ * offset compensation.
+ * @param   pOffsetMicroMeter  Pointer to new Offset value computed by the
+ * function.
+ *
+ * @return  VL53L0_ERROR_NONE    Success
+ * @return  "Other error code"   See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformOffsetCalibration(VL53L0_DEV Dev,
+            FixPoint1616_t CalDistanceMilliMeter, int32_t* pOffsetMicroMeter);
 
 /**
  * @brief Start device measurement
  *
- * @details Started measurement will depend on device parameters set through @a
- * VL53L0_SetParameters()
- * This is a non-blocking function
+ * @details Started measurement will depend on device parameters set through
+ * @a VL53L0_SetParameters()
+ * This is a non-blocking function.
  * This function will change the VL53L0_State from VL53L0_STATE_IDLE to
  * VL53L0_STATE_RUNNING.
  *
@@ -1111,12 +1004,12 @@ VL53L0_API VL53L0_Error VL53L0_PerformXTalkCalibration(VL53L0_DEV Dev,
 
  * @param   Dev                  Device Handle
  * @return  VL53L0_ERROR_NONE                  Success
- * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED    This error occurs when
- * DeviceMode programmed with @a VL53L0_SetDeviceMode is not in the supported
- * list:
+ * @return  VL53L0_ERROR_MODE_NOT_SUPPORTED    This error occurs when 
+ * DeviceMode programmed with @a VL53L0_SetDeviceMode is not in the supported list:
  *                                             Supported mode are:
- * VL53L0_DEVICEMODE_SINGLE_RANGING, VL53L0_DEVICEMODE_CONTINUOUS_RANGING,
- * VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
+ *                                             VL53L0_DEVICEMODE_SINGLE_RANGING, 
+ *                                             VL53L0_DEVICEMODE_CONTINUOUS_RANGING, 
+ *                                             VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING
  * @return  VL53L0_ERROR_TIME_OUT    Time out on start measurement
  * @return  "Other error code"   See ::VL53L0_Error
  */
@@ -1125,11 +1018,11 @@ VL53L0_API VL53L0_Error VL53L0_StartMeasurement(VL53L0_DEV Dev);
 /**
  * @brief Stop device measurement
  *
- * @details Will set the device in standby mode at end of current measurement \n
- *          Not necessary in single mode as device shall return automatically
- * in standby mode at end of measurement.
- *          This function will change the VL53L0_State from
- * VL53L0_STATE_RUNNING to VL53L0_STATE_IDLE.
+ * @details Will set the device in standby mode at end of current measurement\n
+ *          Not necessary in single mode as device shall return automatically 
+ *          in standby mode at end of measurement.
+ *          This function will change the VL53L0_State from VL53L0_STATE_RUNNING 
+ *          to VL53L0_STATE_IDLE.
  *
  * @note This function Access to the device
  *
@@ -1153,8 +1046,8 @@ VL53L0_API VL53L0_Error VL53L0_StopMeasurement(VL53L0_DEV Dev);
  * @note This function Access to the device
  *
  * @param   Dev                    Device Handle
- * @param   pMeasurementDataReady  Pointer to Measurement Data Ready. 0=data
- * not ready, 1 = data ready
+ * @param   pMeasurementDataReady  Pointer to Measurement Data Ready.
+ *  0=data not ready, 1 = data ready
  * @return  VL53L0_ERROR_NONE      Success
  * @return  "Other error code"     See ::VL53L0_Error
  */
@@ -1180,10 +1073,10 @@ VL53L0_API VL53L0_Error VL53L0_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev,
  *
  * @par Function Description
  * Get data from last successful Ranging measurement
- * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() before
- * get data.
- * PAL will fill a NumberOfROIZones times the corresponding data structure used
- * in the measurement function.
+ * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() 
+ * before get data.
+ * PAL will fill a NumberOfROIZones times the corresponding data 
+ * structure used in the measurement function.
  *
  * @note This function Access to the device
  *
@@ -1200,13 +1093,15 @@ VL53L0_API VL53L0_Error VL53L0_GetRangingMeasurementData(VL53L0_DEV Dev,
  *
  * @par Function Description
  * Get data from last successful Histogram measurement
- * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() before
- * get data.
- * PAL will fill a NumberOfROIZones times the corresponding data structure used
- * in the measurement function.
+ * @warning USER should take care about  @a VL53L0_GetNumberOfROIZones() 
+ * before get data.
+ * PAL will fill a NumberOfROIZones times the corresponding data structure
+ * used in the measurement function.
+ *
  * @note This function is not Implemented
- * @param	Dev							Device Handle
- * @param	pHistogramMeasurementData	Pointer to the data structure to fill
+ *
+ * @param   Dev    			            Device Handle
+ * @param	  pHistogramMeasurementData	Pointer to the data structure to fill
  * up.
  * @return  VL53L0_ERROR_NOT_IMPLEMENTED   Not implemented
  */
@@ -1284,10 +1179,10 @@ VL53L0_API VL53L0_Error VL53L0_SetNumberOfROIZones(VL53L0_DEV Dev,
  *
  * @par Function Description
  * Get number of ROI Zones managed by the Device
- * USER should take care about  @a VL53L0_GetNumberOfROIZones() before get data
- * after a perform measurement.
- * PAL will fill a NumberOfROIZones times the corresponding data structure used
- * in the measurement function.
+ * USER should take care about  @a VL53L0_GetNumberOfROIZones() 
+ * before get data after a perform measurement.
+ * PAL will fill a NumberOfROIZones times the corresponding data 
+ * structure used in the measurement function.
  *
  * @note This function doesn't Access to the device
  *
@@ -1307,9 +1202,9 @@ VL53L0_API VL53L0_Error VL53L0_GetNumberOfROIZones(VL53L0_DEV Dev,
  *
  * @note This function doesn't Access to the device
  *
- * @param   Dev							Device Handle
- * @param   pMaxNumberOfROIZones        Pointer to the Maximum Number of ROI
- * Zones value.
+ * @param   Dev    			            Device Handle
+ * @param   pMaxNumberOfROIZones        Pointer to the Maximum Number
+ *  of ROI Zones value.
  * @return  VL53L0_ERROR_NONE           Success
  */
 VL53L0_API VL53L0_Error VL53L0_GetMaxNumberOfROIZones(VL53L0_DEV Dev,
@@ -1331,24 +1226,21 @@ VL53L0_API VL53L0_Error VL53L0_GetMaxNumberOfROIZones(VL53L0_DEV Dev,
  *
  * @param   Dev                   Device Handle
  * @param   Pin                   ID of the GPIO Pin
- * @param   Functionality         Select Pin functionality. Refer to
- * ::VL53L0_GpioFunctionality
+ * @param   Functionality         Select Pin functionality. 
+ *  Refer to ::VL53L0_GpioFunctionality
  * @param   DeviceMode            Device Mode associated to the Gpio.
- * @param   Polarity              Set interrupt polarity. Active high or active
- * low see ::VL53L0_InterruptPolarity
+ * @param   Polarity              Set interrupt polarity. Active high
+ *   or active low see ::VL53L0_InterruptPolarity
  * @return  VL53L0_ERROR_NONE                                Success
- * @return  VL53L0_ERROR_GPIO_NOT_EXISTING                   Only Pin=0 is
- * accepted.
- * @return  VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED    This error occurs
- * when Functionality programmed is not in the supported list:
- * Supported value
- * are:
- *
- * VL53L0_GPIOFUNCTIONALITY_OFF, VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
- * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
- * VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT,
- *
- * VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY
+ * @return  VL53L0_ERROR_GPIO_NOT_EXISTING                   Only Pin=0 is accepted.
+ * @return  VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED    This error occurs when 
+ *  Functionality programmed is not in the supported list:
+ *                              Supported value are:
+ *                               VL53L0_GPIOFUNCTIONALITY_OFF, 
+ *                               VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+ *                               VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+                                 VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT,
+ *                               VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY
  * @return  "Other error code"    See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
@@ -1561,8 +1453,27 @@ VL53L0_API VL53L0_Error VL53L0_SetSpadAmbientDamperFactor(VL53L0_DEV Dev,
  * @return  "Other error code"            See ::VL53L0_Error
  */
 VL53L0_API VL53L0_Error VL53L0_GetSpadAmbientDamperFactor(VL53L0_DEV Dev,
-					uint16_t *pSpadAmbientDamperFactor);
+                    uint16_t* pSpadAmbientDamperFactor);
+
 
+/**
+ * @brief Performs Reference Spad Management
+ *
+ * @par Function Description
+ * The reference SPAD initialization procedure determines the minimum amount
+ * of reference spads to be enables to achieve a target reference signal rate
+ * and should be performed once during initialization.
+ *
+ * @note This function Access to the device
+ *
+ * @note This function change the device mode to VL53L0_DEVICEMODE_SINGLE_RANGING
+ *
+ * @param   Dev    			             Device Handle
+ * @return  VL53L0_ERROR_NONE            Success
+ * @return  VL53L0_ERROR_REF_SPAD_INIT   Error in the Ref Spad procedure.
+ * @return  "Other error code"           See ::VL53L0_Error
+ */
+VL53L0_API VL53L0_Error VL53L0_PerformRefSpadManagement(VL53L0_DEV Dev);
 
 /** @} VL53L0_SPADfunctions_group */
 
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_def.h b/drivers/input/misc/vl53L0/inc/vl53l0_def.h
index a1538e10bc3..6bc138ba953 100644
--- a/drivers/input/misc/vl53L0/inc/vl53l0_def.h
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_def.h
@@ -24,7 +24,7 @@ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*******************************************************************************/
+********************************************************************************/
 
 /*
  * $Date: 2014-12-05 15:06:01 +0100 (Fri, 05 Dec 2014) $
@@ -49,6 +49,24 @@ extern "C" {
 
 
 /** PAL SPECIFICATION major version */
+#define VL53L010_SPECIFICATION_VER_MAJOR   1
+/** PAL SPECIFICATION minor version */
+#define VL53L010_SPECIFICATION_VER_MINOR   2
+/** PAL SPECIFICATION sub version */
+#define VL53L010_SPECIFICATION_VER_SUB     8
+/** PAL SPECIFICATION sub version */
+#define VL53L010_SPECIFICATION_VER_REVISION 1440
+
+/** VL53L0 PAL IMPLEMENTATION major version */
+#define VL53L010_IMPLEMENTATION_VER_MAJOR   1
+/** VL53L0 PAL IMPLEMENTATION minor version */
+#define VL53L010_IMPLEMENTATION_VER_MINOR   0
+/** VL53L0 PAL IMPLEMENTATION sub version */
+#define VL53L010_IMPLEMENTATION_VER_SUB     8
+/** VL53L0 PAL IMPLEMENTATION sub version */
+#define VL53L010_IMPLEMENTATION_VER_REVISION    3123
+
+/** PAL SPECIFICATION major version */
 #define VL53L0_SPECIFICATION_VER_MAJOR   1
 /** PAL SPECIFICATION minor version */
 #define VL53L0_SPECIFICATION_VER_MINOR   2
@@ -60,13 +78,12 @@ extern "C" {
 /** VL53L0 PAL IMPLEMENTATION major version */
 #define VL53L0_IMPLEMENTATION_VER_MAJOR   1
 /** VL53L0 PAL IMPLEMENTATION minor version */
-#define VL53L0_IMPLEMENTATION_VER_MINOR   0
+#define VL53L0_IMPLEMENTATION_VER_MINOR   1
 /** VL53L0 PAL IMPLEMENTATION sub version */
-#define VL53L0_IMPLEMENTATION_VER_SUB     6
+#define VL53L0_IMPLEMENTATION_VER_SUB     7
 /** VL53L0 PAL IMPLEMENTATION sub version */
-#define VL53L0_IMPLEMENTATION_VER_REVISION    2915
-
-#define VL53L0_DEFAULT_MAX_LOOP 100
+#define VL53L0_IMPLEMENTATION_VER_REVISION    3123
+#define VL53L0_DEFAULT_MAX_LOOP 1000
 #define VL53L0_MAX_STRING_LENGTH 32
 
 
@@ -84,7 +101,7 @@ extern "C" {
 
 /** @brief Defines the parameters of the Get Version Functions
  */
-typedef struct {
+typedef struct{
 	uint32_t     revision; /*!< revision number */
 	uint8_t      major;    /*!< major number */
 	uint8_t      minor;    /*!< minor number */
@@ -95,21 +112,16 @@ typedef struct {
 /** @brief Defines the parameters of the Get Device Info Functions
  */
 typedef struct {
-	char Name[VL53L0_MAX_STRING_LENGTH];
-	/*!< Name of the Device e.g. Left_Distance */
-	char Type[VL53L0_MAX_STRING_LENGTH];
-	/*!< Type of the Device e.g VL53L0 */
-	uint8_t ProductType;
-	/*!< Product Type, VL53L0 = 1, VL53L1 = 2 */
-	uint8_t ProductRevisionMajor;
-	/*!< Product revision major */
-	uint8_t ProductRevisionMinor;
-	/*!< Product revision minor */
+    char Name[VL53L0_MAX_STRING_LENGTH]; /*!< Name of the Device e.g. Left_Distance */
+    char Type[VL53L0_MAX_STRING_LENGTH]; /*!< Type of the Device e.g VL53L0 */
+    char ProductId[VL53L0_MAX_STRING_LENGTH]; /*!< Product Identifier String  */
+    uint8_t ProductType; /*!< Product Type, VL53L0 = 1, VL53L1 = 2 */
+    uint8_t ProductRevisionMajor; /*!< Product revision major */
+    uint8_t ProductRevisionMinor; /*!< Product revision minor */
 } VL53L0_DeviceInfo_t ;
 
 
-/** @defgroup VL53L0_define_Error_group PAL Error and Warning code returned by
- *	API
+/** @defgroup VL53L0_define_Error_group PAL Error and Warning code returned by API
  *  The following DEFINE are used to identify the PAL ERROR
  *  @{
  */
@@ -117,46 +129,30 @@ typedef struct {
 typedef int8_t VL53L0_Error;
 
 #define VL53L0_ERROR_NONE                              ((VL53L0_Error)  0)
-/*!< No Error found */
-#define VL53L0_ERROR_CALIBRATION_WARNING               ((VL53L0_Error) - 1)
-/*!< Warning invalid calibration data may be in used
-\a  VL53L0_InitData()
-\a VL53L0_GetOffsetCalibrationData
-\a VL53L0_SetOffsetCalibrationData */
-#define VL53L0_ERROR_MIN_CLIPPED                       ((VL53L0_Error) - 2)
-/*!< Warning parameter passed was clipped to min before to be applied */
-#define VL53L0_ERROR_UNDEFINED                         ((VL53L0_Error) - 3)
-/*!< Unqualified error */
-#define VL53L0_ERROR_INVALID_PARAMS                    ((VL53L0_Error) - 4)
-/*!< Parameter passed is invalid or out of range */
-#define VL53L0_ERROR_NOT_SUPPORTED                     ((VL53L0_Error) - 5)
-/*!< Function is not supported in current mode or configuration */
-#define VL53L0_ERROR_RANGE_ERROR                       ((VL53L0_Error) - 6)
-/*!< Device report a ranging error interrupt status */
-#define VL53L0_ERROR_TIME_OUT                          ((VL53L0_Error) - 7)
-/*!< Aborted due to time out */
-#define VL53L0_ERROR_MODE_NOT_SUPPORTED                ((VL53L0_Error) - 8)
-/*!< Asked mode is not supported by the device */
-#define VL53L0_ERROR_BUFFER_TOO_SMALL                  ((VL53L0_Error) - 9)
-/*!< Buffer is too small */
-#define VL53L0_ERROR_GPIO_NOT_EXISTING                 ((VL53L0_Error) - 10)
-/*!< User tried to setup a non-existing GPIO pin */
-#define VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED  ((VL53L0_Error) - 11)
-/*!< unsupported GPIO functionality */
-#define VL53L0_ERROR_CONTROL_INTERFACE                 ((VL53L0_Error) - 20)
-/*!< error reported from IO functions */
-#define VL53L0_ERROR_INVALID_COMMAND                   ((VL53L0_Error) - 30)
-/*!< The command is not allowed in the current device state (power down) */
-#define VL53L0_ERROR_DIVISION_BY_ZERO                  ((VL53L0_Error) - 40)
-/*!< In the function a division by zero occurs */
-#define VL53L0_ERROR_NOT_IMPLEMENTED                   ((VL53L0_Error) - 99)
-/*!< Tells requested functionality has not been implemented yet or not
-	compatible with the device */
-/** @} */ /* end of VL53L0_define_Error_group */
-
-
-/** @defgroup VL53L0_define_DeviceModes_group Defines all possible modes for the
- *  device
+#define VL53L0_ERROR_CALIBRATION_WARNING               ((VL53L0_Error) -1)    /*!< Warning invalid calibration data may be in used
+                                                                       \a  VL53L0_InitData()
+                                                                       \a VL53L0_GetOffsetCalibrationData
+                                                                       \a VL53L0_SetOffsetCalibrationData */
+#define VL53L0_ERROR_MIN_CLIPPED                       ((VL53L0_Error) -2)    /*!< Warning parameter passed was clipped to min before to be applied */
+
+#define VL53L0_ERROR_UNDEFINED                         ((VL53L0_Error) -3)    /*!< Unqualified error */
+#define VL53L0_ERROR_INVALID_PARAMS                    ((VL53L0_Error) -4)    /*!< Parameter passed is invalid or out of range */
+#define VL53L0_ERROR_NOT_SUPPORTED                     ((VL53L0_Error) -5)    /*!< Function is not supported in current mode or configuration */
+#define VL53L0_ERROR_RANGE_ERROR                       ((VL53L0_Error) -6)    /*!< Device report a ranging error interrupt status */
+#define VL53L0_ERROR_TIME_OUT                          ((VL53L0_Error) -7)    /*!< Aborted due to time out */
+#define VL53L0_ERROR_MODE_NOT_SUPPORTED                ((VL53L0_Error) -8)    /*!< Asked mode is not supported by the device */
+#define VL53L0_ERROR_BUFFER_TOO_SMALL                  ((VL53L0_Error) -9)    /*!< ... */
+#define VL53L0_ERROR_GPIO_NOT_EXISTING                 ((VL53L0_Error) -10)   /*!< User tried to setup a non-existing GPIO pin */
+#define VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED  ((VL53L0_Error) -11)   /*!< unsupported GPIO functionality */
+#define VL53L0_ERROR_CONTROL_INTERFACE                 ((VL53L0_Error) -20)   /*!< error reported from IO functions */
+#define VL53L0_ERROR_INVALID_COMMAND                   ((VL53L0_Error) -30)   /*!< The command is not allowed in the current device state (power down) */
+#define VL53L0_ERROR_DIVISION_BY_ZERO                  ((VL53L0_Error) -40)   /*!< In the function a division by zero occurs */
+#define VL53L0_ERROR_REF_SPAD_INIT                     ((VL53L0_Error) -50)   /*!< Error during reference SPAD initialisation */
+#define VL53L0_ERROR_NOT_IMPLEMENTED                   ((VL53L0_Error) -99)   /*!< Tells requested functionality has not been implemented yet or not compatible with the device */
+/** @} */ // end of VL53L0_define_Error_group
+
+
+/** @defgroup VL53L0_define_DeviceModes_group Defines all possible modes for the device
  *  Defines all possible modes for the device
  *  @{
  */
@@ -169,28 +165,23 @@ typedef uint8_t VL53L0_DeviceModes;
 #define VL53L0_DEVICEMODE_SINGLE_ALS               ((VL53L0_DeviceModes) 10)
 #define VL53L0_DEVICEMODE_GPIO_DRIVE               ((VL53L0_DeviceModes) 20)
 #define VL53L0_DEVICEMODE_GPIO_OSC                 ((VL53L0_DeviceModes) 21)
-/* ... Modes to be added depending on device */
-/** @} */ /* end of VL53L0_define_DeviceModes_group */
+	/* ... Modes to be added depending on device */
+/** @} */ // end of VL53L0_define_DeviceModes_group
 
 
 
-/** @defgroup VL53L0_define_HistogramModes_group Defines all possible Histogram
- *  modes for the device
+/** @defgroup VL53L0_define_HistogramModes_group Defines all possible Histogram modes for the device
  *  Defines all possible Histogram modes for the device
  *  @{
  */
 typedef uint8_t VL53L0_HistogramModes;
 
-#define VL53L0_HISTOGRAMMODE_DISABLED        ((VL53L0_HistogramModes) 0)
-/*!< Histogram Disabled */
-#define VL53L0_HISTOGRAMMODE_REFERENCE_ONLY  ((VL53L0_HistogramModes) 1)
-/*!< Histogram Reference array only */
-#define VL53L0_HISTOGRAMMODE_RETURN_ONLY     ((VL53L0_HistogramModes) 2)
-/*!< Histogram Return array only */
-#define VL53L0_HISTOGRAMMODE_BOTH            ((VL53L0_HistogramModes) 3)
-/*!< Histogram both Reference and Return Arrays */
-
-/** @} */ /* end of VL53L0_define_HistogramModes_group */
+#define VL53L0_HISTOGRAMMODE_DISABLED        ((VL53L0_HistogramModes) 0) /*!< Histogram Disabled */
+#define VL53L0_HISTOGRAMMODE_REFERENCE_ONLY  ((VL53L0_HistogramModes) 1) /*!< Histogram Reference array only */
+#define VL53L0_HISTOGRAMMODE_RETURN_ONLY     ((VL53L0_HistogramModes) 2) /*!< Histogram Return array only */
+#define VL53L0_HISTOGRAMMODE_BOTH            ((VL53L0_HistogramModes) 3) /*!< Histogram both Reference and Return Arrays */
+	/* ... Modes to be added depending on device */
+/** @} */ // end of VL53L0_define_HistogramModes_group
 
 
 /** @defgroup VL53L0_define_PowerModes_group List of available Power Modes
@@ -200,72 +191,42 @@ typedef uint8_t VL53L0_HistogramModes;
 
 typedef uint8_t VL53L0_PowerModes;
 
-#define VL53L0_POWERMODE_STANDBY_LEVEL1 ((VL53L0_PowerModes) 0)
-/*!< Standby level 1 */
-#define VL53L0_POWERMODE_STANDBY_LEVEL2 ((VL53L0_PowerModes) 1)
-/*!< Standby level 2 */
-#define VL53L0_POWERMODE_IDLE_LEVEL1    ((VL53L0_PowerModes) 2)
-/*!< Idle level 1 */
-#define VL53L0_POWERMODE_IDLE_LEVEL2    ((VL53L0_PowerModes) 3)
-/*!< Idle level 2 */
-
-/** @} */ /* end of VL53L0_define_PowerModes_group */
-
-
-/** @defgroup VL53L0_define_CheckPosition_group List of available Positions to
- *  be used in checks functions
- *  List of available Positions to be used in checks functions
- *  @{
- */
-
-typedef uint8_t VL53L0_CheckPosition;
+#define VL53L0_POWERMODE_STANDBY_LEVEL1 ((VL53L0_PowerModes) 0)   /*!< Standby level 1 */
+#define VL53L0_POWERMODE_STANDBY_LEVEL2 ((VL53L0_PowerModes) 1)   /*!< Standby level 2 */
+#define VL53L0_POWERMODE_IDLE_LEVEL1    ((VL53L0_PowerModes) 2)   /*!< Idle level 1 */
+#define VL53L0_POWERMODE_IDLE_LEVEL2    ((VL53L0_PowerModes) 3)   /*!< Idle level 2 */
 
-
-#define VL53L0_CHECKPOSITION_EARLY           ((VL53L0_CheckPosition) 0)
-/*!< Early Position */
-#define VL53L0_CHECKPOSITION_FINAL           ((VL53L0_CheckPosition) 1)
-/*!< Final Position */
-#define VL53L0_CHECKPOSITION_NO_OF_CHECKS    ((VL53L0_CheckPosition) 2)
-/*!< Number of Checks */
-
-/** @} */ /* end of VL53L0_define_PowerModes_group */
+/** @} */ // end of VL53L0_define_PowerModes_group
 
 
 /** @brief Defines all parameters for the device
  */
-typedef struct {
+typedef struct{
 	VL53L0_DeviceModes DeviceMode;
-	/*!< Defines type of measurement to be done for the next measure */
-	VL53L0_HistogramModes HistogramMode;
-	/*!< Defines type of histogram measurement to be done for the next
-		measure */
+    /*!< Defines type of measurement to be done for the next measure */
+    VL53L0_HistogramModes HistogramMode;
+    /*!< Defines type of histogram measurement to be done for the next measure */
 	uint32_t MeasurementTimingBudgetMicroSeconds;
-	/*!< Defines the allowed total time for a single measurement */
+    /*!< Defines the allowed total time for a single measurement */
 	uint32_t InterMeasurementPeriodMilliSeconds;
-	/*!< Defines time between two consecutive measurements (between two
-		measurement starts).If set to 0 means back-to-back mode */
+    /*!< Defines time between two consecutive measurements (between two measurement starts).
+      If set to 0 means back-to-back mode */
 	uint8_t XTalkCompensationEnable;
-	/*!< Tells if Crosstalk compensation shall be enable or not  */
+    /*!< Tells if Crosstalk compensation shall be enable or not  */
 	uint16_t XTalkCompensationRangeMilliMeter;
-	/*!< CrossTalk compensation range in millimeter  */
+    /*!< CrossTalk compensation range in millimeter  */
 	FixPoint1616_t XTalkCompensationRateMegaCps;
-	/*!< CrossTalk compensation rate in Mega counts per seconds.
-		Expressed in 16.16 fixed point format.  */
-	uint8_t SnrLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
-	/*!< Tells if SNR limit Check shall be enable or not for each
-		position. */
-	uint8_t SignalLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
-	/*!< Tells if Signal limit Check shall be enable or not for each
-		position.*/
-	FixPoint1616_t SignalLimitValue[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
-	/*!< Signal limit value for each position */
-	uint8_t SigmaLimitCheckEnable[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
-	/*!< Tells if Sigma limit Check shall be enable or not for each
-		position. */
-	FixPoint1616_t SigmaLimitValue[VL53L0_CHECKPOSITION_NO_OF_CHECKS];
-	/*!< Sigma limit value for each position */
+    /*!< CrossTalk compensation rate in Mega counts per seconds. Expressed in 16.16 fixed point format.  */
+	int32_t RangeOffsetMicroMeters;
+    /*!< Range offset adjustment (mm).  */
+
+	uint8_t LimitChecksEnable[VL53L0_CHECKENABLE_NUMBER_OF_CHECKS];
+    /*!< This Array store all the Limit Check enable for this device. */
+	FixPoint1616_t LimitChecksValue[VL53L0_CHECKENABLE_NUMBER_OF_CHECKS];
+    /*!< This Array store all the Limit Check value for this device */
+
 	uint8_t WrapAroundCheckEnable;
-	/*!< Tells if Wrap Around Check shall be enable or not */
+    /*!< Tells if Wrap Around Check shall be enable or not */
 } VL53L0_DeviceParameters_t;
 
 
@@ -276,96 +237,104 @@ typedef struct {
 
 typedef uint8_t VL53L0_State;
 
-#define VL53L0_STATE_POWERDOWN       ((VL53L0_State)  0)
-/*!< Device is in HW reset  */
-#define VL53L0_STATE_WAIT_STATICINIT ((VL53L0_State)  1)
-/*!< Device is initialized and wait for static initialization  */
-#define VL53L0_STATE_STANDBY         ((VL53L0_State)  2)
-/*!< Device is in Low power Standby mode   */
-#define VL53L0_STATE_IDLE            ((VL53L0_State)  3)
-/*!< Device has been initialized and ready to do measurements  */
-#define VL53L0_STATE_RUNNING         ((VL53L0_State)  4)
-/*!< Device is performing measurement */
-#define VL53L0_STATE_UNKNOWN         ((VL53L0_State)  98)
-/*!< Device is in unknown state and need to be rebooted  */
-#define VL53L0_STATE_ERROR           ((VL53L0_State)  99)
-/*!< Device is in error state and need to be rebooted  */
+#define VL53L0_STATE_POWERDOWN       ((VL53L0_State)  0)  /*!< Device is in HW reset  */
+#define VL53L0_STATE_WAIT_STATICINIT ((VL53L0_State)  1)  /*!< Device is initialized and wait for static initialization  */
+#define VL53L0_STATE_STANDBY         ((VL53L0_State)  2)  /*!< Device is in Low power Standby mode   */
+#define VL53L0_STATE_IDLE            ((VL53L0_State)  3)  /*!< Device has been initialized and ready to do measurements  */
+#define VL53L0_STATE_RUNNING         ((VL53L0_State)  4)  /*!< Device is performing measurement */
+#define VL53L0_STATE_UNKNOWN         ((VL53L0_State)  98) /*!< Device is in unknown state and need to be rebooted  */
+#define VL53L0_STATE_ERROR           ((VL53L0_State)  99) /*!< Device is in error state and need to be rebooted  */
 
-/** @} */ /* end of VL53L0_define_State_group */
+/** @} */ // end of VL53L0_define_State_group
 
 
 /** @brief Structure containing the Dmax computation parameters and data
  */
-typedef struct {
-	int32_t AmbTuningWindowFactor_K;
-	/*!<  internal algo tuning (*1000) */
-	int32_t RetSignalAt0mm;
-	/*!< intermediate dmax computation value caching */
+typedef struct{
+	int32_t AmbTuningWindowFactor_K; /*!<  internal algo tuning (*1000) */
+    int32_t RetSignalAt0mm;          /*!< intermediate dmax computation value caching */
 } VL53L0_DMaxData_t;
 
 /**
  * @struct VL53L0_RangeData_t
  * @brief Range measurement data.
  */
-typedef struct {
-	uint32_t TimeStamp;
-	/*!< 32-bit time stamp. */
-	uint32_t MeasurementTimeUsec;
-	/*!< Give the Measurement time needed by the device to do the
-		measurement.*/
-	uint16_t RangeMilliMeter;
-	/*!< range distance in millimeter. */
-	uint16_t RangeDMaxMilliMeter;
-	/*!< Tells what is the maximum detection distance of the device in
-		current setup and environment conditions
-		(Filled when applicable) */
-	FixPoint1616_t SignalRateRtnMegaCps;
-	/*!< Return signal rate (MCPS)\n these is a 16.16 fix point value,
-		which is effectively a measure of target reflectance.*/
-	FixPoint1616_t AmbientRateRtnMegaCps;
-	/*!< Return ambient rate (MCPS)\n these is a 16.16 fix point value,
-		which is effectively a measure of the ambient light.*/
-	uint16_t EffectiveSpadRtnCount;
-	/*!< Return the effective SPAD count for the return signal.
-		To obtain Real value it should be divided by 32 */
-	uint8_t ZoneId;
-	/*!< Denotes which zone and range scheduler stage the range data
-		relates	to. */
-	uint8_t RangeFractionalPart;
-	/*!< Fractional part of range distance. Final value is a FixPoint168
-		value. */
-	uint8_t RangeStatus;
-	/*!< Range Status for the current measurement. This is device dependent.
-		Value = 11 means value is valid. */
+typedef struct{
+    uint32_t TimeStamp;                   /*!< 32-bit time stamp. */
+	uint32_t MeasurementTimeUsec;         /*!< Give the Measurement time needed by the device to do the measurement.*/
+
+
+	uint16_t RangeMilliMeter;             /*!< range distance in millimeter. */
+
+	uint16_t RangeDMaxMilliMeter;         /*!< Tells what is the maximum detection distance of the device in current
+	                                           setup and environment conditions (Filled when applicable) */
+
+	FixPoint1616_t SignalRateRtnMegaCps;  /*!< Return signal rate (MCPS)\n these is a 16.16 fix point value, which is effectively a measure of target reflectance.*/
+	FixPoint1616_t AmbientRateRtnMegaCps; /*!< Return ambient rate (MCPS)\n these is a 16.16 fix point value, which is effectively a measure of the ambient light.*/
+
+	uint16_t EffectiveSpadRtnCount;       /*!< Return the effective SPAD count for the return signal. To obtain Real value it should be divided by 256 */
+
+	uint8_t ZoneId;                       /*!< Denotes which zone and range scheduler stage the range data relates to. */
+	uint8_t RangeFractionalPart;          /*!< Fractional part of range distance. Final value is a FixPoint168 value. */
+	uint8_t RangeStatus;                  /*!< Range Status for the current measurement. This is device dependent. Value = 11 means value is valid. */
 } VL53L0_RangingMeasurementData_t;
 
 
-#define VL53L0_HISTOGRAM_BUFFER_SIZE 38
+#define VL53L0_HISTOGRAM_BUFFER_SIZE 24
 
 /**
  * @struct VL53L0_HistogramData_t
  * @brief Histogram measurement data.
  */
-typedef struct {
+typedef struct{
 	/* Histogram Measurement data */
 	uint32_t HistogramData[VL53L0_HISTOGRAM_BUFFER_SIZE];
 	/*!< Histogram data */
-	uint8_t HistogramType;
-	/*!< Indicate the types of histogram data : Return only, Reference only,
-		both Return and Reference */
-	uint8_t FirstBin;
-	/*!< First Bin value */
-	uint8_t BufferSize;
-	/*!< Buffer Size */
+	uint8_t HistogramType; /*!< Indicate the types of histogram data :
+	Return only, Reference only, both Return and Reference */
+	uint8_t FirstBin; /*!< First Bin value */
+	uint8_t BufferSize; /*!< Buffer Size - Set by the user.*/
 	uint8_t NumberOfBins;
 	/*!< Number of bins filled by the histogram measurement */
+
 	VL53L0_DeviceError ErrorStatus;
-	/*!< Error status of the current measurement.\n
+	/*!< Error status of the current measurement. \n
 	see @a ::VL53L0_DeviceError @a VL53L0_GetStatusErrorString() */
 } VL53L0_HistogramMeasurementData_t;
 
+#define VL53L0_REF_SPAD_BUFFER_SIZE 6
 
 /**
+ * @struct VL53L0_SpadData_t
+ * @brief Spad Configuration Data.
+ */
+typedef struct{
+	uint8_t RefSpadEnables[VL53L0_REF_SPAD_BUFFER_SIZE];
+	/*!< Reference Spad Enables */
+	uint8_t RefGoodSpadMap[VL53L0_REF_SPAD_BUFFER_SIZE];
+	/*!< Reference Spad Good Spad Map */
+} VL53L0_SpadData_t;
+
+typedef struct{
+    FixPoint1616_t OscFrequencyMHz; /* Frequency used */
+
+    uint16_t LastEncodedTimeout; /* last encoded Time out used for
+    timing budget*/
+
+    VL53L0_GpioFunctionality Pin0GpioFunctionality; /* store the functionality
+    of the GPIO: pin0 */
+
+    uint8_t ReadDataFromDeviceDone; /* Indicate if read from device has
+    been done (==1) or not (==0) */
+    uint8_t ModuleId; /* Module ID */
+    uint8_t Revision; /* test Revision */
+    char ProductId[VL53L0_MAX_STRING_LENGTH]; /* Product Identifier String  */
+    uint8_t ReferenceSpadCount; /* used for ref spad management */
+    uint8_t ReferenceSpadType;  /* used for ref spad management */
+
+} VL53L0_DeviceSpecificParameters_t;
+    
+/**
  * @struct VL53L0_DevData_t
  *
  * @brief VL53L0 PAL device ST private data structure \n
@@ -384,38 +353,51 @@ typedef struct {
 	/*!< Ranging Data */
 	VL53L0_HistogramMeasurementData_t LastHistogramMeasure;
 	/*!< Histogram Data */
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-	/*!< Parameters specific to the device */
-	uint8_t SequenceConfig;
-	/*!< Internal value for the sequence config */
-	VL53L0_State PalState;
-	/*!< Current state of the PAL for this device */
-	VL53L0_PowerModes PowerMode;
-	/*!< Current Power Mode  */
-	uint16_t SigmaEstRefArray;
-	/*!< Reference array sigma value in 1/100th of [mm] e.g. 100 = 1mm */
-	uint16_t SigmaEstEffPulseWidth;
-	/*!< Effective Pulse width for sigma estimate in 1/100th of ns
-		e.g. 900 = 9.0ns */
-	uint16_t SigmaEstEffAmbWidth;
-	/*!< Effective Ambient width for sigma estimate in 1/100th of ns
-		e.g. 500 = 5.0ns */
-	FixPoint1616_t SigmaEstimate;
-	/*!< Sigma Estimate - based on ambient & VCSEL rates and
-		signal_total_events */
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    /*!< Parameters specific to the device */
+    VL53L0_SpadData_t SpadData;
+    /*!< Spad Data */
+    uint8_t SequenceConfig;
+    /*!< Internal value for the sequence config */
+    uint8_t RangeFractionalEnable;
+    /*!< Enable/Disable fractional part of ranging data */
+    VL53L0_State PalState;
+    /*!< Current state of the PAL for this device */
+    VL53L0_PowerModes PowerMode;
+    /*!< Current Power Mode  */
+    uint16_t SigmaEstRefArray;
+    /*!< Reference array sigma value in 1/100th of [mm] e.g. 100 = 1mm */
+    uint16_t SigmaEstEffPulseWidth;
+    /*!< Effective Pulse width for sigma estimate in 1/100th
+     * of ns e.g. 900 = 9.0ns */
+    uint16_t SigmaEstEffAmbWidth;
+    /*!< Effective Ambient width for sigma estimate in 1/100th of ns
+     * e.g. 500 = 5.0ns */
+    uint16_t targetRefRate;
+    /*!< Target Ambient Rate for Ref spad management */
+    FixPoint1616_t SigmaEstimate;
+    /*!< Sigma Estimate - based on ambient & VCSEL rates and
+     * signal_total_events */
 	FixPoint1616_t SignalEstimate;
 	/*!< Signal Estimate - based on ambient & VCSEL rates and cross talk */
+    FixPoint1616_t LastSignalRefMcps;
+    /*!< Latest Signal ref in Mcps */
+    uint8_t *pTuningSettingsPointer;
+    /*!< Pointer for Tuning Settings table */
+    uint8_t UseInternalTuningSettings;
+    /*!< Indicate if we use  Tuning Settings table */
+
 #ifdef PAL_EXTENDED
-	VL53L0_TuningDeviceParameters_t TuningDeviceParameters;
-	/*!< Tuning Device Parameters specific to the device. */
+    VL53L0_TuningDeviceParameters_t TuningDeviceParameters;
+    /*!< Tuning Device Parameters specific to the device. */
 #endif
 
 } VL53L0_DevData_t;
 
 
 
-/** @defgroup VL53L0_define_InterruptPolarity_group Defines the Polarity of the
- *  Interrupt
+/** @defgroup VL53L0_define_InterruptPolarity_group Defines the Polarity
+ * of the Interrupt
  *  Defines the Polarity of the Interrupt
  *  @{
  */
@@ -426,7 +408,7 @@ typedef uint8_t VL53L0_InterruptPolarity;
 #define VL53L0_INTERRUPTPOLARITY_HIGH      ((VL53L0_InterruptPolarity)  1)
 /*!< Set active high polarity best setup for rising edge. */
 
-/** @} */ /* end of VL53L0_define_InterruptPolarity_group */
+/** @} */ // end of VL53L0_define_InterruptPolarity_group
 
 
 #ifdef __cplusplus
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_device.h b/drivers/input/misc/vl53L0/inc/vl53l0_device.h
index 9fc37803c4f..52a5ef403b4 100644
--- a/drivers/input/misc/vl53L0/inc/vl53l0_device.h
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_device.h
@@ -47,22 +47,21 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 typedef uint8_t VL53L0_DeviceError;
 
-#define VL53L0_DEVICEERROR_NONE ((VL53L0_DeviceError)   0)
-#define VL53L0_DEVICEERROR_VCSELCONTINUITYTESTFAILURE ((VL53L0_DeviceError) 1)
-#define VL53L0_DEVICEERROR_VCSELWATCHDOGTESTFAILURE ((VL53L0_DeviceError)   2)
-#define VL53L0_DEVICEERROR_NOVHVVALUEFOUND ((VL53L0_DeviceError)   3)
-#define VL53L0_DEVICEERROR_MSRCNOTARGET ((VL53L0_DeviceError)   4)
-#define VL53L0_DEVICEERROR_MSRCMINIMUMSNR  ((VL53L0_DeviceError)   5)
-#define VL53L0_DEVICEERROR_MSRCWRAPAROUND ((VL53L0_DeviceError)   6)
-#define VL53L0_DEVICEERROR_TCC ((VL53L0_DeviceError)   7)
-#define VL53L0_DEVICEERROR_RANGEAWRAPAROUND ((VL53L0_DeviceError)   8)
-#define VL53L0_DEVICEERROR_RANGEBWRAPAROUND ((VL53L0_DeviceError)   9)
-#define VL53L0_DEVICEERROR_MINCLIP ((VL53L0_DeviceError)   10)
-#define VL53L0_DEVICEERROR_RANGECOMPLETE ((VL53L0_DeviceError)   11)
-#define VL53L0_DEVICEERROR_ALGOUNDERFLOW ((VL53L0_DeviceError)   12)
-#define VL53L0_DEVICEERROR_ALGOOVERFLOW ((VL53L0_DeviceError)   13)
-#define VL53L0_DEVICEERROR_FINALSNRLIMIT ((VL53L0_DeviceError)   14)
-#define VL53L0_DEVICEERROR_NOTARGETIGNORE ((VL53L0_DeviceError)   15)
+#define VL53L0_DEVICEERROR_NONE                         ((VL53L0_DeviceError)   0)    /*!< 0  0b0000 NoError  */
+#define VL53L0_DEVICEERROR_VCSELCONTINUITYTESTFAILURE   ((VL53L0_DeviceError)   1)    /*!< 1  0b0001  */
+#define VL53L0_DEVICEERROR_VCSELWATCHDOGTESTFAILURE     ((VL53L0_DeviceError)   2)    /*!< 2  0b0010  */
+#define VL53L0_DEVICEERROR_NOVHVVALUEFOUND              ((VL53L0_DeviceError)   3)    /*!< 3  0b0011  */
+#define VL53L0_DEVICEERROR_MSRCNOTARGET                 ((VL53L0_DeviceError)   4)    /*!< 4  0b0100  */
+#define VL53L0_DEVICEERROR_SNRCHECK                     ((VL53L0_DeviceError)   5)    /*!< 5  0b0101  */
+#define VL53L0_DEVICEERROR_RANGEPHASECHECK              ((VL53L0_DeviceError)   6)    /*!< 6  0b0110  */
+#define VL53L0_DEVICEERROR_SIGMATHRESHOLDCHECK          ((VL53L0_DeviceError)   7)    /*!< 7  0b0111  */
+#define VL53L0_DEVICEERROR_TCC                          ((VL53L0_DeviceError)   8)    /*!< 8  0b1000  */
+#define VL53L0_DEVICEERROR_PHASECONSISTENCY             ((VL53L0_DeviceError)   9)    /*!< 9  0b1001  */
+#define VL53L0_DEVICEERROR_MINCLIP                      ((VL53L0_DeviceError)   10)   /*!< 10 0b1010  */
+#define VL53L0_DEVICEERROR_RANGECOMPLETE                ((VL53L0_DeviceError)   11)   /*!< 11 0b1011  */
+#define VL53L0_DEVICEERROR_ALGOUNDERFLOW                ((VL53L0_DeviceError)   12)   /*!< 12 0b1100  */
+#define VL53L0_DEVICEERROR_ALGOOVERFLOW                 ((VL53L0_DeviceError)   13)   /*!< 13 0b1101  */
+#define VL53L0_DEVICEERROR_RANGEIGNORETHRESHOLD         ((VL53L0_DeviceError)   14)   /*!< 14 0b1110  */
 
 /** @} */ /* end of VL53L0_DeviceError_group */
 
@@ -75,10 +74,11 @@ typedef uint8_t VL53L0_DeviceError;
  *  @{
  */
 
-#define VL53L0_CHECKENABLE_SIGMA                  0
-#define VL53L0_CHECKENABLE_SIGNAL_RATE            1
+#define VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE           0
+#define VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE     1
+#define VL53L0_CHECKENABLE_SIGNAL_REF_CLIP             2
 
-#define VL53L0_CHECKENABLE_NUMBER_OF_CHECKS       2
+#define VL53L0_CHECKENABLE_NUMBER_OF_CHECKS            3
 
 /** @} */ /* end of VL53L0_CheckEnable_group */
 
@@ -106,13 +106,6 @@ typedef uint8_t VL53L0_GpioFunctionality;
 /** @} */ /* end of VL53L0_GpioFunctionality_group */
 
 
-typedef struct {
-	FixPoint1616_t OscFrequencyMHz;
-	uint16_t LastEncodedTimeout;
-	VL53L0_GpioFunctionality Pin0GpioFunctionality;
-} VL53L0_DeviceSpecificParameters_t;
-
-
 /* Device register map */
 
 /** @defgroup VL53L0_DefineRegisters_group Define Registers
@@ -141,15 +134,10 @@ typedef struct {
 
 #define VL53L0_REG_SYSTEM_THRESH_HIGH               0x000C  /* NOSLC  2 bytes */
 #define VL53L0_REG_SYSTEM_THRESH_LOW                0x000E  /* NOSLC  2 bytes */
-
-
-/* FPGA bitstream */
 #define VL53L0_REG_SYSTEM_SEQUENCE_CONFIG			0x0001
+#define VL53L0_REG_SYSTEM_RANGE_CONFIG		    	0x0009
 #define VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD	0x0004
 
-#define VL53L0_REG_SYSTEM_REPORT_REQUEST	        0x0009
-	#define	VL53L0_REG_SYSTEM_RANGEA_DATA			0x04
-	#define	VL53L0_REG_SYSTEM_RANGEB_DATA			0x05
 
 #define VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO     0x000A
 	#define VL53L0_REG_SYSTEM_INTERRUPT_GPIO_DISABLED		0x00
@@ -166,70 +154,81 @@ typedef struct {
 #define VL53L0_REG_RESULT_INTERRUPT_STATUS		    0x0013
 #define VL53L0_REG_RESULT_RANGE_STATUS		        0x0014
 
-#define VL53L0_REG_RESULT_SIGNAL_COUNT_RATE_RET     0x001A
-#define VL53L0_REG_RESULT_AMBIENT_COUNT_RATE_RET    0x001C
-#define VL53L0_REG_RESULT_FINAL_RANGE		        0x001E
+#define VL53L0_REG_RESULT_CORE_PAGE  1
+#define VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN   0x00BC
+#define VL53L0_REG_RESULT_CORE_RANGING_TOTAL_EVENTS_RTN    0x00C0
+#define VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF   0x00D0
+#define VL53L0_REG_RESULT_CORE_RANGING_TOTAL_EVENTS_REF    0x00D4
+#define VL53L0_REG_RESULT_PEAK_SIGNAL_RATE_REF             0x00B6
 
-/* Algo register */
-#define VL53L0_REG_ALGO_CROSSTALK_COMPENSATION_RATE	0x0020
-#define VL53L0_REG_ALGO_RANGE_IGNORE_VALID_HEIGHT	0x0025
-#define VL53L0_REG_ALGO_RANGE_IGNORE_THRESHOLD		0x0026
-#define VL53L0_REG_ALGO_SNR_RATIO					0x0027
-#define VL53L0_REG_ALGO_RANGE_CHECK_ENABLES		    0x0028
+//Algo register
 
-#define VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET	0x0029
+#define VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET_MM	0x0028
 
 #define VL53L0_REG_I2C_SLAVE_DEVICE_ADDRESS	        0x008a
 
-/* MSRC registers */
-#define VL53L0_REG_MSRC_CONFIG_COUNT		        0x0044
-#define VL53L0_REG_MSRC_CONFIG_TIMEOUT		        0x0046
-#define VL53L0_REG_MSRC_CONFIG_MIN_SNR		        0x0055
-#define VL53L0_REG_MSRC_CONFIG_VALID_PHASE_LOW	    0x0047
-#define VL53L0_REG_MSRC_CONFIG_VALID_PHASE_HIGH     0x0048
-
-/* RANGE A registers */
-#define VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD	0x0050
-#define VL53L0_REG_RNGA_TIMEOUT_MSB			0x0051
-#define VL53L0_REG_RNGA_TIMEOUT_LSB			0x0052
-#define VL53L0_REG_RNGA_CONFIG_VALID_PHASE_LOW	0x0056
-#define VL53L0_REG_RNGA_CONFIG_VALID_PHASE_HIGH	0x0057
-
-/* RANGE B1 registers */
-#define VL53L0_REG_RNGB1_CONFIG_VCSEL_PERIOD	0x0060
-#define VL53L0_REG_RNGB1_TIMEOUT_MSB			0x0061
-#define VL53L0_REG_RNGB1_TIMEOUT_LSB			0x0062
-#define VL53L0_REG_RNGB1_CONFIG_VALID_PHASE_LOW	0x0066
-#define VL53L0_REG_RNGB1_CONFIG_VALID_PHASE_HIGH	0x0067
-
-/* RANGE B2 registers */
-#define VL53L0_REG_RNGB2_CONFIG_VCSEL_PERIOD	0x0070
-#define VL53L0_REG_RNGB2_TIMEOUT_MSB			0x0071
-#define VL53L0_REG_RNGB2_TIMEOUT_LSB			0x0072
-#define VL53L0_REG_RNGB2_CONFIG_VALID_PHASE_LOW	0x0076
-#define VL53L0_REG_RNGB2_CONFIG_VALID_PHASE_HIGH	0x0077
+//Check Limit registers
+#define VL53L0_REG_MSRC_CONFIG_CONTROL		                     0x0060
+
+#define VL53L0_REG_PRE_RANGE_CONFIG_MIN_SNR                      0X0027
+#define VL53L0_REG_PRE_RANGE_CONFIG_VALID_PHASE_LOW              0x0056
+#define VL53L0_REG_PRE_RANGE_CONFIG_VALID_PHASE_HIGH             0x0057
+#define VL53L0_REG_PRE_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT     0x0064
+
+#define VL53L0_REG_FINAL_RANGE_CONFIG_MIN_SNR                    0X0067
+#define VL53L0_REG_FINAL_RANGE_CONFIG_VALID_PHASE_LOW            0x0047
+#define VL53L0_REG_FINAL_RANGE_CONFIG_VALID_PHASE_HIGH           0x0048
+#define VL53L0_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT   0x0044
+
+
+#define VL53L0_REG_PRE_RANGE_CONFIG_SIGMA_THRESH_HI              0X0061
+#define VL53L0_REG_PRE_RANGE_CONFIG_SIGMA_THRESH_LO              0X0062
+
+// PRE RANGE registers
+#define VL53L0_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD	             0x0050
+#define VL53L0_REG_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI            0x0051
+#define VL53L0_REG_PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO            0x0052
+
+#define VL53L0_REG_SYSTEM_HISTOGRAM_BIN                          0x0081
+#define VL53L0_REG_HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT         0x0033
+#define VL53L0_REG_HISTOGRAM_CONFIG_READOUT_CTRL                 0x0055
+
+#define VL53L0_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD               0x0070
+#define VL53L0_REG_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI          0x0071
+#define VL53L0_REG_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO          0x0072
+#define VL53L0_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS         0x0020
+
 
 
 #define VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N	  0x00bf
 #define VL53L0_REG_IDENTIFICATION_MODEL_ID        0x00c0
 #define VL53L0_REG_IDENTIFICATION_REVISION_ID     0x00c2
-#define VL53L0_REG_IDENTIFICATION_MODULE_ID       0x00c3
 
 #define VL53L0_REG_OSC_CALIBRATE_VAL              0x00f8
 
-#define VL53L0_REG_FIRMWARE_MODE_STATUS		           0x00C5
-
-#define VL53L0_REG_DYNAMIC_SPAD_ACTUAL_RTN_SPADS_INT   0x0016
 
 #define VL53L0_SIGMA_ESTIMATE_MAX_VALUE                65535
 /*equivalent to a range sigma of 655.35mm */
 
+#define VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_0   0x0B0
+#define VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_1   0x0B1
+#define VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_2   0x0B2
+#define VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_3   0x0B3
+#define VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_4   0x0B4
+#define VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_5   0x0B5
+                                         
+#define VL53L0_REG_GLOBAL_CONFIG_REF_EN_START_SELECT   0xB6
+#define VL53L0_REG_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD 0x4E /* 0x14E */
+#define VL53L0_REG_DYNAMIC_SPAD_REF_EN_START_OFFSET    0x4F /* 0x14F */
+#define VL53L0_REG_POWER_MANAGEMENT_GO1_POWER_FORCE    0x80
+
 /*
  * Speed of light in um per 1E-10 Seconds
  */
 
 #define VL53L0_SPEED_OF_LIGHT_IN_AIR 2997
 
+#define VL53L0_REG_VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV             0x0089
 
 /** @} */ /* end of VL53L0_DefineRegisters_group */
 
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_strings.h b/drivers/input/misc/vl53L0/inc/vl53l0_strings.h
index 2bf003dd008..f09fcabaee2 100644
--- a/drivers/input/misc/vl53L0/inc/vl53l0_strings.h
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_strings.h
@@ -25,7 +25,6 @@ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
-
 /*
  * @file vl53l0_string.h
  * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
@@ -62,38 +61,33 @@ extern "C" {
 #define  VL53L0_STRING_ERROR_BUFFER_TOO_SMALL   "Buffer too small"
 
 #define  VL53L0_STRING_ERROR_GPIO_NOT_EXISTING  "GPIO not existing"
-#define  VL53L0_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED \
-			"GPIO functionality not supported"
-#define  VL53L0_STRING_ERROR_CONTROL_INTERFACE  "Control Interface Error"
+    #define  VL53L0_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED           "GPIO functionality not supported"
+    #define  VL53L0_STRING_ERROR_CONTROL_INTERFACE                          "Control Interface Error"
+    #define  VL53L0_STRING_ERROR_DIVISION_BY_ZERO                           "Division by zero Error"
 
 
 /* Device Specific */
-#define  VL53L0_STRING_DEVICEERROR_NONE         "No Update"
-#define  VL53L0_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE \
-			"VCSEL Continuity Test Failure"
-#define  VL53L0_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE \
-			"VCSEL Watchdog Test Failure"
-#define  VL53L0_STRING_DEVICEERROR_NOVHVVALUEFOUND	"No VHV Value found"
-#define  VL53L0_STRING_DEVICEERROR_MSRCNOTARGET		"MSRC No Target Error"
-#define  VL53L0_STRING_DEVICEERROR_MSRCMINIMUMSNR   "MSRC Minimum SNR Error"
-#define  VL53L0_STRING_DEVICEERROR_MSRCWRAPAROUND   "MSRC Wraparound Error"
-#define  VL53L0_STRING_DEVICEERROR_TCC              "TCC Error"
-#define  VL53L0_STRING_DEVICEERROR_RANGEAWRAPAROUND "Range A Wraparound Error"
-#define  VL53L0_STRING_DEVICEERROR_RANGEBWRAPAROUND "Range B Wraparound Error"
-#define  VL53L0_STRING_DEVICEERROR_MINCLIP          "Min Clip Error"
+    #define  VL53L0_STRING_DEVICEERROR_NONE                                 "No Update"
+    #define  VL53L0_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE           "VCSEL Continuity Test Failure"
+    #define  VL53L0_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE             "VCSEL Watchdog Test Failure"
+    #define  VL53L0_STRING_DEVICEERROR_NOVHVVALUEFOUND                      "No VHV Value found"
+    #define  VL53L0_STRING_DEVICEERROR_MSRCNOTARGET                         "MSRC No Target Error"
+    #define  VL53L0_STRING_DEVICEERROR_SNRCHECK                             "SNR Check Exit"
+    #define  VL53L0_STRING_DEVICEERROR_RANGEPHASECHECK                      "Range Phase Check Error"
+    #define  VL53L0_STRING_DEVICEERROR_SIGMATHRESHOLDCHECK                  "Sigma Threshold Check Error"
+    #define  VL53L0_STRING_DEVICEERROR_TCC                                  "TCC Error"
+    #define  VL53L0_STRING_DEVICEERROR_PHASECONSISTENCY                     "Phase Consistency Error"
+    #define  VL53L0_STRING_DEVICEERROR_MINCLIP                              "Min Clip Error"
 #define  VL53L0_STRING_DEVICEERROR_RANGECOMPLETE    "Range Complete"
 #define  VL53L0_STRING_DEVICEERROR_ALGOUNDERFLOW    "Range Algo Underflow Error"
 #define  VL53L0_STRING_DEVICEERROR_ALGOOVERFLOW     "Range Algo Overlow Error"
-#define  VL53L0_STRING_DEVICEERROR_FINALSNRLIMIT    "Final Minimum SNR Error"
-#define  VL53L0_STRING_DEVICEERROR_NOTARGETIGNORE   "No Target Ignore Error"
-#define  VL53L0_STRING_DEVICEERROR_UNKNOWN          "Unknown error code"
-
+    #define  VL53L0_STRING_DEVICEERROR_RANGEIGNORETHRESHOLD                 "Range Ignore Threshold Error"
+    #define  VL53L0_STRING_DEVICEERROR_UNKNOWN                              "Unknown error code"
 
 /* Check Enable */
-#define  VL53L0_STRING_CHECKENABLE_SNR              "SNR"
-#define  VL53L0_STRING_CHECKENABLE_SIGMA            "SIGMA"
-#define  VL53L0_STRING_CHECKENABLE_RANGE            "RANGE"
-#define  VL53L0_STRING_CHECKENABLE_SIGNAL_RATE      "SIGNAL RATE"
+    #define  VL53L0_STRING_CHECKENABLE_SIGMA_FINAL_RANGE                    "SIGMA FINAL RANGE"
+	#define  VL53L0_STRING_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE              "SIGNAL RATE FINAL RANGE"
+	#define  VL53L0_STRING_CHECKENABLE_SIGNAL_REF_CLIP                      "SIGNAL REF CLIP"
 
 
 
diff --git a/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h b/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h
index 2066712822d..fd6f5b7ae0b 100644
--- a/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h
+++ b/drivers/input/misc/vl53L0/inc/vl53l0_tuning.h
@@ -26,8 +26,8 @@ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 /*
- * @file vl53l0_api.h
- * $Date: 2014-12-04 16:15:06 +0100 (Thu, 04 Dec 2014) $
+ * @file vl53l0_tuning.h
+ * $Date: 2015-10-01 16:15:06 +0100 (Thu, 01 Oct 2015) $
  * $Revision: 1906 $
  */
 
@@ -45,18 +45,108 @@ extern "C" {
 #endif
 
 
-/**
- * @brief Internal function used to Program the default tuning settings
- *
- * @ingroup VL53L0_general_group
- * @note This function access to the device
- *
- * @param   Dev                   Device Handle
- * @return  VL53L0_ERROR_NONE     Success
- * @return  "Other error code"    See ::VL53L0_Error
- */
-VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev);
+uint8_t DefaultTuningSettings[] = {
+
+    // update 02/11/2015_v35
+    0x01, 0xFF, 0x01,
+    0x01, 0x00, 0x00,
+
+    0x01, 0xFF, 0x00,
+    0x01, 0x09, 0x00,
+    0x01, 0x10, 0x00,
+    0x01, 0x11, 0x00,
+
+    0x01, 0x24, 0x01,
+    0x01, 0x25, 0xff,
+    0x01, 0x75, 0x00,
+
+    0x01, 0xFF, 0x01,
+    0x01, 0x4e, 0x2c,
+    0x01, 0x48, 0x00,
+    0x01, 0x30, 0x20,
+
+    0x01, 0xFF, 0x00,
+    0x01, 0x30, 0x64,
+    0x01, 0x54, 0x00,
+    0x01, 0x31, 0x04,
+    0x01, 0x32, 0x03,
+    0x01, 0x40, 0x82,
+    0x01, 0x41, 0x80,
+    0x01, 0x42, 0x07,
+    0x01, 0x43, 0x1a,
+    0x01, 0x46, 0x25,
+    0x01, 0x60, 0x00,
+    0x01, 0x27, 0x00,
+    0x01, 0x50, 0x06,
+    0x01, 0x51, 0x00,
+    0x01, 0x52, 0x96,
+    0x01, 0x56, 0x08,
+    0x01, 0x57, 0x30,
+    0x01, 0x61, 0x00,
+    0x01, 0x62, 0x00,
+    0x01, 0x64, 0x00,
+    0x01, 0x65, 0x13,
+    0x01, 0x66, 0xa0,
+
+    0x01, 0xFF, 0x01,
+    0x01, 0x22, 0x32,
+    0x01, 0x47, 0x14,
+    0x01, 0x49, 0xff,
+    0x01, 0x4a, 0x00,
+
+    0x01, 0xFF, 0x00,
+    0x01, 0x7a, 0x0a,
+    0x01, 0x7b, 0x00,
+    0x01, 0x78, 0x21,
+
+    0x01, 0xFF, 0x01,
+    0x01, 0x23, 0x34,
+    0x01, 0x42, 0x00,
+    0x01, 0x44, 0xff,
+    0x01, 0x45, 0x26,
+    0x01, 0x46, 0x05,
+    0x01, 0x40, 0x40,
+    0x01, 0x0E, 0x06,
+    0x01, 0x20, 0x1a,
+    0x01, 0x43, 0x40,
+
+    0x01, 0xFF, 0x00,
+    0x01, 0x34, 0x03,
+    0x01, 0x35, 0x44,
+
+    0x01, 0xFF, 0x01,
+    0x01, 0x31, 0x04,
+    0x01, 0x4b, 0x09,
+    0x01, 0x4c, 0x05,
+    0x01, 0x4d, 0x04,
+
+
+    0x01, 0xFF, 0x00,
+    0x01, 0x44, 0x00,
+    0x01, 0x45, 0x20,
+    0x01, 0x47, 0x08,
+    0x01, 0x48, 0x28,
+    0x01, 0x67, 0x00,
+    0x01, 0x70, 0x04,
+    0x01, 0x71, 0x01,
+    0x01, 0x72, 0xfe,
+    0x01, 0x76, 0x00,
+    0x01, 0x77, 0x00,
+
+    0x01, 0xFF, 0x01,
+    0x01, 0x0d, 0x01,
+
+    0x01, 0xFF, 0x00,
+    0x01, 0x80, 0x01,
+    0x01, 0x01, 0xF8,
+
+    0x01, 0xFF, 0x01,
+    0x01, 0x8e, 0x01,
+    0x01, 0x00, 0x01,
+    0x01, 0xFF, 0x00,
 
+    0x00, 0x00, 0x00
+};
 
 #ifdef __cplusplus
 }
diff --git a/drivers/input/misc/vl53L0/src/vl53l010_api.c b/drivers/input/misc/vl53L0/src/vl53l010_api.c
new file mode 100644
index 00000000000..8a25a03fdda
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l010_api.c
@@ -0,0 +1,4128 @@
+/*******************************************************************************
+ Copyright © 2015, STMicroelectronics International N.V.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in the
+ documentation and/or other materials provided with the distribution.
+ * Neither the name of STMicroelectronics nor the
+ names of its contributors may be used to endorse or promote products
+ derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+ NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+ IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+#include "vl53l010_api.h"
+#include "vl53l010_device.h"
+#include "vl53l010_tuning.h"
+
+/* use macro for abs */
+#ifndef __KERNEL__
+#include <stdlib.h>
+#endif
+
+#ifdef VL53L0_EXTERNAL_USE
+#define VL53L010_EXTERNAL
+#else
+#define VL53L010_EXTERNAL  static
+#endif
+
+
+#define LOG_FUNCTION_START(fmt, ...) \
+	_LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
+#define LOG_FUNCTION_END(status, ...) \
+	_LOG_FUNCTION_END(TRACE_MODULE_API, status, ##__VA_ARGS__)
+#define LOG_FUNCTION_END_FMT(status, fmt, ...) \
+	_LOG_FUNCTION_END_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)
+
+#ifdef VL53L0_LOG_ENABLE
+#define trace_print(level, ...) trace_print_module_function(TRACE_MODULE_API, \
+	level, TRACE_FUNCTION_NONE, ##__VA_ARGS__)
+#endif
+
+
+/* Defines */
+#define VL53L010_SETPARAMETERFIELD(Dev, field, value) \
+	do { \
+		if (Status == VL53L0_ERROR_NONE) {\
+			CurrentParameters = \
+				PALDevDataGet(Dev, CurrentParameters); \
+			CurrentParameters.field = value; \
+			CurrentParameters =	\
+				PALDevDataSet(Dev, CurrentParameters, \
+					CurrentParameters); \
+		} \
+	} while (0)
+#define VL53L010_SETARRAYPARAMETERFIELD(Dev, field, index, value) \
+	do { \
+		if (Status == VL53L0_ERROR_NONE) {\
+			CurrentParameters = \
+				PALDevDataGet(Dev, CurrentParameters); \
+			CurrentParameters.field[index] = value; \
+			CurrentParameters = \
+				PALDevDataSet(Dev, CurrentParameters, \
+					CurrentParameters); \
+		} \
+	} while (0)
+
+#define VL53L010_GETPARAMETERFIELD(Dev, field, variable) \
+	do { \
+		if (Status == VL53L0_ERROR_NONE) { \
+			CurrentParameters = \
+				PALDevDataGet(Dev, CurrentParameters); \
+			variable = CurrentParameters.field; \
+		} \
+	} while (0)
+
+#define VL53L010_GETARRAYPARAMETERFIELD(Dev, field, index, variable) \
+	do { \
+		if (Status == VL53L0_ERROR_NONE) { \
+			CurrentParameters = \
+				PALDevDataGet(Dev, CurrentParameters); \
+			variable = CurrentParameters.field[index]; \
+		} \
+	} while (0)
+
+#define VL53L010_SETDEVICESPECIFICPARAMETER(Dev, field, value) \
+	do { \
+		if (Status == VL53L0_ERROR_NONE) { \
+			DeviceSpecificParameters = \
+				PALDevDataGet(Dev, DeviceSpecificParameters); \
+			DeviceSpecificParameters.field = value; \
+			DeviceSpecificParameters = \
+				PALDevDataSet(Dev, DeviceSpecificParameters, \
+				DeviceSpecificParameters); \
+		} \
+	} while (0)
+
+#define VL53L010_GETDEVICESPECIFICPARAMETER(Dev, field) \
+		PALDevDataGet(Dev, DeviceSpecificParameters).field
+
+#define VL53L010_FIXPOINT1616TOFIXPOINT97(Value) \
+			(uint16_t)((Value >> 9) & 0xFFFF)
+#define VL53L010_FIXPOINT97TOFIXPOINT1616(Value) \
+			(FixPoint1616_t)(Value << 9)
+#define VL53L010_FIXPOINT1616TOFIXPOINT412(Value) \
+			(uint16_t)((Value >> 4) & 0xFFFF)
+#define VL53L010_FIXPOINT412TOFIXPOINT1616(Value) \
+			(FixPoint1616_t)(Value << 4)
+#define VL53L010_FIXPOINT1616TOFIXPOINT08(Value) \
+			(uint8_t)((Value >> 8) & 0x00FF)
+#define VL53L010_FIXPOINT08TOFIXPOINT1616(Value) \
+			(FixPoint1616_t)(Value << 8)
+#define VL53L010_MAKEUINT16(lsb, msb) \
+			(uint16_t)((((uint16_t)msb) << 8) + (uint16_t)lsb)
+
+/* Internal functions declaration */
+VL53L010_EXTERNAL VL53L0_Error VL53L010_get_vcsel_pulse_period(VL53L0_DEV Dev,
+				uint8_t *pVCSELPulsePeriod, uint8_t RangeIndex);
+VL53L010_EXTERNAL uint8_t VL53L010_encode_vcsel_period(uint8_t vcsel_period_pclks);
+VL53L010_EXTERNAL uint8_t VL53L010_decode_vcsel_period(uint8_t vcsel_period_reg);
+VL53L010_EXTERNAL uint16_t VL53L010_calc_encoded_timeout(VL53L0_DEV Dev,
+			uint32_t timeout_period_us, uint8_t vcsel_period);
+VL53L010_EXTERNAL uint32_t VL53L010_calc_ranging_wait_us(VL53L0_DEV Dev,
+			uint16_t timeout_overall_periods, uint8_t vcsel_period);
+VL53L010_EXTERNAL VL53L0_Error VL53L010_load_additional_settings1(VL53L0_DEV Dev);
+VL53L010_EXTERNAL VL53L0_Error VL53L010_load_additional_settings3(VL53L0_DEV Dev);
+VL53L010_EXTERNAL VL53L0_Error VL53L010_check_part_used(VL53L0_DEV Dev,
+            uint8_t *Revision, VL53L0_DeviceInfo_t *pVL53L0_DeviceInfo);
+VL53L010_EXTERNAL VL53L0_Error VL53L010_get_info_from_device(VL53L0_DEV Dev);
+VL53L010_EXTERNAL VL53L0_Error VL53L010_device_read_strobe(VL53L0_DEV Dev);
+VL53L010_EXTERNAL VL53L0_Error VL53L010_get_pal_range_status(VL53L0_DEV Dev,
+				uint8_t DeviceRangeStatus,
+				FixPoint1616_t SignalRate,
+				FixPoint1616_t CrosstalkCompensation,
+				uint16_t EffectiveSpadRtnCount,
+				VL53L0_RangingMeasurementData_t
+					*pRangingMeasurementData,
+				uint8_t *pPalRangeStatus);
+
+/* Group PAL General Functions */
+VL53L0_Error VL53L010_GetVersion(VL53L0_Version_t *pVersion)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	pVersion->major = VL53L010_IMPLEMENTATION_VER_MAJOR;
+	pVersion->minor = VL53L010_IMPLEMENTATION_VER_MINOR;
+	pVersion->build = VL53L010_IMPLEMENTATION_VER_SUB;
+
+	pVersion->revision = VL53L0_IMPLEMENTATION_VER_REVISION;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetPalSpecVersion(VL53L0_Version_t *pPalSpecVersion)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	pPalSpecVersion->major = VL53L010_SPECIFICATION_VER_MAJOR;
+	pPalSpecVersion->minor = VL53L010_SPECIFICATION_VER_MINOR;
+	pPalSpecVersion->build = VL53L010_SPECIFICATION_VER_SUB;
+
+	pPalSpecVersion->revision = VL53L010_SPECIFICATION_VER_REVISION;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetDeviceInfo(VL53L0_DEV Dev,
+				VL53L0_DeviceInfo_t *pVL53L0_DeviceInfo)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t model_id;
+	uint8_t Revision;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L010_check_part_used(Dev, &Revision, pVL53L0_DeviceInfo);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Revision == 0) {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L010_STRING_DEVICE_INFO_NAME_TS0);
+		} else if ((Revision <= 34) && (Revision != 32)) {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L010_STRING_DEVICE_INFO_NAME_TS1);
+		} else if (Revision < 39) {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L010_STRING_DEVICE_INFO_NAME_TS2);
+		} else {
+			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+				VL53L010_STRING_DEVICE_INFO_NAME_ES1);
+		}
+
+		VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Type,
+			VL53L010_STRING_DEVICE_INFO_TYPE);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_IDENTIFICATION_MODEL_ID,
+					&pVL53L0_DeviceInfo->ProductType);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_IDENTIFICATION_REVISION_ID,
+					&model_id);
+        pVL53L0_DeviceInfo->ProductRevisionMajor = 1;
+        pVL53L0_DeviceInfo->ProductRevisionMinor = (model_id & 0xF0) >> 4;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetDeviceErrorStatus(VL53L0_DEV Dev,
+				VL53L0_DeviceError *pDeviceErrorStatus)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t RangeStatus;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L010_REG_RESULT_RANGE_STATUS,
+		&RangeStatus);
+
+	*pDeviceErrorStatus = (VL53L0_DeviceError)((RangeStatus & 0x78) >> 3);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+#define VL53L010_BUILDSTATUSERRORSTRING(BUFFER, ERRORCODE, STRINGVALUE) \
+			case ERRORCODE: \
+				VL53L0_COPYSTRING(BUFFER, STRINGVALUE);\
+				break;\
+
+VL53L0_Error VL53L010_GetDeviceErrorString(VL53L0_DeviceError ErrorCode,
+				char *pDeviceErrorString)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	switch (ErrorCode) {
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_NONE,
+			VL53L010_STRING_DEVICEERROR_NONE);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_VCSELCONTINUITYTESTFAILURE,
+			VL53L010_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_VCSELWATCHDOGTESTFAILURE,
+			VL53L010_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_NOVHVVALUEFOUND,
+			VL53L010_STRING_DEVICEERROR_NOVHVVALUEFOUND);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_MSRCNOTARGET,
+			VL53L010_STRING_DEVICEERROR_MSRCNOTARGET);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_MSRCMINIMUMSNR,
+			VL53L010_STRING_DEVICEERROR_MSRCMINIMUMSNR);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_MSRCWRAPAROUND,
+			VL53L010_STRING_DEVICEERROR_MSRCWRAPAROUND);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_TCC, VL53L010_STRING_DEVICEERROR_TCC);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_RANGEAWRAPAROUND,
+			VL53L010_STRING_DEVICEERROR_RANGEAWRAPAROUND);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_RANGEBWRAPAROUND,
+			VL53L010_STRING_DEVICEERROR_RANGEBWRAPAROUND);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_MINCLIP,
+			VL53L010_STRING_DEVICEERROR_MINCLIP);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_RANGECOMPLETE,
+			VL53L010_STRING_DEVICEERROR_RANGECOMPLETE);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_ALGOUNDERFLOW,
+			VL53L010_STRING_DEVICEERROR_ALGOUNDERFLOW);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_ALGOOVERFLOW,
+			VL53L010_STRING_DEVICEERROR_ALGOOVERFLOW);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_FINALSNRLIMIT,
+			VL53L010_STRING_DEVICEERROR_FINALSNRLIMIT);
+	VL53L010_BUILDSTATUSERRORSTRING(pDeviceErrorString,
+			VL53L010_DEVICEERROR_NOTARGETIGNORE,
+			VL53L010_STRING_DEVICEERROR_NOTARGETIGNORE);
+	default:
+		VL53L0_COPYSTRING(pDeviceErrorString,
+			VL53L010_STRING_UNKNOW_ERROR_CODE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetPalErrorString(VL53L0_Error PalErrorCode,
+				char *pPalErrorString)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	switch (PalErrorCode) {
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_NONE, VL53L010_STRING_ERROR_NONE);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_CALIBRATION_WARNING,
+			VL53L010_STRING_ERROR_CALIBRATION_WARNING);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_MIN_CLIPPED,
+			VL53L010_STRING_ERROR_MIN_CLIPPED);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_UNDEFINED, VL53L010_STRING_ERROR_UNDEFINED);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_INVALID_PARAMS,
+			VL53L010_STRING_ERROR_INVALID_PARAMS);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_NOT_SUPPORTED,
+			VL53L010_STRING_ERROR_NOT_SUPPORTED);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_RANGE_ERROR,
+			VL53L010_STRING_ERROR_RANGE_ERROR);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_TIME_OUT,
+			VL53L010_STRING_ERROR_TIME_OUT);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_MODE_NOT_SUPPORTED,
+			VL53L010_STRING_ERROR_MODE_NOT_SUPPORTED);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_NOT_IMPLEMENTED,
+			VL53L010_STRING_ERROR_NOT_IMPLEMENTED);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_BUFFER_TOO_SMALL,
+			VL53L010_STRING_ERROR_BUFFER_TOO_SMALL);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_GPIO_NOT_EXISTING,
+			VL53L010_STRING_ERROR_GPIO_NOT_EXISTING);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED,
+			VL53L010_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED);
+	VL53L010_BUILDSTATUSERRORSTRING(pPalErrorString,
+			VL53L0_ERROR_CONTROL_INTERFACE,
+			VL53L010_STRING_ERROR_CONTROL_INTERFACE);
+	default:
+		VL53L0_COPYSTRING(pPalErrorString,
+			VL53L010_STRING_UNKNOW_ERROR_CODE);
+		break;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L010_GetPalState(VL53L0_DEV Dev, VL53L0_State *pPalState)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	*pPalState = PALDevDataGet(Dev, PalState);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes PowerMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	/* Only level1 of Power mode exists */
+	if ((PowerMode != VL53L0_POWERMODE_STANDBY_LEVEL1) &&
+		(PowerMode != VL53L0_POWERMODE_IDLE_LEVEL1)) {
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	} else if (PowerMode == VL53L0_POWERMODE_STANDBY_LEVEL1) {
+		/* set the standby level1 of power mode */
+		Status = VL53L0_WrByte(Dev, 0x80, 0x00);
+		if (Status == VL53L0_ERROR_NONE) {
+			/* Set PAL State to standby */
+			PALDevDataSet(Dev, PalState, VL53L0_STATE_STANDBY);
+			PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_STANDBY_LEVEL1);
+		}
+
+	} else {
+		/* VL53L0_POWERMODE_IDLE_LEVEL1 */
+		Status = VL53L0_WrByte(Dev, 0x80, 0x01);
+		if (Status == VL53L0_ERROR_NONE)
+			Status = VL53L010_StaticInit(Dev);
+		if (Status == VL53L0_ERROR_NONE)
+			PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_IDLE_LEVEL1);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes *pPowerMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	/* Only level1 of Power mode exists */
+	Status = VL53L0_RdByte(Dev, 0x80, &Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Byte == 1)
+			PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_IDLE_LEVEL1);
+		else
+		    PALDevDataSet(Dev, PowerMode,
+				VL53L0_POWERMODE_STANDBY_LEVEL1);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
+				int32_t OffsetCalibrationDataMicroMeter)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t OffsetCalibrationData;
+
+	LOG_FUNCTION_START("");
+
+	OffsetCalibrationData = (uint8_t) (OffsetCalibrationDataMicroMeter
+							/ 1000);
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_ALGO_PART_TO_PART_RANGE_OFFSET,
+				*(uint8_t *) &OffsetCalibrationData);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
+				int32_t *pOffsetCalibrationDataMicroMeter)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t RangeOffsetRegister;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L010_REG_ALGO_PART_TO_PART_RANGE_OFFSET,
+				&RangeOffsetRegister);
+	if (Status == VL53L0_ERROR_NONE) {
+		*pOffsetCalibrationDataMicroMeter =
+				(*((int8_t *) (&RangeOffsetRegister))) * 1000;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetGroupParamHold(VL53L0_DEV Dev, uint8_t GroupParamHold)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	/* not implemented on VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetUpperLimitMilliMeter(VL53L0_DEV Dev,
+				uint16_t *pUpperLimitMilliMeter)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	/* not implemented on VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+/* End Group PAL General Functions */
+
+/* Group PAL Init Functions */
+VL53L0_Error VL53L010_SetDeviceAddress(VL53L0_DEV Dev, uint8_t DeviceAddress)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_I2C_SLAVE_DEVICE_ADDRESS,
+				DeviceAddress / 2);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_DataInit(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	int32_t OffsetCalibrationData;
+
+	LOG_FUNCTION_START("");
+
+    if (Status == VL53L0_ERROR_NONE) {
+		/* read device info */
+		VL53L010_SETDEVICESPECIFICPARAMETER(Dev, ReadDataFromDeviceDone, 0);
+
+		Status = VL53L010_get_info_from_device(Dev);
+    }
+
+	/* Set Default static parameters */
+	/* set first temporary values 11.3999MHz * 65536 = 748421 */
+	VL53L010_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 748421);
+	/* 11.3999MHz * 65536 = 748421 */
+
+	/* Get default parameters */
+	Status = VL53L010_GetDeviceParameters(Dev, &CurrentParameters);
+	if (Status == VL53L0_ERROR_NONE) {
+		/* initialize PAL values */
+		CurrentParameters.DeviceMode = VL53L0_DEVICEMODE_SINGLE_RANGING;
+		CurrentParameters.HistogramMode = VL53L0_HISTOGRAMMODE_DISABLED;
+		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
+	}
+
+	/* Sigma estimator variable */
+	PALDevDataSet(Dev, SigmaEstRefArray, 100);
+	PALDevDataSet(Dev, SigmaEstEffPulseWidth, 900);
+	PALDevDataSet(Dev, SigmaEstEffAmbWidth, 500);
+
+	/* Set Signal and Sigma check */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L010_SetLimitCheckEnable(Dev,
+            VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE, 0);
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L010_SetLimitCheckEnable(Dev,
+            VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE, 0);
+    }
+    if(Status == VL53L0_ERROR_NONE) {
+        Status = VL53L010_SetLimitCheckValue(Dev,
+            VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE,
+            (FixPoint1616_t)(32<<16));
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L010_SetLimitCheckValue(Dev,
+            VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
+            (FixPoint1616_t)(25 * 65536 / 100));
+			/* 0.25 * 65538 */
+    }
+
+	/* Read back NVM offset */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetOffsetCalibrationDataMicroMeter(Dev,
+			&OffsetCalibrationData);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, Part2PartOffsetNVMMicroMeter,
+			OffsetCalibrationData);
+
+		PALDevDataSet(Dev, SequenceConfig, 0xFF);
+
+		/* Set PAL state to tell that we are waiting for call
+		to VL53L010_StaticInit */
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_WAIT_STATICINIT);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L010_StaticInit(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint16_t TempWord;
+	uint8_t TempByte;
+	uint8_t localBuffer[32];
+	uint8_t i;
+	uint8_t Revision;
+
+	LOG_FUNCTION_START("");
+
+    /* Set I2C standard mode */
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev, 0x88, 0x00);
+
+	/* this function do nothing if it has been called before */
+	Status = VL53L010_get_info_from_device(Dev);
+
+	if (Status == VL53L0_ERROR_NONE) {
+        Revision = VL53L010_GETDEVICESPECIFICPARAMETER(Dev, Revision);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+		if (Revision == 0)
+			Status = VL53L010_load_additional_settings1(Dev);
+	}
+
+    /* update13_05_15 */
+	if (Status == VL53L0_ERROR_NONE) {
+		if ((Revision <= 34) && (Revision != 32)) {
+
+			for (i = 0; i < 32; i++)
+				localBuffer[i] = 0xff;
+
+			Status = VL53L0_WriteMulti(Dev, 0x90, localBuffer, 32);
+
+			Status |= VL53L0_WrByte(Dev, 0xb6, 16);
+			Status |= VL53L0_WrByte(Dev, 0xb0, 0x0);
+			Status |= VL53L0_WrByte(Dev, 0xb1, 0x0);
+			Status |= VL53L0_WrByte(Dev, 0xb2, 0xE0);
+			Status |= VL53L0_WrByte(Dev, 0xb3, 0xE0);
+			Status |= VL53L0_WrByte(Dev, 0xb4, 0xE0);
+			Status |= VL53L0_WrByte(Dev, 0xb5, 0xE0);
+		}
+	}
+
+    /* update 17_06_15_v10 */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_load_tuning_settings(Dev);
+
+    /* check if GO1 power is ON after load default tuning */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, 0x80, &TempByte);
+		if ((TempByte != 0) && (Status == VL53L0_ERROR_NONE)) {
+			/* update 07_05_15 */
+			Status = VL53L010_load_additional_settings3(Dev);
+		}
+	}
+
+    /* Set interrupt config to new sample ready */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetGpioConfig(Dev, 0, 0,
+			VL53L010_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+		Status |= VL53L0_RdWord(Dev, 0x84, &TempWord);
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L010_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz,
+			VL53L010_FIXPOINT412TOFIXPOINT1616(TempWord));
+	}
+
+	/* After static init, some device parameters may be changed,
+	so update them */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_GetDeviceParameters(Dev, &CurrentParameters);
+
+	if (Status == VL53L0_ERROR_NONE)
+		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
+
+
+	/* read the sequence config and save it */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_SYSTEM_SEQUENCE_CONFIG,
+					&TempByte);
+		if (Status == VL53L0_ERROR_NONE)
+			PALDevDataSet(Dev, SequenceConfig, TempByte);
+
+	}
+
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_PerformRefCalibration(Dev);
+
+	/* Set PAL State to standby */
+	if (Status == VL53L0_ERROR_NONE)
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_WaitDeviceBooted(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	/* not implemented on VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_ResetDevice(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	/* Set reset bit */
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SOFT_RESET_GO2_SOFT_RESET_N,
+				0x00);
+
+	/* Wait for some time */
+	if (Status == VL53L0_ERROR_NONE) {
+		do {
+			Status = VL53L0_RdByte(Dev,
+				VL53L010_REG_IDENTIFICATION_MODEL_ID,	&Byte);
+		} while (Byte != 0x00);
+	}
+
+	/* Release reset */
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SOFT_RESET_GO2_SOFT_RESET_N,
+		0x01);
+
+	/* Wait until correct boot-up of the device */
+	if (Status == VL53L0_ERROR_NONE) {
+		do {
+			Status = VL53L0_RdByte(Dev,
+				VL53L010_REG_IDENTIFICATION_MODEL_ID,	&Byte);
+		} while (Byte == 0x00);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+/* End Group PAL Init Functions */
+
+/* Group PAL Parameters Functions */
+VL53L0_Error VL53L010_SetDeviceParameters(VL53L0_DEV Dev,
+	const VL53L0_DeviceParameters_t*
+	pDeviceParameters)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int i;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L010_SetDeviceMode(Dev, pDeviceParameters->DeviceMode);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetHistogramMode(Dev,
+			pDeviceParameters->HistogramMode);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetInterMeasurementPeriodMilliSeconds(Dev,
+
+			pDeviceParameters->InterMeasurementPeriodMilliSeconds);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetXTalkCompensationEnable(Dev,
+
+			pDeviceParameters->XTalkCompensationEnable);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetXTalkCompensationRateMegaCps(Dev,
+
+			pDeviceParameters->XTalkCompensationRateMegaCps);
+	}
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev,
+                pDeviceParameters->RangeOffsetMicroMeters);
+    }
+
+    for (i = 0; i < VL53L010_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
+        if (Status == VL53L0_ERROR_NONE) {
+            Status |= VL53L010_SetLimitCheckEnable(Dev, i,
+                pDeviceParameters->LimitChecksEnable[i]);
+        } else {
+            break;
+        }
+        if (Status == VL53L0_ERROR_NONE) {
+            Status |= VL53L010_SetLimitCheckValue(Dev, i,
+                pDeviceParameters->LimitChecksValue[i]);
+        } else {
+            break;
+        }
+    }
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetWrapAroundCheckEnable(Dev,
+
+			pDeviceParameters->WrapAroundCheckEnable);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_SetMeasurementTimingBudgetMicroSeconds(Dev,
+
+			pDeviceParameters->MeasurementTimingBudgetMicroSeconds);
+	}
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetDeviceParameters(VL53L0_DEV Dev,
+				VL53L0_DeviceParameters_t *pDeviceParameters)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	int i;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L010_GetDeviceMode(Dev, &(pDeviceParameters->DeviceMode));
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetHistogramMode(Dev,
+			&(pDeviceParameters->HistogramMode));
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetInterMeasurementPeriodMilliSeconds(Dev,
+		&(pDeviceParameters->InterMeasurementPeriodMilliSeconds));
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetXTalkCompensationEnable(Dev,
+		&(pDeviceParameters->XTalkCompensationEnable));
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetXTalkCompensationRateMegaCps(Dev,
+
+			&(pDeviceParameters->XTalkCompensationRateMegaCps));
+	}
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L010_GetOffsetCalibrationDataMicroMeter(Dev,
+                &(pDeviceParameters->RangeOffsetMicroMeters));
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        for (i = 0; i < VL53L010_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
+            // get first the values, then the enables.
+            // VL53L0_GetLimitCheckValue will modify the enable flags
+            if (Status == VL53L0_ERROR_NONE) {
+                Status |= VL53L010_GetLimitCheckValue(Dev, i,
+                        &(pDeviceParameters->LimitChecksValue[i]));
+            } else {
+                break;
+            }
+            if (Status == VL53L0_ERROR_NONE) {
+                Status |= VL53L010_GetLimitCheckEnable(Dev, i,
+                        &(pDeviceParameters->LimitChecksEnable[i]));
+            } else {
+                break;
+            }
+        }
+    }
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetWrapAroundCheckEnable(Dev,
+			&(pDeviceParameters->WrapAroundCheckEnable));
+	}
+
+    /* Need to be done at the end as it uses VCSELPulsePeriod */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetMeasurementTimingBudgetMicroSeconds(Dev,
+		&(pDeviceParameters->MeasurementTimingBudgetMicroSeconds));
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetDeviceMode(VL53L0_DEV Dev,
+				VL53L0_DeviceModes DeviceMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("%d", (int)DeviceMode);
+
+	switch (DeviceMode) {
+	case VL53L0_DEVICEMODE_SINGLE_RANGING:
+	case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
+	case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
+	case VL53L0_DEVICEMODE_SINGLE_HISTOGRAM:
+    case VL53L0_DEVICEMODE_GPIO_DRIVE:
+    case VL53L0_DEVICEMODE_GPIO_OSC:
+		/* Supported mode */
+		VL53L010_SETPARAMETERFIELD(Dev, DeviceMode, DeviceMode);
+		break;
+	default:
+		/* Unsupported mode */
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetDeviceMode(VL53L0_DEV Dev,
+				VL53L0_DeviceModes *pDeviceMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("");
+
+	VL53L010_GETPARAMETERFIELD(Dev, DeviceMode, *pDeviceMode);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetHistogramMode(VL53L0_DEV Dev,
+				VL53L0_HistogramModes HistogramMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("%d", (int)HistogramMode);
+
+	switch (HistogramMode) {
+	case VL53L0_HISTOGRAMMODE_DISABLED:
+		/* Supported mode */
+		VL53L010_SETPARAMETERFIELD(Dev, HistogramMode,
+			HistogramMode);
+		break;
+	case VL53L0_HISTOGRAMMODE_REFERENCE_ONLY:
+	case VL53L0_HISTOGRAMMODE_RETURN_ONLY:
+	case VL53L0_HISTOGRAMMODE_BOTH:
+	default:
+		/* Unsupported mode */
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetHistogramMode(VL53L0_DEV Dev,
+				VL53L0_HistogramModes *pHistogramMode)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("");
+
+	VL53L010_GETPARAMETERFIELD(Dev, HistogramMode, *pHistogramMode);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
+				uint32_t MeasurementTimingBudgetMicroSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	uint8_t CurrentVCSELPulsePeriod;
+	uint8_t CurrentVCSELPulsePeriodPClk;
+	uint8_t Byte;
+	uint32_t NewTimingBudgetMicroSeconds;
+	uint16_t encodedTimeOut;
+
+	LOG_FUNCTION_START("");
+
+	/* check if rangeB is done: */
+	Status = VL53L010_GetWrapAroundCheckEnable(Dev, &Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (((Byte == 1) && (MeasurementTimingBudgetMicroSeconds <
+17000)) ||
+			((Byte == 0) && (MeasurementTimingBudgetMicroSeconds <
+12000))) {
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		NewTimingBudgetMicroSeconds =
+MeasurementTimingBudgetMicroSeconds -
+								7000;
+		if (Byte == 1) {
+			NewTimingBudgetMicroSeconds =
+				(uint32_t)(NewTimingBudgetMicroSeconds >> 1);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 0);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		CurrentVCSELPulsePeriod = VL53L010_encode_vcsel_period(
+			CurrentVCSELPulsePeriodPClk);
+		encodedTimeOut = VL53L010_calc_encoded_timeout(Dev,
+			NewTimingBudgetMicroSeconds,
+			(uint8_t)
+			CurrentVCSELPulsePeriod);
+		VL53L010_SETPARAMETERFIELD(Dev,
+MeasurementTimingBudgetMicroSeconds,
+			MeasurementTimingBudgetMicroSeconds);
+		VL53L010_SETDEVICESPECIFICPARAMETER(Dev, LastEncodedTimeout,
+			encodedTimeOut);
+	}
+
+	/* Program in register */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrWord(Dev, VL53L010_REG_RNGA_TIMEOUT_MSB,
+			encodedTimeOut);
+	}
+
+	/* Temp: program same value for rangeB1 and rangeB2 */
+	/* Range B1 */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 1);
+		if (Status == VL53L0_ERROR_NONE) {
+			CurrentVCSELPulsePeriod = VL53L010_encode_vcsel_period(
+				CurrentVCSELPulsePeriodPClk);
+			encodedTimeOut = VL53L010_calc_encoded_timeout(Dev,
+				NewTimingBudgetMicroSeconds,
+				(uint8_t)
+				CurrentVCSELPulsePeriod);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrWord(Dev, VL53L010_REG_RNGB1_TIMEOUT_MSB,
+			encodedTimeOut);
+	}
+
+	/* Range B2 */
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 2);
+		if (Status == VL53L0_ERROR_NONE) {
+			CurrentVCSELPulsePeriod = VL53L010_encode_vcsel_period(
+				CurrentVCSELPulsePeriodPClk);
+			encodedTimeOut = VL53L010_calc_encoded_timeout(Dev,
+				NewTimingBudgetMicroSeconds,
+				(uint8_t)
+				CurrentVCSELPulsePeriod);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrWord(Dev, VL53L010_REG_RNGB2_TIMEOUT_MSB,
+			encodedTimeOut);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
+				uint32_t *pMeasurementTimingBudgetMicroSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t CurrentVCSELPulsePeriod;
+	uint8_t CurrentVCSELPulsePeriodPClk;
+	uint16_t encodedTimeOut;
+	uint32_t RangATimingBudgetMicroSeconds;
+	uint32_t RangBTimingBudgetMicroSeconds;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	/* check if rangeB is done: */
+	Status = VL53L010_GetWrapAroundCheckEnable(Dev, &Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L010_get_vcsel_pulse_period(Dev,
+		&CurrentVCSELPulsePeriodPClk, 0);
+		CurrentVCSELPulsePeriod = VL53L010_encode_vcsel_period(
+			CurrentVCSELPulsePeriodPClk);
+
+		/* Read from register */
+		Status = VL53L0_RdWord(Dev, VL53L010_REG_RNGA_TIMEOUT_MSB,
+			&encodedTimeOut);
+		if (Status == VL53L0_ERROR_NONE) {
+			RangATimingBudgetMicroSeconds =
+			VL53L010_calc_ranging_wait_us(Dev,
+				encodedTimeOut,
+				CurrentVCSELPulsePeriod);
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (Byte == 0) {
+			*pMeasurementTimingBudgetMicroSeconds =
+				RangATimingBudgetMicroSeconds + 7000;
+			VL53L010_SETPARAMETERFIELD(Dev,
+			MeasurementTimingBudgetMicroSeconds,
+				*pMeasurementTimingBudgetMicroSeconds);
+		} else {
+			VL53L010_get_vcsel_pulse_period(Dev,
+			&CurrentVCSELPulsePeriodPClk, 1);
+			CurrentVCSELPulsePeriod = VL53L010_encode_vcsel_period(
+				CurrentVCSELPulsePeriodPClk);
+
+			/* Read from register */
+			Status = VL53L0_RdWord(Dev,
+			VL53L010_REG_RNGB1_TIMEOUT_MSB,
+						&encodedTimeOut);
+			if (Status == VL53L0_ERROR_NONE) {
+				RangBTimingBudgetMicroSeconds =
+				VL53L010_calc_ranging_wait_us(
+					Dev, encodedTimeOut,
+					CurrentVCSELPulsePeriod);
+			}
+
+			*pMeasurementTimingBudgetMicroSeconds =
+				RangATimingBudgetMicroSeconds +
+				RangBTimingBudgetMicroSeconds +
+				7000;
+			VL53L010_SETPARAMETERFIELD(Dev,
+			MeasurementTimingBudgetMicroSeconds,
+				*pMeasurementTimingBudgetMicroSeconds);
+		}
+	}
+
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
+				uint32_t InterMeasurementPeriodMilliSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint16_t osc_calibrate_val;
+	uint32_t IMPeriodMilliSeconds;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdWord(Dev, VL53L010_REG_OSC_CALIBRATE_VAL,
+		&osc_calibrate_val);
+
+	if (Status == VL53L0_ERROR_NONE) {
+
+		if (osc_calibrate_val != 0) {
+
+			IMPeriodMilliSeconds =
+			InterMeasurementPeriodMilliSeconds *
+				osc_calibrate_val;
+		} else {
+			IMPeriodMilliSeconds =
+			InterMeasurementPeriodMilliSeconds;
+		}
+		Status = VL53L0_WrDWord(Dev,
+		VL53L010_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
+			IMPeriodMilliSeconds);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L010_SETPARAMETERFIELD(Dev,
+		InterMeasurementPeriodMilliSeconds,
+			InterMeasurementPeriodMilliSeconds);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
+				uint32_t *pInterMeasurementPeriodMilliSeconds)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint16_t osc_calibrate_val;
+	uint32_t IMPeriodMilliSeconds;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdWord(Dev, VL53L010_REG_OSC_CALIBRATE_VAL,
+				&osc_calibrate_val);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdDWord(Dev,
+		VL53L010_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
+			&IMPeriodMilliSeconds);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (osc_calibrate_val != 0)
+			*pInterMeasurementPeriodMilliSeconds =
+				IMPeriodMilliSeconds /
+				osc_calibrate_val;
+
+		VL53L010_SETPARAMETERFIELD(Dev,
+		InterMeasurementPeriodMilliSeconds,
+			*pInterMeasurementPeriodMilliSeconds);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetXTalkCompensationEnable(VL53L0_DEV Dev,
+		uint8_t XTalkCompensationEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t XTalkCompensationEnableValue;
+
+	LOG_FUNCTION_START("");
+
+	if (XTalkCompensationEnable == 0) {
+		/* Disable the crosstalk compensation */
+		XTalkCompensationEnableValue = 0x00;
+	} else {
+		/* Enable the crosstalk compensation */
+		XTalkCompensationEnableValue = 0x01;
+	}
+	Status = VL53L0_UpdateByte(Dev, VL53L010_REG_ALGO_RANGE_CHECK_ENABLES,
+		0xFE,
+		XTalkCompensationEnableValue);
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L010_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
+			XTalkCompensationEnableValue);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetXTalkCompensationEnable(VL53L0_DEV Dev, uint8_t*
+	pXTalkCompensationEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	uint8_t data;
+	uint8_t Temp;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L010_REG_ALGO_RANGE_CHECK_ENABLES, &data);
+	if (Status == VL53L0_ERROR_NONE) {
+		if (data & 0x01)
+			Temp = 0x01;
+		else
+			Temp = 0x00;
+
+		*pXTalkCompensationEnable = Temp;
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		VL53L010_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
+	FixPoint1616_t XTalkCompensationRateMegaCps)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_WrWord(Dev, VL53L010_REG_ALGO_CROSSTALK_COMPENSATION_RATE,
+		VL53L010_FIXPOINT1616TOFIXPOINT412(XTalkCompensationRateMegaCps));
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L010_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+			XTalkCompensationRateMegaCps);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
+	FixPoint1616_t *pXTalkCompensationRateMegaCps)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t Value;
+	FixPoint1616_t TempFix1616;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdWord(Dev, VL53L010_REG_ALGO_CROSSTALK_COMPENSATION_RATE,
+		(uint16_t *) &Value);
+	if (Status == VL53L0_ERROR_NONE) {
+		TempFix1616 = VL53L010_FIXPOINT412TOFIXPOINT1616(Value);
+		*pXTalkCompensationRateMegaCps = TempFix1616;
+		VL53L010_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+			TempFix1616);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+
+
+/*
+ * CHECK LIMIT FUNCTIONS
+ */
+
+VL53L0_Error VL53L010_GetNumberOfLimitCheck(uint16_t *pNumberOfLimitCheck)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	*pNumberOfLimitCheck = VL53L010_CHECKENABLE_NUMBER_OF_CHECKS;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+#define VL53L010_BUILDCASESTRING(BUFFER, CODE, STRINGVALUE) \
+	do { \
+		case CODE: \
+			VL53L0_COPYSTRING(BUFFER, STRINGVALUE); \
+			break; \
+	} while (0)
+
+VL53L0_Error VL53L010_GetLimitCheckInfo(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	char *pLimitCheckString)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	switch (LimitCheckId) {
+	VL53L010_BUILDCASESTRING(pLimitCheckString,
+			VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE,
+			VL53L010_STRING_CHECKENABLE_SIGMA);
+	VL53L010_BUILDCASESTRING(pLimitCheckString,
+			VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
+			VL53L010_STRING_CHECKENABLE_SIGNAL_RATE);
+
+	default:
+		VL53L0_COPYSTRING(pLimitCheckString,
+			VL53L010_STRING_UNKNOW_ERROR_CODE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	uint8_t LimitCheckEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+    LOG_FUNCTION_START("");
+
+    if (LimitCheckId >= VL53L010_CHECKENABLE_NUMBER_OF_CHECKS) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    } else {
+        if (LimitCheckEnable == 0) {
+            VL53L010_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+            		LimitCheckId, 0);
+        } else {
+            VL53L010_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+            		LimitCheckId, 1);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L010_GetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
+	uint8_t *pLimitCheckEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t Temp8;
+
+    LOG_FUNCTION_START("");
+
+    if (LimitCheckId >= VL53L010_CHECKENABLE_NUMBER_OF_CHECKS) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    } else {
+        VL53L010_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable, LimitCheckId, Temp8);
+        *pLimitCheckEnable = Temp8;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L010_SetLimitCheckValue(VL53L0_DEV Dev,
+		uint16_t LimitCheckId, FixPoint1616_t LimitCheckValue)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+    LOG_FUNCTION_START("");
+
+    if (LimitCheckId >= VL53L010_CHECKENABLE_NUMBER_OF_CHECKS) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    } else {
+        VL53L010_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue, LimitCheckId,
+             LimitCheckValue);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L010_GetLimitCheckValue(VL53L0_DEV Dev,
+		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckValue)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+
+    LOG_FUNCTION_START("");
+
+    if (LimitCheckId >= VL53L010_CHECKENABLE_NUMBER_OF_CHECKS) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    } else {
+		VL53L010_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+				LimitCheckId, *pLimitCheckValue);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+    
+}
+
+VL53L0_Error VL53L010_GetLimitCheckCurrent(VL53L0_DEV Dev,
+		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckCurrent)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	if (LimitCheckId >= VL53L010_CHECKENABLE_NUMBER_OF_CHECKS) {
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	} else {
+		switch (LimitCheckId) {
+		case VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE:
+			/* Need to run a ranging to have the latest values */
+			*pLimitCheckCurrent = PALDevDataGet(Dev, SigmaEstimate);
+
+			break;
+
+		case VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
+			/* Need to run a ranging to have the latest values */
+			*pLimitCheckCurrent = PALDevDataGet(Dev, SignalEstimate);
+
+			break;
+		default:
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
+
+/*
+ * WRAPAROUND LIMIT
+ */
+VL53L0_Error VL53L010_SetWrapAroundCheckEnable(VL53L0_DEV Dev, uint8_t
+	WrapAroundCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+	uint8_t WrapAroundCheckEnableInt;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L010_REG_SYSTEM_SEQUENCE_CONFIG, &Byte);
+	if (WrapAroundCheckEnable == 0) {
+		/* Disable wraparound */
+		Byte = Byte & 0x7F;
+		WrapAroundCheckEnableInt = 0;
+	} else {
+		/* Enable wraparound */
+		Byte = Byte | 0x80;
+		WrapAroundCheckEnableInt = 1;
+	}
+
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSTEM_SEQUENCE_CONFIG, Byte);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, SequenceConfig, Byte);
+		VL53L010_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
+			WrapAroundCheckEnableInt);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetWrapAroundCheckEnable(VL53L0_DEV Dev, uint8_t
+	*pWrapAroundCheckEnable)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t data;
+	VL53L0_DeviceParameters_t CurrentParameters;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L010_REG_SYSTEM_SEQUENCE_CONFIG, &data);
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, SequenceConfig, data);
+		if (data & (0x01 << 7))
+			*pWrapAroundCheckEnable = 0x01;
+		else
+			*pWrapAroundCheckEnable = 0x00;
+
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		VL53L010_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
+			*pWrapAroundCheckEnable);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/*  End Group PAL Parameters Functions */
+
+/* Group PAL Measurement Functions */
+VL53L0_Error VL53L010_PerformSingleMeasurement(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceModes DeviceMode;
+	uint8_t NewDatReady = 0;
+	uint32_t LoopNb;
+
+	LOG_FUNCTION_START("");
+
+	/* Get Current DeviceMode */
+	Status = VL53L010_GetDeviceMode(Dev, &DeviceMode);
+
+	/* Start immediately to run a single ranging measurement in case of
+	single ranging or single histogram */
+	if ((Status == VL53L0_ERROR_NONE) &&
+		((DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING) ||
+		(DeviceMode ==
+		VL53L0_DEVICEMODE_SINGLE_HISTOGRAM))) {
+		Status = VL53L010_StartMeasurement(Dev);
+	}
+
+	/* Wait until it finished
+	use timeout to avoid deadlock
+	*/
+	if (Status == VL53L0_ERROR_NONE) {
+		LoopNb = 0;
+		do {
+			Status = VL53L010_GetMeasurementDataReady(Dev,
+				&NewDatReady);
+			if ((NewDatReady == 0x01) || Status !=
+				VL53L0_ERROR_NONE) {
+				break;
+			}
+			LoopNb = LoopNb + 1;
+			VL53L0_PollingDelay(Dev);
+		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	/* Change PAL State in case of single ranging or single histogram
+	*/
+	if ((Status == VL53L0_ERROR_NONE) &&
+		((DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING) ||
+			(DeviceMode ==
+			VL53L0_DEVICEMODE_SINGLE_HISTOGRAM))) {
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_PerformRefCalibration(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t NewDatReady = 0;
+	uint8_t Byte = 0;
+	uint8_t SequenceConfig = 0;
+	uint32_t LoopNb;
+
+	LOG_FUNCTION_START("");
+
+	/* store the value of the sequence config,
+	 * this will be reset before the end of the function
+	 */
+
+	SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
+
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSTEM_SEQUENCE_CONFIG, 0x03);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		PALDevDataSet(Dev, SequenceConfig, 0x03);
+		Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSRANGE_START,
+			VL53L010_REG_SYSRANGE_MODE_START_STOP);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Wait until start bit has been cleared */
+		LoopNb = 0;
+		do {
+			if (LoopNb > 0)
+				Status = VL53L0_RdByte(Dev,
+					VL53L010_REG_SYSRANGE_START, &Byte);
+			LoopNb = LoopNb + 1;
+		} while (((Byte & VL53L010_REG_SYSRANGE_MODE_START_STOP) ==
+			VL53L010_REG_SYSRANGE_MODE_START_STOP) &&
+			(Status == VL53L0_ERROR_NONE) &&
+			(LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+	}
+
+	/* Wait until it finished
+	use timeout to avoid deadlock
+	*/
+	if (Status == VL53L0_ERROR_NONE) {
+		LoopNb = 0;
+		do {
+			Status = VL53L010_GetMeasurementDataReady(Dev,
+				&NewDatReady);
+			if ((NewDatReady == 0x01) || Status !=
+				VL53L0_ERROR_NONE) {
+				break;
+			}
+			LoopNb = LoopNb + 1;
+			VL53L0_PollingDelay(Dev);
+		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+		Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x04);
+		Status |= VL53L0_RdByte(Dev, 0x30, &Byte);
+
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+		Status |= VL53L0_WrByte(Dev, 0x31, Byte);
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+		Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_ClearInterruptMask(Dev, 0);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* restore the previous Sequence Config */
+		Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSTEM_SEQUENCE_CONFIG,
+			SequenceConfig);
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L010_API VL53L0_Error VL53L010_PerformXTalkCalibration(VL53L0_DEV Dev,
+	FixPoint1616_t XTalkCalDistance,
+    FixPoint1616_t *pXTalkCompensationRateMegaCps)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t sum_ranging = 0;
+	uint16_t sum_spads = 0;
+	FixPoint1616_t sum_signalRate = 0;
+	FixPoint1616_t total_count = 0;
+	uint8_t xtalk_meas = 0;
+	VL53L0_RangingMeasurementData_t RangingMeasurementData;
+	FixPoint1616_t xTalkStoredMeanSignalRate;
+	FixPoint1616_t xTalkStoredMeanRange;
+	FixPoint1616_t xTalkStoredMeanRtnSpads;
+	uint32_t signalXTalkTotalPerSpad;
+	uint32_t xTalkStoredMeanRtnSpadsAsInt;
+	uint32_t xTalkCalDistanceAsInt;
+	FixPoint1616_t XTalkCompensationRateMegaCps;
+
+	LOG_FUNCTION_START("");
+
+	if (XTalkCalDistance <= 0)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	/* Disable the XTalk compensation */
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_SetXTalkCompensationEnable(Dev, 0);
+
+
+	/* Perform 50 measurements and compute the averages */
+	if (Status == VL53L0_ERROR_NONE) {
+		sum_ranging = 0;
+		sum_spads = 0;
+		sum_signalRate = 0;
+		total_count = 0;
+		for (xtalk_meas = 0; xtalk_meas < 50; xtalk_meas++) {
+			Status = VL53L010_PerformSingleRangingMeasurement(Dev,
+				&RangingMeasurementData);
+
+			if (Status != VL53L0_ERROR_NONE)
+				break;
+
+			/* The range is valid when RangeStatus = 0 */
+			if (RangingMeasurementData.RangeStatus == 0) {
+				sum_ranging = sum_ranging +
+				RangingMeasurementData.RangeMilliMeter;
+				sum_signalRate = sum_signalRate +
+				RangingMeasurementData.SignalRateRtnMegaCps;
+				sum_spads = sum_spads +
+				RangingMeasurementData.EffectiveSpadRtnCount
+					/ 32;
+				total_count = total_count + 1;
+			}
+		}
+
+		if (total_count == 0) {
+			/* no valid values found */
+			Status = VL53L0_ERROR_DIVISION_BY_ZERO;
+		}
+	}
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* FixPoint1616_t / uint16_t = FixPoint1616_t */
+		xTalkStoredMeanSignalRate = sum_signalRate / total_count;
+		xTalkStoredMeanRange =
+			(FixPoint1616_t)((uint32_t)(sum_ranging << 16) /
+			total_count);
+		xTalkStoredMeanRtnSpads =
+			(FixPoint1616_t)((uint32_t)(sum_spads<<16) /
+			total_count);
+
+		/* Round Mean Spads to Whole Number.
+		Typically the calculated mean SPAD count is a whole number or
+		very close to a whole
+		number, therefore any truncation will not result in a
+		significant	loss in accuracy.
+		Also, for a grey target at a typical distance of around 400mm,
+		around 220 SPADs will
+		be enabled, therefore, any truncation will result in a loss of
+		accuracy of less than 0.5%.
+		*/
+		xTalkStoredMeanRtnSpadsAsInt = (xTalkStoredMeanRtnSpads +
+			0x8000) >> 16;
+
+		/* Round Cal Distance to Whole Number.
+		Note that the cal distance is in mm, therefore no resolution is
+		lost.
+		*/
+		xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >> 16;
+
+		if (xTalkStoredMeanRtnSpadsAsInt == 0 || xTalkCalDistanceAsInt
+			== 0 ||
+			xTalkStoredMeanRange >= XTalkCalDistance) {
+			XTalkCompensationRateMegaCps = 0;
+		} else {
+			/* Round Cal Distance to Whole Number.
+			Note that the cal distance is in mm, therefore no
+			resolution is lost.
+			*/
+			xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >>
+				16;
+
+			/* Apply division by mean spad count early in the
+			calculation to keep the numbers small.
+			This ensures we can maintain a 32bit calculation.
+			Fixed1616 / int := Fixed1616
+			*/
+			signalXTalkTotalPerSpad =
+				(xTalkStoredMeanSignalRate) /
+				xTalkStoredMeanRtnSpadsAsInt;
+
+			/* Complete the calculation for total Signal XTalk per
+			SPAD Fixed1616 * (Fixed1616 - Fixed1616/int)
+			:= (2^16 * Fixed1616)
+			*/
+			signalXTalkTotalPerSpad *= ((1<<16) -
+				(xTalkStoredMeanRange/xTalkCalDistanceAsInt));
+
+			/* Round from 2^16 * Fixed1616, to Fixed1616. */
+			XTalkCompensationRateMegaCps = (signalXTalkTotalPerSpad
+				+ 0x8000) >> 16;
+		}
+
+		*pXTalkCompensationRateMegaCps = XTalkCompensationRateMegaCps;
+
+		/* Enable the XTalk compensation */
+		if (Status == VL53L0_ERROR_NONE)
+			Status = VL53L010_SetXTalkCompensationEnable(Dev, 1);
+
+
+		/* Enable the XTalk compensation */
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L010_SetXTalkCompensationRateMegaCps(Dev,
+				XTalkCompensationRateMegaCps);
+		}
+
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L010_API VL53L0_Error VL53L010_PerformOffsetCalibration(VL53L0_DEV Dev,
+            FixPoint1616_t CalDistanceMilliMeter,
+            int32_t* pOffsetMicroMeter) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t sum_ranging = 0;
+    FixPoint1616_t total_count = 0;
+    VL53L0_RangingMeasurementData_t RangingMeasurementData;
+    FixPoint1616_t StoredMeanRange;
+    uint32_t StoredMeanRangeAsInt;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint32_t CalDistanceAsInt_mm;
+    int meas = 0;
+    LOG_FUNCTION_START("");
+
+    if (CalDistanceMilliMeter<=0) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, 0);
+    }
+
+    /* Perform 50 measurements and compute the averages */
+    if (Status == VL53L0_ERROR_NONE) {
+        sum_ranging = 0;
+        total_count = 0;
+        for(meas=0;meas<50;meas++)
+        {
+            Status = VL53L010_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);
+
+            if (Status != VL53L0_ERROR_NONE) {
+                break;
+            }
+
+            /* The range is valid when RangeStatus = 0 */
+            if (RangingMeasurementData.RangeStatus == 0) {
+                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;
+                total_count = total_count + 1;
+            }
+        }
+
+        if (total_count == 0) {
+            /* no valid values found */
+            Status = VL53L0_ERROR_RANGE_ERROR;
+        }
+    }
+
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /* FixPoint1616_t / uint16_t = FixPoint1616_t */
+        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);
+
+        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;
+
+        /* Round Cal Distance to Whole Number.
+         * Note that the cal distance is in mm, therefore no resolution is lost.*/
+         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;
+
+         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;
+
+        /* Apply the calculated offset */
+        if (Status == VL53L0_ERROR_NONE) {
+            VL53L010_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter);
+            Status = VL53L010_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);
+        }
+
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L010_StartMeasurement(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceModes DeviceMode;
+	uint8_t Byte = 0;
+	uint32_t LoopNb;
+
+	LOG_FUNCTION_START("");
+
+	/* Get Current DeviceMode */
+	VL53L010_GetDeviceMode(Dev, &DeviceMode);
+
+	switch (DeviceMode) {
+	case VL53L0_DEVICEMODE_SINGLE_RANGING:
+		Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSRANGE_START,
+			VL53L010_REG_SYSRANGE_MODE_SINGLESHOT |
+			VL53L010_REG_SYSRANGE_MODE_START_STOP);
+		break;
+	case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
+		/* Back-to-back mode */
+		Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSRANGE_START,
+			VL53L010_REG_SYSRANGE_MODE_BACKTOBACK |
+			VL53L010_REG_SYSRANGE_MODE_START_STOP);
+		if (Status == VL53L0_ERROR_NONE) {
+			/* Set PAL State to Running */
+			PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+		}
+		break;
+	case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
+		/* Continuous mode */
+		Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSRANGE_START,
+			VL53L010_REG_SYSRANGE_MODE_TIMED |
+			VL53L010_REG_SYSRANGE_MODE_START_STOP);
+		if (Status == VL53L0_ERROR_NONE) {
+			/* Set PAL State to Running */
+			PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+		}
+		break;
+	default:
+		/* Selected mode not supported */
+		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Wait until start bit has been cleared */
+		LoopNb = 0;
+		do {
+			if (LoopNb > 0)
+				Status = VL53L0_RdByte(Dev,
+					VL53L010_REG_SYSRANGE_START, &Byte);
+			LoopNb = LoopNb + 1;
+		} while (((Byte & VL53L010_REG_SYSRANGE_MODE_START_STOP) ==
+			VL53L010_REG_SYSRANGE_MODE_START_STOP) &&
+			(Status == VL53L0_ERROR_NONE) &&
+			(LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+
+		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
+			Status = VL53L0_ERROR_TIME_OUT;
+
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_StopMeasurement(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSRANGE_START,
+		VL53L010_REG_SYSRANGE_MODE_SINGLESHOT);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Set PAL State to Idle */
+		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetMeasurementDataReady(VL53L0_DEV Dev, uint8_t
+	*pMeasurementDataReady)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t SysRangeStatusRegister;
+	uint8_t InterruptConfig;
+	uint32_t InterruptMask;
+
+	LOG_FUNCTION_START("");
+
+	InterruptConfig = VL53L010_GETDEVICESPECIFICPARAMETER(Dev,
+		Pin0GpioFunctionality);
+
+	if (InterruptConfig ==
+	VL53L010_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY) {
+		VL53L010_GetInterruptMaskStatus(Dev, &InterruptMask);
+		if (InterruptMask ==
+		VL53L010_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY){
+			*pMeasurementDataReady = 1;
+		} else {
+			*pMeasurementDataReady = 0;
+		}
+	} else {
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_RESULT_RANGE_STATUS,
+			&SysRangeStatusRegister);
+		if (Status == VL53L0_ERROR_NONE) {
+			if (SysRangeStatusRegister & 0x01)
+				*pMeasurementDataReady = 1;
+			else
+				*pMeasurementDataReady = 0;
+
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev, uint32_t
+	MaxLoop)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	/* not implemented for VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetRangingMeasurementData(VL53L0_DEV Dev,
+	VL53L0_RangingMeasurementData_t *pRangingMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t DeviceRangeStatus;
+	uint8_t PalRangeStatus;
+	uint16_t AmbientRate;
+	FixPoint1616_t SignalRate;
+	FixPoint1616_t CrosstalkCompensation;
+	uint16_t EffectiveSpadRtnCount;
+	uint8_t localBuffer[14];
+	VL53L0_RangingMeasurementData_t LastRangeDataBuffer;
+
+	LOG_FUNCTION_START("");
+
+	/* use multi read even if some registers are not useful, result will be
+	more efficient
+	start reading at 0x14 dec20
+	end reading at 0x21 dec33 total 14 bytes to read
+	*/
+	Status = VL53L0_ReadMulti(Dev, 0x14, localBuffer, 14);
+
+	if (Status == VL53L0_ERROR_NONE) {
+
+		pRangingMeasurementData->ZoneId = 0; /* Only one zone */
+		pRangingMeasurementData->TimeStamp = 0; /* Not Implemented */
+
+		pRangingMeasurementData->RangeMilliMeter =
+			VL53L010_MAKEUINT16(localBuffer[11], localBuffer[10]);
+
+		pRangingMeasurementData->RangeDMaxMilliMeter = 0;
+		pRangingMeasurementData->RangeFractionalPart = 0;
+		pRangingMeasurementData->MeasurementTimeUsec = 0;
+
+		SignalRate =
+			VL53L010_FIXPOINT97TOFIXPOINT1616(
+			VL53L010_MAKEUINT16(localBuffer[7], localBuffer[6]));
+		pRangingMeasurementData->SignalRateRtnMegaCps = SignalRate;
+
+		AmbientRate = VL53L010_MAKEUINT16(localBuffer[9], localBuffer[8]);
+		pRangingMeasurementData->AmbientRateRtnMegaCps =
+			VL53L010_FIXPOINT97TOFIXPOINT1616(AmbientRate);
+
+		EffectiveSpadRtnCount = VL53L010_MAKEUINT16(localBuffer[3],
+			localBuffer[2]);
+		pRangingMeasurementData->EffectiveSpadRtnCount =
+			EffectiveSpadRtnCount;
+
+		DeviceRangeStatus = localBuffer[0];
+
+		/* initial format = 4.12, when pass to 16.16 from 9.7 we shift
+		5 bit more this will be absorbed in the further computation
+		*/
+		CrosstalkCompensation =
+			VL53L010_FIXPOINT97TOFIXPOINT1616(
+			VL53L010_MAKEUINT16(localBuffer[13], localBuffer[12]));
+
+		/*
+		 * For a standard definition of RangeStatus, this should return
+		 * 0 in case of good result after a ranging
+		 * The range status depends on the device so call a device
+		 * specific	function to obtain the right Status.
+		 */
+		Status = VL53L010_get_pal_range_status(Dev, DeviceRangeStatus,
+			SignalRate, CrosstalkCompensation,
+			EffectiveSpadRtnCount,
+			pRangingMeasurementData, &PalRangeStatus);
+
+		if (Status == VL53L0_ERROR_NONE)
+			pRangingMeasurementData->RangeStatus = PalRangeStatus;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Copy last read data into Dev buffer */
+		LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
+
+		LastRangeDataBuffer.RangeMilliMeter =
+			pRangingMeasurementData->RangeMilliMeter;
+		LastRangeDataBuffer.RangeFractionalPart =
+			pRangingMeasurementData->RangeFractionalPart;
+		LastRangeDataBuffer.RangeDMaxMilliMeter =
+			pRangingMeasurementData->RangeDMaxMilliMeter;
+		LastRangeDataBuffer.MeasurementTimeUsec =
+			pRangingMeasurementData->MeasurementTimeUsec;
+		LastRangeDataBuffer.SignalRateRtnMegaCps =
+			pRangingMeasurementData->SignalRateRtnMegaCps;
+		LastRangeDataBuffer.AmbientRateRtnMegaCps =
+			pRangingMeasurementData->AmbientRateRtnMegaCps;
+		LastRangeDataBuffer.EffectiveSpadRtnCount =
+			pRangingMeasurementData->EffectiveSpadRtnCount;
+		LastRangeDataBuffer.RangeStatus =
+			pRangingMeasurementData->RangeStatus;
+
+		PALDevDataSet(Dev, LastRangeMeasure, LastRangeDataBuffer);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetHistogramMeasurementData(VL53L0_DEV Dev,
+	VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L010_PerformSingleRangingMeasurement(VL53L0_DEV Dev,
+	VL53L0_RangingMeasurementData_t *pRangingMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	/*	This function will do a complete single ranging
+	*	Here we fix the mode!
+	*/
+	Status = VL53L010_SetDeviceMode(Dev, VL53L0_DEVICEMODE_SINGLE_RANGING);
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_PerformSingleMeasurement(Dev);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L010_GetRangingMeasurementData(Dev,
+			pRangingMeasurementData);
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L010_ClearInterruptMask(Dev, 0);
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L0_Error VL53L010_PerformSingleHistogramMeasurement(VL53L0_DEV Dev,
+	VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetNumberOfROIZones(VL53L0_DEV Dev, uint8_t
+	NumberOfROIZones)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	if (NumberOfROIZones != 1)
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetNumberOfROIZones(VL53L0_DEV Dev, uint8_t*
+	pNumberOfROIZones)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	*pNumberOfROIZones = 1;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetMaxNumberOfROIZones(VL53L0_DEV Dev, uint8_t
+	*pMaxNumberOfROIZones)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	*pMaxNumberOfROIZones = 1;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* End Group PAL Measurement Functions */
+
+
+VL53L0_Error VL53L010_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+	VL53L0_DeviceModes DeviceMode, VL53L0_GpioFunctionality Functionality,
+	VL53L0_InterruptPolarity Polarity)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	uint8_t data;
+
+	LOG_FUNCTION_START("");
+
+    if (Pin != 0) {
+        Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
+    } else if (DeviceMode == VL53L0_DEVICEMODE_GPIO_DRIVE) {
+        if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW) {
+            data = 0x10;
+        } else {
+            data = 1;
+        }
+        Status = VL53L0_WrByte(Dev,
+        		VL53L010_REG_GPIO_HV_MUX_ACTIVE_HIGH, data);
+
+    } else if (DeviceMode == VL53L0_DEVICEMODE_GPIO_OSC) {
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+    	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+    	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+    	Status |= VL53L0_WrByte(Dev, 0x85, 0x02);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x04);
+    	Status |= VL53L0_WrByte(Dev, 0xcd, 0x00);
+    	Status |= VL53L0_WrByte(Dev, 0xcc, 0x11);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x07);
+    	Status |= VL53L0_WrByte(Dev, 0xbe, 0x00);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x06);
+    	Status |= VL53L0_WrByte(Dev, 0xcc, 0x09);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+    	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+    } else {
+
+		if (Status == VL53L0_ERROR_NONE) {
+			switch (Functionality) {
+			case VL53L010_GPIOFUNCTIONALITY_OFF:
+				data = 0x00;
+				break;
+			case VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW:
+				data = 0x01;
+				break;
+			case VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH:
+				data = 0x02;
+				break;
+			case VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT:
+				data = 0x03;
+				break;
+			case VL53L010_GPIOFUNCTIONALITY_NEW_MEASURE_READY:
+				data = 0x04;
+				break;
+			default:
+				Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
+			}
+		}
+
+		if (Status == VL53L0_ERROR_NONE) {
+			Status = VL53L0_WrByte(Dev,
+				VL53L010_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,
+				data);
+		}
+
+		if (Status == VL53L0_ERROR_NONE) {
+			if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW)
+				data = 0;
+			else
+				data = (uint8_t)(1<<4);
+
+			Status = VL53L0_UpdateByte(Dev,
+				VL53L010_REG_GPIO_HV_MUX_ACTIVE_HIGH,
+				0xEF, data);
+		}
+
+		if (Status == VL53L0_ERROR_NONE) {
+			VL53L010_SETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality,
+				Functionality);
+		}
+
+		if (Status == VL53L0_ERROR_NONE)
+			Status = VL53L010_ClearInterruptMask(Dev, 0);
+    }
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+	VL53L0_DeviceModes *DeviceMode,
+	VL53L0_GpioFunctionality *pFunctionality,
+	VL53L0_InterruptPolarity *pPolarity)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+	VL53L0_GpioFunctionality GpioFunctionality;
+	uint8_t data;
+
+	LOG_FUNCTION_START("");
+
+	if (Pin != 0) {
+		Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
+	} else {
+		Status = VL53L0_RdByte(Dev,
+			VL53L010_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,
+			&data);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		switch (data&0x07) {
+		case 0x00:
+		    GpioFunctionality = VL53L010_GPIOFUNCTIONALITY_OFF;
+		    break;
+		case 0x01:
+			GpioFunctionality =
+				VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW;
+		    break;
+		case 0x02:
+			GpioFunctionality =
+				VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH;
+		    break;
+		case 0x03:
+			GpioFunctionality =
+				VL53L010_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT;
+		    break;
+		case 0x04:
+		    GpioFunctionality =
+				VL53L010_GPIOFUNCTIONALITY_NEW_MEASURE_READY;
+		    break;
+		default:
+		    Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_RdByte(Dev,
+				VL53L010_REG_GPIO_HV_MUX_ACTIVE_HIGH, &data);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if ((data & (uint8_t)(1<<4)) == 0)
+			*pPolarity = VL53L0_INTERRUPTPOLARITY_LOW;
+		else
+			*pPolarity = VL53L0_INTERRUPTPOLARITY_HIGH;
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		*pFunctionality = GpioFunctionality;
+		VL53L010_SETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality,
+			GpioFunctionality);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetInterruptThresholds(VL53L0_DEV Dev, VL53L0_DeviceModes
+	DeviceMode, FixPoint1616_t ThresholdLow, FixPoint1616_t ThresholdHigh)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t Threshold16;
+
+	LOG_FUNCTION_START("");
+
+	/* no dependency on DeviceMode for Ewok */
+    /* Need to divide by 2 because the FW will apply a x2 */
+	Threshold16 = (uint16_t)((ThresholdLow >> 17) & 0x00fff);
+	Status = VL53L0_WrWord(Dev, VL53L010_REG_SYSTEM_THRESH_LOW, Threshold16);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		/* Need to divide by 2 because the FW will apply a x2 */
+		Threshold16 = (uint16_t)((ThresholdHigh >> 17) & 0x00fff);
+		Status = VL53L0_WrWord(Dev, VL53L010_REG_SYSTEM_THRESH_HIGH,
+			Threshold16);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetInterruptThresholds(VL53L0_DEV Dev, VL53L0_DeviceModes
+	DeviceMode, FixPoint1616_t *pThresholdLow,
+	FixPoint1616_t *pThresholdHigh)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t Threshold16;
+
+	LOG_FUNCTION_START("");
+
+	/* no dependency on DeviceMode for Ewok */
+
+	Status = VL53L0_RdWord(Dev, VL53L010_REG_SYSTEM_THRESH_LOW, &Threshold16);
+    /* Need to multiply by 2 because the FW will apply a x2 */
+	*pThresholdLow = (FixPoint1616_t)((0x00fff & Threshold16)<<17);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdWord(Dev, VL53L010_REG_SYSTEM_THRESH_HIGH,
+			&Threshold16);
+       /* Need to multiply by 2 because the FW will apply a x2 */
+		*pThresholdHigh = (FixPoint1616_t)((0x00fff & Threshold16)<<17);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* Group PAL Interrupt Functions */
+VL53L0_Error VL53L010_ClearInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t LoopCount;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	/* clear bit 0 range interrupt, bit 1 error interrupt */
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSTEM_INTERRUPT_CLEAR, 0x01);
+	LoopCount = 0;
+	do {
+		VL53L0_RdByte(Dev, VL53L010_REG_RESULT_INTERRUPT_STATUS, &Byte);
+		LoopCount++;
+	} while (((Byte & 0x07) != 0x00) && (LoopCount < 8));
+	Status = VL53L0_WrByte(Dev, VL53L010_REG_SYSTEM_INTERRUPT_CLEAR, 0x00);
+	/* clear all */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetInterruptMaskStatus(VL53L0_DEV Dev, uint32_t
+	*pInterruptMaskStatus)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	Status = VL53L0_RdByte(Dev, VL53L010_REG_RESULT_INTERRUPT_STATUS, &Byte);
+	*pInterruptMaskStatus = Byte & 0x07;
+
+	if (Byte & 0x18) {
+		Status = VL53L0_ERROR_RANGE_ERROR; /* check if some error
+		occurs */
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_EnableInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+
+	LOG_FUNCTION_START("");
+
+	/* not implemented for VL53L0 */
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* End Group PAL Interrupt Functions */
+
+/* Group SPAD functions */
+
+VL53L0_Error VL53L010_SetSpadAmbientDamperThreshold(VL53L0_DEV Dev, uint16_t
+	SpadAmbientDamperThreshold)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_WrWord(Dev, 0x40, SpadAmbientDamperThreshold);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetSpadAmbientDamperThreshold(VL53L0_DEV Dev, uint16_t
+	*pSpadAmbientDamperThreshold)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_RdWord(Dev, 0x40, pSpadAmbientDamperThreshold);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_SetSpadAmbientDamperFactor(VL53L0_DEV Dev, uint16_t
+	SpadAmbientDamperFactor)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	Byte = (uint8_t) (SpadAmbientDamperFactor & 0x00FF);
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_WrByte(Dev, 0x42, Byte);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_GetSpadAmbientDamperFactor(VL53L0_DEV Dev, uint16_t
+	*pSpadAmbientDamperFactor)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t Byte;
+
+	LOG_FUNCTION_START("");
+
+	VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status = VL53L0_RdByte(Dev, 0x42, &Byte);
+	VL53L0_WrByte(Dev, 0xFF, 0x00);
+	*pSpadAmbientDamperFactor = (uint16_t) Byte;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* END Group SPAD functions */
+
+/*//////////////////////////////////////////////////////////////////////////////
+//
+//////////////////////////////////
+// Internal functions
+////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////
+*/
+
+
+VL53L010_EXTERNAL uint32_t VL53L010_calc_macro_period_ps(VL53L0_DEV Dev,
+		uint8_t vcsel_period);
+VL53L010_EXTERNAL uint16_t VL53L010_encode_timeout(uint32_t timeout_mclks);
+VL53L010_EXTERNAL uint32_t VL53L010_decode_timeout(uint16_t encoded_timeout);
+
+
+VL53L010_EXTERNAL VL53L0_Error VL53L010_get_vcsel_pulse_period(VL53L0_DEV Dev, uint8_t
+	*pVCSELPulsePeriod, uint8_t RangeIndex)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t vcsel_period_reg;
+
+	LOG_FUNCTION_START("");
+
+	switch (RangeIndex) {
+	case 0:
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_RNGA_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+		break;
+	case 1:
+		Status = VL53L0_RdByte(Dev,
+			VL53L010_REG_RNGB1_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+		break;
+	case 2:
+		Status = VL53L0_RdByte(Dev,
+			VL53L010_REG_RNGB2_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+		break;
+	default:
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_RNGA_CONFIG_VCSEL_PERIOD,
+			&vcsel_period_reg);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		*pVCSELPulsePeriod =
+			VL53L010_decode_vcsel_period(vcsel_period_reg);
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+/* To convert ms into register value */
+VL53L010_EXTERNAL uint16_t VL53L010_calc_encoded_timeout(VL53L0_DEV Dev, uint32_t
+	timeout_period_us, uint8_t vcsel_period)
+{
+	uint32_t macro_period_ps;
+	uint32_t macro_period_ns;
+	uint32_t timeout_period_mclks = 0;
+	uint16_t timeout_overall_periods = 0;
+
+	macro_period_ps = VL53L010_calc_macro_period_ps(Dev, vcsel_period);
+	macro_period_ns = macro_period_ps / 1000;
+
+	timeout_period_mclks = (uint32_t) (((timeout_period_us * 1000) +
+		(macro_period_ns / 2)) / macro_period_ns);
+	timeout_overall_periods = VL53L010_encode_timeout(timeout_period_mclks);
+
+	return timeout_overall_periods;
+}
+
+/* To convert register value into us */
+VL53L010_EXTERNAL uint32_t VL53L010_calc_ranging_wait_us(VL53L0_DEV Dev, uint16_t
+	timeout_overall_periods, uint8_t vcsel_period)
+{
+	uint32_t macro_period_ps;
+	uint32_t macro_period_ns;
+	uint32_t timeout_period_mclks = 0;
+	uint32_t actual_timeout_period_us = 0;
+
+	macro_period_ps = VL53L010_calc_macro_period_ps(Dev, vcsel_period);
+	macro_period_ns = macro_period_ps / 1000;
+
+	timeout_period_mclks = VL53L010_decode_timeout(timeout_overall_periods);
+	actual_timeout_period_us = ((timeout_period_mclks * macro_period_ns) +
+		(macro_period_ns / 2)) / 1000;
+
+	return actual_timeout_period_us;
+}
+
+VL53L010_EXTERNAL uint32_t VL53L010_calc_macro_period_ps(VL53L0_DEV Dev,
+		uint8_t vcsel_period)
+{
+	uint32_t PLL_multiplier;
+	uint64_t PLL_period_ps;
+	uint8_t vcsel_period_pclks;
+	uint32_t macro_period_vclks;
+	uint32_t macro_period_ps;
+	FixPoint1616_t OscFrequencyMHz;
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+
+	LOG_FUNCTION_START("");
+
+	PLL_multiplier = 65536 / 64; /* PLL multiplier is 64 */
+
+	OscFrequencyMHz =  VL53L010_GETDEVICESPECIFICPARAMETER(Dev,
+							OscFrequencyMHz);
+
+	if (OscFrequencyMHz == 0) {
+		/* Use default one */
+		VL53L010_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 748421);
+		OscFrequencyMHz = 748421;
+	}
+	PLL_period_ps = (1000 * 1000 * PLL_multiplier) /
+		OscFrequencyMHz;
+
+	vcsel_period_pclks = VL53L010_decode_vcsel_period(vcsel_period);
+
+	macro_period_vclks = 2304;
+	macro_period_ps = (uint32_t)(macro_period_vclks * vcsel_period_pclks *
+		PLL_period_ps);
+
+	LOG_FUNCTION_END("");
+	return macro_period_ps;
+}
+
+VL53L010_EXTERNAL uint8_t VL53L010_decode_vcsel_period(uint8_t vcsel_period_reg)
+{
+
+	/*!
+	 * Converts the encoded VCSEL period register value into the real
+	 * period in PLL clocks
+	 */
+
+	uint8_t vcsel_period_pclks = 0;
+
+	vcsel_period_pclks = (vcsel_period_reg + 1) << 1;
+
+	return vcsel_period_pclks;
+}
+
+VL53L010_EXTERNAL uint8_t VL53L010_encode_vcsel_period(uint8_t vcsel_period_pclks)
+{
+
+	/*!
+	 * Converts the encoded VCSEL period register value into the real
+	 * period in PLL clocks
+	 */
+
+	uint8_t vcsel_period_reg = 0;
+
+	vcsel_period_reg = (vcsel_period_pclks >> 1) - 1;
+
+	return vcsel_period_reg;
+}
+
+VL53L010_EXTERNAL uint16_t VL53L010_encode_timeout(uint32_t timeout_mclks)
+{
+    /*!
+     * Encode timeout in macro periods in (LSByte * 2^MSByte) + 1 format
+     *
+     */
+
+	uint16_t encoded_timeout = 0;
+	uint32_t ls_byte = 0;
+	uint16_t ms_byte = 0;
+
+	if (timeout_mclks > 0) {
+		ls_byte = timeout_mclks - 1;
+
+		while ((ls_byte & 0xFFFFFF00) > 0) {
+			ls_byte = ls_byte >> 1;
+			ms_byte++;
+		}
+
+		encoded_timeout = (ms_byte << 8) + (uint16_t) (ls_byte &
+			0x000000FF);
+
+	}
+
+	return encoded_timeout;
+
+}
+
+VL53L010_EXTERNAL uint32_t VL53L010_decode_timeout(uint16_t encoded_timeout)
+{
+	/*!
+	 * Decode 16-bit timeout register value - format (LSByte * 2^MSByte) + 1
+	 *
+	 */
+
+	uint32_t timeout_mclks = 0;
+
+	timeout_mclks = ((uint32_t) (encoded_timeout & 0x00FF) << (uint32_t)
+		((encoded_timeout & 0xFF00) >> 8)) + 1;
+
+	return timeout_mclks;
+
+}
+
+
+VL53L010_EXTERNAL VL53L0_Error VL53L010_load_additional_settings1(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	/* update 12_05_15_v6 */
+	/* OSCT */
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x14, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCD, 0x6C);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x86, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	/* update 12_05_15_v6 */
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xcd, 0x6c);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x3f);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x3f);
+	Status |= VL53L0_WrByte(Dev, 0x88, 0x2b);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xcd, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+	/* update 12_05_15 */
+	Status |= VL53L0_WrByte(Dev, 0xb0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb1, 0xfc);
+	Status |= VL53L0_WrByte(Dev, 0xb2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb3, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb5, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xb6, 0xb0);
+
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x03);
+
+	Status |= VL53L0_WrByte(Dev, 0x41, 0xff);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0x01, 0x01);
+
+	if (Status != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+
+VL53L010_EXTERNAL VL53L0_Error VL53L010_load_additional_settings3(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	LOG_FUNCTION_START("");
+
+	/* update 150624_b */
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x4f, 0x0B);
+
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x0E);
+
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x01, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x02, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x03, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x04, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x05, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x06, 0x06);
+	Status |= VL53L0_WrByte(Dev, 0x07, 0x47);
+	Status |= VL53L0_WrByte(Dev, 0x08, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x09, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x0A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x0B, 0x49);
+	Status |= VL53L0_WrByte(Dev, 0x0C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x0D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x0E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x0F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x10, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x11, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x12, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x13, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x14, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x15, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x16, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x17, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x18, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x19, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x1A, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x1B, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x1C, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x1D, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x1E, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x1F, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x20, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x21, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x22, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x23, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x24, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x25, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x26, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x27, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x28, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x29, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x2A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2B, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x2C, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x2D, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x2E, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x2F, 0x92);
+	Status |= VL53L0_WrByte(Dev, 0x30, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x31, 0x64);
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x33, 0x8A);
+	Status |= VL53L0_WrByte(Dev, 0x34, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x35, 0xE0);
+	Status |= VL53L0_WrByte(Dev, 0x36, 0x0F);
+	Status |= VL53L0_WrByte(Dev, 0x37, 0xAA);
+	Status |= VL53L0_WrByte(Dev, 0x38, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x39, 0xE4);
+	Status |= VL53L0_WrByte(Dev, 0x3A, 0x0F);
+	Status |= VL53L0_WrByte(Dev, 0x3B, 0xAE);
+	Status |= VL53L0_WrByte(Dev, 0x3C, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x3D, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x3E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x3F, 0x54);
+	Status |= VL53L0_WrByte(Dev, 0x40, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x41, 0x88);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x44, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x45, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x46, 0x06);
+	Status |= VL53L0_WrByte(Dev, 0x47, 0x87);
+	Status |= VL53L0_WrByte(Dev, 0x48, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x49, 0x38);
+	Status |= VL53L0_WrByte(Dev, 0x4A, 0x2B);
+	Status |= VL53L0_WrByte(Dev, 0x4B, 0x89);
+	Status |= VL53L0_WrByte(Dev, 0x4C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x4D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x4E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x4F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x50, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x51, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x52, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x53, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x54, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x55, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x56, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x57, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x58, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x59, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x5A, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x5B, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x5C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x5D, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x5E, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x5F, 0x67);
+	Status |= VL53L0_WrByte(Dev, 0x60, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x61, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x62, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x63, 0xB0);
+	Status |= VL53L0_WrByte(Dev, 0x64, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x65, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x66, 0x29);
+	Status |= VL53L0_WrByte(Dev, 0x67, 0xC1);
+	Status |= VL53L0_WrByte(Dev, 0x68, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x69, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x6B, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x6D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x6F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x71, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x72, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x73, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x74, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x75, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x76, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x77, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x78, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x79, 0x0D);
+	Status |= VL53L0_WrByte(Dev, 0x7A, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x7B, 0x1B);
+	Status |= VL53L0_WrByte(Dev, 0x7C, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x7D, 0x82);
+	Status |= VL53L0_WrByte(Dev, 0x7E, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x7F, 0x24);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x82, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x84, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x85, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x86, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0x21);
+	Status |= VL53L0_WrByte(Dev, 0x88, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x58);
+	Status |= VL53L0_WrByte(Dev, 0x8A, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x8B, 0xCC);
+	Status |= VL53L0_WrByte(Dev, 0x8C, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x8D, 0xC3);
+	Status |= VL53L0_WrByte(Dev, 0x8E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x8F, 0x94);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x53);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x1E);
+	Status |= VL53L0_WrByte(Dev, 0x93, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x95, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x96, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x97, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x98, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x99, 0x20);
+	Status |= VL53L0_WrByte(Dev, 0x9A, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x9B, 0x10);
+	Status |= VL53L0_WrByte(Dev, 0x9C, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x9D, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x9E, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x9F, 0x50);
+	Status |= VL53L0_WrByte(Dev, 0xA0, 0x2B);
+	Status |= VL53L0_WrByte(Dev, 0xA1, 0xB1);
+	Status |= VL53L0_WrByte(Dev, 0xA2, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xA3, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0xA4, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xA5, 0x50);
+	Status |= VL53L0_WrByte(Dev, 0xA6, 0x2C);
+	Status |= VL53L0_WrByte(Dev, 0xA7, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0xA8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xA9, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xAA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xAB, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xAC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xAD, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xAE, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xAF, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xB0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xB1, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xB2, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xB3, 0x4E);
+	Status |= VL53L0_WrByte(Dev, 0xB4, 0x2D);
+	Status |= VL53L0_WrByte(Dev, 0xB5, 0x47);
+	Status |= VL53L0_WrByte(Dev, 0xB6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xB7, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xB8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xB9, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xBA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xBB, 0xA7);
+	Status |= VL53L0_WrByte(Dev, 0xBC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xBD, 0xA6);
+	Status |= VL53L0_WrByte(Dev, 0xBE, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xBF, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0xC0, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xC1, 0x30);
+	Status |= VL53L0_WrByte(Dev, 0xC2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xC3, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xC4, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xC5, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0xC6, 0x2D);
+	Status |= VL53L0_WrByte(Dev, 0xC7, 0x89);
+	Status |= VL53L0_WrByte(Dev, 0xC8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xC9, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xCA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCB, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xCC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCD, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xCE, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xCF, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xD0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD1, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xD2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD3, 0x25);
+	Status |= VL53L0_WrByte(Dev, 0xD4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD5, 0x2E);
+	Status |= VL53L0_WrByte(Dev, 0xD6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD7, 0x25);
+	Status |= VL53L0_WrByte(Dev, 0xD8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xD9, 0x2E);
+	Status |= VL53L0_WrByte(Dev, 0xDA, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xDB, 0xF3);
+	Status |= VL53L0_WrByte(Dev, 0xDC, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xDD, 0xEA);
+	Status |= VL53L0_WrByte(Dev, 0xDE, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xDF, 0x58);
+	Status |= VL53L0_WrByte(Dev, 0xE0, 0x2C);
+	Status |= VL53L0_WrByte(Dev, 0xE1, 0xD9);
+	Status |= VL53L0_WrByte(Dev, 0xE2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE3, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xE4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE5, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xE6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE7, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xE8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xE9, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xEA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xEB, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xEC, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xED, 0x26);
+	Status |= VL53L0_WrByte(Dev, 0xEE, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xEF, 0xDC);
+	Status |= VL53L0_WrByte(Dev, 0xF0, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0xF1, 0x58);
+	Status |= VL53L0_WrByte(Dev, 0xF2, 0x2F);
+	Status |= VL53L0_WrByte(Dev, 0xF3, 0x21);
+	Status |= VL53L0_WrByte(Dev, 0xF4, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xF5, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xF6, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xF7, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xF8, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xF9, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0xFA, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFB, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0xFC, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xFD, 0x04);
+	Status |= VL53L0_WrWord(Dev, 0xFE, 0x01E3);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x0F);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x01, 0x48);
+	Status |= VL53L0_WrByte(Dev, 0x02, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x03, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x04, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x05, 0xA4);
+	Status |= VL53L0_WrByte(Dev, 0x06, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x07, 0xB8);
+	Status |= VL53L0_WrByte(Dev, 0x08, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x09, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x0A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x0B, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x0C, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x0D, 0x6B);
+	Status |= VL53L0_WrByte(Dev, 0x0E, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x0F, 0x64);
+	Status |= VL53L0_WrByte(Dev, 0x10, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x11, 0x3C);
+	Status |= VL53L0_WrByte(Dev, 0x12, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x13, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x14, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x15, 0x74);
+	Status |= VL53L0_WrByte(Dev, 0x16, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x17, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x18, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x19, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x1A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x1B, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x1C, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x1D, 0xA2);
+	Status |= VL53L0_WrByte(Dev, 0x1E, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x1F, 0x8E);
+	Status |= VL53L0_WrByte(Dev, 0x20, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x21, 0x50);
+	Status |= VL53L0_WrByte(Dev, 0x22, 0x2E);
+	Status |= VL53L0_WrByte(Dev, 0x23, 0xC9);
+	Status |= VL53L0_WrByte(Dev, 0x24, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x25, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x26, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x27, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x28, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x29, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x2A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2B, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x2C, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x2D, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x2F, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x30, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x31, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x32, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x33, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x34, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x35, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x36, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x37, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x38, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x39, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x3A, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x3B, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x3C, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x3D, 0x18);
+	Status |= VL53L0_WrByte(Dev, 0x3E, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x3F, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x40, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x41, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x42, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x43, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x44, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x45, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x46, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x47, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x48, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x49, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x4A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x4B, 0x40);
+	Status |= VL53L0_WrByte(Dev, 0x4C, 0x2F);
+	Status |= VL53L0_WrByte(Dev, 0x4D, 0xD1);
+	Status |= VL53L0_WrByte(Dev, 0x4E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x4F, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x50, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x51, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x52, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x53, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x54, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x55, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x56, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x57, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x58, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x59, 0x11);
+	Status |= VL53L0_WrByte(Dev, 0x5A, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x5B, 0x48);
+	Status |= VL53L0_WrByte(Dev, 0x5C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x5D, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x5E, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x5F, 0xA2);
+	Status |= VL53L0_WrByte(Dev, 0x60, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x61, 0x60);
+	Status |= VL53L0_WrByte(Dev, 0x62, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x63, 0x3E);
+	Status |= VL53L0_WrByte(Dev, 0x64, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x65, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x66, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x67, 0x54);
+	Status |= VL53L0_WrByte(Dev, 0x68, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x69, 0x80);
+	Status |= VL53L0_WrByte(Dev, 0x6A, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x6B, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x6C, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x6D, 0x38);
+	Status |= VL53L0_WrByte(Dev, 0x6E, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x6F, 0xE1);
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x71, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x72, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x73, 0x38);
+	Status |= VL53L0_WrByte(Dev, 0x74, 0x29);
+	Status |= VL53L0_WrByte(Dev, 0x75, 0x21);
+	Status |= VL53L0_WrByte(Dev, 0x76, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x77, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x78, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x79, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x7A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x7B, 0xA1);
+	Status |= VL53L0_WrByte(Dev, 0x7C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x7D, 0xA0);
+	Status |= VL53L0_WrByte(Dev, 0x7E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x7F, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x80, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x33);
+	Status |= VL53L0_WrByte(Dev, 0x82, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x6A);
+	Status |= VL53L0_WrByte(Dev, 0x84, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x85, 0x61);
+	Status |= VL53L0_WrByte(Dev, 0x86, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0xF9);
+	Status |= VL53L0_WrByte(Dev, 0x88, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x8A, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x8B, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x8C, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x8D, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0x8E, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x8F, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x66);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x2A);
+	Status |= VL53L0_WrByte(Dev, 0x93, 0x67);
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x95, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x96, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x97, 0x66);
+	Status |= VL53L0_WrByte(Dev, 0x98, 0x2A);
+	Status |= VL53L0_WrByte(Dev, 0x99, 0xAF);
+	Status |= VL53L0_WrByte(Dev, 0x9A, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x9B, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x9C, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x9D, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x9E, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0x9F, 0xA7);
+	Status |= VL53L0_WrByte(Dev, 0xA0, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xA1, 0xA6);
+	Status |= VL53L0_WrByte(Dev, 0xA2, 0x00);
+	Status |= VL53L0_WrByte(Dev, 0xA3, 0x04);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x04);
+
+	Status |= VL53L0_WrByte(Dev, 0x79, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0x7B, 0x16);
+	Status |= VL53L0_WrByte(Dev, 0x7D, 0x2B);
+	Status |= VL53L0_WrByte(Dev, 0x7F, 0x3B);
+	Status |= VL53L0_WrByte(Dev, 0x81, 0x59);
+	Status |= VL53L0_WrByte(Dev, 0x83, 0x62);
+	Status |= VL53L0_WrByte(Dev, 0x85, 0x69);
+	Status |= VL53L0_WrByte(Dev, 0x87, 0x76);
+	Status |= VL53L0_WrByte(Dev, 0x89, 0x7F);
+	Status |= VL53L0_WrByte(Dev, 0x8B, 0x98);
+	Status |= VL53L0_WrByte(Dev, 0x8D, 0xAC);
+	Status |= VL53L0_WrByte(Dev, 0x8F, 0xC0);
+	Status |= VL53L0_WrByte(Dev, 0x90, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0x91, 0x30);
+	Status |= VL53L0_WrByte(Dev, 0x92, 0x28);
+	Status |= VL53L0_WrByte(Dev, 0x93, 0x02);
+	Status |= VL53L0_WrByte(Dev, 0x94, 0x37);
+	Status |= VL53L0_WrByte(Dev, 0x95, 0x62);
+
+	Status |= VL53L0_WrByte(Dev, 0x96, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0x97, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0x98, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x99, 0x18);
+	Status |= VL53L0_WrByte(Dev, 0x9A, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0x9B, 0x6F);
+	Status |= VL53L0_WrByte(Dev, 0x9C, 0x05);
+	Status |= VL53L0_WrByte(Dev, 0x9D, 0xD4);
+	Status |= VL53L0_WrByte(Dev, 0x9E, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0x9F, 0x6E);
+	Status |= VL53L0_WrByte(Dev, 0xA0, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0xA1, 0xA2);
+	Status |= VL53L0_WrByte(Dev, 0xA2, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0xA3, 0xAA);
+	Status |= VL53L0_WrByte(Dev, 0xA4, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xA5, 0x97);
+	Status |= VL53L0_WrByte(Dev, 0xA6, 0x0B);
+	Status |= VL53L0_WrByte(Dev, 0xA7, 0xD8);
+	Status |= VL53L0_WrByte(Dev, 0xA8, 0x0A);
+	Status |= VL53L0_WrByte(Dev, 0xA9, 0xD7);
+	Status |= VL53L0_WrByte(Dev, 0xAA, 0x08);
+	Status |= VL53L0_WrByte(Dev, 0xAB, 0xF6);
+	Status |= VL53L0_WrByte(Dev, 0xAC, 0x07);
+	Status |= VL53L0_WrByte(Dev, 0xAD, 0x1A);
+	Status |= VL53L0_WrByte(Dev, 0xAE, 0x0C);
+	Status |= VL53L0_WrByte(Dev, 0xAF, 0x49);
+	Status |= VL53L0_WrByte(Dev, 0xB0, 0x09);
+	Status |= VL53L0_WrByte(Dev, 0xB1, 0x17);
+	Status |= VL53L0_WrByte(Dev, 0xB2, 0x03);
+	Status |= VL53L0_WrByte(Dev, 0xB3, 0xCD);
+	Status |= VL53L0_WrByte(Dev, 0xB4, 0x04);
+	Status |= VL53L0_WrByte(Dev, 0xB5, 0x55);
+
+	Status |= VL53L0_WrByte(Dev, 0x72, 0xFF);
+	Status |= VL53L0_WrByte(Dev, 0x73, 0xFF);
+
+	Status |= VL53L0_WrByte(Dev, 0x74, 0xE0);
+
+	Status |= VL53L0_WrByte(Dev, 0x70, 0x01);
+
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+
+	if (Status != 0)
+		Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L010_EXTERNAL VL53L0_Error VL53L010_check_part_used(VL53L0_DEV Dev,
+		uint8_t *Revision, VL53L0_DeviceInfo_t* pVL53L0_DeviceInfo)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t ModuleIdInt;
+    char *ProductId_tmp;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L010_get_info_from_device(Dev);
+
+    if (Status == VL53L0_ERROR_NONE) {
+		ModuleIdInt = VL53L010_GETDEVICESPECIFICPARAMETER(Dev, ModuleId);
+
+        if (ModuleIdInt == 0) {
+            *Revision = 0;
+            VL53L0_COPYSTRING(pVL53L0_DeviceInfo->ProductId, "");
+        } else {
+            *Revision = VL53L010_GETDEVICESPECIFICPARAMETER(Dev, Revision);
+        	ProductId_tmp = VL53L010_GETDEVICESPECIFICPARAMETER(Dev, ProductId);
+        	VL53L0_COPYSTRING(pVL53L0_DeviceInfo->ProductId, ProductId_tmp);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L010_EXTERNAL VL53L0_Error VL53L010_get_info_from_device(VL53L0_DEV Dev)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t byte;
+    uint32_t TmpDWord;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    uint8_t ModuleId;
+    uint8_t Revision;
+    uint8_t ReferenceSpadCount;
+    uint8_t ReferenceSpadType;
+    char ProductId[19];
+    char *ProductId_tmp;
+    uint8_t ReadDataFromDeviceDone;
+
+    LOG_FUNCTION_START("");
+
+    ReadDataFromDeviceDone = VL53L010_GETDEVICESPECIFICPARAMETER(Dev,
+    		ReadDataFromDeviceDone);
+
+    /* This access is done only once after that a GetDeviceInfo or
+     * datainit is done*/
+    if (ReadDataFromDeviceDone == 0) {
+
+        Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+        Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
+        Status |= VL53L0_RdByte(Dev, 0x83, &byte);
+        Status |= VL53L0_WrByte(Dev, 0x83, byte|4);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x07);
+        Status |= VL53L0_WrByte(Dev, 0x81, 0x01);
+
+        Status |= VL53L0_PollingDelay(Dev);
+
+        Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x6b);
+        Status |= VL53L010_device_read_strobe(Dev);
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ReferenceSpadCount = (uint8_t)((TmpDWord >> 8) & 0x07f);
+        ReferenceSpadType  = (uint8_t)((TmpDWord >> 15) & 0x01);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x02);
+        Status |= VL53L010_device_read_strobe(Dev);
+        Status |= VL53L0_RdByte(Dev, 0x90, &ModuleId);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x7B);
+        Status |= VL53L010_device_read_strobe(Dev);
+        Status |= VL53L0_RdByte(Dev, 0x90, &Revision);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x77);
+        Status |= VL53L010_device_read_strobe(Dev);
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[0] = (char)((TmpDWord >> 25) & 0x07f);
+        ProductId[1] = (char)((TmpDWord >> 18) & 0x07f);
+        ProductId[2] = (char)((TmpDWord >> 11) & 0x07f);
+        ProductId[3] = (char)((TmpDWord >> 4) & 0x07f);
+
+        byte = (uint8_t)((TmpDWord & 0x00f) << 3);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x78);
+        Status |= VL53L010_device_read_strobe(Dev);
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[4] = (char)(byte +
+        		((TmpDWord >> 29) & 0x07f));
+        ProductId[5] = (char)((TmpDWord >> 22) & 0x07f);
+        ProductId[6] = (char)((TmpDWord >> 15) & 0x07f);
+        ProductId[7] = (char)((TmpDWord >> 8) & 0x07f);
+        ProductId[8] = (char)((TmpDWord >> 1) & 0x07f);
+
+        byte = (uint8_t)((TmpDWord & 0x001) << 6);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x79);
+
+        Status |= VL53L010_device_read_strobe(Dev);
+
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[9] = (char)(byte +
+        		((TmpDWord >> 26) & 0x07f));
+        ProductId[10] = (char)((TmpDWord >> 19) & 0x07f);
+        ProductId[11] = (char)((TmpDWord >> 12) & 0x07f);
+        ProductId[12] = (char)((TmpDWord >> 5) & 0x07f);
+
+        byte = (uint8_t)((TmpDWord & 0x01f) << 2);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x80);
+
+        Status |= VL53L010_device_read_strobe(Dev);
+
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[13] = (char)(byte +
+        		((TmpDWord >> 30) & 0x07f));
+        ProductId[14] = (char)((TmpDWord >> 23) & 0x07f);
+        ProductId[15] = (char)((TmpDWord >> 16) & 0x07f);
+        ProductId[16] = (char)((TmpDWord >> 9) & 0x07f);
+        ProductId[17] = (char)((TmpDWord >> 2) & 0x07f);
+        ProductId[18] = '\0';
+
+        Status |= VL53L0_WrByte(Dev, 0x81, 0x00);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
+        Status |= VL53L0_RdByte(Dev, 0x83, &byte);
+        Status |= VL53L0_WrByte(Dev, 0x83, byte&0xfb);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+        Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+        Status |= VL53L0_WrByte(Dev, 0x80, 0x00);
+
+        if (Status == VL53L0_ERROR_NONE) {
+        	VL53L010_SETDEVICESPECIFICPARAMETER(Dev,
+        			ModuleId, ModuleId);
+
+        	VL53L010_SETDEVICESPECIFICPARAMETER(Dev,
+        			Revision, Revision);
+
+        	VL53L010_SETDEVICESPECIFICPARAMETER(Dev,
+        			ReferenceSpadCount, ReferenceSpadCount);
+
+        	VL53L010_SETDEVICESPECIFICPARAMETER(Dev,
+        			ReferenceSpadType, ReferenceSpadType);
+
+        	ProductId_tmp = VL53L010_GETDEVICESPECIFICPARAMETER(Dev,
+        			ProductId);
+        	VL53L0_COPYSTRING(ProductId_tmp, ProductId);
+
+        	VL53L010_SETDEVICESPECIFICPARAMETER(Dev,
+        	    		ReadDataFromDeviceDone, 1);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+uint32_t VL53L010_isqrt(uint32_t num)
+{
+
+    /*
+     * Implements an integer square root
+     *
+     * From: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
+     */
+
+	uint32_t  res = 0;
+	uint32_t  bit = 1 << 30;
+	/* The second-to-top bit is set: 1 << 14 for
+	16-bits, 1 << 30 for 32 bits
+	*/
+    /* "bit" starts at the highest power of four <= the argument.*/
+	while (bit > num)
+		bit >>= 2;
+
+
+	while (bit != 0) {
+		if (num >= res + bit) {
+			num -= res + bit;
+			res = (res >> 1) + bit;
+		} else
+			res >>= 1;
+
+		bit >>= 2;
+	}
+
+	return res;
+}
+
+
+VL53L0_Error VL53L010_device_read_strobe(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t strobe;
+    uint32_t LoopNb;
+    LOG_FUNCTION_START("");
+
+    Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
+
+    // polling
+    // use timeout to avoid deadlock
+    if (Status == VL53L0_ERROR_NONE) {
+        LoopNb = 0;
+        do {
+            Status =VL53L0_RdByte(Dev, 0x83, &strobe);
+            if ((strobe != 0x00) || Status != VL53L0_ERROR_NONE) {
+                break;
+            }
+            LoopNb = LoopNb + 1;
+        } while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+        if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP) {
+            Status = VL53L0_ERROR_TIME_OUT;
+        }
+    }
+
+    Status |= VL53L0_WrByte(Dev, 0x83, 0x01);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+
+}
+
+uint32_t VL53L010_quadrature_sum(uint32_t a,
+	uint32_t b)
+{
+	/*
+	* Implements a quadrature sum
+	*
+	* rea = sqrt(a^2 + b^2)
+	*
+	* Trap overflow case max input value is 65535 (16-bit value)
+	* as internal calc are 32-bit wide
+	*
+	* If overflow then seta output to maximum
+	*/
+	uint32_t  res = 0;
+
+	if (a > 65535 || b > 65535)
+		res = 65535;
+	else
+		res = VL53L010_isqrt(a*a + b*b);
+
+
+	return res;
+}
+
+
+
+VL53L0_Error VL53L010_get_jmp_vcsel_ambient_rate(VL53L0_DEV Dev,
+	uint32_t *pAmbient_rate_kcps,
+	uint32_t *pVcsel_rate_kcps,
+	uint32_t *pSignalTotalEventsRtn)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint16_t encodedTimeOut;
+
+	uint32_t    total_periods_elapsed_rtn__macrop  = 0;
+	uint32_t    result_core__total_periods_elapsed_rtn  = 0;
+	uint32_t    rngb1_config__timeout__macrop = 0;
+	uint32_t    rngb2_config__timeout__macrop = 0;
+	uint32_t    result_core__ambient_window_events_rtn = 0;
+	uint32_t     result_core__signal_total_events_rtn = 0;
+	uint8_t     last_woi_period;
+	uint8_t     rnga_config__vcsel_period;
+	uint8_t     rngb1_config__vcsel_period;
+	uint8_t     rngb2_config__vcsel_period;
+	uint8_t     global_config__vcsel_width;
+
+	uint32_t    ambient_duration_us = 0;
+	uint32_t    vcsel_duration_us = 0;
+
+	uint32_t    pll_period_us  = 0;
+
+	LOG_FUNCTION_START("");
+
+	/* read the following */
+	Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+	Status |= VL53L0_RdDWord(Dev, 0xC8,
+		&result_core__total_periods_elapsed_rtn);
+	Status |= VL53L0_RdDWord(Dev, 0xF0, &pll_period_us);
+	Status |= VL53L0_RdDWord(Dev, 0xbc,
+		&result_core__ambient_window_events_rtn);
+	Status |= VL53L0_RdDWord(Dev, 0xc4,
+		&result_core__signal_total_events_rtn);
+	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		result_core__total_periods_elapsed_rtn =
+			(int32_t)(result_core__total_periods_elapsed_rtn &
+			0x00ffffff);
+		pll_period_us = (int32_t)(pll_period_us & 0x3ffff);
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdWord(Dev, VL53L010_REG_RNGB1_TIMEOUT_MSB,
+			&encodedTimeOut);
+	if (Status == VL53L0_ERROR_NONE)
+		rngb1_config__timeout__macrop =
+			VL53L010_decode_timeout(encodedTimeOut) - 1;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev, VL53L010_REG_RNGA_CONFIG_VCSEL_PERIOD,
+			&rnga_config__vcsel_period);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev,
+			VL53L010_REG_RNGB1_CONFIG_VCSEL_PERIOD,
+			&rngb1_config__vcsel_period);
+	}
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdByte(Dev,
+			VL53L010_REG_RNGB2_CONFIG_VCSEL_PERIOD,
+			&rngb2_config__vcsel_period);
+	}
+	if (Status == VL53L0_ERROR_NONE)
+		Status = VL53L0_RdByte(Dev, 0x32, &global_config__vcsel_width);
+
+
+	if (Status == VL53L0_ERROR_NONE) {
+		Status = VL53L0_RdWord(Dev, VL53L010_REG_RNGB2_TIMEOUT_MSB,
+			&encodedTimeOut);
+		if (Status == VL53L0_ERROR_NONE)
+			rngb2_config__timeout__macrop =
+				VL53L010_decode_timeout(encodedTimeOut) - 1;
+
+	}
+
+	if (Status == VL53L0_ERROR_NONE) {
+		total_periods_elapsed_rtn__macrop =
+			result_core__total_periods_elapsed_rtn + 1;
+
+		if (result_core__total_periods_elapsed_rtn ==
+			rngb1_config__timeout__macrop) {
+			last_woi_period = rngb1_config__vcsel_period;
+		} else if (result_core__total_periods_elapsed_rtn ==
+			rngb2_config__timeout__macrop) {
+			last_woi_period = rngb2_config__vcsel_period;
+		} else {
+			last_woi_period = rnga_config__vcsel_period;
+
+		}
+		/* 512 = 1<<9  ==> 24-9=15 */
+		ambient_duration_us = last_woi_period *
+			total_periods_elapsed_rtn__macrop * pll_period_us;
+		ambient_duration_us = ambient_duration_us / 1000;
+
+		if (ambient_duration_us != 0) {
+			*pAmbient_rate_kcps = ((1 << 15) *
+				result_core__ambient_window_events_rtn) /
+				ambient_duration_us;
+		} else {
+			Status = VL53L0_ERROR_DIVISION_BY_ZERO;
+		}
+
+		if (Status == VL53L0_ERROR_NONE) {
+
+			/* 2048 = 1<<11  ==> 24-11=13 */
+			vcsel_duration_us =
+				(10 * global_config__vcsel_width + 4)
+				* total_periods_elapsed_rtn__macrop *
+				pll_period_us ;
+			vcsel_duration_us = vcsel_duration_us / 10000 ;
+
+
+			if (vcsel_duration_us != 0) {
+				*pVcsel_rate_kcps = ((1 << 13) *
+					result_core__signal_total_events_rtn) /
+					vcsel_duration_us;
+				*pSignalTotalEventsRtn =
+					result_core__signal_total_events_rtn;
+			} else {
+				Status = VL53L0_ERROR_DIVISION_BY_ZERO;
+			}
+
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
+
+VL53L0_Error VL53L010_calc_sigma_estimate(VL53L0_DEV Dev,
+	VL53L0_RangingMeasurementData_t
+	*pRangingMeasurementData,
+	FixPoint1616_t *pSigmaEstimate)
+{
+	/* Expressed in 100ths of a ns, i.e. centi-ns */
+	const uint32_t cPulseEffectiveWidth_centi_ns   = 800;
+	/* Expressed in 100ths of a ns, i.e. centi-ns */
+	const uint32_t cAmbientEffectiveWidth_centi_ns = 600;
+	const FixPoint1616_t cSigmaEstRef              = 0x00000042;
+	/* pico secs */
+	const uint32_t cVcselPulseWidth_ps             = 4700;
+	const FixPoint1616_t cSigmaEstMax              = 0x028F87AE;
+	/* Time Of Flight per mm (6.6 pico secs) */
+	const FixPoint1616_t cTOF_per_mm_ps            = 0x0006999A;
+	const uint32_t c16BitRoundingParam             = 0x00008000;
+	const FixPoint1616_t cMaxXTalk_kcps            = 0x00320000;
+
+	uint32_t signalTotalEventsRtn;
+	FixPoint1616_t sigmaEstimateP1;
+	FixPoint1616_t sigmaEstimateP2;
+	FixPoint1616_t sigmaEstimateP3;
+	FixPoint1616_t deltaT_ps;
+	FixPoint1616_t pwMult;
+	FixPoint1616_t sigmaEstRtn;
+	FixPoint1616_t sigmaEstimate;
+	FixPoint1616_t xTalkCorrection;
+	uint32_t signalTotalEventsRtnRawVal;
+	FixPoint1616_t ambientRate_kcps;
+	FixPoint1616_t vcselRate_kcps;
+	FixPoint1616_t xTalkCompRate_mcps;
+	uint32_t xTalkCompRate_kcps;
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	VL53L0_DeviceParameters_t CurrentParameters;
+	FixPoint1616_t diff1_mcps;
+	FixPoint1616_t diff2_mcps;
+	FixPoint1616_t sqr1;
+	FixPoint1616_t sqr2;
+	FixPoint1616_t sqrSum;
+	FixPoint1616_t sqrtResult_centi_ns;
+	FixPoint1616_t sqrtResult;
+
+	/*! \addtogroup calc_sigma_estimate
+	* @{
+	*
+	* Estimates the range sigma based on the
+	*
+	*  - vcsel_rate_kcps
+	*  - ambient_rate_kcps
+	*  - signal_total_events
+	*  - xtalk_rate
+	*
+	* and the following parameters
+	*
+	*  - SigmaEstRefArray
+	*  - SigmaEstEffPulseWidth
+	*  - SigmaEstEffAmbWidth
+	*/
+
+	LOG_FUNCTION_START("");
+
+	VL53L010_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+		xTalkCompRate_mcps);
+    /*
+     * We work in kcps rather than mcps as this helps keep within the confines
+     * of the 32 Fix1616 type.
+     */
+
+	xTalkCompRate_kcps = xTalkCompRate_mcps * 1000;
+	if (xTalkCompRate_kcps > cMaxXTalk_kcps)
+		xTalkCompRate_kcps = cMaxXTalk_kcps;
+
+
+	Status =  VL53L010_get_jmp_vcsel_ambient_rate(Dev,
+					&ambientRate_kcps,
+					&vcselRate_kcps,
+					&signalTotalEventsRtnRawVal);
+
+	if (Status == VL53L0_ERROR_NONE) {
+		if (vcselRate_kcps == 0) {
+			Status = VL53L0_ERROR_DIVISION_BY_ZERO;
+		} else {
+			signalTotalEventsRtn = signalTotalEventsRtnRawVal;
+			if (signalTotalEventsRtn < 1)
+				signalTotalEventsRtn = 1;
+
+			/*
+			 * Calculate individual components of the main
+			 * equation - replicating the equation implemented in
+			 * the script OpenAll_Ewok_ranging_data.jsl.
+			 *
+			 * sigmaEstimateP1 represents the effective pulse width,
+			 * which is a tuning parameter, rather than a real
+			 * value.
+			 *
+			 * sigmaEstimateP2 represents the ambient/signal rate
+			 * ratio expressed as a multiple of the effective
+			 * ambient width (tuning parameter).
+			 *
+			 * sigmaEstimateP3 provides the signal event component,
+			 * with the knowledge that
+			 *	- Noise of a square pulse is 1/sqrt(12) of the
+			 * pulse width.
+			 *	- at 0Lux, sigma is proportional to
+			 *	effectiveVcselPulseWidth /
+			 *	sqrt(12 * signalTotalEvents)
+			 *
+			 * deltaT_ps represents the time of flight in pico secs
+			 * for the current range measurement, using the
+			 * "TOF per mm" constant (in ps).
+			 */
+
+			sigmaEstimateP1 = cPulseEffectiveWidth_centi_ns;
+
+			/*
+			((FixPoint1616 << 16)* uint32)/FixPoint1616 =
+				FixPoint1616
+			*/
+			sigmaEstimateP2 = (ambientRate_kcps << 16) /
+				vcselRate_kcps;
+			sigmaEstimateP2 *= cAmbientEffectiveWidth_centi_ns;
+
+			sigmaEstimateP3 = 2 *
+				VL53L010_isqrt(signalTotalEventsRtn * 12);
+
+			/* uint32 * FixPoint1616 = FixPoint1616 */
+			deltaT_ps =
+				pRangingMeasurementData->RangeMilliMeter *
+					cTOF_per_mm_ps;
+
+			/*
+			 * vcselRate - xtalkCompRate
+			 * (uint32 << 16) - FixPoint1616 = FixPoint1616.
+			 * Divide result by 1000 to convert to mcps.
+			 * 500 is added to ensure rounding when integer
+			 * division truncates.
+			 */
+			diff1_mcps = (((vcselRate_kcps << 16) -
+					xTalkCompRate_kcps) + 500)/1000;
+
+			/* vcselRate + xtalkCompRate */
+			diff2_mcps = (((vcselRate_kcps << 16) +
+					xTalkCompRate_kcps) + 500)/1000;
+
+			/* Shift by 12 bits to increase resolution prior to the
+			division */
+			diff1_mcps <<= 12;
+
+			/* FixPoint0428/FixPoint1616 = FixPoint2012 */
+			xTalkCorrection  = abs(diff1_mcps/diff2_mcps);
+
+			/* FixPoint2012 << 4 = FixPoint1616 */
+			xTalkCorrection <<= 4;
+
+			/* FixPoint1616/uint32 = FixPoint1616 */
+			pwMult = deltaT_ps/cVcselPulseWidth_ps;
+			/* smaller than 1.0f */
+
+			/*
+			 * FixPoint1616 * FixPoint1616 = FixPoint3232, however
+			 * both values are small enough such that32 bits will
+			 * not be exceeded.
+			 */
+			pwMult *= ((1 << 16) - xTalkCorrection);
+
+			/* (FixPoint3232 >> 16) = FixPoint1616 */
+			pwMult =  (pwMult + c16BitRoundingParam) >> 16;
+
+			/* FixPoint1616 + FixPoint1616 = FixPoint1616 */
+			pwMult += (1 << 16);
+
+			/*
+			 * At this point the value will be 1.xx, therefore if we
+			 * square the value this will exceed 32 bits. To address
+			 * this perform a single shift to the right before the
+			 * multiplication.
+			 */
+			pwMult >>= 1;
+			/* FixPoint1715 * FixPoint1715 = FixPoint3430 */
+			pwMult = pwMult * pwMult;
+
+			/* (FixPoint3430 >> 14) = Fix1616 */
+			pwMult >>= 14;
+
+			/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+			sqr1 = pwMult * sigmaEstimateP1;
+
+			/* (FixPoint1616 >> 12) = FixPoint2804 */
+			sqr1 = (sqr1 + 0x800) >> 12;
+
+			/* FixPoint2804 * FixPoint2804 = FixPoint5608 */
+			sqr1 *= sqr1;
+
+			sqr2 = sigmaEstimateP2;
+
+			/* (FixPoint1616 >> 12) = FixPoint2804 */
+			sqr2 = (sqr2 + 0x800) >> 12;
+
+			/* FixPoint2804 * FixPoint2804 = FixPoint5608 */
+			sqr2 *= sqr2;
+
+			/* FixPoint5608 + FixPoint5608 = FixPoint5608 */
+			sqrSum = sqr1 + sqr2;
+
+			/* SQRT(FixPoint5608) = FixPoint2804 */
+			sqrtResult_centi_ns = VL53L010_isqrt(sqrSum);
+
+			/* (FixPoint2804 << 12) = FixPoint1616 */
+			sqrtResult_centi_ns <<= 12;
+
+			/*
+			 * Note that the Speed Of Light is expressed in um
+			 * per 1E-10 seconds (2997). Therefore to get mm/ns
+			 * we have to divide by 10000
+			 */
+			sigmaEstRtn      =
+				((sqrtResult_centi_ns + 50) / 100 *
+				VL53L010_SPEED_OF_LIGHT_IN_AIR);
+			sigmaEstRtn      /= (sigmaEstimateP3);
+			/* Add 5000 before dividing by 10000 to ensure
+			rounding. */
+			sigmaEstRtn      += 5000;
+			sigmaEstRtn      /= 10000;
+
+			/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+			sqr1 = sigmaEstRtn * sigmaEstRtn;
+			/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+			sqr2 = cSigmaEstRef * cSigmaEstRef;
+
+			/* sqrt(FixPoint3232 << 12) = FixPoint1022 */
+			sqrtResult = VL53L010_isqrt((sqr1 + sqr2) << 12);
+			sqrtResult = (sqrtResult + 0x20) >> 6;
+			/*
+			 * Note that the Shift by 12bits increases resolution
+			 * prior to the sqrt, therefore the result must be
+			 * shifted by 6bits to the right to revert back to the
+			 * FixPoint1616 format.
+			 */
+
+			sigmaEstimate    = 1000 * sqrtResult;
+
+			if ((vcselRate_kcps < 1) ||
+					(signalTotalEventsRtn < 1) ||
+					(sigmaEstimate > cSigmaEstMax)) {
+				sigmaEstimate = cSigmaEstMax;
+			}
+
+			*pSigmaEstimate = (uint32_t)(sigmaEstimate);
+			PALDevDataSet(Dev, SigmaEstimate, *pSigmaEstimate);
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+}
+
+VL53L0_Error VL53L010_get_pal_range_status(VL53L0_DEV Dev,
+		uint8_t DeviceRangeStatus,
+		FixPoint1616_t SignalRate,
+		FixPoint1616_t CrosstalkCompensation,
+		uint16_t EffectiveSpadRtnCount,
+		VL53L0_RangingMeasurementData_t *pRangingMeasurementData,
+		uint8_t *pPalRangeStatus)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+	uint8_t tmpByte;
+	uint8_t SigmaLimitCheckEnable;
+	uint8_t SignalLimitCheckEnable;
+	FixPoint1616_t SigmaEstimate;
+	FixPoint1616_t SignalEstimate;
+	FixPoint1616_t SigmaLimitValue;
+	FixPoint1616_t SignalLimitValue;
+	uint8_t DeviceRangeStatusInternal = 0;
+
+	LOG_FUNCTION_START("");
+
+	/*
+	 * VL53L0 has a good ranging when the value of the
+	 * DeviceRangeStatus = 11. This function will replace
+	 * the value 0 with the value 11 in the DeviceRangeStatus.
+	 * In addition, the SigmaEstimator is not included in the
+	 * VL53L0 DeviceRangeStatus, this will be added in the
+	 * PalRangeStatus.
+	 */
+
+	DeviceRangeStatusInternal = ((DeviceRangeStatus & 0x78) >> 3);
+
+	if (DeviceRangeStatusInternal == 11)
+		tmpByte = 0;
+	else if (DeviceRangeStatusInternal == 0)
+		tmpByte = 11;
+	else
+		tmpByte = DeviceRangeStatusInternal;
+
+
+    /*
+     * Check if Sigma limit is enabled, if yes then do comparison with
+     * limit value and put the result back into pPalRangeStatus.
+     */
+    Status =  VL53L010_GetLimitCheckEnable(Dev,
+                  VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE,
+                  &SigmaLimitCheckEnable);
+
+	if ((SigmaLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
+		/*
+		 * compute the Sigma and check with limit
+		 */
+		Status = VL53L010_calc_sigma_estimate(Dev,
+				pRangingMeasurementData, &SigmaEstimate);
+
+		if (Status == VL53L0_ERROR_NONE) {
+            Status = VL53L010_GetLimitCheckValue(Dev,
+            		VL53L010_CHECKENABLE_SIGMA_FINAL_RANGE,
+                     &SigmaLimitValue);
+
+			if ((SigmaLimitValue > 0) &&
+				(SigmaEstimate > SigmaLimitValue)) {
+				/* Limit Fail add 2^4 to range status */
+				tmpByte += 16;
+			}
+		}
+	}
+
+    /*
+	* Check if Signal limit is enabled, if yes then do comparison with
+	* limit value and put the result back into pPalRangeStatus.
+	*/
+    Status =  VL53L010_GetLimitCheckEnable(Dev,
+                  VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
+                  &SignalLimitCheckEnable);
+
+	if ((SignalLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
+		/*
+		* compute the Signal and check with limit
+		*/
+
+		SignalEstimate  = (FixPoint1616_t)(SignalRate -
+			(FixPoint1616_t)((EffectiveSpadRtnCount *
+			CrosstalkCompensation) >> 1));
+
+		PALDevDataSet(Dev, SignalEstimate, SignalEstimate);
+
+        Status = VL53L010_GetLimitCheckValue(Dev,
+            VL53L010_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
+            &SignalLimitValue);
+
+        if ((SignalLimitValue > 0) && (SignalEstimate <
+			SignalLimitValue)) {
+			/* Limit Fail add 2^5 to range status */
+			tmpByte += 32;
+		}
+	}
+
+	if (Status == VL53L0_ERROR_NONE)
+		*pPalRangeStatus = tmpByte;
+
+
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l010_tuning.c b/drivers/input/misc/vl53L0/src/vl53l010_tuning.c
new file mode 100644
index 00000000000..59d90a2b774
--- /dev/null
+++ b/drivers/input/misc/vl53L0/src/vl53l010_tuning.c
@@ -0,0 +1,137 @@
+/*******************************************************************************
+ Copyright © 2015, STMicroelectronics International N.V.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in the
+ documentation and/or other materials provided with the distribution.
+ * Neither the name of STMicroelectronics nor the
+ names of its contributors may be used to endorse or promote products
+ derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+ NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+ IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ******************************************************************************/
+
+#include "vl53l010_tuning.h"
+
+#define LOG_FUNCTION_START(fmt, ...) \
+	_LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
+#define LOG_FUNCTION_END(status, ...) \
+	_LOG_FUNCTION_END(TRACE_MODULE_API, status, ##__VA_ARGS__)
+#define LOG_FUNCTION_END_FMT(status, fmt, ...) \
+	_LOG_FUNCTION_END_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)
+
+#ifdef VL53L0_LOG_ENABLE
+#define trace_print(level, ...) \
+	trace_print_module_function(TRACE_MODULE_API,\
+	level, TRACE_FUNCTION_NONE, ##__VA_ARGS__)
+#endif
+
+/*
+//////////////////////////////////////////////////////
+////       DEFAULT TUNING SETTINGS                ////
+//////////////////////////////////////////////////////
+*/
+VL53L0_Error VL53L010_load_tuning_settings(VL53L0_DEV Dev)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+	/* update 17_06_15_v10 */
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x91, 0x3C);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x54, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x33, 0x05);
+    Status |= VL53L0_WrByte(Dev, 0x32, 0x03);
+    Status |= VL53L0_WrByte(Dev, 0x30, 0x05);
+    Status |= VL53L0_WrByte(Dev, 0x50, 0x05);
+    Status |= VL53L0_WrByte(Dev, 0x60, 0x04);
+    Status |= VL53L0_WrByte(Dev, 0x70, 0x06);
+
+    Status |= VL53L0_WrByte(Dev, 0x46, 0x1a);
+    Status |= VL53L0_WrWord(Dev, 0x51, 0x01a3);
+    Status |= VL53L0_WrWord(Dev, 0x61, 0x01c4);
+    Status |= VL53L0_WrWord(Dev, 0x71, 0x018c);
+
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x31, 0x0f);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x66, 0x38);
+
+    Status |= VL53L0_WrByte(Dev, 0x47, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x48, 0xff);
+    Status |= VL53L0_WrByte(Dev, 0x57, 0x4c);
+    Status |= VL53L0_WrByte(Dev, 0x67, 0x3c);
+    Status |= VL53L0_WrByte(Dev, 0x77, 0x5c);
+
+    Status |= VL53L0_WrWord(Dev, 0x44, 0x0000);
+
+    Status |= VL53L0_WrByte(Dev, 0x27, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x55, 0x00);
+
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x30, 0x28);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    Status |= VL53L0_WrByte(Dev, 0x10, 0x0f);
+    Status |= VL53L0_WrByte(Dev, 0x11, 0xff);
+    Status |= VL53L0_WrByte(Dev, 0x41, 0xff);
+    Status |= VL53L0_WrByte(Dev, 0x42, 0x07);
+    Status |= VL53L0_WrByte(Dev, 0x43, 0x12);
+
+    Status |= VL53L0_WrByte(Dev, 0x20, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x21, 0x00);
+
+    Status |= VL53L0_WrByte(Dev, 0x28, 0x06);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x48, 0x28);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    Status |= VL53L0_WrByte(Dev, 0x7a, 0x0a);
+    Status |= VL53L0_WrByte(Dev, 0x7b, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x78, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x44, 0xff);
+    Status |= VL53L0_WrByte(Dev, 0x45, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x46, 0x10);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    Status |= VL53L0_WrByte(Dev, 0x04, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x05, 0x04);
+    Status |= VL53L0_WrByte(Dev, 0x06, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x07, 0x00);
+
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x0d, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+    Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x01, 0xF8);
+
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x8e, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+
+    if (Status != 0)
+        Status = VL53L0_ERROR_CONTROL_INTERFACE;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_api.c b/drivers/input/misc/vl53L0/src/vl53l0_api.c
index ae188a3a56b..d5f592ed27f 100644
--- a/drivers/input/misc/vl53L0/src/vl53l0_api.c
+++ b/drivers/input/misc/vl53L0/src/vl53l0_api.c
@@ -1,4171 +1,4497 @@
-/*******************************************************************************
- Copyright © 2015, STMicroelectronics International N.V.
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions are met:
- * Redistributions of source code must retain the above copyright
- notice, this list of conditions and the following disclaimer.
- * Redistributions in binary form must reproduce the above copyright
- notice, this list of conditions and the following disclaimer in the
- documentation and/or other materials provided with the distribution.
- * Neither the name of STMicroelectronics nor the
- names of its contributors may be used to endorse or promote products
- derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
- NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
- IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ******************************************************************************/
-
-#include "vl53l0_api.h"
-#include "vl53l0_tuning.h"
-
-/* use macro for abs */
-#ifndef __KERNEL__
-#include <stdlib.h>
-#endif
-
-
-#define LOG_FUNCTION_START(fmt, ...) \
-	_LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
-#define LOG_FUNCTION_END(status, ...) \
-	_LOG_FUNCTION_END(TRACE_MODULE_API, status, ##__VA_ARGS__)
-#define LOG_FUNCTION_END_FMT(status, fmt, ...) \
-	_LOG_FUNCTION_END_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)
-
-#ifdef VL53L0_LOG_ENABLE
-#define trace_print(level, ...) trace_print_module_function(TRACE_MODULE_API, \
-	level, TRACE_FUNCTION_NONE, ##__VA_ARGS__)
-#endif
-
-
-/* Defines */
-#define VL53L0_SETPARAMETERFIELD(Dev, field, value) \
-	do { \
-		if (Status == VL53L0_ERROR_NONE) {\
-			CurrentParameters = \
-				PALDevDataGet(Dev, CurrentParameters); \
-			CurrentParameters.field = value; \
-			CurrentParameters =	\
-				PALDevDataSet(Dev, CurrentParameters, \
-					CurrentParameters); \
-		} \
-	} while (0)
-#define VL53L0_SETARRAYPARAMETERFIELD(Dev, field, index, value) \
-	do { \
-		if (Status == VL53L0_ERROR_NONE) {\
-			CurrentParameters = \
-				PALDevDataGet(Dev, CurrentParameters); \
-			CurrentParameters.field[index] = value; \
-			CurrentParameters = \
-				PALDevDataSet(Dev, CurrentParameters, \
-					CurrentParameters); \
-		} \
-	} while (0)
-
-#define VL53L0_GETPARAMETERFIELD(Dev, field, variable) \
-	do { \
-		if (Status == VL53L0_ERROR_NONE) { \
-			CurrentParameters = \
-				PALDevDataGet(Dev, CurrentParameters); \
-			variable = CurrentParameters.field; \
-		} \
-	} while (0)
-
-#define VL53L0_GETARRAYPARAMETERFIELD(Dev, field, index, variable) \
-	do { \
-		if (Status == VL53L0_ERROR_NONE) { \
-			CurrentParameters = \
-				PALDevDataGet(Dev, CurrentParameters); \
-			variable = CurrentParameters.field[index]; \
-		} \
-	} while (0)
-
-#define VL53L0_SETDEVICESPECIFICPARAMETER(Dev, field, value) \
-	do { \
-		if (Status == VL53L0_ERROR_NONE) { \
-			DeviceSpecificParameters = \
-				PALDevDataGet(Dev, DeviceSpecificParameters); \
-			DeviceSpecificParameters.field = value; \
-			DeviceSpecificParameters = \
-				PALDevDataSet(Dev, DeviceSpecificParameters, \
-				DeviceSpecificParameters); \
-		} \
-	} while (0)
-
-#define VL53L0_GETDEVICESPECIFICPARAMETER(Dev, field) \
-		PALDevDataGet(Dev, DeviceSpecificParameters).field
-
-#define VL53L0_FIXPOINT1616TOFIXPOINT97(Value) \
-			(uint16_t)((Value >> 9) & 0xFFFF)
-#define VL53L0_FIXPOINT97TOFIXPOINT1616(Value) \
-			(FixPoint1616_t)(Value << 9)
-#define VL53L0_FIXPOINT1616TOFIXPOINT412(Value) \
-			(uint16_t)((Value >> 4) & 0xFFFF)
-#define VL53L0_FIXPOINT412TOFIXPOINT1616(Value) \
-			(FixPoint1616_t)(Value << 4)
-#define VL53L0_FIXPOINT1616TOFIXPOINT08(Value) \
-			(uint8_t)((Value >> 8) & 0x00FF)
-#define VL53L0_FIXPOINT08TOFIXPOINT1616(Value) \
-			(FixPoint1616_t)(Value << 8)
-#define VL53L0_MAKEUINT16(lsb, msb) \
-			(uint16_t)((((uint16_t)msb) << 8) + (uint16_t)lsb)
-
-/* Internal functions declaration */
-static VL53L0_Error VL53L0_get_vcsel_pulse_period(VL53L0_DEV Dev,
-				uint8_t *pVCSELPulsePeriod, uint8_t RangeIndex);
-static uint8_t VL53L0_encode_vcsel_period(uint8_t vcsel_period_pclks);
-static uint8_t VL53L0_decode_vcsel_period(uint8_t vcsel_period_reg);
-static uint16_t VL53L0_calc_encoded_timeout(VL53L0_DEV Dev,
-			uint32_t timeout_period_us, uint8_t vcsel_period);
-static uint32_t VL53L0_calc_ranging_wait_us(VL53L0_DEV Dev,
-			uint16_t timeout_overall_periods, uint8_t vcsel_period);
-static VL53L0_Error VL53L0_load_additional_settings1(VL53L0_DEV Dev);
-static VL53L0_Error VL53L0_load_additional_settings3(VL53L0_DEV Dev);
-static VL53L0_Error VL53L0_check_part_used(VL53L0_DEV Dev,
-			uint8_t *Revision);
-static VL53L0_Error VL53L0_get_info_from_device(VL53L0_DEV Dev,
-				uint8_t *Revision);
-static VL53L0_Error VL53L0_get_pal_range_status(VL53L0_DEV Dev,
-				uint8_t DeviceRangeStatus,
-				FixPoint1616_t SignalRate,
-				FixPoint1616_t CrosstalkCompensation,
-				uint16_t EffectiveSpadRtnCount,
-				VL53L0_RangingMeasurementData_t
-					*pRangingMeasurementData,
-				uint8_t *pPalRangeStatus);
-
-/* Group PAL General Functions */
-VL53L0_Error VL53L0_GetVersion(VL53L0_Version_t *pVersion)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	pVersion->major = VL53L0_IMPLEMENTATION_VER_MAJOR;
-	pVersion->minor = VL53L0_IMPLEMENTATION_VER_MINOR;
-	pVersion->build = VL53L0_IMPLEMENTATION_VER_SUB;
-
-	pVersion->revision = VL53L0_IMPLEMENTATION_VER_REVISION;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetPalSpecVersion(VL53L0_Version_t *pPalSpecVersion)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	pPalSpecVersion->major = VL53L0_SPECIFICATION_VER_MAJOR;
-	pPalSpecVersion->minor = VL53L0_SPECIFICATION_VER_MINOR;
-	pPalSpecVersion->build = VL53L0_SPECIFICATION_VER_SUB;
-
-	pPalSpecVersion->revision = VL53L0_SPECIFICATION_VER_REVISION;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetDeviceInfo(VL53L0_DEV Dev,
-				VL53L0_DeviceInfo_t *pVL53L0_DeviceInfo)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t model_id;
-	uint8_t Revision;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_check_part_used(Dev, &Revision);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (Revision == 0) {
-			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
-				VL53L0_STRING_DEVICE_INFO_NAME_TS0);
-		} else if ((Revision <= 34) && (Revision != 32)) {
-			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
-				VL53L0_STRING_DEVICE_INFO_NAME_TS1);
-		} else if (Revision < 39) {
-			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
-				VL53L0_STRING_DEVICE_INFO_NAME_TS2);
-		} else {
-			VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
-				VL53L0_STRING_DEVICE_INFO_NAME_ES1);
-		}
-
-		VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Type,
-			VL53L0_STRING_DEVICE_INFO_TYPE);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODEL_ID,
-					&pVL53L0_DeviceInfo->ProductType);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODEL_ID,
-					&model_id);
-		pVL53L0_DeviceInfo->ProductRevisionMajor =
-			(model_id & 0xE0) >> 5;
-		pVL53L0_DeviceInfo->ProductRevisionMinor =
-			(model_id + 9) & 0x1F;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetDeviceErrorStatus(VL53L0_DEV Dev,
-				VL53L0_DeviceError *pDeviceErrorStatus)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t RangeStatus;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_RANGE_STATUS,
-		&RangeStatus);
-
-	*pDeviceErrorStatus = (VL53L0_DeviceError)((RangeStatus & 0x78) >> 3);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-#define VL53L0_BUILDSTATUSERRORSTRING(BUFFER, ERRORCODE, STRINGVALUE) \
-		do { \
-			case ERRORCODE: \
-				VL53L0_COPYSTRING(BUFFER, STRINGVALUE);\
-				break;\
-		} while (0)
-
-VL53L0_Error VL53L0_GetDeviceErrorString(VL53L0_DeviceError ErrorCode,
-				char *pDeviceErrorString)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	switch (ErrorCode) {
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_NONE,
-			VL53L0_STRING_DEVICEERROR_NONE);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_VCSELCONTINUITYTESTFAILURE,
-			VL53L0_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_VCSELWATCHDOGTESTFAILURE,
-			VL53L0_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_NOVHVVALUEFOUND,
-			VL53L0_STRING_DEVICEERROR_NOVHVVALUEFOUND);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_MSRCNOTARGET,
-			VL53L0_STRING_DEVICEERROR_MSRCNOTARGET);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_MSRCMINIMUMSNR,
-			VL53L0_STRING_DEVICEERROR_MSRCMINIMUMSNR);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_MSRCWRAPAROUND,
-			VL53L0_STRING_DEVICEERROR_MSRCWRAPAROUND);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_TCC, VL53L0_STRING_DEVICEERROR_TCC);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_RANGEAWRAPAROUND,
-			VL53L0_STRING_DEVICEERROR_RANGEAWRAPAROUND);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_RANGEBWRAPAROUND,
-			VL53L0_STRING_DEVICEERROR_RANGEBWRAPAROUND);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_MINCLIP,
-			VL53L0_STRING_DEVICEERROR_MINCLIP);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_RANGECOMPLETE,
-			VL53L0_STRING_DEVICEERROR_RANGECOMPLETE);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_ALGOUNDERFLOW,
-			VL53L0_STRING_DEVICEERROR_ALGOUNDERFLOW);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_ALGOOVERFLOW,
-			VL53L0_STRING_DEVICEERROR_ALGOOVERFLOW);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_FINALSNRLIMIT,
-			VL53L0_STRING_DEVICEERROR_FINALSNRLIMIT);
-	VL53L0_BUILDSTATUSERRORSTRING(pDeviceErrorString,
-			VL53L0_DEVICEERROR_NOTARGETIGNORE,
-			VL53L0_STRING_DEVICEERROR_NOTARGETIGNORE);
-	default:
-		VL53L0_COPYSTRING(pDeviceErrorString,
-			VL53L0_STRING_UNKNOW_ERROR_CODE);
-
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetPalErrorString(VL53L0_Error PalErrorCode,
-				char *pPalErrorString)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	switch (PalErrorCode) {
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_NONE, VL53L0_STRING_ERROR_NONE);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_CALIBRATION_WARNING,
-			VL53L0_STRING_ERROR_CALIBRATION_WARNING);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_MIN_CLIPPED,
-			VL53L0_STRING_ERROR_MIN_CLIPPED);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_UNDEFINED, VL53L0_STRING_ERROR_UNDEFINED);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_INVALID_PARAMS,
-			VL53L0_STRING_ERROR_INVALID_PARAMS);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_NOT_SUPPORTED,
-			VL53L0_STRING_ERROR_NOT_SUPPORTED);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_RANGE_ERROR,
-			VL53L0_STRING_ERROR_RANGE_ERROR);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_TIME_OUT,
-			VL53L0_STRING_ERROR_TIME_OUT);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_MODE_NOT_SUPPORTED,
-			VL53L0_STRING_ERROR_MODE_NOT_SUPPORTED);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_NOT_IMPLEMENTED,
-			VL53L0_STRING_ERROR_NOT_IMPLEMENTED);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_BUFFER_TOO_SMALL,
-			VL53L0_STRING_ERROR_BUFFER_TOO_SMALL);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_GPIO_NOT_EXISTING,
-			VL53L0_STRING_ERROR_GPIO_NOT_EXISTING);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED,
-			VL53L0_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED);
-	VL53L0_BUILDSTATUSERRORSTRING(pPalErrorString,
-			VL53L0_ERROR_CONTROL_INTERFACE,
-			VL53L0_STRING_ERROR_CONTROL_INTERFACE);
-	default:
-		VL53L0_COPYSTRING(pPalErrorString,
-			VL53L0_STRING_UNKNOW_ERROR_CODE);
-		break;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-VL53L0_Error VL53L0_GetPalState(VL53L0_DEV Dev, VL53L0_State *pPalState)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	*pPalState = PALDevDataGet(Dev, PalState);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes PowerMode)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	/* Only level1 of Power mode exists */
-	if ((PowerMode != VL53L0_POWERMODE_STANDBY_LEVEL1) &&
-		(PowerMode != VL53L0_POWERMODE_IDLE_LEVEL1)) {
-		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
-	} else if (PowerMode == VL53L0_POWERMODE_STANDBY_LEVEL1) {
-		/* set the standby level1 of power mode */
-		Status = VL53L0_WrByte(Dev, 0x80, 0x00);
-		if (Status == VL53L0_ERROR_NONE) {
-			/* Set PAL State to standby */
-			PALDevDataSet(Dev, PalState, VL53L0_STATE_STANDBY);
-			PALDevDataSet(Dev, PowerMode,
-				VL53L0_POWERMODE_STANDBY_LEVEL1);
-		}
-
-	} else {
-		/* VL53L0_POWERMODE_IDLE_LEVEL1 */
-		Status = VL53L0_WrByte(Dev, 0x80, 0x01);
-		if (Status == VL53L0_ERROR_NONE)
-			Status = VL53L0_StaticInit(Dev);
-		if (Status == VL53L0_ERROR_NONE)
-			PALDevDataSet(Dev, PowerMode,
-				VL53L0_POWERMODE_IDLE_LEVEL1);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes *pPowerMode)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	/* Only level1 of Power mode exists */
-	Status = VL53L0_RdByte(Dev, 0x80, &Byte);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (Byte == 1)
-			PALDevDataSet(Dev, PowerMode,
-				VL53L0_POWERMODE_IDLE_LEVEL1);
-		else
-		    PALDevDataSet(Dev, PowerMode,
-				VL53L0_POWERMODE_STANDBY_LEVEL1);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
-				int32_t OffsetCalibrationDataMicroMeter)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t OffsetCalibrationData;
-
-	LOG_FUNCTION_START("");
-
-	OffsetCalibrationData = (uint8_t) (OffsetCalibrationDataMicroMeter
-							/ 1000);
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET,
-				*(uint8_t *) &OffsetCalibrationData);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
-				int32_t *pOffsetCalibrationDataMicroMeter)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t RangeOffsetRegister;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET,
-				&RangeOffsetRegister);
-	if (Status == VL53L0_ERROR_NONE) {
-		*pOffsetCalibrationDataMicroMeter =
-				(*((int8_t *) (&RangeOffsetRegister))) * 1000;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetGroupParamHold(VL53L0_DEV Dev, uint8_t GroupParamHold)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	/* not implemented on VL53L0 */
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetUpperLimitMilliMeter(VL53L0_DEV Dev,
-				uint16_t *pUpperLimitMilliMeter)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	/* not implemented on VL53L0 */
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-/* End Group PAL General Functions */
-
-/* Group PAL Init Functions */
-VL53L0_Error VL53L0_SetDeviceAddress(VL53L0_DEV Dev, uint8_t DeviceAddress)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_I2C_SLAVE_DEVICE_ADDRESS,
-				DeviceAddress / 2);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_DataInit(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-	int32_t OffsetCalibrationData;
-
-	LOG_FUNCTION_START("");
-
-	/* Set Default static parameters */
-	/* set first temporary values 11.3999MHz * 65536 = 748421 */
-	VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 748421);
-	/* 11.3999MHz * 65536 = 748421 */
-
-	/* Get default parameters */
-	Status = VL53L0_GetDeviceParameters(Dev, &CurrentParameters);
-	if (Status == VL53L0_ERROR_NONE) {
-		/* initialize PAL values */
-		CurrentParameters.DeviceMode = VL53L0_DEVICEMODE_SINGLE_RANGING;
-		CurrentParameters.HistogramMode = VL53L0_HISTOGRAMMODE_DISABLED;
-		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
-	}
-
-	/* Sigma estimator variable */
-	PALDevDataSet(Dev, SigmaEstRefArray, 100);
-	PALDevDataSet(Dev, SigmaEstEffPulseWidth, 900);
-	PALDevDataSet(Dev, SigmaEstEffAmbWidth, 500);
-
-	/* Set Signal and Sigma check */
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_SetSigmaLimitCheckEnable(Dev, 0, 1);
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_SetSignalLimitCheckEnable(Dev, 0, 1);
-
-
-	if (Status == VL53L0_ERROR_NONE)
-		VL53L0_SetSigmaLimitValue(Dev, 0, (FixPoint1616_t)(32<<16));
-
-	if (Status == VL53L0_ERROR_NONE)
-		VL53L0_SetSignalLimitValue(Dev, 0,
-			(FixPoint1616_t)(25 * 65536 / 100));
-			/* 0.25 * 65538 */
-
-	/* Read back NVM offset */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetOffsetCalibrationDataMicroMeter(Dev,
-			&OffsetCalibrationData);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		PALDevDataSet(Dev, Part2PartOffsetNVMMicroMeter,
-			OffsetCalibrationData);
-
-		PALDevDataSet(Dev, SequenceConfig, 0xFF);
-
-		/* Set PAL state to tell that we are waiting for call
-		to VL53L0_StaticInit */
-		PALDevDataSet(Dev, PalState, VL53L0_STATE_WAIT_STATICINIT);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-VL53L0_Error VL53L0_StaticInit(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint16_t TempWord;
-	uint8_t TempByte;
-	uint8_t localBuffer[32];
-	uint8_t i;
-	uint8_t Revision;
-
-	LOG_FUNCTION_START("");
-
-    /* Set I2C standard mode */
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_WrByte(Dev, 0x88, 0x00);
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_check_part_used(Dev, &Revision);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (Revision == 0)
-			Status = VL53L0_load_additional_settings1(Dev);
-	}
-
-    /* update13_05_15 */
-	if (Status == VL53L0_ERROR_NONE) {
-		if ((Revision <= 34) && (Revision != 32)) {
-
-			for (i = 0; i < 32; i++)
-				localBuffer[i] = 0xff;
-
-			Status = VL53L0_WriteMulti(Dev, 0x90, localBuffer, 32);
-
-			Status |= VL53L0_WrByte(Dev, 0xb6, 16);
-			Status |= VL53L0_WrByte(Dev, 0xb0, 0x0);
-			Status |= VL53L0_WrByte(Dev, 0xb1, 0x0);
-			Status |= VL53L0_WrByte(Dev, 0xb2, 0xE0);
-			Status |= VL53L0_WrByte(Dev, 0xb3, 0xE0);
-			Status |= VL53L0_WrByte(Dev, 0xb4, 0xE0);
-			Status |= VL53L0_WrByte(Dev, 0xb5, 0xE0);
-		}
-	}
-
-    /* update 17_06_15_v10 */
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_load_tuning_settings(Dev);
-
-    /* check if GO1 power is ON after load default tuning */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev, 0x80, &TempByte);
-		if ((TempByte != 0) && (Status == VL53L0_ERROR_NONE)) {
-			/* update 07_05_15 */
-			Status = VL53L0_load_additional_settings3(Dev);
-		}
-	}
-
-    /* Set interrupt config to new sample ready */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetGpioConfig(Dev, 0, 0,
-			VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY,
-			VL53L0_INTERRUPTPOLARITY_LOW);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
-		Status |= VL53L0_RdWord(Dev, 0x84, &TempWord);
-		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz,
-			VL53L0_FIXPOINT412TOFIXPOINT1616(TempWord));
-	}
-
-	/* After static init, some device parameters may be changed,
-	so update them */
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_GetDeviceParameters(Dev, &CurrentParameters);
-
-	if (Status == VL53L0_ERROR_NONE)
-		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
-
-
-	/* read the sequence config and save it */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG,
-					&TempByte);
-		if (Status == VL53L0_ERROR_NONE)
-			PALDevDataSet(Dev, SequenceConfig, TempByte);
-
-	}
-
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_PerformRefCalibration(Dev);
-
-	/* Set PAL State to standby */
-	if (Status == VL53L0_ERROR_NONE)
-		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_WaitDeviceBooted(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	/* not implemented on VL53L0 */
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_ResetDevice(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	/* Set reset bit */
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N,
-				0x00);
-
-	/* Wait for some time */
-	if (Status == VL53L0_ERROR_NONE) {
-		do {
-			Status = VL53L0_RdByte(Dev,
-				VL53L0_REG_IDENTIFICATION_MODEL_ID,	&Byte);
-		} while (Byte != 0x00);
-	}
-
-	/* Release reset */
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N,
-		0x01);
-
-	/* Wait until correct boot-up of the device */
-	if (Status == VL53L0_ERROR_NONE) {
-		do {
-			Status = VL53L0_RdByte(Dev,
-				VL53L0_REG_IDENTIFICATION_MODEL_ID,	&Byte);
-		} while (Byte == 0x00);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-/* End Group PAL Init Functions */
-
-/* Group PAL Parameters Functions */
-VL53L0_Error VL53L0_SetDeviceParameters(VL53L0_DEV Dev,
-	const VL53L0_DeviceParameters_t*
-	pDeviceParameters)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	int i;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_SetDeviceMode(Dev, pDeviceParameters->DeviceMode);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetHistogramMode(Dev,
-			pDeviceParameters->HistogramMode);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetInterMeasurementPeriodMilliSeconds(Dev,
-
-			pDeviceParameters->InterMeasurementPeriodMilliSeconds);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetXTalkCompensationEnable(Dev,
-
-			pDeviceParameters->XTalkCompensationEnable);
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetXTalkCompensationRateMegaCps(Dev,
-
-			pDeviceParameters->XTalkCompensationRateMegaCps);
-	}
-
-	for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_SetSignalLimitCheckEnable(Dev,
-				(VL53L0_CheckPosition) i,
-
-				pDeviceParameters->SignalLimitCheckEnable[i]);
-		}
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_SetSignalLimitValue(Dev,
-				(VL53L0_CheckPosition) i,
-				pDeviceParameters->SignalLimitValue[i]);
-		}
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_SetSigmaLimitCheckEnable(Dev,
-				(VL53L0_CheckPosition) i,
-
-				pDeviceParameters->SigmaLimitCheckEnable[i]);
-		}
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_SetSigmaLimitValue(Dev,
-				(VL53L0_CheckPosition) i,
-
-				pDeviceParameters->SigmaLimitValue[i]);
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetWrapAroundCheckEnable(Dev,
-
-			pDeviceParameters->WrapAroundCheckEnable);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_SetMeasurementTimingBudgetMicroSeconds(Dev,
-
-			pDeviceParameters->MeasurementTimingBudgetMicroSeconds);
-	}
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetDeviceParameters(VL53L0_DEV Dev,
-				VL53L0_DeviceParameters_t *pDeviceParameters)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	int i;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_GetDeviceMode(Dev, &(pDeviceParameters->DeviceMode));
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetHistogramMode(Dev,
-			&(pDeviceParameters->HistogramMode));
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetInterMeasurementPeriodMilliSeconds(Dev,
-		&(pDeviceParameters->InterMeasurementPeriodMilliSeconds));
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetXTalkCompensationEnable(Dev,
-		&(pDeviceParameters->XTalkCompensationEnable));
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetXTalkCompensationRateMegaCps(Dev,
-
-			&(pDeviceParameters->XTalkCompensationRateMegaCps));
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
-			if (Status == VL53L0_ERROR_NONE) {
-				Status |= VL53L0_GetSignalLimitCheckEnable(Dev,
-				(VL53L0_CheckPosition)
-				i,
-				&(pDeviceParameters->SignalLimitCheckEnable[i]
-				));
-			}
-			if (Status == VL53L0_ERROR_NONE) {
-				Status |= VL53L0_GetSignalLimitValue(Dev,
-				(VL53L0_CheckPosition)
-				i,
-				&(pDeviceParameters->SignalLimitValue[i]));
-			}
-			if (Status == VL53L0_ERROR_NONE) {
-				Status |= VL53L0_GetSigmaLimitCheckEnable(Dev,
-				(VL53L0_CheckPosition)
-				i,
-				&(pDeviceParameters->SigmaLimitCheckEnable[i]));
-			}
-			if (Status == VL53L0_ERROR_NONE) {
-				Status |= VL53L0_GetSigmaLimitValue(Dev,
-				(VL53L0_CheckPosition)
-				i,
-				&(pDeviceParameters->SigmaLimitValue[i]));
-			}
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetWrapAroundCheckEnable(Dev,
-			&(pDeviceParameters->WrapAroundCheckEnable));
-	}
-
-    /* Need to be done at the end as it uses VCSELPulsePeriod */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetMeasurementTimingBudgetMicroSeconds(Dev,
-		&(pDeviceParameters->MeasurementTimingBudgetMicroSeconds));
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetDeviceMode(VL53L0_DEV Dev,
-				VL53L0_DeviceModes DeviceMode)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("%d", (int)DeviceMode);
-
-	switch (DeviceMode) {
-	case VL53L0_DEVICEMODE_SINGLE_RANGING:
-	case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
-	case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
-	case VL53L0_DEVICEMODE_SINGLE_HISTOGRAM:
-	case VL53L0_DEVICEMODE_GPIO_DRIVE:
-	case VL53L0_DEVICEMODE_GPIO_OSC:
-		/* Supported mode */
-		VL53L0_SETPARAMETERFIELD(Dev, DeviceMode, DeviceMode);
-		break;
-	default:
-		/* Unsupported mode */
-		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetDeviceMode(VL53L0_DEV Dev,
-				VL53L0_DeviceModes *pDeviceMode)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	VL53L0_GETPARAMETERFIELD(Dev, DeviceMode, *pDeviceMode);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetHistogramMode(VL53L0_DEV Dev,
-				VL53L0_HistogramModes HistogramMode)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("%d", (int)HistogramMode);
-
-	switch (HistogramMode) {
-	case VL53L0_HISTOGRAMMODE_DISABLED:
-		/* Supported mode */
-		VL53L0_SETPARAMETERFIELD(Dev, HistogramMode,
-			HistogramMode);
-		break;
-	case VL53L0_HISTOGRAMMODE_REFERENCE_ONLY:
-	case VL53L0_HISTOGRAMMODE_RETURN_ONLY:
-	case VL53L0_HISTOGRAMMODE_BOTH:
-	default:
-		/* Unsupported mode */
-		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetHistogramMode(VL53L0_DEV Dev,
-				VL53L0_HistogramModes *pHistogramMode)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	VL53L0_GETPARAMETERFIELD(Dev, HistogramMode, *pHistogramMode);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
-				uint32_t MeasurementTimingBudgetMicroSeconds)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-	uint8_t CurrentVCSELPulsePeriod;
-	uint8_t CurrentVCSELPulsePeriodPClk;
-	uint8_t Byte;
-	uint32_t NewTimingBudgetMicroSeconds;
-	uint16_t encodedTimeOut;
-
-	LOG_FUNCTION_START("");
-
-	/* check if rangeB is done: */
-	Status = VL53L0_GetWrapAroundCheckEnable(Dev, &Byte);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (((Byte == 1) && (MeasurementTimingBudgetMicroSeconds <
-17000)) ||
-			((Byte == 0) && (MeasurementTimingBudgetMicroSeconds <
-12000))) {
-			Status = VL53L0_ERROR_INVALID_PARAMS;
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		NewTimingBudgetMicroSeconds =
-MeasurementTimingBudgetMicroSeconds -
-								7000;
-		if (Byte == 1) {
-			NewTimingBudgetMicroSeconds =
-				(uint32_t)(NewTimingBudgetMicroSeconds >> 1);
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_get_vcsel_pulse_period(Dev,
-			&CurrentVCSELPulsePeriodPClk, 0);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
-			CurrentVCSELPulsePeriodPClk);
-		encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
-			NewTimingBudgetMicroSeconds,
-			(uint8_t)
-			CurrentVCSELPulsePeriod);
-		VL53L0_SETPARAMETERFIELD(Dev,
-MeasurementTimingBudgetMicroSeconds,
-			MeasurementTimingBudgetMicroSeconds);
-		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, LastEncodedTimeout,
-			encodedTimeOut);
-	}
-
-	/* Program in register */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_WrWord(Dev, VL53L0_REG_RNGA_TIMEOUT_MSB,
-			encodedTimeOut);
-	}
-
-	/* Temp: program same value for rangeB1 and rangeB2 */
-	/* Range B1 */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_get_vcsel_pulse_period(Dev,
-			&CurrentVCSELPulsePeriodPClk, 1);
-		if (Status == VL53L0_ERROR_NONE) {
-			CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
-				CurrentVCSELPulsePeriodPClk);
-			encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
-				NewTimingBudgetMicroSeconds,
-				(uint8_t)
-				CurrentVCSELPulsePeriod);
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_WrWord(Dev, VL53L0_REG_RNGB1_TIMEOUT_MSB,
-			encodedTimeOut);
-	}
-
-	/* Range B2 */
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_get_vcsel_pulse_period(Dev,
-			&CurrentVCSELPulsePeriodPClk, 2);
-		if (Status == VL53L0_ERROR_NONE) {
-			CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
-				CurrentVCSELPulsePeriodPClk);
-			encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
-				NewTimingBudgetMicroSeconds,
-				(uint8_t)
-				CurrentVCSELPulsePeriod);
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_WrWord(Dev, VL53L0_REG_RNGB2_TIMEOUT_MSB,
-			encodedTimeOut);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
-				uint32_t *pMeasurementTimingBudgetMicroSeconds)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t CurrentVCSELPulsePeriod;
-	uint8_t CurrentVCSELPulsePeriodPClk;
-	uint16_t encodedTimeOut;
-	uint32_t RangATimingBudgetMicroSeconds;
-	uint32_t RangBTimingBudgetMicroSeconds;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	/* check if rangeB is done: */
-	Status = VL53L0_GetWrapAroundCheckEnable(Dev, &Byte);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_get_vcsel_pulse_period(Dev,
-		&CurrentVCSELPulsePeriodPClk, 0);
-		CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
-			CurrentVCSELPulsePeriodPClk);
-
-		/* Read from register */
-		Status = VL53L0_RdWord(Dev, VL53L0_REG_RNGA_TIMEOUT_MSB,
-			&encodedTimeOut);
-		if (Status == VL53L0_ERROR_NONE) {
-			RangATimingBudgetMicroSeconds =
-			VL53L0_calc_ranging_wait_us(Dev,
-				encodedTimeOut,
-				CurrentVCSELPulsePeriod);
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (Byte == 0) {
-			*pMeasurementTimingBudgetMicroSeconds =
-				RangATimingBudgetMicroSeconds + 7000;
-			VL53L0_SETPARAMETERFIELD(Dev,
-			MeasurementTimingBudgetMicroSeconds,
-				*pMeasurementTimingBudgetMicroSeconds);
-		} else {
-			VL53L0_get_vcsel_pulse_period(Dev,
-			&CurrentVCSELPulsePeriodPClk, 1);
-			CurrentVCSELPulsePeriod = VL53L0_encode_vcsel_period(
-				CurrentVCSELPulsePeriodPClk);
-
-			/* Read from register */
-			Status = VL53L0_RdWord(Dev,
-			VL53L0_REG_RNGB1_TIMEOUT_MSB,
-						&encodedTimeOut);
-			if (Status == VL53L0_ERROR_NONE) {
-				RangBTimingBudgetMicroSeconds =
-				VL53L0_calc_ranging_wait_us(
-					Dev, encodedTimeOut,
-					CurrentVCSELPulsePeriod);
-			}
-
-			*pMeasurementTimingBudgetMicroSeconds =
-				RangATimingBudgetMicroSeconds +
-				RangBTimingBudgetMicroSeconds +
-				7000;
-			VL53L0_SETPARAMETERFIELD(Dev,
-			MeasurementTimingBudgetMicroSeconds,
-				*pMeasurementTimingBudgetMicroSeconds);
-		}
-	}
-
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
-				uint32_t InterMeasurementPeriodMilliSeconds)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint16_t osc_calibrate_val;
-	uint32_t IMPeriodMilliSeconds;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdWord(Dev, VL53L0_REG_OSC_CALIBRATE_VAL,
-		&osc_calibrate_val);
-
-	if (Status == VL53L0_ERROR_NONE) {
-
-		if (osc_calibrate_val != 0) {
-
-			IMPeriodMilliSeconds =
-			InterMeasurementPeriodMilliSeconds *
-				osc_calibrate_val;
-		} else {
-			IMPeriodMilliSeconds =
-			InterMeasurementPeriodMilliSeconds;
-		}
-		Status = VL53L0_WrDWord(Dev,
-		VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
-			IMPeriodMilliSeconds);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_SETPARAMETERFIELD(Dev,
-		InterMeasurementPeriodMilliSeconds,
-			InterMeasurementPeriodMilliSeconds);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
-				uint32_t *pInterMeasurementPeriodMilliSeconds)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint16_t osc_calibrate_val;
-	uint32_t IMPeriodMilliSeconds;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdWord(Dev, VL53L0_REG_OSC_CALIBRATE_VAL,
-				&osc_calibrate_val);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdDWord(Dev,
-		VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
-			&IMPeriodMilliSeconds);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (osc_calibrate_val != 0)
-			*pInterMeasurementPeriodMilliSeconds =
-				IMPeriodMilliSeconds /
-				osc_calibrate_val;
-
-		VL53L0_SETPARAMETERFIELD(Dev,
-		InterMeasurementPeriodMilliSeconds,
-			*pInterMeasurementPeriodMilliSeconds);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetXTalkCompensationEnable(VL53L0_DEV Dev,
-		uint8_t XTalkCompensationEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t XTalkCompensationEnableValue;
-
-	LOG_FUNCTION_START("");
-
-	if (XTalkCompensationEnable == 0) {
-		/* Disable the crosstalk compensation */
-		XTalkCompensationEnableValue = 0x00;
-	} else {
-		/* Enable the crosstalk compensation */
-		XTalkCompensationEnableValue = 0x01;
-	}
-	Status = VL53L0_UpdateByte(Dev, VL53L0_REG_ALGO_RANGE_CHECK_ENABLES,
-		0xFE,
-		XTalkCompensationEnableValue);
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
-			XTalkCompensationEnableValue);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetXTalkCompensationEnable(VL53L0_DEV Dev, uint8_t*
-	pXTalkCompensationEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t data;
-	uint8_t Temp;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_ALGO_RANGE_CHECK_ENABLES, &data);
-	if (Status == VL53L0_ERROR_NONE) {
-		if (data & 0x01)
-			Temp = 0x01;
-		else
-			Temp = 0x00;
-
-		*pXTalkCompensationEnable = Temp;
-	}
-	if (Status == VL53L0_ERROR_NONE)
-		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
-	FixPoint1616_t XTalkCompensationRateMegaCps)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_WrWord(Dev, VL53L0_REG_ALGO_CROSSTALK_COMPENSATION_RATE,
-		VL53L0_FIXPOINT1616TOFIXPOINT412(XTalkCompensationRateMegaCps));
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
-			XTalkCompensationRateMegaCps);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
-	FixPoint1616_t *pXTalkCompensationRateMegaCps)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint16_t Value;
-	FixPoint1616_t TempFix1616;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdWord(Dev, VL53L0_REG_ALGO_CROSSTALK_COMPENSATION_RATE,
-		(uint16_t *) &Value);
-	if (Status == VL53L0_ERROR_NONE) {
-		TempFix1616 = VL53L0_FIXPOINT412TOFIXPOINT1616(Value);
-		*pXTalkCompensationRateMegaCps = TempFix1616;
-		VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
-			TempFix1616);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-
-/*
- * SIGNAL LIMIT
- */
-VL53L0_Error VL53L0_SetSignalLimitCheckEnable(VL53L0_DEV Dev,
-	VL53L0_CheckPosition Position, uint8_t SignalLimitCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t i;
-
-	LOG_FUNCTION_START("");
-
-	/* In this function VL53L0_CheckPosition is ignored */
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
-			VL53L0_SETARRAYPARAMETERFIELD(Dev,
-				SignalLimitCheckEnable,
-				(VL53L0_CheckPosition) i,
-				SignalLimitCheckEnable);
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetSignalLimitCheckEnable(VL53L0_DEV Dev,
-	VL53L0_CheckPosition Position, uint8_t *pSignalLimitCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	/* In this function VL53L0_CheckPosition is ignored */
-
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS) {
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	} else {
-		VL53L0_GETARRAYPARAMETERFIELD(Dev, SignalLimitCheckEnable,
-			Position,
-			*pSignalLimitCheckEnable);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetSignalLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
-	Position, FixPoint1616_t SignalLimitValue)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t i;
-
-	LOG_FUNCTION_START("");
-
-	/* In this function VL53L0_CheckPosition is ignored, set is done on all
-	positions */
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
-			VL53L0_SETARRAYPARAMETERFIELD(Dev,
-				SignalLimitValue,
-				(VL53L0_CheckPosition) i,
-				SignalLimitValue);
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetSignalLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
-	Position, FixPoint1616_t *pSignalLimitValue)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	/* In this function VL53L0_CheckPosition is ignored */
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_GETARRAYPARAMETERFIELD(Dev, SignalLimitValue, Position,
-			*pSignalLimitValue);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/*
- * SIGMA LIMIT
- */
-VL53L0_Error VL53L0_SetSigmaLimitCheckEnable(VL53L0_DEV Dev,
-	VL53L0_CheckPosition Position, uint8_t SigmaLimitCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t i;
-
-	LOG_FUNCTION_START("");
-
-	/* In this function VL53L0_CheckPosition is ignored, set is done on all
-	positions */
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
-			VL53L0_SETARRAYPARAMETERFIELD(Dev,
-				SigmaLimitCheckEnable,
-				(VL53L0_CheckPosition) i,
-				SigmaLimitCheckEnable);
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetSigmaLimitCheckEnable(VL53L0_DEV Dev,
-	VL53L0_CheckPosition Position, uint8_t *pSigmaLimitCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS) {
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	} else {
-		VL53L0_GETARRAYPARAMETERFIELD(Dev, SigmaLimitCheckEnable,
-			Position,
-			*pSigmaLimitCheckEnable);
-	}
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetSigmaLimitValue(VL53L0_DEV Dev, VL53L0_CheckPosition
-	Position, FixPoint1616_t SigmaLimitValue)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	uint8_t i;
-
-	LOG_FUNCTION_START("");
-
-	/* In this function VL53L0_CheckPosition is ignored, set is done on all
-	positions */
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		for (i = 0; i < VL53L0_CHECKPOSITION_NO_OF_CHECKS; i++) {
-			VL53L0_SETARRAYPARAMETERFIELD(Dev, SigmaLimitValue,
-				(VL53L0_CheckPosition) i, SigmaLimitValue);
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetSigmaLimitValue(VL53L0_DEV Dev,
-	VL53L0_CheckPosition Position,
-	FixPoint1616_t *pSigmaLimitValue)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	if (Position >= VL53L0_CHECKPOSITION_NO_OF_CHECKS)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_GETARRAYPARAMETERFIELD(Dev,
-			SigmaLimitValue, Position,
-			*pSigmaLimitValue);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-
-/*
- * CHECK LIMIT FUNCTIONS
- */
-
-VL53L0_Error VL53L0_GetNumberOfLimitCheck(uint16_t *pNumberOfLimitCheck)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	*pNumberOfLimitCheck = VL53L0_CHECKENABLE_NUMBER_OF_CHECKS;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-#define VL53L0_BUILDCASESTRING(BUFFER, CODE, STRINGVALUE) \
-	do { \
-		case CODE: \
-			VL53L0_COPYSTRING(BUFFER, STRINGVALUE); \
-			break; \
-	} while (0)
-
-VL53L0_Error VL53L0_GetLimitCheckInfo(VL53L0_DEV Dev, uint16_t LimitCheckId,
-	char *pLimitCheckString)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	switch (LimitCheckId) {
-	VL53L0_BUILDCASESTRING(pLimitCheckString,
-			VL53L0_CHECKENABLE_SIGMA,
-			VL53L0_STRING_CHECKENABLE_SIGMA);
-	VL53L0_BUILDCASESTRING(pLimitCheckString,
-			VL53L0_CHECKENABLE_SIGNAL_RATE,
-			VL53L0_STRING_CHECKENABLE_SIGNAL_RATE);
-
-	default:
-		VL53L0_COPYSTRING(pLimitCheckString,
-			VL53L0_STRING_UNKNOW_ERROR_CODE);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
-	uint8_t LimitCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	switch (LimitCheckId) {
-	case VL53L0_CHECKENABLE_SIGMA:
-		Status = VL53L0_SetSigmaLimitCheckEnable(Dev, 0,
-					LimitCheckEnable);
-		break;
-
-	case VL53L0_CHECKENABLE_SIGNAL_RATE:
-		Status = VL53L0_SetSignalLimitCheckEnable(Dev, 0,
-			LimitCheckEnable);
-		break;
-
-	default:
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-VL53L0_Error VL53L0_GetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
-	uint8_t *pLimitCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	switch (LimitCheckId) {
-	case VL53L0_CHECKENABLE_SIGMA:
-		Status = VL53L0_GetSigmaLimitCheckEnable(Dev, 0,
-					pLimitCheckEnable);
-		break;
-
-	case VL53L0_CHECKENABLE_SIGNAL_RATE:
-		Status = VL53L0_GetSignalLimitCheckEnable(Dev, 0,
-				pLimitCheckEnable);
-		break;
-
-	default:
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-
-VL53L0_Error VL53L0_SetLimitCheckValue(VL53L0_DEV Dev,
-		uint16_t LimitCheckId, FixPoint1616_t LimitCheckValue)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	switch (LimitCheckId) {
-	case VL53L0_CHECKENABLE_SIGMA:
-		Status = VL53L0_SetSigmaLimitValue(Dev, 0, LimitCheckValue);
-		break;
-
-	case VL53L0_CHECKENABLE_SIGNAL_RATE:
-		Status = VL53L0_SetSignalLimitValue(Dev, 0, LimitCheckValue);
-		break;
-
-	default:
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-VL53L0_Error VL53L0_GetLimitCheckValue(VL53L0_DEV Dev,
-		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckValue)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	if (LimitCheckId >= VL53L0_CHECKENABLE_NUMBER_OF_CHECKS) {
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	} else {
-		switch (LimitCheckId) {
-		case VL53L0_CHECKENABLE_SIGMA:
-			Status = VL53L0_GetSigmaLimitValue(Dev, 0,
-						pLimitCheckValue);
-			break;
-
-		case VL53L0_CHECKENABLE_SIGNAL_RATE:
-			Status = VL53L0_GetSignalLimitValue(Dev, 0,
-						pLimitCheckValue);
-			break;
-
-		default:
-			Status = VL53L0_ERROR_INVALID_PARAMS;
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-
-}
-
-
-VL53L0_Error VL53L0_GetLimitCheckCurrent(VL53L0_DEV Dev,
-		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckCurrent)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	if (LimitCheckId >= VL53L0_CHECKENABLE_NUMBER_OF_CHECKS) {
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-	} else {
-		switch (LimitCheckId) {
-		case VL53L0_CHECKENABLE_SIGMA:
-			/* Need to run a ranging to have the latest values */
-			*pLimitCheckCurrent = PALDevDataGet(Dev, SigmaEstimate);
-
-			break;
-
-		case VL53L0_CHECKENABLE_SIGNAL_RATE:
-			/* Need to run a ranging to have the latest values */
-			*pLimitCheckCurrent =
-				PALDevDataGet(Dev, SignalEstimate);
-
-			break;
-
-		default:
-			Status = VL53L0_ERROR_INVALID_PARAMS;
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-
-}
-
-
-
-
-/*
- * WRAPAROUND LIMIT
- */
-VL53L0_Error VL53L0_SetWrapAroundCheckEnable(VL53L0_DEV Dev, uint8_t
-	WrapAroundCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t Byte;
-	uint8_t WrapAroundCheckEnableInt;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &Byte);
-	if (WrapAroundCheckEnable == 0) {
-		/* Disable wraparound */
-		Byte = Byte & 0x7F;
-		WrapAroundCheckEnableInt = 0;
-	} else {
-		/* Enable wraparound */
-		Byte = Byte | 0x80;
-		WrapAroundCheckEnableInt = 1;
-	}
-
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, Byte);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		PALDevDataSet(Dev, SequenceConfig, Byte);
-		VL53L0_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
-			WrapAroundCheckEnableInt);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetWrapAroundCheckEnable(VL53L0_DEV Dev, uint8_t
-	*pWrapAroundCheckEnable)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t data;
-	VL53L0_DeviceParameters_t CurrentParameters;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &data);
-	if (Status == VL53L0_ERROR_NONE) {
-		PALDevDataSet(Dev, SequenceConfig, data);
-		if (data & (0x01 << 7))
-			*pWrapAroundCheckEnable = 0x01;
-		else
-			*pWrapAroundCheckEnable = 0x00;
-
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		VL53L0_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
-			*pWrapAroundCheckEnable);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/*  End Group PAL Parameters Functions */
-
-/* Group PAL Measurement Functions */
-VL53L0_Error VL53L0_PerformSingleMeasurement(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceModes DeviceMode;
-	uint8_t NewDatReady = 0;
-	uint32_t LoopNb;
-
-	LOG_FUNCTION_START("");
-
-	/* Get Current DeviceMode */
-	Status = VL53L0_GetDeviceMode(Dev, &DeviceMode);
-
-	/* Start immediately to run a single ranging measurement in case of
-	single ranging or single histogram */
-	if ((Status == VL53L0_ERROR_NONE) &&
-		((DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING) ||
-		(DeviceMode ==
-		VL53L0_DEVICEMODE_SINGLE_HISTOGRAM))) {
-		Status = VL53L0_StartMeasurement(Dev);
-	}
-
-	/* Wait until it finished
-	use timeout to avoid deadlock
-	*/
-	if (Status == VL53L0_ERROR_NONE) {
-		LoopNb = 0;
-		do {
-			Status = VL53L0_GetMeasurementDataReady(Dev,
-				&NewDatReady);
-			if ((NewDatReady == 0x01) || Status !=
-				VL53L0_ERROR_NONE) {
-				break;
-			}
-			LoopNb = LoopNb + 1;
-			VL53L0_PollingDelay(Dev);
-		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
-
-		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
-			Status = VL53L0_ERROR_TIME_OUT;
-
-	}
-
-	/* Change PAL State in case of single ranging or single histogram
-	*/
-	if ((Status == VL53L0_ERROR_NONE) &&
-		((DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING) ||
-			(DeviceMode ==
-			VL53L0_DEVICEMODE_SINGLE_HISTOGRAM))) {
-		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_PerformRefCalibration(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t NewDatReady = 0;
-	uint8_t Byte = 0;
-	uint8_t SequenceConfig = 0;
-	uint32_t LoopNb;
-
-	LOG_FUNCTION_START("");
-
-	/* store the value of the sequence config,
-	 * this will be reset before the end of the function
-	 */
-
-	SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
-
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, 0x03);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		PALDevDataSet(Dev, SequenceConfig, 0x03);
-		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
-			VL53L0_REG_SYSRANGE_MODE_START_STOP);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* Wait until start bit has been cleared */
-		LoopNb = 0;
-		do {
-			if (LoopNb > 0)
-				Status = VL53L0_RdByte(Dev,
-					VL53L0_REG_SYSRANGE_START, &Byte);
-			LoopNb = LoopNb + 1;
-		} while (((Byte & VL53L0_REG_SYSRANGE_MODE_START_STOP) ==
-			VL53L0_REG_SYSRANGE_MODE_START_STOP) &&
-			(Status == VL53L0_ERROR_NONE) &&
-			(LoopNb < VL53L0_DEFAULT_MAX_LOOP));
-	}
-
-	/* Wait until it finished
-	use timeout to avoid deadlock
-	*/
-	if (Status == VL53L0_ERROR_NONE) {
-		LoopNb = 0;
-		do {
-			Status = VL53L0_GetMeasurementDataReady(Dev,
-				&NewDatReady);
-			if ((NewDatReady == 0x01) || Status !=
-				VL53L0_ERROR_NONE) {
-				break;
-			}
-			LoopNb = LoopNb + 1;
-			VL53L0_PollingDelay(Dev);
-		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
-
-		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
-			Status = VL53L0_ERROR_TIME_OUT;
-
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
-		Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-
-		Status |= VL53L0_WrByte(Dev, 0xFF, 0x04);
-		Status |= VL53L0_RdByte(Dev, 0x30, &Byte);
-
-		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-		Status |= VL53L0_WrByte(Dev, 0x31, Byte);
-		Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-		Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
-		Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	}
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_ClearInterruptMask(Dev, 0);
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* restore the previous Sequence Config */
-		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG,
-			SequenceConfig);
-	}
-	if (Status == VL53L0_ERROR_NONE)
-		PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_API VL53L0_Error VL53L0_PerformXTalkCalibration(VL53L0_DEV Dev,
-	FixPoint1616_t XTalkCalDistance, FixPoint1616_t
-	*pXTalkCompensationRateMegaCps)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint16_t sum_ranging = 0;
-	uint16_t sum_spads = 0;
-	FixPoint1616_t sum_signalRate = 0;
-	FixPoint1616_t total_count = 0;
-	uint8_t xtalk_meas = 0;
-	VL53L0_RangingMeasurementData_t RangingMeasurementData;
-	FixPoint1616_t xTalkStoredMeanSignalRate;
-	FixPoint1616_t xTalkStoredMeanRange;
-	FixPoint1616_t xTalkStoredMeanRtnSpads;
-	uint32_t signalXTalkTotalPerSpad;
-	uint32_t xTalkStoredMeanRtnSpadsAsInt;
-	uint32_t xTalkCalDistanceAsInt;
-	FixPoint1616_t XTalkCompensationRateMegaCps;
-
-	LOG_FUNCTION_START("");
-
-	if (XTalkCalDistance <= 0)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	/* Disable the XTalk compensation */
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_SetXTalkCompensationEnable(Dev, 0);
-
-
-	/* Perform 50 measurements and compute the averages */
-	if (Status == VL53L0_ERROR_NONE) {
-		sum_ranging = 0;
-		sum_spads = 0;
-		sum_signalRate = 0;
-		total_count = 0;
-		for (xtalk_meas = 0; xtalk_meas < 50; xtalk_meas++) {
-			Status = VL53L0_PerformSingleRangingMeasurement(Dev,
-				&RangingMeasurementData);
-
-			if (Status != VL53L0_ERROR_NONE)
-				break;
-
-			/* The range is valid when RangeStatus = 0 */
-			if (RangingMeasurementData.RangeStatus == 0) {
-				sum_ranging = sum_ranging +
-				RangingMeasurementData.RangeMilliMeter;
-				sum_signalRate = sum_signalRate +
-				RangingMeasurementData.SignalRateRtnMegaCps;
-				sum_spads = sum_spads +
-				RangingMeasurementData.EffectiveSpadRtnCount
-					/ 32;
-				total_count = total_count + 1;
-			}
-		}
-
-		if (total_count == 0) {
-			/* no valid values found */
-			Status = VL53L0_ERROR_DIVISION_BY_ZERO;
-		}
-	}
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* FixPoint1616_t / uint16_t = FixPoint1616_t */
-		xTalkStoredMeanSignalRate = sum_signalRate / total_count;
-		xTalkStoredMeanRange =
-			(FixPoint1616_t)((uint32_t)(sum_ranging << 16) /
-			total_count);
-		xTalkStoredMeanRtnSpads =
-			(FixPoint1616_t)((uint32_t)(sum_spads<<16) /
-			total_count);
-
-		/* Round Mean Spads to Whole Number.
-		Typically the calculated mean SPAD count is a whole number or
-		very close to a whole
-		number, therefore any truncation will not result in a
-		significant	loss in accuracy.
-		Also, for a grey target at a typical distance of around 400mm,
-		around 220 SPADs will
-		be enabled, therefore, any truncation will result in a loss of
-		accuracy of less than 0.5%.
-		*/
-		xTalkStoredMeanRtnSpadsAsInt = (xTalkStoredMeanRtnSpads +
-			0x8000) >> 16;
-
-		/* Round Cal Distance to Whole Number.
-		Note that the cal distance is in mm, therefore no resolution is
-		lost.
-		*/
-		xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >> 16;
-
-		if (xTalkStoredMeanRtnSpadsAsInt == 0 || xTalkCalDistanceAsInt
-			== 0 ||
-			xTalkStoredMeanRange >= XTalkCalDistance) {
-			XTalkCompensationRateMegaCps = 0;
-		} else {
-			/* Round Cal Distance to Whole Number.
-			Note that the cal distance is in mm, therefore no
-			resolution is lost.
-			*/
-			xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >>
-				16;
-
-			/* Apply division by mean spad count early in the
-			calculation to keep the numbers small.
-			This ensures we can maintain a 32bit calculation.
-			Fixed1616 / int := Fixed1616
-			*/
-			signalXTalkTotalPerSpad =
-				(xTalkStoredMeanSignalRate) /
-				xTalkStoredMeanRtnSpadsAsInt;
-
-			/* Complete the calculation for total Signal XTalk per
-			SPAD Fixed1616 * (Fixed1616 - Fixed1616/int)
-			:= (2^16 * Fixed1616)
-			*/
-			signalXTalkTotalPerSpad *= ((1<<16) -
-				(xTalkStoredMeanRange/xTalkCalDistanceAsInt));
-
-			/* Round from 2^16 * Fixed1616, to Fixed1616. */
-			XTalkCompensationRateMegaCps = (signalXTalkTotalPerSpad
-				+ 0x8000) >> 16;
-		}
-
-		*pXTalkCompensationRateMegaCps = XTalkCompensationRateMegaCps;
-
-		/* Enable the XTalk compensation */
-		if (Status == VL53L0_ERROR_NONE)
-			Status = VL53L0_SetXTalkCompensationEnable(Dev, 1);
-
-
-		/* Enable the XTalk compensation */
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_SetXTalkCompensationRateMegaCps(Dev,
-				XTalkCompensationRateMegaCps);
-		}
-
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_StartMeasurement(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceModes DeviceMode;
-	uint8_t Byte = 0;
-	uint32_t LoopNb;
-
-	LOG_FUNCTION_START("");
-
-	/* Get Current DeviceMode */
-	VL53L0_GetDeviceMode(Dev, &DeviceMode);
-
-	switch (DeviceMode) {
-	case VL53L0_DEVICEMODE_SINGLE_RANGING:
-		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
-			VL53L0_REG_SYSRANGE_MODE_SINGLESHOT |
-			VL53L0_REG_SYSRANGE_MODE_START_STOP);
-		break;
-	case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
-		/* Back-to-back mode */
-		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
-			VL53L0_REG_SYSRANGE_MODE_BACKTOBACK |
-			VL53L0_REG_SYSRANGE_MODE_START_STOP);
-		if (Status == VL53L0_ERROR_NONE) {
-			/* Set PAL State to Running */
-			PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
-		}
-		break;
-	case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
-		/* Continuous mode */
-		Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
-			VL53L0_REG_SYSRANGE_MODE_TIMED |
-			VL53L0_REG_SYSRANGE_MODE_START_STOP);
-		if (Status == VL53L0_ERROR_NONE) {
-			/* Set PAL State to Running */
-			PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
-		}
-		break;
-	default:
-		/* Selected mode not supported */
-		Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* Wait until start bit has been cleared */
-		LoopNb = 0;
-		do {
-			if (LoopNb > 0)
-				Status = VL53L0_RdByte(Dev,
-					VL53L0_REG_SYSRANGE_START, &Byte);
-			LoopNb = LoopNb + 1;
-		} while (((Byte & VL53L0_REG_SYSRANGE_MODE_START_STOP) ==
-			VL53L0_REG_SYSRANGE_MODE_START_STOP) &&
-			(Status == VL53L0_ERROR_NONE) &&
-			(LoopNb < VL53L0_DEFAULT_MAX_LOOP));
-
-		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
-			Status = VL53L0_ERROR_TIME_OUT;
-
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_StopMeasurement(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
-		VL53L0_REG_SYSRANGE_MODE_SINGLESHOT);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* Set PAL State to Idle */
-		PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetMeasurementDataReady(VL53L0_DEV Dev, uint8_t
-	*pMeasurementDataReady)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t SysRangeStatusRegister;
-	uint8_t InterruptConfig;
-	uint32_t InterruptMask;
-
-	LOG_FUNCTION_START("");
-
-	InterruptConfig = VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
-		Pin0GpioFunctionality);
-
-	if (InterruptConfig ==
-	VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY) {
-		VL53L0_GetInterruptMaskStatus(Dev, &InterruptMask);
-		if (InterruptMask ==
-		VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY){
-			*pMeasurementDataReady = 1;
-		} else {
-			*pMeasurementDataReady = 0;
-		}
-	} else {
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_RANGE_STATUS,
-			&SysRangeStatusRegister);
-		if (Status == VL53L0_ERROR_NONE) {
-			if (SysRangeStatusRegister & 0x01)
-				*pMeasurementDataReady = 1;
-			else
-				*pMeasurementDataReady = 0;
-
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev, uint32_t
-	MaxLoop)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	/* not implemented for VL53L0 */
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetRangingMeasurementData(VL53L0_DEV Dev,
-	VL53L0_RangingMeasurementData_t *pRangingMeasurementData)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t DeviceRangeStatus;
-	uint8_t PalRangeStatus;
-	uint16_t AmbientRate;
-	FixPoint1616_t SignalRate;
-	FixPoint1616_t CrosstalkCompensation;
-	uint16_t EffectiveSpadRtnCount;
-	uint8_t localBuffer[14];
-	VL53L0_RangingMeasurementData_t LastRangeDataBuffer;
-
-	LOG_FUNCTION_START("");
-
-	/* use multi read even if some registers are not useful, result will be
-	more efficient
-	start reading at 0x14 dec20
-	end reading at 0x21 dec33 total 14 bytes to read
-	*/
-	Status = VL53L0_ReadMulti(Dev, 0x14, localBuffer, 14);
-
-	if (Status == VL53L0_ERROR_NONE) {
-
-		pRangingMeasurementData->ZoneId = 0; /* Only one zone */
-		pRangingMeasurementData->TimeStamp = 0; /* Not Implemented */
-
-		pRangingMeasurementData->RangeMilliMeter =
-			VL53L0_MAKEUINT16(localBuffer[11], localBuffer[10]);
-
-		pRangingMeasurementData->RangeDMaxMilliMeter = 0;
-		pRangingMeasurementData->RangeFractionalPart = 0;
-		pRangingMeasurementData->MeasurementTimeUsec = 0;
-
-		SignalRate =
-			VL53L0_FIXPOINT97TOFIXPOINT1616(
-			VL53L0_MAKEUINT16(localBuffer[7], localBuffer[6]));
-		pRangingMeasurementData->SignalRateRtnMegaCps = SignalRate;
-
-		AmbientRate = VL53L0_MAKEUINT16(localBuffer[9], localBuffer[8]);
-		pRangingMeasurementData->AmbientRateRtnMegaCps =
-			VL53L0_FIXPOINT97TOFIXPOINT1616(AmbientRate);
-
-		EffectiveSpadRtnCount = VL53L0_MAKEUINT16(localBuffer[3],
-			localBuffer[2]);
-		pRangingMeasurementData->EffectiveSpadRtnCount =
-			EffectiveSpadRtnCount;
-
-		DeviceRangeStatus = localBuffer[0];
-
-		/* initial format = 4.12, when pass to 16.16 from 9.7 we shift
-		5 bit more this will be absorbed in the further computation
-		*/
-		CrosstalkCompensation =
-			VL53L0_FIXPOINT97TOFIXPOINT1616(
-			VL53L0_MAKEUINT16(localBuffer[13], localBuffer[12]));
-
-		/*
-		 * For a standard definition of RangeStatus, this should return
-		 * 0 in case of good result after a ranging
-		 * The range status depends on the device so call a device
-		 * specific	function to obtain the right Status.
-		 */
-		Status = VL53L0_get_pal_range_status(Dev, DeviceRangeStatus,
-			SignalRate, CrosstalkCompensation,
-			EffectiveSpadRtnCount,
-			pRangingMeasurementData, &PalRangeStatus);
-
-		if (Status == VL53L0_ERROR_NONE)
-			pRangingMeasurementData->RangeStatus = PalRangeStatus;
-
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* Copy last read data into Dev buffer */
-		LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
-
-		LastRangeDataBuffer.RangeMilliMeter =
-			pRangingMeasurementData->RangeMilliMeter;
-		LastRangeDataBuffer.RangeFractionalPart =
-			pRangingMeasurementData->RangeFractionalPart;
-		LastRangeDataBuffer.RangeDMaxMilliMeter =
-			pRangingMeasurementData->RangeDMaxMilliMeter;
-		LastRangeDataBuffer.MeasurementTimeUsec =
-			pRangingMeasurementData->MeasurementTimeUsec;
-		LastRangeDataBuffer.SignalRateRtnMegaCps =
-			pRangingMeasurementData->SignalRateRtnMegaCps;
-		LastRangeDataBuffer.AmbientRateRtnMegaCps =
-			pRangingMeasurementData->AmbientRateRtnMegaCps;
-		LastRangeDataBuffer.EffectiveSpadRtnCount =
-			pRangingMeasurementData->EffectiveSpadRtnCount;
-		LastRangeDataBuffer.RangeStatus =
-			pRangingMeasurementData->RangeStatus;
-
-		PALDevDataSet(Dev, LastRangeMeasure, LastRangeDataBuffer);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetHistogramMeasurementData(VL53L0_DEV Dev,
-	VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-VL53L0_Error VL53L0_PerformSingleRangingMeasurement(VL53L0_DEV Dev,
-	VL53L0_RangingMeasurementData_t *pRangingMeasurementData)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	/*	This function will do a complete single ranging
-	*	Here we fix the mode!
-	*/
-	Status = VL53L0_SetDeviceMode(Dev, VL53L0_DEVICEMODE_SINGLE_RANGING);
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_PerformSingleMeasurement(Dev);
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_GetRangingMeasurementData(Dev,
-			pRangingMeasurementData);
-	}
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_ClearInterruptMask(Dev, 0);
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-VL53L0_Error VL53L0_PerformSingleHistogramMeasurement(VL53L0_DEV Dev,
-	VL53L0_HistogramMeasurementData_t *pHistogramMeasurementData)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetNumberOfROIZones(VL53L0_DEV Dev, uint8_t
-	NumberOfROIZones)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	if (NumberOfROIZones != 1)
-		Status = VL53L0_ERROR_INVALID_PARAMS;
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetNumberOfROIZones(VL53L0_DEV Dev, uint8_t*
-	pNumberOfROIZones)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	*pNumberOfROIZones = 1;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetMaxNumberOfROIZones(VL53L0_DEV Dev, uint8_t
-	*pMaxNumberOfROIZones)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	*pMaxNumberOfROIZones = 1;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/* End Group PAL Measurement Functions */
-
-
-VL53L0_Error VL53L0_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
-	VL53L0_DeviceModes DeviceMode, VL53L0_GpioFunctionality Functionality,
-	VL53L0_InterruptPolarity Polarity)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-	uint8_t data;
-
-	LOG_FUNCTION_START("");
-
-	if (Pin != 0) {
-		Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
-	} else if (DeviceMode == VL53L0_DEVICEMODE_GPIO_DRIVE) {
-		if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW)
-			data = 0x10;
-		else
-			data = 1;
-
-		Status = VL53L0_WrByte(Dev,
-			VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH, data);
-
-	} else if (DeviceMode == VL53L0_DEVICEMODE_GPIO_OSC) {
-
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
-		Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
-		Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
-		Status |= VL53L0_WrByte(Dev, 0x85, 0x02);
-
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x04);
-		Status |= VL53L0_WrByte(Dev, 0xcd, 0x00);
-		Status |= VL53L0_WrByte(Dev, 0xcc, 0x11);
-
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x07);
-		Status |= VL53L0_WrByte(Dev, 0xbe, 0x00);
-
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x06);
-		Status |= VL53L0_WrByte(Dev, 0xcc, 0x09);
-
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
-		Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
-		Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-
-	} else {
-
-		if (Status == VL53L0_ERROR_NONE) {
-			switch (Functionality) {
-			case VL53L0_GPIOFUNCTIONALITY_OFF:
-				data = 0x00;
-				break;
-			case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW:
-				data = 0x01;
-				break;
-			case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH:
-				data = 0x02;
-				break;
-			case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT:
-				data = 0x03;
-				break;
-			case VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY:
-				data = 0x04;
-				break;
-			default:
-				Status =
-				VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
-			}
-		}
-
-
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_WrByte(Dev,
-				VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,
-				data);
-		}
-
-		if (Status == VL53L0_ERROR_NONE) {
-			if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW)
-				data = 0;
-			else
-				data = (uint8_t)(1<<4);
-
-			Status = VL53L0_UpdateByte(Dev,
-				VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH,
-				0xEF, data);
-		}
-
-		if (Status == VL53L0_ERROR_NONE) {
-			VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
-				Pin0GpioFunctionality,
-				Functionality);
-		}
-
-		if (Status == VL53L0_ERROR_NONE)
-			Status = VL53L0_ClearInterruptMask(Dev, 0);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
-	VL53L0_DeviceModes *DeviceMode,
-	VL53L0_GpioFunctionality *pFunctionality,
-	VL53L0_InterruptPolarity *pPolarity)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-	VL53L0_GpioFunctionality GpioFunctionality;
-	uint8_t data;
-
-	LOG_FUNCTION_START("");
-
-	if (Pin != 0) {
-		Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
-	} else {
-		Status = VL53L0_RdByte(Dev,
-			VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO,
-			&data);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		switch (data&0x07) {
-		case 0x00:
-		    GpioFunctionality = VL53L0_GPIOFUNCTIONALITY_OFF;
-		    break;
-		case 0x01:
-			GpioFunctionality =
-				VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW;
-		    break;
-		case 0x02:
-			GpioFunctionality =
-				VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH;
-		    break;
-		case 0x03:
-			GpioFunctionality =
-				VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT;
-		    break;
-		case 0x04:
-		    GpioFunctionality =
-				VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY;
-		    break;
-		default:
-		    Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_RdByte(Dev,
-				VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH, &data);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if ((data & (uint8_t)(1<<4)) == 0)
-			*pPolarity = VL53L0_INTERRUPTPOLARITY_LOW;
-		else
-			*pPolarity = VL53L0_INTERRUPTPOLARITY_HIGH;
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		*pFunctionality = GpioFunctionality;
-		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality,
-			GpioFunctionality);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetInterruptThresholds(VL53L0_DEV Dev, VL53L0_DeviceModes
-	DeviceMode, FixPoint1616_t ThresholdLow, FixPoint1616_t ThresholdHigh)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint16_t Threshold16;
-
-	LOG_FUNCTION_START("");
-
-	/* no dependency on DeviceMode for Ewok */
-    /* Need to divide by 2 because the FW will apply a x2 */
-	Threshold16 = (uint16_t)((ThresholdLow >> 17) & 0x00fff);
-	Status = VL53L0_WrWord(Dev, VL53L0_REG_SYSTEM_THRESH_LOW, Threshold16);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		/* Need to divide by 2 because the FW will apply a x2 */
-		Threshold16 = (uint16_t)((ThresholdHigh >> 17) & 0x00fff);
-		Status = VL53L0_WrWord(Dev, VL53L0_REG_SYSTEM_THRESH_HIGH,
-			Threshold16);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetInterruptThresholds(VL53L0_DEV Dev, VL53L0_DeviceModes
-	DeviceMode, FixPoint1616_t *pThresholdLow,
-	FixPoint1616_t *pThresholdHigh)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint16_t Threshold16;
-
-	LOG_FUNCTION_START("");
-
-	/* no dependency on DeviceMode for Ewok */
-
-	Status = VL53L0_RdWord(Dev, VL53L0_REG_SYSTEM_THRESH_LOW, &Threshold16);
-    /* Need to multiply by 2 because the FW will apply a x2 */
-	*pThresholdLow = (FixPoint1616_t)((0x00fff & Threshold16)<<17);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdWord(Dev, VL53L0_REG_SYSTEM_THRESH_HIGH,
-			&Threshold16);
-       /* Need to multiply by 2 because the FW will apply a x2 */
-		*pThresholdHigh = (FixPoint1616_t)((0x00fff & Threshold16)<<17);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/* Group PAL Interrupt Functions */
-VL53L0_Error VL53L0_ClearInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t LoopCount;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	/* clear bit 0 range interrupt, bit 1 error interrupt */
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_INTERRUPT_CLEAR, 0x01);
-	LoopCount = 0;
-	do {
-		VL53L0_RdByte(Dev, VL53L0_REG_RESULT_INTERRUPT_STATUS, &Byte);
-		LoopCount++;
-	} while (((Byte & 0x07) != 0x00) && (LoopCount < 8));
-	Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_INTERRUPT_CLEAR, 0x00);
-	/* clear all */
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetInterruptMaskStatus(VL53L0_DEV Dev, uint32_t
-	*pInterruptMaskStatus)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_INTERRUPT_STATUS, &Byte);
-	*pInterruptMaskStatus = Byte & 0x07;
-
-	if (Byte & 0x18) {
-		Status = VL53L0_ERROR_RANGE_ERROR; /* check if some error
-		occurs */
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_EnableInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
-
-	LOG_FUNCTION_START("");
-
-	/* not implemented for VL53L0 */
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/* End Group PAL Interrupt Functions */
-
-/* Group SPAD functions */
-
-VL53L0_Error VL53L0_SetSpadAmbientDamperThreshold(VL53L0_DEV Dev, uint16_t
-	SpadAmbientDamperThreshold)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status = VL53L0_WrWord(Dev, 0x40, SpadAmbientDamperThreshold);
-	VL53L0_WrByte(Dev, 0xFF, 0x00);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetSpadAmbientDamperThreshold(VL53L0_DEV Dev, uint16_t
-	*pSpadAmbientDamperThreshold)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status = VL53L0_RdWord(Dev, 0x40, pSpadAmbientDamperThreshold);
-	VL53L0_WrByte(Dev, 0xFF, 0x00);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_SetSpadAmbientDamperFactor(VL53L0_DEV Dev, uint16_t
-	SpadAmbientDamperFactor)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	Byte = (uint8_t) (SpadAmbientDamperFactor & 0x00FF);
-
-	VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status = VL53L0_WrByte(Dev, 0x42, Byte);
-	VL53L0_WrByte(Dev, 0xFF, 0x00);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_GetSpadAmbientDamperFactor(VL53L0_DEV Dev, uint16_t
-	*pSpadAmbientDamperFactor)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t Byte;
-
-	LOG_FUNCTION_START("");
-
-	VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status = VL53L0_RdByte(Dev, 0x42, &Byte);
-	VL53L0_WrByte(Dev, 0xFF, 0x00);
-	*pSpadAmbientDamperFactor = (uint16_t) Byte;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/* END Group SPAD functions */
-
-/*//////////////////////////////////////////////////////////////////////////////
-//
-//////////////////////////////////
-// Internal functions
-////////////////////////////////////////////////////////////////////////////////
-//////////////////////////////////
-*/
-
-
-static uint32_t VL53L0_calc_macro_period_ps(VL53L0_DEV Dev,
-		uint8_t vcsel_period);
-static uint16_t VL53L0_encode_timeout(uint32_t timeout_mclks);
-static uint32_t VL53L0_decode_timeout(uint16_t encoded_timeout);
-
-static VL53L0_Error VL53L0_get_vcsel_pulse_period(VL53L0_DEV Dev, uint8_t
-	*pVCSELPulsePeriod, uint8_t RangeIndex)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t vcsel_period_reg;
-
-	LOG_FUNCTION_START("");
-
-	switch (RangeIndex) {
-	case 0:
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
-			&vcsel_period_reg);
-		break;
-	case 1:
-		Status = VL53L0_RdByte(Dev,
-			VL53L0_REG_RNGB1_CONFIG_VCSEL_PERIOD,
-			&vcsel_period_reg);
-		break;
-	case 2:
-		Status = VL53L0_RdByte(Dev,
-			VL53L0_REG_RNGB2_CONFIG_VCSEL_PERIOD,
-			&vcsel_period_reg);
-		break;
-	default:
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
-			&vcsel_period_reg);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		*pVCSELPulsePeriod =
-			VL53L0_decode_vcsel_period(vcsel_period_reg);
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-/* To convert ms into register value */
-static uint16_t VL53L0_calc_encoded_timeout(VL53L0_DEV Dev, uint32_t
-	timeout_period_us, uint8_t vcsel_period)
-{
-	uint32_t macro_period_ps;
-	uint32_t macro_period_ns;
-	uint32_t timeout_period_mclks = 0;
-	uint16_t timeout_overall_periods = 0;
-
-	macro_period_ps = VL53L0_calc_macro_period_ps(Dev, vcsel_period);
-	macro_period_ns = macro_period_ps / 1000;
-
-	timeout_period_mclks = (uint32_t) (((timeout_period_us * 1000) +
-		(macro_period_ns / 2)) / macro_period_ns);
-	timeout_overall_periods = VL53L0_encode_timeout(timeout_period_mclks);
-
-	return timeout_overall_periods;
-}
-
-/* To convert register value into us */
-static uint32_t VL53L0_calc_ranging_wait_us(VL53L0_DEV Dev, uint16_t
-	timeout_overall_periods, uint8_t vcsel_period)
-{
-	uint32_t macro_period_ps;
-	uint32_t macro_period_ns;
-	uint32_t timeout_period_mclks = 0;
-	uint32_t actual_timeout_period_us = 0;
-
-	macro_period_ps = VL53L0_calc_macro_period_ps(Dev, vcsel_period);
-	macro_period_ns = macro_period_ps / 1000;
-
-	timeout_period_mclks = VL53L0_decode_timeout(timeout_overall_periods);
-	actual_timeout_period_us = ((timeout_period_mclks * macro_period_ns) +
-		(macro_period_ns / 2)) / 1000;
-
-	return actual_timeout_period_us;
-}
-
-static uint32_t VL53L0_calc_macro_period_ps(VL53L0_DEV Dev,
-		uint8_t vcsel_period)
-{
-	uint32_t PLL_multiplier;
-	uint64_t PLL_period_ps;
-	uint8_t vcsel_period_pclks;
-	uint32_t macro_period_vclks;
-	uint32_t macro_period_ps;
-	FixPoint1616_t OscFrequencyMHz;
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
-
-	LOG_FUNCTION_START("");
-
-	PLL_multiplier = 65536 / 64; /* PLL multiplier is 64 */
-
-	OscFrequencyMHz =  VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
-							OscFrequencyMHz);
-
-	if (OscFrequencyMHz == 0) {
-		/* Use default one */
-		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 748421);
-		OscFrequencyMHz = 748421;
-	}
-	PLL_period_ps = (1000 * 1000 * PLL_multiplier) /
-		OscFrequencyMHz;
-
-	vcsel_period_pclks = VL53L0_decode_vcsel_period(vcsel_period);
-
-	macro_period_vclks = 2304;
-	macro_period_ps = (uint32_t)(macro_period_vclks * vcsel_period_pclks *
-		PLL_period_ps);
-
-	LOG_FUNCTION_END("");
-	return macro_period_ps;
-}
-
-static uint8_t VL53L0_decode_vcsel_period(uint8_t vcsel_period_reg)
-{
-
-	/*!
-	 * Converts the encoded VCSEL period register value into the real
-	 * period in PLL clocks
-	 */
-
-	uint8_t vcsel_period_pclks = 0;
-
-	vcsel_period_pclks = (vcsel_period_reg + 1) << 1;
-
-	return vcsel_period_pclks;
-}
-
-static uint8_t VL53L0_encode_vcsel_period(uint8_t vcsel_period_pclks)
-{
-
-	/*!
-	 * Converts the encoded VCSEL period register value into the real
-	 * period in PLL clocks
-	 */
-
-	uint8_t vcsel_period_reg = 0;
-
-	vcsel_period_reg = (vcsel_period_pclks >> 1) - 1;
-
-	return vcsel_period_reg;
-}
-
-static uint16_t VL53L0_encode_timeout(uint32_t timeout_mclks)
-{
-    /*!
-     * Encode timeout in macro periods in (LSByte * 2^MSByte) + 1 format
-     *
-     */
-
-	uint16_t encoded_timeout = 0;
-	uint32_t ls_byte = 0;
-	uint16_t ms_byte = 0;
-
-	if (timeout_mclks > 0) {
-		ls_byte = timeout_mclks - 1;
-
-		while ((ls_byte & 0xFFFFFF00) > 0) {
-			ls_byte = ls_byte >> 1;
-			ms_byte++;
-		}
-
-		encoded_timeout = (ms_byte << 8) + (uint16_t) (ls_byte &
-			0x000000FF);
-
-	}
-
-	return encoded_timeout;
-
-}
-
-static uint32_t VL53L0_decode_timeout(uint16_t encoded_timeout)
-{
-	/*!
-	 * Decode 16-bit timeout register value - format (LSByte * 2^MSByte) + 1
-	 *
-	 */
-
-	uint32_t timeout_mclks = 0;
-
-	timeout_mclks = ((uint32_t) (encoded_timeout & 0x00FF) << (uint32_t)
-		((encoded_timeout & 0xFF00) >> 8)) + 1;
-
-	return timeout_mclks;
-
-}
-
-
-static VL53L0_Error VL53L0_load_additional_settings1(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	/* update 12_05_15_v6 */
-	/* OSCT */
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x14, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xCD, 0x6C);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x86, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x87, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-
-	/* update 12_05_15_v6 */
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xcd, 0x6c);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x90, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x91, 0x3f);
-	Status |= VL53L0_WrByte(Dev, 0x92, 0x3f);
-	Status |= VL53L0_WrByte(Dev, 0x88, 0x2b);
-	Status |= VL53L0_WrByte(Dev, 0x89, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xcd, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-
-	/* update 12_05_15 */
-	Status |= VL53L0_WrByte(Dev, 0xb0, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xb1, 0xfc);
-	Status |= VL53L0_WrByte(Dev, 0xb2, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xb3, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xb4, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xb5, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xb6, 0xb0);
-
-	Status |= VL53L0_WrByte(Dev, 0x32, 0x03);
-
-	Status |= VL53L0_WrByte(Dev, 0x41, 0xff);
-	Status |= VL53L0_WrByte(Dev, 0x42, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x43, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0x01, 0x01);
-
-	if (Status != 0)
-		Status = VL53L0_ERROR_CONTROL_INTERFACE;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-
-static VL53L0_Error VL53L0_load_additional_settings3(VL53L0_DEV Dev)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-
-	LOG_FUNCTION_START("");
-
-	/* update 150624_b */
-
-	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-
-	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x4f, 0x0B);
-
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x0E);
-
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x01, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x02, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0x03, 0x0D);
-	Status |= VL53L0_WrByte(Dev, 0x04, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x05, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x06, 0x06);
-	Status |= VL53L0_WrByte(Dev, 0x07, 0x47);
-	Status |= VL53L0_WrByte(Dev, 0x08, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x09, 0x20);
-	Status |= VL53L0_WrByte(Dev, 0x0A, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x0B, 0x49);
-	Status |= VL53L0_WrByte(Dev, 0x0C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x0D, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x0E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x0F, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x10, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x11, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0x12, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x13, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x14, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x15, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x16, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x17, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x18, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x19, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x1A, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0x1B, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x1C, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x1D, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x1E, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0x1F, 0x08);
-	Status |= VL53L0_WrByte(Dev, 0x20, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x21, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x22, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x23, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x24, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0x25, 0x0D);
-	Status |= VL53L0_WrByte(Dev, 0x26, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x27, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x28, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x29, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x2A, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x2B, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x2C, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x2D, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x2E, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x2F, 0x92);
-	Status |= VL53L0_WrByte(Dev, 0x30, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x31, 0x64);
-	Status |= VL53L0_WrByte(Dev, 0x32, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x33, 0x8A);
-	Status |= VL53L0_WrByte(Dev, 0x34, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x35, 0xE0);
-	Status |= VL53L0_WrByte(Dev, 0x36, 0x0F);
-	Status |= VL53L0_WrByte(Dev, 0x37, 0xAA);
-	Status |= VL53L0_WrByte(Dev, 0x38, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x39, 0xE4);
-	Status |= VL53L0_WrByte(Dev, 0x3A, 0x0F);
-	Status |= VL53L0_WrByte(Dev, 0x3B, 0xAE);
-	Status |= VL53L0_WrByte(Dev, 0x3C, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x3D, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x3E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x3F, 0x54);
-	Status |= VL53L0_WrByte(Dev, 0x40, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x41, 0x88);
-	Status |= VL53L0_WrByte(Dev, 0x42, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x43, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x44, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x45, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x46, 0x06);
-	Status |= VL53L0_WrByte(Dev, 0x47, 0x87);
-	Status |= VL53L0_WrByte(Dev, 0x48, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x49, 0x38);
-	Status |= VL53L0_WrByte(Dev, 0x4A, 0x2B);
-	Status |= VL53L0_WrByte(Dev, 0x4B, 0x89);
-	Status |= VL53L0_WrByte(Dev, 0x4C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x4D, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x4E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x4F, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x50, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x51, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0x52, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x53, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x54, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x55, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x56, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x57, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x58, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x59, 0x0D);
-	Status |= VL53L0_WrByte(Dev, 0x5A, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x5B, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x5C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x5D, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x5E, 0x0D);
-	Status |= VL53L0_WrByte(Dev, 0x5F, 0x67);
-	Status |= VL53L0_WrByte(Dev, 0x60, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x61, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x62, 0x0D);
-	Status |= VL53L0_WrByte(Dev, 0x63, 0xB0);
-	Status |= VL53L0_WrByte(Dev, 0x64, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x65, 0x20);
-	Status |= VL53L0_WrByte(Dev, 0x66, 0x29);
-	Status |= VL53L0_WrByte(Dev, 0x67, 0xC1);
-	Status |= VL53L0_WrByte(Dev, 0x68, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x69, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x6A, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x6B, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x6C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x6D, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x6E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x6F, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x70, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x71, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0x72, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x73, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x74, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x75, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x76, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x77, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x78, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x79, 0x0D);
-	Status |= VL53L0_WrByte(Dev, 0x7A, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x7B, 0x1B);
-	Status |= VL53L0_WrByte(Dev, 0x7C, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x7D, 0x82);
-	Status |= VL53L0_WrByte(Dev, 0x7E, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x7F, 0x24);
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x81, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x82, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x84, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x85, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x86, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x87, 0x21);
-	Status |= VL53L0_WrByte(Dev, 0x88, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x89, 0x58);
-	Status |= VL53L0_WrByte(Dev, 0x8A, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x8B, 0xCC);
-	Status |= VL53L0_WrByte(Dev, 0x8C, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x8D, 0xC3);
-	Status |= VL53L0_WrByte(Dev, 0x8E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x8F, 0x94);
-	Status |= VL53L0_WrByte(Dev, 0x90, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x91, 0x53);
-	Status |= VL53L0_WrByte(Dev, 0x92, 0x1E);
-	Status |= VL53L0_WrByte(Dev, 0x93, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x94, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x95, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x96, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x97, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x98, 0x20);
-	Status |= VL53L0_WrByte(Dev, 0x99, 0x20);
-	Status |= VL53L0_WrByte(Dev, 0x9A, 0x08);
-	Status |= VL53L0_WrByte(Dev, 0x9B, 0x10);
-	Status |= VL53L0_WrByte(Dev, 0x9C, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x9D, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x9E, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x9F, 0x50);
-	Status |= VL53L0_WrByte(Dev, 0xA0, 0x2B);
-	Status |= VL53L0_WrByte(Dev, 0xA1, 0xB1);
-	Status |= VL53L0_WrByte(Dev, 0xA2, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xA3, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0xA4, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0xA5, 0x50);
-	Status |= VL53L0_WrByte(Dev, 0xA6, 0x2C);
-	Status |= VL53L0_WrByte(Dev, 0xA7, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0xA8, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xA9, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xAA, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xAB, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xAC, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xAD, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0xAE, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xAF, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0xB0, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xB1, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0xB2, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0xB3, 0x4E);
-	Status |= VL53L0_WrByte(Dev, 0xB4, 0x2D);
-	Status |= VL53L0_WrByte(Dev, 0xB5, 0x47);
-	Status |= VL53L0_WrByte(Dev, 0xB6, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xB7, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xB8, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xB9, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xBA, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xBB, 0xA7);
-	Status |= VL53L0_WrByte(Dev, 0xBC, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xBD, 0xA6);
-	Status |= VL53L0_WrByte(Dev, 0xBE, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0xBF, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0xC0, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0xC1, 0x30);
-	Status |= VL53L0_WrByte(Dev, 0xC2, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xC3, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0xC4, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0xC5, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0xC6, 0x2D);
-	Status |= VL53L0_WrByte(Dev, 0xC7, 0x89);
-	Status |= VL53L0_WrByte(Dev, 0xC8, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xC9, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xCA, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xCB, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xCC, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xCD, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0xCE, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xCF, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0xD0, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xD1, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0xD2, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xD3, 0x25);
-	Status |= VL53L0_WrByte(Dev, 0xD4, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xD5, 0x2E);
-	Status |= VL53L0_WrByte(Dev, 0xD6, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xD7, 0x25);
-	Status |= VL53L0_WrByte(Dev, 0xD8, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xD9, 0x2E);
-	Status |= VL53L0_WrByte(Dev, 0xDA, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0xDB, 0xF3);
-	Status |= VL53L0_WrByte(Dev, 0xDC, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0xDD, 0xEA);
-	Status |= VL53L0_WrByte(Dev, 0xDE, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0xDF, 0x58);
-	Status |= VL53L0_WrByte(Dev, 0xE0, 0x2C);
-	Status |= VL53L0_WrByte(Dev, 0xE1, 0xD9);
-	Status |= VL53L0_WrByte(Dev, 0xE2, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xE3, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xE4, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xE5, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xE6, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xE7, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0xE8, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xE9, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0xEA, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xEB, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0xEC, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0xED, 0x26);
-	Status |= VL53L0_WrByte(Dev, 0xEE, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xEF, 0xDC);
-	Status |= VL53L0_WrByte(Dev, 0xF0, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0xF1, 0x58);
-	Status |= VL53L0_WrByte(Dev, 0xF2, 0x2F);
-	Status |= VL53L0_WrByte(Dev, 0xF3, 0x21);
-	Status |= VL53L0_WrByte(Dev, 0xF4, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xF5, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xF6, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xF7, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xF8, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xF9, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0xFA, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xFB, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0xFC, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xFD, 0x04);
-	Status |= VL53L0_WrWord(Dev, 0xFE, 0x01E3);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x0F);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x01, 0x48);
-	Status |= VL53L0_WrByte(Dev, 0x02, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x03, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x04, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x05, 0xA4);
-	Status |= VL53L0_WrByte(Dev, 0x06, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x07, 0xB8);
-	Status |= VL53L0_WrByte(Dev, 0x08, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x09, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x0A, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x0B, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x0C, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x0D, 0x6B);
-	Status |= VL53L0_WrByte(Dev, 0x0E, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x0F, 0x64);
-	Status |= VL53L0_WrByte(Dev, 0x10, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x11, 0x3C);
-	Status |= VL53L0_WrByte(Dev, 0x12, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x13, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x14, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x15, 0x74);
-	Status |= VL53L0_WrByte(Dev, 0x16, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x17, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x18, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x19, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x1A, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x1B, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x1C, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x1D, 0xA2);
-	Status |= VL53L0_WrByte(Dev, 0x1E, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x1F, 0x8E);
-	Status |= VL53L0_WrByte(Dev, 0x20, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x21, 0x50);
-	Status |= VL53L0_WrByte(Dev, 0x22, 0x2E);
-	Status |= VL53L0_WrByte(Dev, 0x23, 0xC9);
-	Status |= VL53L0_WrByte(Dev, 0x24, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x25, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x26, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x27, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x28, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x29, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0x2A, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x2B, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x2C, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x2D, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x2E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x2F, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x30, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x31, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x32, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x33, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x34, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0x35, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x36, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x37, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x38, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0x39, 0x08);
-	Status |= VL53L0_WrByte(Dev, 0x3A, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x3B, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x3C, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0x3D, 0x18);
-	Status |= VL53L0_WrByte(Dev, 0x3E, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x3F, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x40, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x41, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x42, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x43, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x44, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0x45, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x46, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x47, 0x08);
-	Status |= VL53L0_WrByte(Dev, 0x48, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0x49, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x4A, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x4B, 0x40);
-	Status |= VL53L0_WrByte(Dev, 0x4C, 0x2F);
-	Status |= VL53L0_WrByte(Dev, 0x4D, 0xD1);
-	Status |= VL53L0_WrByte(Dev, 0x4E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x4F, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x50, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x51, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x52, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x53, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0x54, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x55, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x56, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x57, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x58, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x59, 0x11);
-	Status |= VL53L0_WrByte(Dev, 0x5A, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x5B, 0x48);
-	Status |= VL53L0_WrByte(Dev, 0x5C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x5D, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x5E, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0x5F, 0xA2);
-	Status |= VL53L0_WrByte(Dev, 0x60, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x61, 0x60);
-	Status |= VL53L0_WrByte(Dev, 0x62, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x63, 0x3E);
-	Status |= VL53L0_WrByte(Dev, 0x64, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x65, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x66, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x67, 0x54);
-	Status |= VL53L0_WrByte(Dev, 0x68, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x69, 0x80);
-	Status |= VL53L0_WrByte(Dev, 0x6A, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x6B, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x6C, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x6D, 0x38);
-	Status |= VL53L0_WrByte(Dev, 0x6E, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x6F, 0xE1);
-	Status |= VL53L0_WrByte(Dev, 0x70, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x71, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x72, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x73, 0x38);
-	Status |= VL53L0_WrByte(Dev, 0x74, 0x29);
-	Status |= VL53L0_WrByte(Dev, 0x75, 0x21);
-	Status |= VL53L0_WrByte(Dev, 0x76, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x77, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x78, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x79, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x7A, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x7B, 0xA1);
-	Status |= VL53L0_WrByte(Dev, 0x7C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x7D, 0xA0);
-	Status |= VL53L0_WrByte(Dev, 0x7E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x7F, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x81, 0x33);
-	Status |= VL53L0_WrByte(Dev, 0x82, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x83, 0x6A);
-	Status |= VL53L0_WrByte(Dev, 0x84, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x85, 0x61);
-	Status |= VL53L0_WrByte(Dev, 0x86, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x87, 0xF9);
-	Status |= VL53L0_WrByte(Dev, 0x88, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x89, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x8A, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x8B, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x8C, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x8D, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0x8E, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x8F, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0x90, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x91, 0x66);
-	Status |= VL53L0_WrByte(Dev, 0x92, 0x2A);
-	Status |= VL53L0_WrByte(Dev, 0x93, 0x67);
-	Status |= VL53L0_WrByte(Dev, 0x94, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x95, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x96, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x97, 0x66);
-	Status |= VL53L0_WrByte(Dev, 0x98, 0x2A);
-	Status |= VL53L0_WrByte(Dev, 0x99, 0xAF);
-	Status |= VL53L0_WrByte(Dev, 0x9A, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x9B, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x9C, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x9D, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x9E, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x9F, 0xA7);
-	Status |= VL53L0_WrByte(Dev, 0xA0, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xA1, 0xA6);
-	Status |= VL53L0_WrByte(Dev, 0xA2, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xA3, 0x04);
-
-	Status |= VL53L0_WrByte(Dev, 0xff, 0x04);
-
-	Status |= VL53L0_WrByte(Dev, 0x79, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0x7B, 0x16);
-	Status |= VL53L0_WrByte(Dev, 0x7D, 0x2B);
-	Status |= VL53L0_WrByte(Dev, 0x7F, 0x3B);
-	Status |= VL53L0_WrByte(Dev, 0x81, 0x59);
-	Status |= VL53L0_WrByte(Dev, 0x83, 0x62);
-	Status |= VL53L0_WrByte(Dev, 0x85, 0x69);
-	Status |= VL53L0_WrByte(Dev, 0x87, 0x76);
-	Status |= VL53L0_WrByte(Dev, 0x89, 0x7F);
-	Status |= VL53L0_WrByte(Dev, 0x8B, 0x98);
-	Status |= VL53L0_WrByte(Dev, 0x8D, 0xAC);
-	Status |= VL53L0_WrByte(Dev, 0x8F, 0xC0);
-	Status |= VL53L0_WrByte(Dev, 0x90, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0x91, 0x30);
-	Status |= VL53L0_WrByte(Dev, 0x92, 0x28);
-	Status |= VL53L0_WrByte(Dev, 0x93, 0x02);
-	Status |= VL53L0_WrByte(Dev, 0x94, 0x37);
-	Status |= VL53L0_WrByte(Dev, 0x95, 0x62);
-
-	Status |= VL53L0_WrByte(Dev, 0x96, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0x97, 0x08);
-	Status |= VL53L0_WrByte(Dev, 0x98, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x99, 0x18);
-	Status |= VL53L0_WrByte(Dev, 0x9A, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x9B, 0x6F);
-	Status |= VL53L0_WrByte(Dev, 0x9C, 0x05);
-	Status |= VL53L0_WrByte(Dev, 0x9D, 0xD4);
-	Status |= VL53L0_WrByte(Dev, 0x9E, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0x9F, 0x6E);
-	Status |= VL53L0_WrByte(Dev, 0xA0, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0xA1, 0xA2);
-	Status |= VL53L0_WrByte(Dev, 0xA2, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0xA3, 0xAA);
-	Status |= VL53L0_WrByte(Dev, 0xA4, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xA5, 0x97);
-	Status |= VL53L0_WrByte(Dev, 0xA6, 0x0B);
-	Status |= VL53L0_WrByte(Dev, 0xA7, 0xD8);
-	Status |= VL53L0_WrByte(Dev, 0xA8, 0x0A);
-	Status |= VL53L0_WrByte(Dev, 0xA9, 0xD7);
-	Status |= VL53L0_WrByte(Dev, 0xAA, 0x08);
-	Status |= VL53L0_WrByte(Dev, 0xAB, 0xF6);
-	Status |= VL53L0_WrByte(Dev, 0xAC, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0xAD, 0x1A);
-	Status |= VL53L0_WrByte(Dev, 0xAE, 0x0C);
-	Status |= VL53L0_WrByte(Dev, 0xAF, 0x49);
-	Status |= VL53L0_WrByte(Dev, 0xB0, 0x09);
-	Status |= VL53L0_WrByte(Dev, 0xB1, 0x17);
-	Status |= VL53L0_WrByte(Dev, 0xB2, 0x03);
-	Status |= VL53L0_WrByte(Dev, 0xB3, 0xCD);
-	Status |= VL53L0_WrByte(Dev, 0xB4, 0x04);
-	Status |= VL53L0_WrByte(Dev, 0xB5, 0x55);
-
-	Status |= VL53L0_WrByte(Dev, 0x72, 0xFF);
-	Status |= VL53L0_WrByte(Dev, 0x73, 0xFF);
-
-	Status |= VL53L0_WrByte(Dev, 0x74, 0xE0);
-
-	Status |= VL53L0_WrByte(Dev, 0x70, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
-
-	if (Status != 0)
-		Status = VL53L0_ERROR_CONTROL_INTERFACE;
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-static VL53L0_Error VL53L0_check_part_used(VL53L0_DEV Dev,
-		uint8_t *Revision)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t ModuleIdInt;
-
-	LOG_FUNCTION_START("");
-
-	Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODULE_ID,
-		&ModuleIdInt);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (ModuleIdInt == 0)
-			Revision = 0;
-		else
-			Status = VL53L0_get_info_from_device(Dev, Revision);
-
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-static VL53L0_Error VL53L0_get_info_from_device(VL53L0_DEV Dev,
-		uint8_t *Revision)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t strobe;
-	uint8_t byte;
-	uint32_t LoopNb;
-
-	LOG_FUNCTION_START("");
-
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
-
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
-	Status |= VL53L0_RdByte(Dev, 0x83, &byte);
-	Status |= VL53L0_WrByte(Dev, 0x83, byte|4);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x07);
-	Status |= VL53L0_WrByte(Dev, 0x81, 0x01);
-
-	Status |= VL53L0_PollingDelay(Dev);
-
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0x94, 0x7B);
-
-	Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
-
-	/*	polling
-	*	use timeout to avoid deadlock
-	*/
-	if (Status == VL53L0_ERROR_NONE) {
-		LoopNb = 0;
-		do {
-			Status = VL53L0_RdByte(Dev, 0x83, &strobe);
-			if ((strobe != 0x00) || Status != VL53L0_ERROR_NONE)
-				break;
-
-			LoopNb = LoopNb + 1;
-		} while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
-
-		if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP)
-			Status = VL53L0_ERROR_TIME_OUT;
-
-	}
-
-	Status |= VL53L0_WrByte(Dev, 0x83, 0x01);
-	Status |= VL53L0_RdByte(Dev, 0x90, Revision);
-
-	Status |= VL53L0_WrByte(Dev, 0x83, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x81, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
-	Status |= VL53L0_RdByte(Dev, 0x83, &byte);
-	Status |= VL53L0_WrByte(Dev, 0x83, byte&0xfb);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
-
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-uint32_t VL53L0_isqrt(uint32_t num)
-{
-
-    /*
-     * Implements an integer square root
-     *
-     * From: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
-     */
-
-	uint32_t  res = 0;
-	uint32_t  bit = 1 << 30;
-	/* The second-to-top bit is set: 1 << 14 for
-	16-bits, 1 << 30 for 32 bits
-	*/
-    /* "bit" starts at the highest power of four <= the argument.*/
-	while (bit > num)
-		bit >>= 2;
-
-
-	while (bit != 0) {
-		if (num >= res + bit) {
-			num -= res + bit;
-			res = (res >> 1) + bit;
-		} else
-			res >>= 1;
-
-		bit >>= 2;
-	}
-
-	return res;
-}
-
-uint32_t VL53L0_quadrature_sum(uint32_t a,
-	uint32_t b)
-{
-	/*
-	* Implements a quadrature sum
-	*
-	* rea = sqrt(a^2 + b^2)
-	*
-	* Trap overflow case max input value is 65535 (16-bit value)
-	* as internal calc are 32-bit wide
-	*
-	* If overflow then seta output to maximum
-	*/
-	uint32_t  res = 0;
-
-	if (a > 65535 || b > 65535)
-		res = 65535;
-	else
-		res = VL53L0_isqrt(a*a + b*b);
-
-
-	return res;
-}
-
-
-
-VL53L0_Error VL53L0_get_jmp_vcsel_ambient_rate(VL53L0_DEV Dev,
-	uint32_t *pAmbient_rate_kcps,
-	uint32_t *pVcsel_rate_kcps,
-	uint32_t *pSignalTotalEventsRtn)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint16_t encodedTimeOut;
-
-	uint32_t    total_periods_elapsed_rtn__macrop  = 0;
-	uint32_t    result_core__total_periods_elapsed_rtn  = 0;
-	uint32_t    rngb1_config__timeout__macrop = 0;
-	uint32_t    rngb2_config__timeout__macrop = 0;
-	uint32_t    result_core__ambient_window_events_rtn = 0;
-	uint32_t     result_core__signal_total_events_rtn = 0;
-	uint8_t     last_woi_period;
-	uint8_t     rnga_config__vcsel_period;
-	uint8_t     rngb1_config__vcsel_period;
-	uint8_t     rngb2_config__vcsel_period;
-	uint8_t     global_config__vcsel_width;
-
-	uint32_t    ambient_duration_us = 0;
-	uint32_t    vcsel_duration_us = 0;
-
-	uint32_t    pll_period_us  = 0;
-
-	LOG_FUNCTION_START("");
-
-	/* read the following */
-	Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
-	Status |= VL53L0_RdDWord(Dev, 0xC8,
-		&result_core__total_periods_elapsed_rtn);
-	Status |= VL53L0_RdDWord(Dev, 0xF0, &pll_period_us);
-	Status |= VL53L0_RdDWord(Dev, 0xbc,
-		&result_core__ambient_window_events_rtn);
-	Status |= VL53L0_RdDWord(Dev, 0xc4,
-		&result_core__signal_total_events_rtn);
-	Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		result_core__total_periods_elapsed_rtn =
-			(int32_t)(result_core__total_periods_elapsed_rtn &
-			0x00ffffff);
-		pll_period_us = (int32_t)(pll_period_us & 0x3ffff);
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdWord(Dev, VL53L0_REG_RNGB1_TIMEOUT_MSB,
-			&encodedTimeOut);
-	if (Status == VL53L0_ERROR_NONE)
-		rngb1_config__timeout__macrop =
-			VL53L0_decode_timeout(encodedTimeOut) - 1;
-
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev, VL53L0_REG_RNGA_CONFIG_VCSEL_PERIOD,
-			&rnga_config__vcsel_period);
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev,
-			VL53L0_REG_RNGB1_CONFIG_VCSEL_PERIOD,
-			&rngb1_config__vcsel_period);
-	}
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdByte(Dev,
-			VL53L0_REG_RNGB2_CONFIG_VCSEL_PERIOD,
-			&rngb2_config__vcsel_period);
-	}
-	if (Status == VL53L0_ERROR_NONE)
-		Status = VL53L0_RdByte(Dev, 0x32, &global_config__vcsel_width);
-
-
-	if (Status == VL53L0_ERROR_NONE) {
-		Status = VL53L0_RdWord(Dev, VL53L0_REG_RNGB2_TIMEOUT_MSB,
-			&encodedTimeOut);
-		if (Status == VL53L0_ERROR_NONE)
-			rngb2_config__timeout__macrop =
-				VL53L0_decode_timeout(encodedTimeOut) - 1;
-
-	}
-
-	if (Status == VL53L0_ERROR_NONE) {
-		total_periods_elapsed_rtn__macrop =
-			result_core__total_periods_elapsed_rtn + 1;
-
-		if (result_core__total_periods_elapsed_rtn ==
-			rngb1_config__timeout__macrop) {
-			last_woi_period = rngb1_config__vcsel_period;
-		} else if (result_core__total_periods_elapsed_rtn ==
-			rngb2_config__timeout__macrop) {
-			last_woi_period = rngb2_config__vcsel_period;
-		} else {
-			last_woi_period = rnga_config__vcsel_period;
-
-		}
-		/* 512 = 1<<9  ==> 24-9=15 */
-		ambient_duration_us = last_woi_period *
-			total_periods_elapsed_rtn__macrop * pll_period_us;
-		ambient_duration_us = ambient_duration_us / 1000;
-
-		if (ambient_duration_us != 0) {
-			*pAmbient_rate_kcps = ((1 << 15) *
-				result_core__ambient_window_events_rtn) /
-				ambient_duration_us;
-		} else {
-			Status = VL53L0_ERROR_DIVISION_BY_ZERO;
-		}
-
-		if (Status == VL53L0_ERROR_NONE) {
-
-			/* 2048 = 1<<11  ==> 24-11=13 */
-			vcsel_duration_us =
-				(10 * global_config__vcsel_width + 4)
-				* total_periods_elapsed_rtn__macrop *
-				pll_period_us ;
-			vcsel_duration_us = vcsel_duration_us / 10000 ;
-
-
-			if (vcsel_duration_us != 0) {
-				*pVcsel_rate_kcps = ((1 << 13) *
-					result_core__signal_total_events_rtn) /
-					vcsel_duration_us;
-				*pSignalTotalEventsRtn =
-					result_core__signal_total_events_rtn;
-			} else {
-				Status = VL53L0_ERROR_DIVISION_BY_ZERO;
-			}
-
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-
-}
-
-VL53L0_Error VL53L0_calc_sigma_estimate(VL53L0_DEV Dev,
-	VL53L0_RangingMeasurementData_t
-	*pRangingMeasurementData,
-	FixPoint1616_t *pSigmaEstimate)
-{
-	/* Expressed in 100ths of a ns, i.e. centi-ns */
-	const uint32_t cPulseEffectiveWidth_centi_ns   = 800;
-	/* Expressed in 100ths of a ns, i.e. centi-ns */
-	const uint32_t cAmbientEffectiveWidth_centi_ns = 600;
-	const FixPoint1616_t cSigmaEstRef              = 0x00000042;
-	/* pico secs */
-	const uint32_t cVcselPulseWidth_ps             = 4700;
-	const FixPoint1616_t cSigmaEstMax              = 0x028F87AE;
-	/* Time Of Flight per mm (6.6 pico secs) */
-	const FixPoint1616_t cTOF_per_mm_ps            = 0x0006999A;
-	const uint32_t c16BitRoundingParam             = 0x00008000;
-	const FixPoint1616_t cMaxXTalk_kcps            = 0x00320000;
-
-	uint32_t signalTotalEventsRtn;
-	FixPoint1616_t sigmaEstimateP1;
-	FixPoint1616_t sigmaEstimateP2;
-	FixPoint1616_t sigmaEstimateP3;
-	FixPoint1616_t deltaT_ps;
-	FixPoint1616_t pwMult;
-	FixPoint1616_t sigmaEstRtn;
-	FixPoint1616_t sigmaEstimate;
-	FixPoint1616_t xTalkCorrection;
-	uint32_t signalTotalEventsRtnRawVal;
-	FixPoint1616_t ambientRate_kcps;
-	FixPoint1616_t vcselRate_kcps;
-	FixPoint1616_t xTalkCompRate_mcps;
-	uint32_t xTalkCompRate_kcps;
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	VL53L0_DeviceParameters_t CurrentParameters;
-	FixPoint1616_t diff1_mcps;
-	FixPoint1616_t diff2_mcps;
-	FixPoint1616_t sqr1;
-	FixPoint1616_t sqr2;
-	FixPoint1616_t sqrSum;
-	FixPoint1616_t sqrtResult_centi_ns;
-	FixPoint1616_t sqrtResult;
-
-	/*! \addtogroup calc_sigma_estimate
-	* @{
-	*
-	* Estimates the range sigma based on the
-	*
-	*  - vcsel_rate_kcps
-	*  - ambient_rate_kcps
-	*  - signal_total_events
-	*  - xtalk_rate
-	*
-	* and the following parameters
-	*
-	*  - SigmaEstRefArray
-	*  - SigmaEstEffPulseWidth
-	*  - SigmaEstEffAmbWidth
-	*/
-
-	LOG_FUNCTION_START("");
-
-	VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
-		xTalkCompRate_mcps);
-    /*
-     * We work in kcps rather than mcps as this helps keep within the confines
-     * of the 32 Fix1616 type.
-     */
-
-	xTalkCompRate_kcps = xTalkCompRate_mcps * 1000;
-	if (xTalkCompRate_kcps > cMaxXTalk_kcps)
-		xTalkCompRate_kcps = cMaxXTalk_kcps;
-
-
-	Status =  VL53L0_get_jmp_vcsel_ambient_rate(Dev,
-					&ambientRate_kcps,
-					&vcselRate_kcps,
-					&signalTotalEventsRtnRawVal);
-
-	if (Status == VL53L0_ERROR_NONE) {
-		if (vcselRate_kcps == 0) {
-			Status = VL53L0_ERROR_DIVISION_BY_ZERO;
-		} else {
-			signalTotalEventsRtn = signalTotalEventsRtnRawVal;
-			if (signalTotalEventsRtn < 1)
-				signalTotalEventsRtn = 1;
-
-			/*
-			 * Calculate individual components of the main
-			 * equation - replicating the equation implemented in
-			 * the script OpenAll_Ewok_ranging_data.jsl.
-			 *
-			 * sigmaEstimateP1 represents the effective pulse width,
-			 * which is a tuning parameter, rather than a real
-			 * value.
-			 *
-			 * sigmaEstimateP2 represents the ambient/signal rate
-			 * ratio expressed as a multiple of the effective
-			 * ambient width (tuning parameter).
-			 *
-			 * sigmaEstimateP3 provides the signal event component,
-			 * with the knowledge that
-			 *	- Noise of a square pulse is 1/sqrt(12) of the
-			 * pulse width.
-			 *	- at 0Lux, sigma is proportional to
-			 *	effectiveVcselPulseWidth /
-			 *	sqrt(12 * signalTotalEvents)
-			 *
-			 * deltaT_ps represents the time of flight in pico secs
-			 * for the current range measurement, using the
-			 * "TOF per mm" constant (in ps).
-			 */
-
-			sigmaEstimateP1 = cPulseEffectiveWidth_centi_ns;
-
-			/*
-			((FixPoint1616 << 16)* uint32)/FixPoint1616 =
-				FixPoint1616
-			*/
-			sigmaEstimateP2 = (ambientRate_kcps << 16) /
-				vcselRate_kcps;
-			sigmaEstimateP2 *= cAmbientEffectiveWidth_centi_ns;
-
-			sigmaEstimateP3 = 2 *
-				VL53L0_isqrt(signalTotalEventsRtn * 12);
-
-			/* uint32 * FixPoint1616 = FixPoint1616 */
-			deltaT_ps =
-				pRangingMeasurementData->RangeMilliMeter *
-					cTOF_per_mm_ps;
-
-			/*
-			 * vcselRate - xtalkCompRate
-			 * (uint32 << 16) - FixPoint1616 = FixPoint1616.
-			 * Divide result by 1000 to convert to mcps.
-			 * 500 is added to ensure rounding when integer
-			 * division truncates.
-			 */
-			diff1_mcps = (((vcselRate_kcps << 16) -
-					xTalkCompRate_kcps) + 500)/1000;
-
-			/* vcselRate + xtalkCompRate */
-			diff2_mcps = (((vcselRate_kcps << 16) +
-					xTalkCompRate_kcps) + 500)/1000;
-
-			/* Shift by 12 bits to increase resolution prior to the
-			division */
-			diff1_mcps <<= 12;
-
-			/* FixPoint0428/FixPoint1616 = FixPoint2012 */
-			xTalkCorrection  = abs(diff1_mcps/diff2_mcps);
-
-			/* FixPoint2012 << 4 = FixPoint1616 */
-			xTalkCorrection <<= 4;
-
-			/* FixPoint1616/uint32 = FixPoint1616 */
-			pwMult = deltaT_ps/cVcselPulseWidth_ps;
-			/* smaller than 1.0f */
-
-			/*
-			 * FixPoint1616 * FixPoint1616 = FixPoint3232, however
-			 * both values are small enough such that32 bits will
-			 * not be exceeded.
-			 */
-			pwMult *= ((1 << 16) - xTalkCorrection);
-
-			/* (FixPoint3232 >> 16) = FixPoint1616 */
-			pwMult =  (pwMult + c16BitRoundingParam) >> 16;
-
-			/* FixPoint1616 + FixPoint1616 = FixPoint1616 */
-			pwMult += (1 << 16);
-
-			/*
-			 * At this point the value will be 1.xx, therefore if we
-			 * square the value this will exceed 32 bits. To address
-			 * this perform a single shift to the right before the
-			 * multiplication.
-			 */
-			pwMult >>= 1;
-			/* FixPoint1715 * FixPoint1715 = FixPoint3430 */
-			pwMult = pwMult * pwMult;
-
-			/* (FixPoint3430 >> 14) = Fix1616 */
-			pwMult >>= 14;
-
-			/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
-			sqr1 = pwMult * sigmaEstimateP1;
-
-			/* (FixPoint1616 >> 12) = FixPoint2804 */
-			sqr1 = (sqr1 + 0x800) >> 12;
-
-			/* FixPoint2804 * FixPoint2804 = FixPoint5608 */
-			sqr1 *= sqr1;
-
-			sqr2 = sigmaEstimateP2;
-
-			/* (FixPoint1616 >> 12) = FixPoint2804 */
-			sqr2 = (sqr2 + 0x800) >> 12;
-
-			/* FixPoint2804 * FixPoint2804 = FixPoint5608 */
-			sqr2 *= sqr2;
-
-			/* FixPoint5608 + FixPoint5608 = FixPoint5608 */
-			sqrSum = sqr1 + sqr2;
-
-			/* SQRT(FixPoint5608) = FixPoint2804 */
-			sqrtResult_centi_ns = VL53L0_isqrt(sqrSum);
-
-			/* (FixPoint2804 << 12) = FixPoint1616 */
-			sqrtResult_centi_ns <<= 12;
-
-			/*
-			 * Note that the Speed Of Light is expressed in um
-			 * per 1E-10 seconds (2997). Therefore to get mm/ns
-			 * we have to divide by 10000
-			 */
-			sigmaEstRtn      =
-				((sqrtResult_centi_ns + 50) / 100 *
-				VL53L0_SPEED_OF_LIGHT_IN_AIR);
-			sigmaEstRtn      /= (sigmaEstimateP3);
-			/* Add 5000 before dividing by 10000 to ensure
-			rounding. */
-			sigmaEstRtn      += 5000;
-			sigmaEstRtn      /= 10000;
-
-			/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
-			sqr1 = sigmaEstRtn * sigmaEstRtn;
-			/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
-			sqr2 = cSigmaEstRef * cSigmaEstRef;
-
-			/* sqrt(FixPoint3232 << 12) = FixPoint1022 */
-			sqrtResult = VL53L0_isqrt((sqr1 + sqr2) << 12);
-			sqrtResult = (sqrtResult + 0x20) >> 6;
-			/*
-			 * Note that the Shift by 12bits increases resolution
-			 * prior to the sqrt, therefore the result must be
-			 * shifted by 6bits to the right to revert back to the
-			 * FixPoint1616 format.
-			 */
-
-			sigmaEstimate    = 1000 * sqrtResult;
-
-			if ((vcselRate_kcps < 1) ||
-					(signalTotalEventsRtn < 1) ||
-					(sigmaEstimate > cSigmaEstMax)) {
-				sigmaEstimate = cSigmaEstMax;
-			}
-
-			*pSigmaEstimate = (uint32_t)(sigmaEstimate);
-			PALDevDataSet(Dev, SigmaEstimate, *pSigmaEstimate);
-		}
-	}
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-}
-
-VL53L0_Error VL53L0_get_pal_range_status(VL53L0_DEV Dev,
-		uint8_t DeviceRangeStatus,
-		FixPoint1616_t SignalRate,
-		FixPoint1616_t CrosstalkCompensation,
-		uint16_t EffectiveSpadRtnCount,
-		VL53L0_RangingMeasurementData_t *pRangingMeasurementData,
-		uint8_t *pPalRangeStatus)
-{
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-	uint8_t tmpByte;
-	uint8_t SigmaLimitCheckEnable;
-	uint8_t SignalLimitCheckEnable;
-	FixPoint1616_t SigmaEstimate;
-	FixPoint1616_t SignalEstimate;
-	FixPoint1616_t SigmaLimitValue;
-	FixPoint1616_t SignalLimitValue;
-	uint8_t DeviceRangeStatusInternal = 0;
-
-	LOG_FUNCTION_START("");
-
-	/*
-	 * VL53L0 has a good ranging when the value of the
-	 * DeviceRangeStatus = 11. This function will replace
-	 * the value 0 with the value 11 in the DeviceRangeStatus.
-	 * In addition, the SigmaEstimator is not included in the
-	 * VL53L0 DeviceRangeStatus, this will be added in the
-	 * PalRangeStatus.
-	 */
-
-	DeviceRangeStatusInternal = ((DeviceRangeStatus & 0x78) >> 3);
-
-	if (DeviceRangeStatusInternal == 11)
-		tmpByte = 0;
-	else if (DeviceRangeStatusInternal == 0)
-		tmpByte = 11;
-	else
-		tmpByte = DeviceRangeStatusInternal;
-
-
-    /*
-     * Check if Sigma limit is enabled, if yes then do comparison with
-     * limit value and put the result back into pPalRangeStatus.
-     */
-	Status =  VL53L0_GetSigmaLimitCheckEnable(Dev,
-				VL53L0_CHECKPOSITION_EARLY,
-				&SigmaLimitCheckEnable);
-
-	if ((SigmaLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
-		/*
-		 * compute the Sigma and check with limit
-		 */
-		Status = VL53L0_calc_sigma_estimate(Dev,
-				pRangingMeasurementData, &SigmaEstimate);
-
-		if (Status == VL53L0_ERROR_NONE) {
-			Status = VL53L0_GetSigmaLimitValue(Dev,
-				VL53L0_CHECKPOSITION_EARLY, &SigmaLimitValue);
-
-			if ((SigmaLimitValue > 0) &&
-				(SigmaEstimate > SigmaLimitValue)) {
-				/* Limit Fail add 2^4 to range status */
-				tmpByte += 16;
-			}
-		}
-	}
-
-    /*
-	* Check if Signal limit is enabled, if yes then do comparison with
-	* limit value and put the result back into pPalRangeStatus.
-	*/
-	Status =  VL53L0_GetSignalLimitCheckEnable(Dev,
-		VL53L0_CHECKPOSITION_EARLY,	&SignalLimitCheckEnable);
-
-	if ((SignalLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
-		/*
-		* compute the Signal and check with limit
-		*/
-
-		SignalEstimate  = (FixPoint1616_t)(SignalRate -
-			(FixPoint1616_t)((EffectiveSpadRtnCount *
-			CrosstalkCompensation) >> 1));
-
-		PALDevDataSet(Dev, SignalEstimate, SignalEstimate);
-
-		Status = VL53L0_GetSignalLimitValue(Dev,
-			VL53L0_CHECKPOSITION_EARLY, &SignalLimitValue);
-
-		if ((SignalLimitValue > 0) && (SignalEstimate <
-			SignalLimitValue)) {
-			/* Limit Fail add 2^5 to range status */
-			tmpByte += 32;
-		}
-	}
-
-	if (Status == VL53L0_ERROR_NONE)
-		*pPalRangeStatus = tmpByte;
-
-
-
-	LOG_FUNCTION_END(Status);
-	return Status;
-
-}
+/*******************************************************************************
+ Copyright © 2015, STMicroelectronics International N.V.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in the
+ documentation and/or other materials provided with the distribution.
+ * Neither the name of STMicroelectronics nor the
+ names of its contributors may be used to endorse or promote products
+ derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
+ NON-INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS ARE DISCLAIMED.
+ IN NO EVENT SHALL STMICROELECTRONICS INTERNATIONAL N.V. BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ ********************************************************************************/
+
+#include "vl53l0_api.h"
+#include "vl53l0_tuning.h"
+#ifndef __KERNEL__
+#include <stdlib.h>
+#endif
+#define LOG_FUNCTION_START(fmt, ... ) \
+    _LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
+#define LOG_FUNCTION_END(status, ... ) \
+    _LOG_FUNCTION_END(TRACE_MODULE_API, status, ##__VA_ARGS__)
+#define LOG_FUNCTION_END_FMT(status, fmt, ... ) \
+    _LOG_FUNCTION_END_FMT(TRACE_MODULE_API, status, fmt, ##__VA_ARGS__)
+
+#ifdef VL53L0_LOG_ENABLE
+#define trace_print(level, ...) trace_print_module_function(TRACE_MODULE_API, \
+    level, TRACE_FUNCTION_NONE, ##__VA_ARGS__)
+#endif
+
+
+/* Defines */
+#define VL53L0_SETPARAMETERFIELD(Dev, field, value) \
+    if(Status==VL53L0_ERROR_NONE){ \
+        CurrentParameters = PALDevDataGet(Dev, CurrentParameters); \
+        CurrentParameters.field = value; \
+        CurrentParameters = \
+            PALDevDataSet(Dev, CurrentParameters, \
+                          CurrentParameters); }
+#define VL53L0_SETARRAYPARAMETERFIELD(Dev, field, index, value) \
+    if(Status==VL53L0_ERROR_NONE){ \
+        CurrentParameters = PALDevDataGet(Dev, CurrentParameters); \
+        CurrentParameters.field[index] = value; \
+        CurrentParameters = \
+            PALDevDataSet(Dev, CurrentParameters, \
+                          CurrentParameters); }
+
+#define VL53L0_GETPARAMETERFIELD(Dev, field, variable) \
+    if(Status==VL53L0_ERROR_NONE){ \
+        CurrentParameters = \
+            PALDevDataGet(Dev, CurrentParameters);  \
+        variable = CurrentParameters.field; }
+#define VL53L0_GETARRAYPARAMETERFIELD(Dev, field, index, variable) \
+    if(Status==VL53L0_ERROR_NONE){ \
+        CurrentParameters = \
+            PALDevDataGet(Dev, CurrentParameters);      \
+        variable = CurrentParameters.field[index]; }
+
+#define VL53L0_SETDEVICESPECIFICPARAMETER(Dev, field, value) \
+	if(Status==VL53L0_ERROR_NONE){ \
+		DeviceSpecificParameters = \
+            PALDevDataGet(Dev, DeviceSpecificParameters);   \
+		DeviceSpecificParameters.field = value; \
+		DeviceSpecificParameters = \
+            PALDevDataSet(Dev, DeviceSpecificParameters, \
+                          DeviceSpecificParameters); }
+#define VL53L0_GETDEVICESPECIFICPARAMETER(Dev, field) \
+		PALDevDataGet(Dev, DeviceSpecificParameters).field
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT97(Value) \
+            (uint16_t)((Value>>9)&0xFFFF)
+#define VL53L0_FIXPOINT97TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<9)
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT88(Value) \
+            (uint16_t)((Value>>8)&0xFFFF)
+#define VL53L0_FIXPOINT88TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<8)
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT412(Value) \
+            (uint16_t)((Value>>4)&0xFFFF)
+#define VL53L0_FIXPOINT412TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<4)
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT313(Value) \
+            (uint16_t)((Value>>3)&0xFFFF)
+#define VL53L0_FIXPOINT313TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<3)
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT08(Value) \
+            (uint8_t)((Value>>8)&0x00FF)
+#define VL53L0_FIXPOINT08TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<8)
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT53(Value) \
+            (uint8_t)((Value>>13)&0x00FF)
+#define VL53L0_FIXPOINT53TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<13)
+
+#define VL53L0_FIXPOINT1616TOFIXPOINT102(Value) \
+            (uint16_t)((Value>>14)&0x0FFF)
+#define VL53L0_FIXPOINT102TOFIXPOINT1616(Value) \
+            (FixPoint1616_t)(Value<<12)
+
+#define VL53L0_MAKEUINT16(lsb, msb) (uint16_t)((((uint16_t)msb)<<8) + \
+		(uint16_t)lsb)
+
+#define REF_ARRAY_SPAD_0  0
+#define REF_ARRAY_SPAD_5  5
+#define REF_ARRAY_SPAD_10 10
+
+uint32_t refArrayQuadrants[4] = {REF_ARRAY_SPAD_10, REF_ARRAY_SPAD_5,
+		REF_ARRAY_SPAD_0, REF_ARRAY_SPAD_5 };
+
+/* Internal functions declaration */
+VL53L0_Error VL53L0_get_vcsel_pulse_period(VL53L0_DEV Dev,
+		uint8_t* pVCSELPulsePeriod, uint8_t RangeIndex);
+uint8_t VL53L0_encode_vcsel_period(uint8_t vcsel_period_pclks);
+uint8_t VL53L0_decode_vcsel_period(uint8_t vcsel_period_reg);
+uint16_t VL53L0_calc_encoded_timeout(VL53L0_DEV Dev, uint32_t timeout_period_us,
+		uint8_t vcsel_period);
+uint32_t VL53L0_calc_ranging_wait_us(VL53L0_DEV Dev,
+		uint16_t timeout_overall_periods, uint8_t vcsel_period);
+VL53L0_Error VL53L0_check_part_used(VL53L0_DEV Dev, uint8_t* Revision,
+		VL53L0_DeviceInfo_t* pVL53L0_DeviceInfo);
+VL53L0_Error VL53L0_get_info_from_device(VL53L0_DEV Dev);
+VL53L0_Error VL53L0_device_read_strobe(VL53L0_DEV Dev);
+VL53L0_Error VL53L0_get_pal_range_status(VL53L0_DEV Dev,
+					 uint8_t DeviceRangeStatus,
+					 FixPoint1616_t SignalRate,
+					 FixPoint1616_t CrosstalkCompensation,
+					 uint16_t EffectiveSpadRtnCount,
+					 VL53L0_RangingMeasurementData_t *pRangingMeasurementData,
+					 uint8_t* pPalRangeStatus);
+VL53L0_Error VL53L0_measurement_poll_for_completion(VL53L0_DEV Dev);
+VL53L0_Error VL53L0_confirm_measurement_start(VL53L0_DEV Dev);
+VL53L0_Error VL53L0_start_histogram_measurement(VL53L0_DEV Dev,
+		VL53L0_HistogramModes histoMode, uint32_t count);
+VL53L0_Error VL53L0_read_histo_measurement(VL53L0_DEV Dev, uint32_t *histoData,
+		uint32_t offset, VL53L0_HistogramModes histoMode);
+VL53L0_Error VL53L0_reverse_bytes(uint8_t *data, uint32_t size);
+VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev,
+		uint8_t* pTuningSettingBuffer);
+VL53L0_Error enable_ref_spads(VL53L0_DEV Dev,
+                              uint8_t apertureSpads,
+                              uint8_t goodSpadArray[],
+                              uint8_t spadArray[],
+                              uint32_t size,
+                              uint32_t start,
+                              uint32_t offset,
+                              uint32_t minimumSpadCount,
+                              uint32_t *lastSpad);
+VL53L0_Error perform_ref_signal_measurement(VL53L0_DEV Dev,
+		uint16_t *refSignalRate);
+uint8_t is_aperture(uint32_t spadIndex);
+void get_next_good_spad(uint8_t array1[], uint32_t size, uint32_t current1,
+		int32_t *next);
+VL53L0_Error enable_spad_bit(uint8_t spadArray[], uint32_t size,
+		uint32_t spadIndex);
+VL53L0_Error set_ref_spad_map(VL53L0_DEV Dev, uint8_t *refSpadArray);
+VL53L0_Error get_ref_spad_map(VL53L0_DEV Dev, uint8_t *refSpadArray);
+VL53L0_Error VL53L0_apply_ref_spads(VL53L0_DEV Dev, uint8_t apertureSpads, uint32_t count);
+
+/* Group PAL General Functions */
+
+VL53L0_Error VL53L0_GetVersion(VL53L0_Version_t* pVersion) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    pVersion->major = VL53L0_IMPLEMENTATION_VER_MAJOR;
+    pVersion->minor = VL53L0_IMPLEMENTATION_VER_MINOR;
+    pVersion->build = VL53L0_IMPLEMENTATION_VER_SUB;
+
+    pVersion->revision = VL53L0_IMPLEMENTATION_VER_REVISION;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetPalSpecVersion(VL53L0_Version_t* pPalSpecVersion)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    pPalSpecVersion->major = VL53L0_SPECIFICATION_VER_MAJOR;
+    pPalSpecVersion->minor = VL53L0_SPECIFICATION_VER_MINOR;
+    pPalSpecVersion->build = VL53L0_SPECIFICATION_VER_SUB;
+
+    pPalSpecVersion->revision = VL53L0_SPECIFICATION_VER_REVISION;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceInfo(VL53L0_DEV Dev, VL53L0_DeviceInfo_t* pVL53L0_DeviceInfo) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t revision_id;
+    uint8_t Revision;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_check_part_used(Dev, &Revision, pVL53L0_DeviceInfo);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (Revision == 0) {
+            VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+            		VL53L0_STRING_DEVICE_INFO_NAME_TS0);
+        } else if ((Revision <= 34) && (Revision != 32)) {
+            VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+            		VL53L0_STRING_DEVICE_INFO_NAME_TS1);
+        } else if (Revision < 39) {
+            VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+            		VL53L0_STRING_DEVICE_INFO_NAME_TS2);
+        } else {
+            VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Name,
+            		VL53L0_STRING_DEVICE_INFO_NAME_ES1);
+        }
+
+        VL53L0_COPYSTRING(pVL53L0_DeviceInfo->Type,
+        		VL53L0_STRING_DEVICE_INFO_TYPE);
+
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_MODEL_ID,
+        		&pVL53L0_DeviceInfo->ProductType);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_IDENTIFICATION_REVISION_ID,
+        		&revision_id);
+        pVL53L0_DeviceInfo->ProductRevisionMajor = 1;
+        pVL53L0_DeviceInfo->ProductRevisionMinor = (revision_id & 0xF0) >> 4;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceErrorStatus(VL53L0_DEV Dev,
+		VL53L0_DeviceError* pDeviceErrorStatus)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t RangeStatus;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_RANGE_STATUS, &RangeStatus);
+
+    *pDeviceErrorStatus = (VL53L0_DeviceError)((RangeStatus & 0x78) >> 3);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+#define VL53L0_BUILDCASESTRING(BUFFER, CODE,STRINGVALUE) \
+    case CODE: \
+    VL53L0_COPYSTRING(BUFFER, STRINGVALUE); \
+    break;\
+
+VL53L0_Error VL53L0_GetDeviceErrorString(VL53L0_DeviceError ErrorCode,
+		char* pDeviceErrorString)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    switch (ErrorCode)
+    {
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_NONE,
+            VL53L0_STRING_DEVICEERROR_NONE);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_VCSELCONTINUITYTESTFAILURE,
+    		VL53L0_STRING_DEVICEERROR_VCSELCONTINUITYTESTFAILURE);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_VCSELWATCHDOGTESTFAILURE,
+    		VL53L0_STRING_DEVICEERROR_VCSELWATCHDOGTESTFAILURE);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_NOVHVVALUEFOUND,
+    		VL53L0_STRING_DEVICEERROR_NOVHVVALUEFOUND);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_MSRCNOTARGET,
+    		VL53L0_STRING_DEVICEERROR_MSRCNOTARGET);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_SNRCHECK,
+    		VL53L0_STRING_DEVICEERROR_SNRCHECK);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_RANGEPHASECHECK,
+    		VL53L0_STRING_DEVICEERROR_RANGEPHASECHECK);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_SIGMATHRESHOLDCHECK,
+    		VL53L0_STRING_DEVICEERROR_SIGMATHRESHOLDCHECK);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_TCC,
+    		VL53L0_STRING_DEVICEERROR_TCC);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_PHASECONSISTENCY,
+    		VL53L0_STRING_DEVICEERROR_PHASECONSISTENCY);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_MINCLIP,
+    		VL53L0_STRING_DEVICEERROR_MINCLIP);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_RANGECOMPLETE,
+    		VL53L0_STRING_DEVICEERROR_RANGECOMPLETE);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_ALGOUNDERFLOW,
+    		VL53L0_STRING_DEVICEERROR_ALGOUNDERFLOW);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+            VL53L0_DEVICEERROR_ALGOOVERFLOW,
+    		VL53L0_STRING_DEVICEERROR_ALGOOVERFLOW);
+    VL53L0_BUILDCASESTRING(pDeviceErrorString,
+    		VL53L0_DEVICEERROR_RANGEIGNORETHRESHOLD,
+    		VL53L0_STRING_DEVICEERROR_RANGEIGNORETHRESHOLD);
+    default:
+        VL53L0_COPYSTRING(pDeviceErrorString,
+            VL53L0_STRING_UNKNOW_ERROR_CODE);
+
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetPalErrorString(VL53L0_Error PalErrorCode,
+		char* pPalErrorString)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    switch (PalErrorCode)
+    {
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_NONE,
+            VL53L0_STRING_ERROR_NONE);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_CALIBRATION_WARNING,
+            VL53L0_STRING_ERROR_CALIBRATION_WARNING);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_MIN_CLIPPED,
+            VL53L0_STRING_ERROR_MIN_CLIPPED);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_UNDEFINED,
+            VL53L0_STRING_ERROR_UNDEFINED);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_INVALID_PARAMS,
+            VL53L0_STRING_ERROR_INVALID_PARAMS);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_NOT_SUPPORTED,
+            VL53L0_STRING_ERROR_NOT_SUPPORTED);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_RANGE_ERROR,
+            VL53L0_STRING_ERROR_RANGE_ERROR);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_TIME_OUT,
+            VL53L0_STRING_ERROR_TIME_OUT);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_MODE_NOT_SUPPORTED,
+            VL53L0_STRING_ERROR_MODE_NOT_SUPPORTED);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_NOT_IMPLEMENTED,
+            VL53L0_STRING_ERROR_NOT_IMPLEMENTED);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_BUFFER_TOO_SMALL,
+            VL53L0_STRING_ERROR_BUFFER_TOO_SMALL);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_GPIO_NOT_EXISTING,
+            VL53L0_STRING_ERROR_GPIO_NOT_EXISTING);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED,
+            VL53L0_STRING_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_DIVISION_BY_ZERO,
+            VL53L0_STRING_ERROR_DIVISION_BY_ZERO);
+    VL53L0_BUILDCASESTRING(pPalErrorString,
+            VL53L0_ERROR_CONTROL_INTERFACE,
+            VL53L0_STRING_ERROR_CONTROL_INTERFACE);
+    default:
+        VL53L0_COPYSTRING(pPalErrorString,
+                          VL53L0_STRING_UNKNOW_ERROR_CODE);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+VL53L0_Error VL53L0_GetPalState(VL53L0_DEV Dev, VL53L0_State* pPalState) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    *pPalState = PALDevDataGet(Dev, PalState);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes PowerMode) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    /* Only level1 of Power mode exists */
+    if ((PowerMode != VL53L0_POWERMODE_STANDBY_LEVEL1) &&
+        (PowerMode != VL53L0_POWERMODE_IDLE_LEVEL1)) {
+        Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+    } else if (PowerMode == VL53L0_POWERMODE_STANDBY_LEVEL1) {
+        /* set the standby level1 of power mode */
+        Status = VL53L0_WrByte(Dev, 0x80, 0x00);
+        if (Status == VL53L0_ERROR_NONE) {
+            /* Set PAL State to standby */
+            PALDevDataSet(Dev, PalState, VL53L0_STATE_STANDBY);
+            PALDevDataSet(Dev, PowerMode, VL53L0_POWERMODE_STANDBY_LEVEL1);
+        }
+
+    } else {
+        /* VL53L0_POWERMODE_IDLE_LEVEL1 */
+
+        Status = VL53L0_WrByte(Dev, 0x80, 0x00);
+        if (Status == VL53L0_ERROR_NONE) {
+            Status = VL53L0_StaticInit(Dev);
+        }
+        if (Status == VL53L0_ERROR_NONE) {
+            PALDevDataSet(Dev, PowerMode, VL53L0_POWERMODE_IDLE_LEVEL1);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetPowerMode(VL53L0_DEV Dev, VL53L0_PowerModes* pPowerMode) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte;
+    LOG_FUNCTION_START("");
+
+    /* Only level1 of Power mode exists */
+    Status = VL53L0_RdByte(Dev, 0x80, &Byte);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (Byte == 1) {
+            PALDevDataSet(Dev, PowerMode, VL53L0_POWERMODE_IDLE_LEVEL1);
+        } else {
+            PALDevDataSet(Dev, PowerMode, VL53L0_POWERMODE_STANDBY_LEVEL1);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
+		int32_t OffsetCalibrationDataMicroMeter)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    int16_t cMaxOffset = 1023;
+    int16_t cMinOffset = -1024;
+    int16_t cOffsetRange = 2048;
+    int16_t OffsetCalibrationDataMilliMeter =
+    		(OffsetCalibrationDataMicroMeter + 500)/1000;
+
+    LOG_FUNCTION_START("");
+
+    if(OffsetCalibrationDataMilliMeter > cMaxOffset)
+    {
+        OffsetCalibrationDataMilliMeter = cMaxOffset;
+    }
+    else if(OffsetCalibrationDataMilliMeter < cMinOffset)
+    {
+        OffsetCalibrationDataMilliMeter = cMinOffset;
+    }
+
+    if(OffsetCalibrationDataMilliMeter < 0)
+    {
+        /* Apply 10 bit 2's compliment conversion */
+        OffsetCalibrationDataMilliMeter += cOffsetRange;
+    }
+
+    Status = VL53L0_WrWord(Dev, VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET_MM,
+    		(uint16_t)(OffsetCalibrationDataMilliMeter << 2));
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetOffsetCalibrationDataMicroMeter(VL53L0_DEV Dev,
+		int32_t * pOffsetCalibrationDataMicroMeter)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t RangeOffsetRegister;
+    int16_t cMaxOffset = 1023;
+    int16_t cOffsetRange = 2048;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdWord(Dev,
+                           VL53L0_REG_ALGO_PART_TO_PART_RANGE_OFFSET_MM,
+                           &RangeOffsetRegister);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /*
+         * Remove fractional part. We don't expect the offset to be less than 1mm resolution
+         * as this is unrealistic.
+         */
+        
+        RangeOffsetRegister = ((RangeOffsetRegister & 0x0fff) + 0x02) >> 2;
+
+        /* Apply 10 bit 2's compliment conversion */
+        if(RangeOffsetRegister > cMaxOffset)
+        {
+            *pOffsetCalibrationDataMicroMeter =
+                (int16_t)(RangeOffsetRegister - cOffsetRange) * 1000;
+        }
+        else
+        {
+            *pOffsetCalibrationDataMicroMeter =
+                (int16_t)RangeOffsetRegister * 1000;
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetGroupParamHold(VL53L0_DEV Dev, uint8_t GroupParamHold) {
+    VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+    LOG_FUNCTION_START("");
+
+    /* not implemented on VL53L0 */
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetUpperLimitMilliMeter(VL53L0_DEV Dev, uint16_t* pUpperLimitMilliMeter) {
+    VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+    LOG_FUNCTION_START("");
+
+    /* not implemented on VL53L0 */
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+/* End Group PAL General Functions */
+
+/* Group PAL Init Functions */
+VL53L0_Error VL53L0_SetDeviceAddress(VL53L0_DEV Dev, uint8_t DeviceAddress) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_I2C_SLAVE_DEVICE_ADDRESS, DeviceAddress / 2);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_DataInit(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    int32_t OffsetCalibrationData;
+
+    int i;
+
+    LOG_FUNCTION_START("");
+
+    /* by default the I2C is running at 1V8 if you want to change it you
+     * need to include this define at compilation level. */
+#ifdef USE_I2C_2V8
+    Status = VL53L0_UpdateByte(Dev,
+                               VL53L0_REG_VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV,
+                               0xFE,
+                               0x01);
+#endif
+
+    /* Set I2C standard mode */
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev, 0x88, 0x00);
+
+    if (Status == VL53L0_ERROR_NONE) {
+		/* read device info */
+		VL53L0_SETDEVICESPECIFICPARAMETER(Dev, ReadDataFromDeviceDone, 0);
+
+		Status = VL53L0_get_info_from_device(Dev);
+    }
+
+    /* Set Default static parameters
+     *set first temporary values 11.3999MHz * 65536 = 748421 */
+    VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 748421);
+
+    /* Get default parameters */
+    Status = VL53L0_GetDeviceParameters(Dev, &CurrentParameters);
+    if (Status == VL53L0_ERROR_NONE) {
+        /* initialize PAL values */
+        CurrentParameters.DeviceMode = VL53L0_DEVICEMODE_SINGLE_RANGING;
+        CurrentParameters.HistogramMode = VL53L0_HISTOGRAMMODE_DISABLED;
+        PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
+    }
+
+    /* Sigma estimator variable */
+    PALDevDataSet(Dev, SigmaEstRefArray, 100);
+    PALDevDataSet(Dev, SigmaEstEffPulseWidth, 900);
+    PALDevDataSet(Dev, SigmaEstEffAmbWidth, 500);
+    PALDevDataSet(Dev, targetRefRate, 0x0A00); /* 20 MCPS in 9:7 format */
+
+    /* Use internal default settings */
+    PALDevDataSet(Dev, UseInternalTuningSettings, 1);
+
+    /* Enable all check */
+    for (i = 0; i < VL53L0_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
+		if (Status == VL53L0_ERROR_NONE) {
+				Status |= VL53L0_SetLimitCheckEnable(Dev, i, 1);
+			} else {
+				break;
+		}
+    }
+
+    /* Disable the following check */
+    if (Status == VL53L0_ERROR_NONE)
+    	Status = VL53L0_SetLimitCheckEnable(Dev,
+    			VL53L0_CHECKENABLE_SIGNAL_REF_CLIP, 0);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetLimitCheckValue(Dev,
+        		VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE,
+        		(FixPoint1616_t)(32<<16));
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetLimitCheckValue(Dev,
+        		VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
+    			(FixPoint1616_t)(25 * 65536 / 100));
+    			/* 0.25 * 65538 */
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetLimitCheckValue(Dev,
+        		VL53L0_CHECKENABLE_SIGNAL_REF_CLIP,
+    			(FixPoint1616_t)(35 * 65536));
+    }
+
+    /* Read back NVM offset */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetOffsetCalibrationDataMicroMeter(Dev,
+        		&OffsetCalibrationData);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L0_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters,
+        		OffsetCalibrationData)
+        PALDevDataSet(Dev, Part2PartOffsetNVMMicroMeter,
+        		OffsetCalibrationData);
+
+        PALDevDataSet(Dev, SequenceConfig, 0xFF);
+
+        /* Set PAL state to tell that we are waiting for call to
+         * VL53L0_StaticInit */
+        PALDevDataSet(Dev, PalState, VL53L0_STATE_WAIT_STATICINIT);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetTuningSettingBuffer(VL53L0_DEV Dev,
+		uint8_t* pTuningSettingBuffer, uint8_t UseInternalTuningSettings)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    if (UseInternalTuningSettings == 1) {
+        /* Force use internal settings */
+        PALDevDataSet(Dev, UseInternalTuningSettings, 1);
+    } else {
+
+        /* check that the first byte is not 0 */
+        if (*pTuningSettingBuffer != 0) {
+            PALDevDataSet(Dev, pTuningSettingsPointer, pTuningSettingBuffer);
+            PALDevDataSet(Dev, UseInternalTuningSettings, 0);
+
+        } else {
+            Status = VL53L0_ERROR_INVALID_PARAMS;
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetTuningSettingBuffer(VL53L0_DEV Dev,
+		uint8_t* pTuningSettingBuffer, uint8_t* pUseInternalTuningSettings)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    pTuningSettingBuffer = PALDevDataGet(Dev, pTuningSettingsPointer);
+    *pUseInternalTuningSettings = PALDevDataGet(Dev, UseInternalTuningSettings);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+
+VL53L0_Error VL53L0_StaticInit(VL53L0_DEV Dev)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t* pTuningSettingBuffer;
+    uint16_t tempword;
+    uint8_t  tempbyte;
+    uint8_t  UseInternalTuningSettings;
+    uint8_t ReferenceSpadCount; /* used for ref spad management */
+    uint8_t ReferenceSpadType;  /* used for ref spad management */
+
+    LOG_FUNCTION_START("");
+
+	/* this function do nothing if it has been called before */
+	Status = VL53L0_get_info_from_device(Dev);
+
+    if (Status == VL53L0_ERROR_NONE) {
+    	ReferenceSpadCount = VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
+    			ReferenceSpadCount);
+    	ReferenceSpadType = VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
+    			ReferenceSpadType);
+
+    	if ((Status == VL53L0_ERROR_NONE) && (ReferenceSpadCount >= 5)) {
+    	    VL53L0_apply_ref_spads(Dev, ReferenceSpadType, ReferenceSpadCount);
+    	}
+
+    }
+
+    /* Initialise tuning settings buffer to prevent compiler warning. */
+    pTuningSettingBuffer = DefaultTuningSettings;
+
+    if (Status == VL53L0_ERROR_NONE) {
+		UseInternalTuningSettings = PALDevDataGet(Dev,
+				UseInternalTuningSettings);
+
+		if (UseInternalTuningSettings == 0) {
+			pTuningSettingBuffer = PALDevDataGet(Dev, pTuningSettingsPointer);
+		} else {
+			pTuningSettingBuffer = DefaultTuningSettings;
+		}
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    	Status = VL53L0_load_tuning_settings(Dev, pTuningSettingBuffer);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_WrByte(Dev, 0x80, 0x00);
+    }
+
+    /* Set interrupt config to new sample ready */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetGpioConfig(Dev, 0, 0,
+                VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY,
+                VL53L0_INTERRUPTPOLARITY_LOW);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+        Status |= VL53L0_RdWord(Dev, 0x84, &tempword);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L0_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz,
+                VL53L0_FIXPOINT412TOFIXPOINT1616(tempword));
+    }
+
+    /* After static init, some device parameters may be changed, so update them */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetDeviceParameters(Dev, &CurrentParameters);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_RANGE_CONFIG, &tempbyte);
+        PALDevDataSet(Dev, RangeFractionalEnable, tempbyte);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
+    }
+
+    /* read the sequence config and save it */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev,
+                VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &tempbyte);
+        if (Status == VL53L0_ERROR_NONE) {
+            PALDevDataSet(Dev, SequenceConfig, tempbyte);
+    	}
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_PerformRefCalibration(Dev);
+    }
+
+    /* Set PAL State to standby */
+    if (Status == VL53L0_ERROR_NONE) {
+        PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_WaitDeviceBooted(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+    LOG_FUNCTION_START("");
+
+    /* not implemented on VL53L0 */
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_ResetDevice(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte;
+    LOG_FUNCTION_START("");
+
+    /* Set reset bit */
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N, 0x00);
+
+    /* Wait for some time */
+    if (Status == VL53L0_ERROR_NONE) {
+        do {
+            Status = VL53L0_RdByte(Dev,
+                    VL53L0_REG_IDENTIFICATION_MODEL_ID, &Byte);
+        } while (Byte != 0x00);
+    }
+
+    /* Release reset */
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SOFT_RESET_GO2_SOFT_RESET_N, 0x01);
+
+    /* Wait until correct boot-up of the device */
+    if (Status == VL53L0_ERROR_NONE) {
+        do {
+            Status = VL53L0_RdByte(Dev,
+                    VL53L0_REG_IDENTIFICATION_MODEL_ID, &Byte);
+        } while (Byte == 0x00);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+/* End Group PAL Init Functions */
+
+/* Group PAL Parameters Functions */
+VL53L0_Error VL53L0_SetDeviceParameters(VL53L0_DEV Dev,
+        const VL53L0_DeviceParameters_t* pDeviceParameters) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    int i;
+    LOG_FUNCTION_START("");
+    Status = VL53L0_SetDeviceMode(Dev, pDeviceParameters->DeviceMode);
+
+
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetHistogramMode(Dev, pDeviceParameters->HistogramMode);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetInterMeasurementPeriodMilliSeconds(Dev,
+                pDeviceParameters->InterMeasurementPeriodMilliSeconds);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetXTalkCompensationRateMegaCps(Dev,
+                pDeviceParameters->XTalkCompensationRateMegaCps);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetOffsetCalibrationDataMicroMeter(Dev,
+                pDeviceParameters->RangeOffsetMicroMeters);
+    }
+
+    for (i = 0; i < VL53L0_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
+        if (Status == VL53L0_ERROR_NONE) {
+            Status |= VL53L0_SetLimitCheckEnable(Dev, i,
+                    pDeviceParameters->LimitChecksEnable[i]);
+        } else {
+            break;
+        }
+        if (Status == VL53L0_ERROR_NONE) {
+            Status |= VL53L0_SetLimitCheckValue(Dev, i,
+                    pDeviceParameters->LimitChecksValue[i]);
+        } else {
+            break;
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetWrapAroundCheckEnable(Dev,
+                pDeviceParameters->WrapAroundCheckEnable);
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetMeasurementTimingBudgetMicroSeconds(Dev,
+                pDeviceParameters->MeasurementTimingBudgetMicroSeconds);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceParameters(VL53L0_DEV Dev,
+        VL53L0_DeviceParameters_t* pDeviceParameters) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    int i;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_GetDeviceMode(Dev, &(pDeviceParameters->DeviceMode));
+
+    if(Status==VL53L0_ERROR_NONE){
+       Status = VL53L0_GetHistogramMode(Dev,
+               &(pDeviceParameters->HistogramMode));
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetInterMeasurementPeriodMilliSeconds(Dev,
+                &(pDeviceParameters->InterMeasurementPeriodMilliSeconds));
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        pDeviceParameters->XTalkCompensationEnable = 0;
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetXTalkCompensationRateMegaCps(Dev,
+                &(pDeviceParameters->XTalkCompensationRateMegaCps));
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetOffsetCalibrationDataMicroMeter(Dev,
+                &(pDeviceParameters->RangeOffsetMicroMeters));
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        for (i = 0; i < VL53L0_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
+            /* get first the values, then the enables.
+             * VL53L0_GetLimitCheckValue will modify the enable flags
+             */
+            if (Status == VL53L0_ERROR_NONE) {
+                Status |= VL53L0_GetLimitCheckValue(Dev, i,
+                        &(pDeviceParameters->LimitChecksValue[i]));
+            } else {
+                break;
+            }
+            if (Status == VL53L0_ERROR_NONE) {
+                Status |= VL53L0_GetLimitCheckEnable(Dev, i,
+                        &(pDeviceParameters->LimitChecksEnable[i]));
+            } else {
+                break;
+            }
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetWrapAroundCheckEnable(Dev,
+                &(pDeviceParameters->WrapAroundCheckEnable));
+    }
+
+    /* Need to be done at the end as it uses VCSELPulsePeriod */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetMeasurementTimingBudgetMicroSeconds(Dev,
+                &(pDeviceParameters->MeasurementTimingBudgetMicroSeconds));
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetDeviceMode(VL53L0_DEV Dev,
+        VL53L0_DeviceModes DeviceMode) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+    LOG_FUNCTION_START("%d", (int)DeviceMode);
+
+    switch (DeviceMode) {
+    case VL53L0_DEVICEMODE_SINGLE_RANGING:
+    case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
+    case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
+    case VL53L0_DEVICEMODE_SINGLE_HISTOGRAM:
+    case VL53L0_DEVICEMODE_GPIO_DRIVE:
+    case VL53L0_DEVICEMODE_GPIO_OSC:
+        /* Supported modes */
+        VL53L0_SETPARAMETERFIELD(Dev, DeviceMode, DeviceMode);
+        break;
+    default:
+        /* Unsupported mode */
+        Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetDeviceMode(VL53L0_DEV Dev,
+        VL53L0_DeviceModes* pDeviceMode) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    LOG_FUNCTION_START("");
+
+    VL53L0_GETPARAMETERFIELD(Dev, DeviceMode, *pDeviceMode);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetHistogramMode(VL53L0_DEV Dev,
+        VL53L0_HistogramModes HistogramMode)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    LOG_FUNCTION_START("%d", (int)HistogramMode);
+
+    switch (HistogramMode)
+    {
+    case VL53L0_HISTOGRAMMODE_DISABLED:
+    case VL53L0_HISTOGRAMMODE_REFERENCE_ONLY:
+    case VL53L0_HISTOGRAMMODE_RETURN_ONLY:
+    case VL53L0_HISTOGRAMMODE_BOTH:
+        /* Supported mode */
+        VL53L0_SETPARAMETERFIELD(Dev, HistogramMode, HistogramMode);
+        break;
+    default:
+        /* Unsupported mode */
+        Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetHistogramMode(VL53L0_DEV Dev,
+    VL53L0_HistogramModes* pHistogramMode)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    LOG_FUNCTION_START("");
+
+    VL53L0_GETPARAMETERFIELD(Dev, HistogramMode, *pHistogramMode);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
+        uint32_t MeasurementTimingBudgetMicroSeconds)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    uint8_t CurrentVCSELPulsePeriod;
+    uint8_t CurrentVCSELPulsePeriodPClk;
+    uint32_t FinalRangeTimingBudgetMicroSeconds;
+    uint16_t encodedTimeOut;
+    uint32_t MinTimingBudgetMicroSeconds = 26000;
+    uint32_t PreRangeTimeoutMicroSeconds = 8000;
+    uint32_t DccAndTccTimeoutMicroSeconds = 6000;
+    uint32_t AdditionalOverheadsMicroSeconds = 5360;
+    uint32_t TotalAdditionalTimingMicroSeconds = PreRangeTimeoutMicroSeconds +
+    		DccAndTccTimeoutMicroSeconds + AdditionalOverheadsMicroSeconds;
+    LOG_FUNCTION_START("");
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (MeasurementTimingBudgetMicroSeconds < MinTimingBudgetMicroSeconds) {
+            Status = VL53L0_ERROR_INVALID_PARAMS;
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_get_vcsel_pulse_period(Dev,
+        		&CurrentVCSELPulsePeriodPClk, 1);
+        if (Status == VL53L0_ERROR_NONE) {
+
+            CurrentVCSELPulsePeriod =
+            		VL53L0_encode_vcsel_period(CurrentVCSELPulsePeriodPClk);
+
+            FinalRangeTimingBudgetMicroSeconds =
+            		MeasurementTimingBudgetMicroSeconds -
+            		TotalAdditionalTimingMicroSeconds;
+
+            encodedTimeOut = VL53L0_calc_encoded_timeout(Dev,
+            		FinalRangeTimingBudgetMicroSeconds,
+            		(uint8_t) CurrentVCSELPulsePeriod);
+
+            VL53L0_SETPARAMETERFIELD(Dev, MeasurementTimingBudgetMicroSeconds,
+            		MeasurementTimingBudgetMicroSeconds);
+            VL53L0_SETDEVICESPECIFICPARAMETER(Dev, LastEncodedTimeout,
+            		encodedTimeOut);
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_WrWord(Dev,
+        		VL53L0_REG_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI,
+        		encodedTimeOut);
+    }
+
+    LOG_FUNCTION_END(Status);
+
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetMeasurementTimingBudgetMicroSeconds(VL53L0_DEV Dev,
+		uint32_t* pMeasurementTimingBudgetMicroSeconds)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t CurrentVCSELPulsePeriod;
+    uint8_t CurrentVCSELPulsePeriodPClk;
+    uint16_t encodedTimeOut;
+    uint32_t FinalRangeTimeoutMicroSeconds;
+    uint32_t PreRangeTimeoutMicroSeconds = 8000;
+    uint32_t DccAndTccTimeoutMicroSeconds = 6000;
+    uint32_t AdditionalOverheadsMicroSeconds = 5360;
+    uint32_t TotalAdditionalTimingMicroSeconds = PreRangeTimeoutMicroSeconds +
+    		DccAndTccTimeoutMicroSeconds + AdditionalOverheadsMicroSeconds;
+
+    LOG_FUNCTION_START("");
+
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L0_get_vcsel_pulse_period(Dev, &CurrentVCSELPulsePeriodPClk, 1);
+        CurrentVCSELPulsePeriod =
+        		VL53L0_encode_vcsel_period(CurrentVCSELPulsePeriodPClk);
+
+        /* Read from register */
+        Status = VL53L0_RdWord(Dev,
+        		VL53L0_REG_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI,
+        		&encodedTimeOut);
+        if (Status == VL53L0_ERROR_NONE) {
+            FinalRangeTimeoutMicroSeconds = VL53L0_calc_ranging_wait_us(Dev,
+            		encodedTimeOut, CurrentVCSELPulsePeriod);
+
+            *pMeasurementTimingBudgetMicroSeconds =
+            		FinalRangeTimeoutMicroSeconds +
+            		TotalAdditionalTimingMicroSeconds;
+            VL53L0_SETPARAMETERFIELD(Dev, MeasurementTimingBudgetMicroSeconds,
+            		*pMeasurementTimingBudgetMicroSeconds);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
+		uint32_t InterMeasurementPeriodMilliSeconds)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint16_t osc_calibrate_val;
+    uint32_t IMPeriodMilliSeconds;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdWord(Dev, VL53L0_REG_OSC_CALIBRATE_VAL,
+    		&osc_calibrate_val);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (osc_calibrate_val !=0) {
+            IMPeriodMilliSeconds =
+            		InterMeasurementPeriodMilliSeconds*osc_calibrate_val;
+        } else {
+            IMPeriodMilliSeconds = InterMeasurementPeriodMilliSeconds;
+        }
+        Status = VL53L0_WrDWord(Dev,
+        		VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
+        		IMPeriodMilliSeconds);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L0_SETPARAMETERFIELD(Dev, InterMeasurementPeriodMilliSeconds,
+        		InterMeasurementPeriodMilliSeconds);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetInterMeasurementPeriodMilliSeconds(VL53L0_DEV Dev,
+		uint32_t* pInterMeasurementPeriodMilliSeconds)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint16_t osc_calibrate_val;
+    uint32_t IMPeriodMilliSeconds;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdWord(Dev, VL53L0_REG_OSC_CALIBRATE_VAL,
+    		&osc_calibrate_val);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdDWord(Dev, VL53L0_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
+        		&IMPeriodMilliSeconds);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (osc_calibrate_val !=0) {
+            *pInterMeasurementPeriodMilliSeconds = IMPeriodMilliSeconds /
+            		osc_calibrate_val;
+        }
+        VL53L0_SETPARAMETERFIELD(Dev, InterMeasurementPeriodMilliSeconds,
+        		*pInterMeasurementPeriodMilliSeconds);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetXTalkCompensationEnable(VL53L0_DEV Dev,
+		uint8_t XTalkCompensationEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    FixPoint1616_t TempFix1616;
+
+    LOG_FUNCTION_START("");
+
+    if (XTalkCompensationEnable == 0) {
+        TempFix1616 = 0;
+    } else {
+        VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+        		TempFix1616);
+    }
+
+    /* the following register has a format 3.13 */
+    Status = VL53L0_WrWord(Dev,
+                           VL53L0_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS,
+                           VL53L0_FIXPOINT1616TOFIXPOINT313(TempFix1616));
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (XTalkCompensationEnable == 0) {
+            VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, 0);
+        } else {
+            VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, 1);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetXTalkCompensationEnable(VL53L0_DEV Dev,
+              uint8_t* pXTalkCompensationEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t Temp8;
+    LOG_FUNCTION_START("");
+
+    VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp8);
+    *pXTalkCompensationEnable = Temp8;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
+              FixPoint1616_t XTalkCompensationRateMegaCps)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t Temp8;
+    LOG_FUNCTION_START("");
+
+    VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp8);
+
+    if (Temp8 == 0) { /* disabled write only internal value */
+        VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps, XTalkCompensationRateMegaCps);
+    } else {
+        /* the following register has a format 3.13 */
+        Status = VL53L0_WrWord(Dev,
+                               VL53L0_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS,
+                               VL53L0_FIXPOINT1616TOFIXPOINT412(XTalkCompensationRateMegaCps));
+        if (Status == VL53L0_ERROR_NONE) {
+            VL53L0_SETPARAMETERFIELD(Dev,
+                                     XTalkCompensationRateMegaCps,
+                                     XTalkCompensationRateMegaCps);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetXTalkCompensationRateMegaCps(VL53L0_DEV Dev,
+		FixPoint1616_t* pXTalkCompensationRateMegaCps)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t Value;
+    FixPoint1616_t TempFix1616;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdWord(Dev,
+    		VL53L0_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS,
+    		(uint16_t*) &Value);
+    if (Status == VL53L0_ERROR_NONE) {
+        if (Value == 0) { /* the Xtalk is disabled return value from memory */
+            VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+            		TempFix1616);
+            *pXTalkCompensationRateMegaCps = TempFix1616;
+            VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, 0);
+        } else {
+            TempFix1616 = VL53L0_FIXPOINT412TOFIXPOINT1616(Value);
+            *pXTalkCompensationRateMegaCps = TempFix1616;
+            VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+            		TempFix1616);
+            VL53L0_SETPARAMETERFIELD(Dev, XTalkCompensationEnable, 1);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+/*
+ * CHECK LIMIT FUNCTIONS
+ */
+
+VL53L0_Error VL53L0_GetNumberOfLimitCheck(uint16_t* pNumberOfLimitCheck) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    *pNumberOfLimitCheck = VL53L0_CHECKENABLE_NUMBER_OF_CHECKS;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetLimitCheckInfo(VL53L0_DEV Dev, uint16_t LimitCheckId,
+		char* pLimitCheckString)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    switch (LimitCheckId)
+    {
+    VL53L0_BUILDCASESTRING(pLimitCheckString,
+    		VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE,
+    		VL53L0_STRING_CHECKENABLE_SIGMA_FINAL_RANGE);
+
+    VL53L0_BUILDCASESTRING(pLimitCheckString,
+    		VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
+    		VL53L0_STRING_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE);
+
+    VL53L0_BUILDCASESTRING(pLimitCheckString,
+    		VL53L0_CHECKENABLE_SIGNAL_REF_CLIP,
+    		VL53L0_STRING_CHECKENABLE_SIGNAL_REF_CLIP);
+
+    default:
+        VL53L0_COPYSTRING(pLimitCheckString, VL53L0_STRING_UNKNOW_ERROR_CODE);
+
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
+		uint8_t LimitCheckEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    FixPoint1616_t TempFix1616 = 0;
+    uint8_t LimitCheckEnableInt;
+
+    LOG_FUNCTION_START("");
+
+    if (LimitCheckId >= VL53L0_CHECKENABLE_NUMBER_OF_CHECKS) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    } else {
+        if (LimitCheckEnable == 0) {
+            TempFix1616 = 0;
+            LimitCheckEnableInt = 0;
+        } else {
+            VL53L0_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+            		LimitCheckId, TempFix1616);
+            /* this to be sure to have either 0 or 1 */
+            LimitCheckEnableInt = 1;
+        }
+
+        switch (LimitCheckId) {
+
+		case VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE:
+			/* internal computation: */
+			VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+					VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE, LimitCheckEnableInt);
+
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
+
+			Status = VL53L0_WrWord(Dev,
+					VL53L0_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT,
+					VL53L0_FIXPOINT1616TOFIXPOINT97(TempFix1616));
+
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_REF_CLIP:
+
+			/* internal computation: */
+			VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+					VL53L0_CHECKENABLE_SIGNAL_REF_CLIP, LimitCheckEnableInt);
+
+			break;
+
+		default:
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+
+        }
+
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (LimitCheckEnable == 0) {
+            VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+            		LimitCheckId, 0);
+        } else {
+            VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+            		LimitCheckId, 1);
+    }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+VL53L0_Error VL53L0_GetLimitCheckEnable(VL53L0_DEV Dev, uint16_t LimitCheckId,
+		uint8_t *pLimitCheckEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t Temp8;
+
+    LOG_FUNCTION_START("");
+
+    if (LimitCheckId >= VL53L0_CHECKENABLE_NUMBER_OF_CHECKS) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    }
+
+    VL53L0_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable, LimitCheckId, Temp8);
+    *pLimitCheckEnable = Temp8;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+
+VL53L0_Error VL53L0_SetLimitCheckValue(VL53L0_DEV Dev, uint16_t LimitCheckId,
+		FixPoint1616_t LimitCheckValue)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t Temp8;
+
+    LOG_FUNCTION_START("");
+
+    VL53L0_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable, LimitCheckId, Temp8);
+
+    if (Temp8 == 0) { /* disabled write only internal value */
+        VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue, LimitCheckId,
+        		LimitCheckValue);
+    } else {
+
+        switch (LimitCheckId) {
+
+		case VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE:
+			/* internal computation: */
+			VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+					VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE, LimitCheckValue);
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
+
+			Status = VL53L0_WrWord(Dev,
+					VL53L0_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT,
+					VL53L0_FIXPOINT1616TOFIXPOINT97(LimitCheckValue));
+
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_REF_CLIP:
+
+			/* internal computation: */
+			VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+					VL53L0_CHECKENABLE_SIGNAL_REF_CLIP, LimitCheckValue);
+
+			break;
+
+		default:
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+            VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue, LimitCheckId,
+            		LimitCheckValue);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+VL53L0_Error VL53L0_GetLimitCheckValue(VL53L0_DEV Dev, uint16_t LimitCheckId,
+		FixPoint1616_t *pLimitCheckValue)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint8_t EnableZeroValue = 0;
+    uint16_t Temp16;
+    FixPoint1616_t TempFix1616;
+
+    LOG_FUNCTION_START("");
+
+    switch (LimitCheckId) {
+
+	case VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE:
+		/* internal computation: */
+		VL53L0_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+				VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE, TempFix1616);
+		EnableZeroValue = 0;
+		break;
+
+	case VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
+		Status = VL53L0_RdWord(Dev,
+				VL53L0_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT,
+				&Temp16);
+		if (Status == VL53L0_ERROR_NONE) {
+			TempFix1616 = VL53L0_FIXPOINT97TOFIXPOINT1616(Temp16);
+		}
+
+		EnableZeroValue = 1;
+		break;
+
+	case VL53L0_CHECKENABLE_SIGNAL_REF_CLIP:
+		/* internal computation: */
+		VL53L0_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+				VL53L0_CHECKENABLE_SIGNAL_REF_CLIP, TempFix1616);
+		EnableZeroValue = 0;
+		break;
+
+	default:
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+
+        if (EnableZeroValue == 1) {
+
+            if (TempFix1616 == 0) { /* disabled: return value from memory */
+                VL53L0_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+                		LimitCheckId, TempFix1616);
+                *pLimitCheckValue = TempFix1616;
+                VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+                		LimitCheckId, 0);
+            } else {
+                *pLimitCheckValue = TempFix1616;
+                VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
+                		LimitCheckId, TempFix1616);
+                VL53L0_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
+                		LimitCheckId, 1);
+            }
+        } else {
+            *pLimitCheckValue = TempFix1616;
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+
+}
+
+VL53L0_Error VL53L0_GetLimitCheckCurrent(VL53L0_DEV Dev,
+		uint16_t LimitCheckId, FixPoint1616_t *pLimitCheckCurrent)
+{
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_RangingMeasurementData_t LastRangeDataBuffer;
+
+	LOG_FUNCTION_START("");
+
+	if (LimitCheckId >= VL53L0_CHECKENABLE_NUMBER_OF_CHECKS) {
+		Status = VL53L0_ERROR_INVALID_PARAMS;
+	} else {
+		switch (LimitCheckId) {
+		case VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE:
+			/* Need to run a ranging to have the latest values */
+			*pLimitCheckCurrent = PALDevDataGet(Dev, SigmaEstimate);
+
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
+			/* Need to run a ranging to have the latest values */
+			LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
+			*pLimitCheckCurrent = LastRangeDataBuffer.SignalRateRtnMegaCps;
+
+			break;
+
+		case VL53L0_CHECKENABLE_SIGNAL_REF_CLIP:
+			/* Need to run a ranging to have the latest values */
+			*pLimitCheckCurrent = PALDevDataGet(Dev, LastSignalRefMcps);
+
+			break;
+
+		default:
+			Status = VL53L0_ERROR_INVALID_PARAMS;
+		}
+	}
+
+	LOG_FUNCTION_END(Status);
+	return Status;
+
+}
+
+
+/*
+ * WRAPAROUND Check
+ */
+VL53L0_Error VL53L0_SetWrapAroundCheckEnable(VL53L0_DEV Dev,
+		uint8_t WrapAroundCheckEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte;
+    uint8_t WrapAroundCheckEnableInt;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &Byte);
+    if (WrapAroundCheckEnable == 0) {
+        /* Disable wraparound */
+        Byte = Byte & 0x7F;
+        WrapAroundCheckEnableInt = 0;
+    } else {
+        /*Enable wraparound */
+        Byte = Byte | 0x80;
+		WrapAroundCheckEnableInt = 1;
+    }
+
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, Byte);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        PALDevDataSet(Dev, SequenceConfig, Byte);
+        VL53L0_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
+        		WrapAroundCheckEnableInt);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetWrapAroundCheckEnable(VL53L0_DEV Dev,
+		uint8_t* pWrapAroundCheckEnable)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t data;
+    VL53L0_DeviceParameters_t CurrentParameters;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, &data);
+    if (Status == VL53L0_ERROR_NONE) {
+        PALDevDataSet(Dev, SequenceConfig, data);
+        if (data & (0x01 << 7)) {
+            *pWrapAroundCheckEnable = 0x01;
+        } else {
+            *pWrapAroundCheckEnable = 0x00;
+        }
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L0_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
+        		*pWrapAroundCheckEnable);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+/* End Group PAL Parameters Functions */
+
+ /* Group PAL Measurement Functions */
+VL53L0_Error VL53L0_PerformSingleMeasurement(VL53L0_DEV Dev)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceModes DeviceMode;
+
+    LOG_FUNCTION_START("");
+
+    /* Get Current DeviceMode */
+    Status = VL53L0_GetDeviceMode(Dev, &DeviceMode);
+
+    /* Start immediately to run a single ranging measurement in case of single
+     * ranging or single histogram */
+    if (Status     == VL53L0_ERROR_NONE &&
+        DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING)
+    {
+        Status = VL53L0_StartMeasurement(Dev);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_measurement_poll_for_completion(Dev);
+    }
+
+    /* Change PAL State in case of single ranging or single histogram */
+    if (Status     == VL53L0_ERROR_NONE &&
+        DeviceMode == VL53L0_DEVICEMODE_SINGLE_RANGING)
+    {
+        PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_PerformSingleHistogramMeasurement(VL53L0_DEV Dev,
+		VL53L0_HistogramMeasurementData_t* pHistogramMeasurementData)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceModes DeviceMode;
+    VL53L0_HistogramModes HistogramMode = VL53L0_HISTOGRAMMODE_DISABLED;
+    uint32_t MeasCount;
+    uint32_t Measurements;
+
+    /* Get Current DeviceMode */
+    Status = VL53L0_GetHistogramMode(Dev, &HistogramMode);
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        if(HistogramMode == VL53L0_HISTOGRAMMODE_BOTH)
+        {
+            if(pHistogramMeasurementData->BufferSize < VL53L0_HISTOGRAM_BUFFER_SIZE)
+            {
+                Status = VL53L0_ERROR_BUFFER_TOO_SMALL;
+            }
+        }
+        else
+        {
+            if(pHistogramMeasurementData->BufferSize < VL53L0_HISTOGRAM_BUFFER_SIZE/2)
+            {
+                Status = VL53L0_ERROR_BUFFER_TOO_SMALL;
+            }
+        }
+        pHistogramMeasurementData->HistogramType = (uint8_t)HistogramMode;
+        pHistogramMeasurementData->ErrorStatus   = VL53L0_DEVICEERROR_NONE;
+        pHistogramMeasurementData->FirstBin      = 0;
+        pHistogramMeasurementData->NumberOfBins  = 0;
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        /* Get Current DeviceMode */
+        Status = VL53L0_GetDeviceMode(Dev, &DeviceMode);
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_HISTOGRAM_BIN, 0x00);
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT, 0x00);
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_HISTOGRAM_CONFIG_READOUT_CTRL, 0x01);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Measurements = 3;
+        if(HistogramMode == VL53L0_HISTOGRAMMODE_BOTH)
+        {
+            Measurements = 6;
+        }
+
+        if(DeviceMode == VL53L0_DEVICEMODE_SINGLE_HISTOGRAM)
+        {
+            MeasCount = 0;
+            while((MeasCount < Measurements) && (Status == VL53L0_ERROR_NONE))
+            {
+                Status = VL53L0_start_histogram_measurement(Dev, HistogramMode,
+                		MeasCount);
+
+                if (Status == VL53L0_ERROR_NONE)
+                    VL53L0_confirm_measurement_start(Dev);
+
+                if (Status == VL53L0_ERROR_NONE)
+                    PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+
+                if (Status == VL53L0_ERROR_NONE)
+                    Status = VL53L0_measurement_poll_for_completion(Dev);
+
+                if (Status == VL53L0_ERROR_NONE)
+                {
+                    Status = VL53L0_read_histo_measurement(Dev,
+								   pHistogramMeasurementData->HistogramData,
+								   MeasCount,
+								   HistogramMode);
+                    if(Status==VL53L0_ERROR_NONE)
+                    {
+                        /*
+                         * When reading both rtn and ref arrays, histograms
+                         * are read two bins at a time. For rtn or ref only,
+                         * histograms are read four bins at a time.
+                         */
+                        if(HistogramMode == VL53L0_HISTOGRAMMODE_BOTH)
+                            pHistogramMeasurementData->NumberOfBins+= 2;
+                        else
+                            pHistogramMeasurementData->NumberOfBins+= 4;
+
+                    }
+                }
+
+                if(Status==VL53L0_ERROR_NONE)
+                    Status = VL53L0_ClearInterruptMask(Dev, 0);
+
+                MeasCount++;
+            }
+        } else {
+            Status = VL53L0_ERROR_INVALID_COMMAND;
+        }
+    }
+
+
+    /* Change PAL State in case of single ranging or single histogram */
+    if (Status     == VL53L0_ERROR_NONE)
+    {
+        pHistogramMeasurementData->NumberOfBins = 12;
+        PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+    }
+
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_measurement_poll_for_completion(VL53L0_DEV Dev){
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t NewDataReady=0;
+    uint32_t LoopNb;
+
+    LOG_FUNCTION_START("");
+
+    LoopNb = 0;
+    do {
+        Status = VL53L0_GetMeasurementDataReady(Dev, &NewDataReady);
+        VL53L0_PollingDelay(Dev);
+        LoopNb++;
+    } while((NewDataReady == 0 ) &&
+            (Status == VL53L0_ERROR_NONE) &&
+            (LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+
+    LOG_FUNCTION_END(Status);
+
+    return Status;
+}
+
+VL53L0_Error VL53L0_confirm_measurement_start(VL53L0_DEV Dev){
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t NewDataReady=0;
+    uint32_t LoopNb;
+
+    LOG_FUNCTION_START("");
+
+    LoopNb = 0;
+    do {
+        Status = VL53L0_GetMeasurementDataReady(Dev, &NewDataReady);
+        if ((NewDataReady == 0x01) || Status != VL53L0_ERROR_NONE) {
+            break;
+        }
+        LoopNb = LoopNb + 1;
+        VL53L0_PollingDelay(Dev);
+    } while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+    if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP) {
+        Status = VL53L0_ERROR_TIME_OUT;
+    }
+
+    LOG_FUNCTION_END(Status);
+
+    return Status;
+}
+
+VL53L0_Error VL53L0_perform_single_ref_calibration(VL53L0_DEV Dev)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte = 0;
+    uint32_t LoopNb;
+
+    LOG_FUNCTION_START("");
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START,
+        		VL53L0_REG_SYSRANGE_MODE_START_STOP);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /* Wait until start bit has been cleared */
+        LoopNb = 0;
+        do {
+            if (LoopNb > 0)
+                Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSRANGE_START, &Byte);
+            LoopNb = LoopNb + 1;
+        } while (((Byte & VL53L0_REG_SYSRANGE_MODE_START_STOP) ==
+        		VL53L0_REG_SYSRANGE_MODE_START_STOP) &&
+                  (Status == VL53L0_ERROR_NONE) &&
+                  (LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_measurement_poll_for_completion(Dev);
+    }
+    if(Status==VL53L0_ERROR_NONE){
+        Status = VL53L0_ClearInterruptMask(Dev, 0);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_PerformRefCalibration(VL53L0_DEV Dev)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t SequenceConfig = 0;
+
+    LOG_FUNCTION_START("");
+
+    /* store the value of the sequence config,
+     * this will be reset before the end of the function
+     */
+
+    SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
+
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, 0x03);
+
+    /* Run VHV */
+    PALDevDataSet(Dev, SequenceConfig, 0x01);
+
+    if(Status==VL53L0_ERROR_NONE)
+    	Status = VL53L0_perform_single_ref_calibration(Dev);
+
+    /* Run PhaseCal */
+    PALDevDataSet(Dev, SequenceConfig, 0x02);
+
+    if(Status==VL53L0_ERROR_NONE)
+    	Status = VL53L0_perform_single_ref_calibration(Dev);
+
+    if(Status==VL53L0_ERROR_NONE){
+        /* restore the previous Sequence Config */
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG,
+        		SequenceConfig);
+		if(Status==VL53L0_ERROR_NONE){
+			PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
+		}
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_API VL53L0_Error VL53L0_PerformXTalkCalibration(VL53L0_DEV Dev,
+            FixPoint1616_t XTalkCalDistance,
+            FixPoint1616_t* pXTalkCompensationRateMegaCps) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t sum_ranging = 0;
+    uint16_t sum_spads =0;
+    FixPoint1616_t sum_signalRate = 0;
+    FixPoint1616_t total_count = 0;
+    uint8_t xtalk_meas = 0;
+    VL53L0_RangingMeasurementData_t RangingMeasurementData;
+    FixPoint1616_t xTalkStoredMeanSignalRate;
+    FixPoint1616_t xTalkStoredMeanRange;
+    FixPoint1616_t xTalkStoredMeanRtnSpads;
+    uint32_t signalXTalkTotalPerSpad;
+    uint32_t xTalkStoredMeanRtnSpadsAsInt;
+    uint32_t xTalkCalDistanceAsInt;
+    FixPoint1616_t XTalkCompensationRateMegaCps;
+    LOG_FUNCTION_START("");
+
+    if (XTalkCalDistance<=0) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    }
+
+    /* Disable the XTalk compensation */
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_SetXTalkCompensationEnable(Dev, 0);
+    }
+
+    /* Perform 50 measurements and compute the averages */
+    if (Status == VL53L0_ERROR_NONE) {
+        sum_ranging = 0;
+        sum_spads =0;
+        sum_signalRate = 0;
+        total_count = 0;
+        for(xtalk_meas=0;xtalk_meas<50;xtalk_meas++)
+        {
+            Status = VL53L0_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);
+
+            if (Status != VL53L0_ERROR_NONE) {
+                break;
+            }
+
+            /* The range is valid when RangeStatus = 0 */
+            if (RangingMeasurementData.RangeStatus == 0) {
+                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;
+                sum_signalRate = sum_signalRate + RangingMeasurementData.SignalRateRtnMegaCps;
+                sum_spads = sum_spads + RangingMeasurementData.EffectiveSpadRtnCount/32;
+                total_count = total_count + 1;
+            }
+        }
+
+        if (total_count == 0) {
+            /* no valid values found */
+            Status = VL53L0_ERROR_RANGE_ERROR;
+        }
+    }
+
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /* FixPoint1616_t / uint16_t = FixPoint1616_t */
+        xTalkStoredMeanSignalRate = sum_signalRate / total_count;
+        xTalkStoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);
+        xTalkStoredMeanRtnSpads = (FixPoint1616_t)((uint32_t)(sum_spads<<16) / total_count);
+
+        /* Round Mean Spads to Whole Number.
+         * Typically the calculated mean SPAD count is a whole number or very close to a whole
+         * number, therefore any truncation will not result in a significant loss in accuracy.
+         * Also, for a grey target at a typical distance of around 400mm, around 220 SPADs will
+         * be enabled, therefore, any truncation will result in a loss of accuracy of less than
+         * 0.5%.
+         */
+        xTalkStoredMeanRtnSpadsAsInt = (xTalkStoredMeanRtnSpads + 0x8000) >> 16;
+
+        /* Round Cal Distance to Whole Number.
+         * Note that the cal distance is in mm, therefore no resolution is lost.*/
+         xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >> 16;
+
+        if(xTalkStoredMeanRtnSpadsAsInt == 0 ||
+           xTalkCalDistanceAsInt == 0 ||
+           xTalkStoredMeanRange >= XTalkCalDistance)
+        {
+            XTalkCompensationRateMegaCps = 0;
+        }
+        else
+        {
+            /* Round Cal Distance to Whole Number.
+               Note that the cal distance is in mm, therefore no resolution is lost.*/
+            xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >> 16;
+
+            /* Apply division by mean spad count early in the calculation to keep the numbers small.
+             * This ensures we can maintain a 32bit calculation.
+             * Fixed1616 / int := Fixed1616 */
+            signalXTalkTotalPerSpad = (xTalkStoredMeanSignalRate)/xTalkStoredMeanRtnSpadsAsInt;
+
+            /* Complete the calculation for total Signal XTalk per SPAD
+             * Fixed1616 * (Fixed1616 - Fixed1616/int) := (2^16 * Fixed1616)
+             */
+            signalXTalkTotalPerSpad *= ((1<<16) - (xTalkStoredMeanRange/xTalkCalDistanceAsInt));
+
+            /* Round from 2^16 * Fixed1616, to Fixed1616. */
+            XTalkCompensationRateMegaCps = (signalXTalkTotalPerSpad + 0x8000) >> 16;
+        }
+
+        *pXTalkCompensationRateMegaCps = XTalkCompensationRateMegaCps;
+
+        /* Enable the XTalk compensation */
+        if (Status == VL53L0_ERROR_NONE) {
+            Status = VL53L0_SetXTalkCompensationEnable(Dev, 1);
+        }
+
+        /* Enable the XTalk compensation */
+        if (Status == VL53L0_ERROR_NONE) {
+            Status = VL53L0_SetXTalkCompensationRateMegaCps(Dev, XTalkCompensationRateMegaCps);
+        }
+
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_API VL53L0_Error VL53L0_PerformOffsetCalibration(VL53L0_DEV Dev,
+            FixPoint1616_t CalDistanceMilliMeter,
+            int32_t* pOffsetMicroMeter) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t sum_ranging = 0;
+    FixPoint1616_t total_count = 0;
+    VL53L0_RangingMeasurementData_t RangingMeasurementData;
+    FixPoint1616_t StoredMeanRange;
+    uint32_t StoredMeanRangeAsInt;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    uint32_t CalDistanceAsInt_mm;
+    int meas = 0;
+    LOG_FUNCTION_START("");
+
+    if (CalDistanceMilliMeter<=0) {
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        VL53L0_SetOffsetCalibrationDataMicroMeter(Dev, 0);
+    }
+
+    /* Perform 50 measurements and compute the averages */
+    if (Status == VL53L0_ERROR_NONE) {
+        sum_ranging = 0;
+        total_count = 0;
+        for(meas=0;meas<50;meas++)
+        {
+            Status = VL53L0_PerformSingleRangingMeasurement(Dev, &RangingMeasurementData);
+
+            if (Status != VL53L0_ERROR_NONE) {
+                break;
+            }
+
+            /* The range is valid when RangeStatus = 0 */
+            if (RangingMeasurementData.RangeStatus == 0) {
+                sum_ranging = sum_ranging + RangingMeasurementData.RangeMilliMeter;
+                total_count = total_count + 1;
+            }
+        }
+
+        if (total_count == 0) {
+            /* no valid values found */
+            Status = VL53L0_ERROR_RANGE_ERROR;
+        }
+    }
+
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /* FixPoint1616_t / uint16_t = FixPoint1616_t */
+        StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging<<16) / total_count);
+
+        StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;
+
+        /* Round Cal Distance to Whole Number.
+         * Note that the cal distance is in mm, therefore no resolution is lost.*/
+         CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;
+
+         *pOffsetMicroMeter = (CalDistanceAsInt_mm - StoredMeanRangeAsInt) * 1000;
+
+        /* Apply the calculated offset */
+        if (Status == VL53L0_ERROR_NONE) {
+            VL53L0_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters, *pOffsetMicroMeter)
+            Status = VL53L0_SetOffsetCalibrationDataMicroMeter(Dev, *pOffsetMicroMeter);
+        }
+
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_StartMeasurement(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceModes DeviceMode;
+    uint8_t Byte;
+    uint32_t LoopNb;
+    LOG_FUNCTION_START("");
+
+    /* Get Current DeviceMode */
+    VL53L0_GetDeviceMode(Dev, &DeviceMode);
+
+    switch (DeviceMode)
+    {
+    case VL53L0_DEVICEMODE_SINGLE_RANGING:
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START, VL53L0_REG_SYSRANGE_MODE_SINGLESHOT | VL53L0_REG_SYSRANGE_MODE_START_STOP);
+        break;
+    case VL53L0_DEVICEMODE_CONTINUOUS_RANGING:
+        /* Back-to-back mode */
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START, VL53L0_REG_SYSRANGE_MODE_BACKTOBACK | VL53L0_REG_SYSRANGE_MODE_START_STOP);
+        if (Status == VL53L0_ERROR_NONE) {
+            /* Set PAL State to Running */
+            PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+        }
+        break;
+    case VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
+        /* Continuous mode */
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START, VL53L0_REG_SYSRANGE_MODE_TIMED | VL53L0_REG_SYSRANGE_MODE_START_STOP);
+        if (Status == VL53L0_ERROR_NONE) {
+            /* Set PAL State to Running */
+            PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+        }
+        break;
+    default:
+        /* Selected mode not supported */
+        Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+    }
+
+    Byte = VL53L0_REG_SYSRANGE_MODE_START_STOP;
+    if (Status == VL53L0_ERROR_NONE) {
+        /* Wait until start bit has been cleared */
+        LoopNb = 0;
+        do {
+            if (LoopNb > 0)
+                Status = VL53L0_RdByte(Dev, VL53L0_REG_SYSRANGE_START, &Byte);
+            LoopNb = LoopNb + 1;
+        } while (((Byte & VL53L0_REG_SYSRANGE_MODE_START_STOP) == VL53L0_REG_SYSRANGE_MODE_START_STOP) &&
+                  (Status == VL53L0_ERROR_NONE) &&
+                  (LoopNb < VL53L0_DEFAULT_MAX_LOOP));
+
+        if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP) {
+            Status = VL53L0_ERROR_TIME_OUT;
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+
+VL53L0_Error VL53L0_start_histogram_measurement(VL53L0_DEV Dev,
+              VL53L0_HistogramModes histoMode,
+              uint32_t count)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t dataByte;
+    LOG_FUNCTION_START("");
+
+
+    dataByte = VL53L0_REG_SYSRANGE_MODE_SINGLESHOT | VL53L0_REG_SYSRANGE_MODE_START_STOP;
+    if(count == 0)
+    {
+        /* First histogram measurement must have bit 5 set */
+        dataByte |= (1 << 5);
+    }
+
+    switch (histoMode)
+    {
+        case VL53L0_HISTOGRAMMODE_DISABLED:
+            /* Selected mode not supported */
+            Status = VL53L0_ERROR_INVALID_COMMAND;
+            break;
+
+        case VL53L0_HISTOGRAMMODE_REFERENCE_ONLY:
+        case VL53L0_HISTOGRAMMODE_RETURN_ONLY:
+        case VL53L0_HISTOGRAMMODE_BOTH:
+            dataByte |= (histoMode << 3);
+            Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START, dataByte);
+            if (Status == VL53L0_ERROR_NONE)
+            {
+                /* Set PAL State to Running */
+                PALDevDataSet(Dev, PalState, VL53L0_STATE_RUNNING);
+            }
+            break;
+
+        default:
+            /* Selected mode not supported */
+            Status = VL53L0_ERROR_MODE_NOT_SUPPORTED;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_StopMeasurement(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSRANGE_START, VL53L0_REG_SYSRANGE_MODE_SINGLESHOT);
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /* Set PAL State to Idle */
+        PALDevDataSet(Dev, PalState, VL53L0_STATE_IDLE);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetMeasurementDataReady(VL53L0_DEV Dev, uint8_t *pMeasurementDataReady) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t SysRangeStatusRegister;
+    uint8_t InterruptConfig;
+    uint32_t InterruptMask;
+    LOG_FUNCTION_START("");
+
+    InterruptConfig = VL53L0_GETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality);
+
+    if (InterruptConfig == VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY) {
+        VL53L0_GetInterruptMaskStatus(Dev, &InterruptMask);
+        if (InterruptMask == VL53L0_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY) {
+            *pMeasurementDataReady = 1;
+        } else {
+            *pMeasurementDataReady = 0;
+        }
+    } else {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_RANGE_STATUS, &SysRangeStatusRegister);
+        if (Status == VL53L0_ERROR_NONE) {
+            if (SysRangeStatusRegister & 0x01) {
+                *pMeasurementDataReady = 1;
+            } else {
+                *pMeasurementDataReady = 0;
+            }
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_WaitDeviceReadyForNewMeasurement(VL53L0_DEV Dev, uint32_t MaxLoop) {
+    VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+    LOG_FUNCTION_START("");
+
+    /* not implemented for VL53L0 */
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetRangingMeasurementData(VL53L0_DEV Dev,
+              VL53L0_RangingMeasurementData_t* pRangingMeasurementData)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t DeviceRangeStatus;
+    uint8_t RangeFractionalEnable;
+    uint8_t PalRangeStatus;
+    uint16_t AmbientRate;
+    FixPoint1616_t SignalRate;
+    uint16_t CrosstalkCompensation;
+    uint16_t EffectiveSpadRtnCount;
+    uint16_t tmpuint16;
+    uint8_t localBuffer[14];
+    VL53L0_RangingMeasurementData_t LastRangeDataBuffer;
+    LOG_FUNCTION_START("");
+
+    /*
+     * use multi read even if some registers are not useful, result will be more efficient
+     * start reading at 0x14 dec20
+     * end reading at 0x21 dec33 total 14 bytes to read
+     */
+    Status = VL53L0_ReadMulti(Dev, 0x14, localBuffer, 14);
+
+    if (Status == VL53L0_ERROR_NONE) {
+
+        pRangingMeasurementData->ZoneId = 0; /* Only one zone */
+        pRangingMeasurementData->TimeStamp = 0; /* Not Implemented */
+
+        tmpuint16 = VL53L0_MAKEUINT16(localBuffer[11], localBuffer[10]);
+        /* cut1.1 if SYSTEM__RANGE_CONFIG if 1 range is 2bits fractional
+         *(format 11.2) else no fractional
+         */
+
+        /* Get ranging configuration */
+        RangeFractionalEnable = PALDevDataGet(Dev, RangeFractionalEnable);
+
+        if (RangeFractionalEnable) {
+            pRangingMeasurementData->RangeMilliMeter = (uint16_t)((tmpuint16)>>2);
+            pRangingMeasurementData->RangeFractionalPart = (uint8_t)((tmpuint16 & 0x03)<<6);
+        } else {
+            pRangingMeasurementData->RangeMilliMeter = tmpuint16;
+            pRangingMeasurementData->RangeFractionalPart = 0;
+        }
+
+
+        pRangingMeasurementData->RangeDMaxMilliMeter = 0;
+        pRangingMeasurementData->MeasurementTimeUsec = 0;
+
+        SignalRate = VL53L0_FIXPOINT97TOFIXPOINT1616(VL53L0_MAKEUINT16(localBuffer[7], localBuffer[6]));
+        pRangingMeasurementData->SignalRateRtnMegaCps = SignalRate; /* peak_signal_count_rate_rtn_mcps */
+
+        AmbientRate = VL53L0_MAKEUINT16(localBuffer[9], localBuffer[8]);
+        pRangingMeasurementData->AmbientRateRtnMegaCps = VL53L0_FIXPOINT97TOFIXPOINT1616(AmbientRate);
+
+        EffectiveSpadRtnCount = VL53L0_MAKEUINT16(localBuffer[3], localBuffer[2]);
+        pRangingMeasurementData->EffectiveSpadRtnCount = EffectiveSpadRtnCount; /* 8.8 format */
+
+        DeviceRangeStatus = localBuffer[0];
+
+        /* format is = 3.13 */
+        CrosstalkCompensation = VL53L0_MAKEUINT16(localBuffer[13], localBuffer[12]);
+
+        /*
+         * For a standard definition of RangeStatus, this should return 0 in
+         * case of good result after a ranging
+         * The range status depends on the device so call a device specific
+         * function to obtain the right Status.
+         */
+        Status = VL53L0_get_pal_range_status(Dev,
+                                             DeviceRangeStatus,
+                                             SignalRate,
+                                             CrosstalkCompensation,
+                                             EffectiveSpadRtnCount,
+                                             pRangingMeasurementData,
+                                             &PalRangeStatus);
+
+        if (Status == VL53L0_ERROR_NONE) {
+            pRangingMeasurementData->RangeStatus = PalRangeStatus;
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        /* Copy last read data into Dev buffer */
+        LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
+
+        LastRangeDataBuffer.RangeMilliMeter = pRangingMeasurementData->RangeMilliMeter;
+        LastRangeDataBuffer.RangeFractionalPart = pRangingMeasurementData->RangeFractionalPart;
+        LastRangeDataBuffer.RangeDMaxMilliMeter = pRangingMeasurementData->RangeDMaxMilliMeter;
+        LastRangeDataBuffer.MeasurementTimeUsec = pRangingMeasurementData->MeasurementTimeUsec;
+        LastRangeDataBuffer.SignalRateRtnMegaCps = pRangingMeasurementData->SignalRateRtnMegaCps;
+        LastRangeDataBuffer.AmbientRateRtnMegaCps = pRangingMeasurementData->AmbientRateRtnMegaCps;
+        LastRangeDataBuffer.EffectiveSpadRtnCount = pRangingMeasurementData->EffectiveSpadRtnCount;
+        LastRangeDataBuffer.RangeStatus = pRangingMeasurementData->RangeStatus;
+
+        PALDevDataSet(Dev, LastRangeMeasure, LastRangeDataBuffer);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetHistogramMeasurementData(VL53L0_DEV Dev,
+              VL53L0_HistogramMeasurementData_t* pHistogramMeasurementData) {
+    VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+    LOG_FUNCTION_START("");
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_read_histo_measurement(VL53L0_DEV Dev,
+              uint32_t *histoData,
+              uint32_t offset,
+              VL53L0_HistogramModes histoMode) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t localBuffer[28];
+    uint32_t cDataSize  = 4;
+    uint32_t offset1;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_WrByte(Dev, 0xFF, VL53L0_REG_RESULT_CORE_PAGE);
+    Status = VL53L0_ReadMulti(Dev,
+                              (uint8_t)VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN,
+                              localBuffer,
+                              28);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        VL53L0_reverse_bytes(&localBuffer[0], cDataSize);
+        VL53L0_reverse_bytes(&localBuffer[4], cDataSize);
+        VL53L0_reverse_bytes(&localBuffer[20], cDataSize);
+        VL53L0_reverse_bytes(&localBuffer[24], cDataSize);
+
+        offset1 = offset * cDataSize;
+        if(histoMode == VL53L0_HISTOGRAMMODE_BOTH)
+        {
+            /*
+             * When reading both return and ref data, each measurement reads two
+             * ref values and two return values.
+             * Data is stored in an interleaved sequence, starting with the return
+             * histogram.
+             *
+             * Some result Core registers are reused for the histogram measurements
+             *
+             * The bin values are retrieved in the following order
+             *  VL53L0_REG_RESULT_CORE_RANGING_TOTAL_EVENTS_RTN
+             *  VL53L0_REG_RESULT_CORE_RANGING_TOTAL_EVENTS_REF
+             *  VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN
+             *  VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF
+             */
+
+            memcpy(&histoData[offset1],     &localBuffer[4],  cDataSize); /* rtn */
+            memcpy(&histoData[offset1 + 1], &localBuffer[24], cDataSize); /* ref */
+            memcpy(&histoData[offset1 + 2], &localBuffer[0],  cDataSize); /* rtn */
+            memcpy(&histoData[offset1 + 3], &localBuffer[20], cDataSize); /* ref */
+
+        }
+        else
+        {
+            /*
+             * When reading either return and ref data, each measurement reads four
+             * bin values.
+             *
+             * The bin values are retrieved in the following order
+             *  VL53L0_REG_RESULT_CORE_RANGING_TOTAL_EVENTS_RTN
+             *  VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN
+             *  VL53L0_REG_RESULT_CORE_RANGING_TOTAL_EVENTS_REF
+             *  VL53L0_REG_RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF
+             */
+
+            memcpy(&histoData[offset1],     &localBuffer[24], cDataSize);
+            memcpy(&histoData[offset1 + 1], &localBuffer[20], cDataSize);
+            memcpy(&histoData[offset1 + 2], &localBuffer[4],  cDataSize);
+            memcpy(&histoData[offset1 + 3], &localBuffer[0],  cDataSize);
+
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+
+    return Status;
+}
+
+
+VL53L0_Error VL53L0_PerformSingleRangingMeasurement(VL53L0_DEV Dev,
+		VL53L0_RangingMeasurementData_t* pRangingMeasurementData)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    /* This function will do a complete single ranging
+     * Here we fix the mode! */
+    Status = VL53L0_SetDeviceMode(Dev, VL53L0_DEVICEMODE_SINGLE_RANGING);
+
+    if (Status == VL53L0_ERROR_NONE) {
+    	Status = VL53L0_PerformSingleMeasurement(Dev);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_GetRangingMeasurementData(Dev, pRangingMeasurementData);
+    }
+
+    if(Status==VL53L0_ERROR_NONE){
+        Status = VL53L0_ClearInterruptMask(Dev, 0);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetNumberOfROIZones(VL53L0_DEV Dev,
+		uint8_t NumberOfROIZones)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    if (NumberOfROIZones != 1){
+        Status = VL53L0_ERROR_INVALID_PARAMS;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetNumberOfROIZones(VL53L0_DEV Dev,
+		uint8_t* pNumberOfROIZones)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    *pNumberOfROIZones = 1;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetMaxNumberOfROIZones(VL53L0_DEV Dev,
+		uint8_t* pMaxNumberOfROIZones)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+    LOG_FUNCTION_START("");
+
+    *pMaxNumberOfROIZones = 1;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+/* End Group PAL Measurement Functions */
+
+
+VL53L0_Error VL53L0_SetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+		VL53L0_DeviceModes DeviceMode,
+        VL53L0_GpioFunctionality Functionality,
+		VL53L0_InterruptPolarity Polarity)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    uint8_t data;
+
+    LOG_FUNCTION_START("");
+
+    if (Pin != 0) {
+        Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
+    } else if (DeviceMode == VL53L0_DEVICEMODE_GPIO_DRIVE) {
+        if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW) {
+            data = 0x10;
+        } else {
+            data = 1;
+        }
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH, data);
+
+    } else if (DeviceMode == VL53L0_DEVICEMODE_GPIO_OSC) {
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+    	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+    	Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+    	Status |= VL53L0_WrByte(Dev, 0x85, 0x02);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x04);
+    	Status |= VL53L0_WrByte(Dev, 0xcd, 0x00);
+    	Status |= VL53L0_WrByte(Dev, 0xcc, 0x11);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x07);
+    	Status |= VL53L0_WrByte(Dev, 0xbe, 0x00);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x06);
+    	Status |= VL53L0_WrByte(Dev, 0xcc, 0x09);
+
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x00);
+    	Status |= VL53L0_WrByte(Dev, 0xff, 0x01);
+    	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+    } else {
+
+		if (Status == VL53L0_ERROR_NONE) {
+			switch(Functionality){
+				case VL53L0_GPIOFUNCTIONALITY_OFF:
+					data = 0x00;
+					break;
+				case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW:
+					data = 0x01;
+					break;
+				case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH:
+					data = 0x02;
+					break;
+				case VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT:
+					data = 0x03;
+					break;
+				case VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY:
+					data = 0x04;
+					break;
+				default:
+					Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
+			}
+		}
+
+		if(Status==VL53L0_ERROR_NONE)
+			Status = VL53L0_WrByte(Dev,
+					VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO, data);
+
+
+		if(Status==VL53L0_ERROR_NONE){
+			if (Polarity == VL53L0_INTERRUPTPOLARITY_LOW) {
+				data = 0;
+			} else {
+				data = (uint8_t)(1<<4);
+			}
+			Status = VL53L0_UpdateByte(Dev,
+					VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH, 0xEF, data);
+		}
+
+		if(Status==VL53L0_ERROR_NONE)
+			VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+					Pin0GpioFunctionality, Functionality);
+
+
+		if(Status==VL53L0_ERROR_NONE)
+			Status = VL53L0_ClearInterruptMask(Dev, 0);
+
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetGpioConfig(VL53L0_DEV Dev, uint8_t Pin,
+		VL53L0_DeviceModes* DeviceMode,
+		VL53L0_GpioFunctionality* pFunctionality,
+		VL53L0_InterruptPolarity* pPolarity)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    VL53L0_GpioFunctionality GpioFunctionality;
+    uint8_t data;
+
+    LOG_FUNCTION_START("");
+
+    if(Pin != 0){
+        Status = VL53L0_ERROR_GPIO_NOT_EXISTING;
+    } else {
+        Status = VL53L0_RdByte(Dev,
+        		VL53L0_REG_SYSTEM_INTERRUPT_CONFIG_GPIO, &data);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        switch(data&0x07){
+            case 0x00:
+                GpioFunctionality = VL53L0_GPIOFUNCTIONALITY_OFF;
+                break;
+            case 0x01:
+                GpioFunctionality =
+                		VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW;
+                break;
+            case 0x02:
+                GpioFunctionality =
+                		VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH;
+                break;
+            case 0x03:
+                GpioFunctionality =
+                		VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT;
+                break;
+            case 0x04:
+                GpioFunctionality = VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY;
+                break;
+            default:
+                Status = VL53L0_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_GPIO_HV_MUX_ACTIVE_HIGH, &data);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if ((data & (uint8_t)(1<<4)) == 0) {
+            *pPolarity = VL53L0_INTERRUPTPOLARITY_LOW;
+        } else {
+            *pPolarity = VL53L0_INTERRUPTPOLARITY_HIGH;
+        }
+    }
+
+    if(Status==VL53L0_ERROR_NONE){
+        *pFunctionality = GpioFunctionality;
+        VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+        		Pin0GpioFunctionality, GpioFunctionality);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetInterruptThresholds(VL53L0_DEV Dev,
+        VL53L0_DeviceModes DeviceMode, FixPoint1616_t ThresholdLow,
+        FixPoint1616_t ThresholdHigh) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t Threshold16;
+    LOG_FUNCTION_START("");
+
+    /* no dependency on DeviceMode for Ewok */
+    /* Need to divide by 2 because the FW will apply a x2 */
+    Threshold16 = (uint16_t)((ThresholdLow>>17) & 0x00fff);
+    Status = VL53L0_WrWord(Dev, VL53L0_REG_SYSTEM_THRESH_LOW, Threshold16);
+
+    if(Status==VL53L0_ERROR_NONE){
+        /* Need to divide by 2 because the FW will apply a x2 */
+        Threshold16 = (uint16_t)((ThresholdHigh>>17) & 0x00fff);
+        Status = VL53L0_WrWord(Dev, VL53L0_REG_SYSTEM_THRESH_HIGH, Threshold16);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetInterruptThresholds(VL53L0_DEV Dev,
+    VL53L0_DeviceModes DeviceMode, FixPoint1616_t* pThresholdLow,
+    FixPoint1616_t* pThresholdHigh) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t Threshold16;
+    LOG_FUNCTION_START("");
+
+    /* no dependency on DeviceMode for Ewok */
+
+    Status = VL53L0_RdWord(Dev, VL53L0_REG_SYSTEM_THRESH_LOW, &Threshold16);
+    /* Need to multiply by 2 because the FW will apply a x2 */
+    *pThresholdLow = (FixPoint1616_t)((0x00fff & Threshold16)<<17);
+
+    if(Status==VL53L0_ERROR_NONE){
+       Status = VL53L0_RdWord(Dev, VL53L0_REG_SYSTEM_THRESH_HIGH, &Threshold16);
+       /* Need to multiply by 2 because the FW will apply a x2 */
+       *pThresholdHigh = (FixPoint1616_t)((0x00fff & Threshold16)<<17);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+/* Group PAL Interrupt Functions */
+VL53L0_Error VL53L0_ClearInterruptMask(VL53L0_DEV Dev, uint32_t InterruptMask) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t LoopCount;
+    uint8_t Byte;
+    LOG_FUNCTION_START("");
+
+    /* clear bit 0 range interrupt, bit 1 error interrupt */
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_INTERRUPT_CLEAR, 0x01);
+    LoopCount = 0;
+    do {
+        VL53L0_RdByte(Dev, VL53L0_REG_RESULT_INTERRUPT_STATUS, &Byte);
+        LoopCount++;
+    } while (((Byte & 0x07) != 0x00) && (LoopCount < 8));
+    Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_INTERRUPT_CLEAR, 0x00);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetInterruptMaskStatus(VL53L0_DEV Dev,
+        uint32_t *pInterruptMaskStatus)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte;
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_RdByte(Dev, VL53L0_REG_RESULT_INTERRUPT_STATUS, &Byte);
+    *pInterruptMaskStatus = Byte & 0x07;
+
+    if (Byte & 0x18){
+        Status = VL53L0_ERROR_RANGE_ERROR;
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_EnableInterruptMask(VL53L0_DEV Dev,
+        uint32_t InterruptMask)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NOT_IMPLEMENTED;
+    LOG_FUNCTION_START("");
+
+    /* not implemented for VL53L0 */
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+/* End Group PAL Interrupt Functions */
+
+/* Group SPAD functions */
+
+VL53L0_Error VL53L0_SetSpadAmbientDamperThreshold(VL53L0_DEV Dev,
+        uint16_t SpadAmbientDamperThreshold)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status = VL53L0_WrWord(Dev, 0x40, SpadAmbientDamperThreshold);
+    VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetSpadAmbientDamperThreshold(VL53L0_DEV Dev,
+        uint16_t* pSpadAmbientDamperThreshold)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    LOG_FUNCTION_START("");
+
+    VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status = VL53L0_RdWord(Dev, 0x40, pSpadAmbientDamperThreshold);
+    VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_SetSpadAmbientDamperFactor(VL53L0_DEV Dev,
+        uint16_t SpadAmbientDamperFactor)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte;
+    LOG_FUNCTION_START("");
+
+    Byte = (uint8_t) (SpadAmbientDamperFactor & 0x00FF);
+
+    VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status = VL53L0_WrByte(Dev, 0x42, Byte);
+    VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_GetSpadAmbientDamperFactor(VL53L0_DEV Dev,
+        uint16_t* pSpadAmbientDamperFactor)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t Byte;
+    LOG_FUNCTION_START("");
+
+    VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status = VL53L0_RdByte(Dev, 0x42, &Byte);
+    VL53L0_WrByte(Dev, 0xFF, 0x00);
+    *pSpadAmbientDamperFactor = (uint16_t) Byte;
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+/* END Group SPAD functions */
+
+/*****************************************************************************
+ * Internal functions
+ *****************************************************************************/
+
+uint32_t VL53L0_calc_macro_period_ps(VL53L0_DEV Dev, uint8_t vcsel_period);
+uint16_t VL53L0_encode_timeout(uint32_t timeout_mclks);
+uint32_t VL53L0_decode_timeout(uint16_t encoded_timeout);
+
+VL53L0_Error VL53L0_get_vcsel_pulse_period(VL53L0_DEV Dev,
+		uint8_t* pVCSELPulsePeriod, uint8_t RangeIndex)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t vcsel_period_reg;
+
+    LOG_FUNCTION_START("");
+
+    switch (RangeIndex)
+    {
+        case 0:
+            Status = VL53L0_RdByte(Dev,
+            		VL53L0_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD,
+            		&vcsel_period_reg);
+            break;
+        case 1:
+            Status = VL53L0_RdByte(Dev,
+            		VL53L0_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD,
+            		&vcsel_period_reg);
+            break;
+        case 2:
+            Status = VL53L0_RdByte(Dev,
+            		VL53L0_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD,
+            		&vcsel_period_reg);
+            break;
+        default:
+            Status = VL53L0_RdByte(Dev,
+            		VL53L0_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD,
+            		&vcsel_period_reg);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        *pVCSELPulsePeriod = VL53L0_decode_vcsel_period(vcsel_period_reg);
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+/* To convert ms into register value */
+uint16_t VL53L0_calc_encoded_timeout(VL53L0_DEV Dev,
+          uint32_t timeout_period_us,
+          uint8_t vcsel_period)
+{
+    uint32_t macro_period_ps;
+    uint32_t macro_period_ns;
+    uint32_t timeout_period_mclks = 0;
+    uint16_t timeout_overall_periods = 0;
+
+    macro_period_ps = VL53L0_calc_macro_period_ps(Dev, vcsel_period);
+    macro_period_ns = macro_period_ps / 1000;
+
+    timeout_period_mclks =
+        (uint32_t) (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns);
+    timeout_overall_periods = VL53L0_encode_timeout(timeout_period_mclks);
+
+    return timeout_overall_periods;
+}
+
+/* To convert register value into us */
+uint32_t VL53L0_calc_ranging_wait_us(VL53L0_DEV Dev,
+          uint16_t timeout_overall_periods,
+          uint8_t vcsel_period)
+{
+    uint32_t macro_period_ps;
+    uint32_t macro_period_ns;
+    uint32_t timeout_period_mclks = 0;
+    uint32_t actual_timeout_period_us = 0;
+
+    macro_period_ps = VL53L0_calc_macro_period_ps(Dev, vcsel_period);
+    macro_period_ns = macro_period_ps / 1000;
+
+    timeout_period_mclks = VL53L0_decode_timeout(timeout_overall_periods);
+    actual_timeout_period_us =
+        ((timeout_period_mclks * macro_period_ns) + (macro_period_ns / 2)) / 1000;
+
+    return actual_timeout_period_us;
+}
+
+uint32_t VL53L0_calc_macro_period_ps(VL53L0_DEV Dev, uint8_t vcsel_period) {
+    uint32_t PLL_multiplier;
+    uint64_t PLL_period_ps;
+    uint8_t vcsel_period_pclks;
+    uint32_t macro_period_vclks;
+    uint32_t macro_period_ps;
+
+    LOG_FUNCTION_START("");
+
+    PLL_multiplier = 65536 / 64; /* PLL multiplier is 64 */
+
+    PLL_period_ps =
+        (1000 * 1000 * PLL_multiplier) / VL53L0_GETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz);
+
+    vcsel_period_pclks = VL53L0_decode_vcsel_period(vcsel_period);
+
+    macro_period_vclks = 2304;
+    macro_period_ps = (uint32_t)(macro_period_vclks * vcsel_period_pclks * PLL_period_ps);
+
+    LOG_FUNCTION_END("");
+    return macro_period_ps;
+}
+
+uint8_t VL53L0_decode_vcsel_period(uint8_t vcsel_period_reg) {
+
+    /*!
+     * Converts the encoded VCSEL period register value into the real period in PLL clocks
+     */
+
+    uint8_t vcsel_period_pclks = 0;
+
+    vcsel_period_pclks = (vcsel_period_reg + 1) << 1;
+
+    return vcsel_period_pclks;
+}
+
+uint8_t VL53L0_encode_vcsel_period(uint8_t vcsel_period_pclks) {
+
+    /*!
+     * Converts the encoded VCSEL period register value into the real period in PLL clocks
+     */
+
+    uint8_t vcsel_period_reg = 0;
+
+    vcsel_period_reg = (vcsel_period_pclks >> 1) - 1;
+
+    return vcsel_period_reg;
+}
+
+uint16_t VL53L0_encode_timeout(uint32_t timeout_mclks) {
+    /*!
+     * Encode timeout in macro periods in (LSByte * 2^MSByte) + 1 format
+     *
+     */
+
+    uint16_t encoded_timeout = 0;
+    uint32_t ls_byte = 0;
+    uint16_t ms_byte = 0;
+
+    if (timeout_mclks > 0) {
+        ls_byte = timeout_mclks - 1;
+
+        while ((ls_byte & 0xFFFFFF00) > 0) {
+            ls_byte = ls_byte >> 1;
+            ms_byte++;
+        }
+
+        encoded_timeout = (ms_byte << 8) + (uint16_t) (ls_byte & 0x000000FF);
+
+    }
+
+    return encoded_timeout;
+
+}
+
+uint32_t VL53L0_decode_timeout(uint16_t encoded_timeout) {
+    /*!
+     * Decode 16-bit timeout register value - format (LSByte * 2^MSByte) + 1
+     *
+     */
+
+    uint32_t timeout_mclks = 0;
+
+    timeout_mclks = ((uint32_t) (encoded_timeout & 0x00FF) << (uint32_t) ((encoded_timeout & 0xFF00) >> 8)) + 1;
+
+    return timeout_mclks;
+
+}
+
+
+VL53L0_Error VL53L0_check_part_used(VL53L0_DEV Dev,
+		uint8_t* Revision,
+        VL53L0_DeviceInfo_t* pVL53L0_DeviceInfo)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t ModuleIdInt;
+    char *ProductId_tmp;
+
+    LOG_FUNCTION_START("");
+
+    Status = VL53L0_get_info_from_device(Dev);
+
+    if (Status == VL53L0_ERROR_NONE) {
+		ModuleIdInt = VL53L0_GETDEVICESPECIFICPARAMETER(Dev, ModuleId);
+
+        if (ModuleIdInt == 0) {
+            *Revision = 0;
+            VL53L0_COPYSTRING(pVL53L0_DeviceInfo->ProductId, "");
+        } else {
+            *Revision = VL53L0_GETDEVICESPECIFICPARAMETER(Dev, Revision);
+        	ProductId_tmp = VL53L0_GETDEVICESPECIFICPARAMETER(Dev, ProductId);
+        	VL53L0_COPYSTRING(pVL53L0_DeviceInfo->ProductId, ProductId_tmp);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_get_info_from_device(VL53L0_DEV Dev)
+{
+
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t byte;
+    uint32_t TmpDWord;
+    VL53L0_DeviceSpecificParameters_t DeviceSpecificParameters;
+    uint8_t ModuleId;
+    uint8_t Revision;
+    uint8_t ReferenceSpadCount;
+    uint8_t ReferenceSpadType;
+    char ProductId[19];
+    char *ProductId_tmp;
+    uint8_t ReadDataFromDeviceDone;
+
+    LOG_FUNCTION_START("");
+
+    ReadDataFromDeviceDone = VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
+    		ReadDataFromDeviceDone);
+
+    /* This access is done only once after that a GetDeviceInfo or
+     * datainit is done*/
+    if (ReadDataFromDeviceDone == 0) {
+
+        Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+        Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
+
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
+        Status |= VL53L0_RdByte(Dev, 0x83, &byte);
+        Status |= VL53L0_WrByte(Dev, 0x83, byte|4);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x07);
+        Status |= VL53L0_WrByte(Dev, 0x81, 0x01);
+
+        Status |= VL53L0_PollingDelay(Dev);
+
+        Status |= VL53L0_WrByte(Dev, 0x80, 0x01);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x6b);
+        Status |= VL53L0_device_read_strobe(Dev);
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ReferenceSpadCount = (uint8_t)((TmpDWord >> 8) & 0x07f);
+        ReferenceSpadType  = (uint8_t)((TmpDWord >> 15) & 0x01);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x02);
+        Status |= VL53L0_device_read_strobe(Dev);
+        Status |= VL53L0_RdByte(Dev, 0x90, &ModuleId);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x7B);
+        Status |= VL53L0_device_read_strobe(Dev);
+        Status |= VL53L0_RdByte(Dev, 0x90, &Revision);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x77);
+        Status |= VL53L0_device_read_strobe(Dev);
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[0] = (char)((TmpDWord >> 25) & 0x07f);
+        ProductId[1] = (char)((TmpDWord >> 18) & 0x07f);
+        ProductId[2] = (char)((TmpDWord >> 11) & 0x07f);
+        ProductId[3] = (char)((TmpDWord >> 4) & 0x07f);
+
+        byte = (uint8_t)((TmpDWord & 0x00f) << 3);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x78);
+        Status |= VL53L0_device_read_strobe(Dev);
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[4] = (char)(byte +
+        		((TmpDWord >> 29) & 0x07f));
+        ProductId[5] = (char)((TmpDWord >> 22) & 0x07f);
+        ProductId[6] = (char)((TmpDWord >> 15) & 0x07f);
+        ProductId[7] = (char)((TmpDWord >> 8) & 0x07f);
+        ProductId[8] = (char)((TmpDWord >> 1) & 0x07f);
+
+        byte = (uint8_t)((TmpDWord & 0x001) << 6);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x79);
+
+        Status |= VL53L0_device_read_strobe(Dev);
+
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[9] = (char)(byte +
+        		((TmpDWord >> 26) & 0x07f));
+        ProductId[10] = (char)((TmpDWord >> 19) & 0x07f);
+        ProductId[11] = (char)((TmpDWord >> 12) & 0x07f);
+        ProductId[12] = (char)((TmpDWord >> 5) & 0x07f);
+
+        byte = (uint8_t)((TmpDWord & 0x01f) << 2);
+
+        Status |= VL53L0_WrByte(Dev, 0x94, 0x80);
+
+        Status |= VL53L0_device_read_strobe(Dev);
+
+        Status |= VL53L0_RdDWord(Dev, 0x90, &TmpDWord);
+
+        ProductId[13] = (char)(byte +
+        		((TmpDWord >> 30) & 0x07f));
+        ProductId[14] = (char)((TmpDWord >> 23) & 0x07f);
+        ProductId[15] = (char)((TmpDWord >> 16) & 0x07f);
+        ProductId[16] = (char)((TmpDWord >> 9) & 0x07f);
+        ProductId[17] = (char)((TmpDWord >> 2) & 0x07f);
+        ProductId[18] = '\0';
+
+        Status |= VL53L0_WrByte(Dev, 0x81, 0x00);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x06);
+        Status |= VL53L0_RdByte(Dev, 0x83, &byte);
+        Status |= VL53L0_WrByte(Dev, 0x83, byte&0xfb);
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
+        Status |= VL53L0_WrByte(Dev, 0x00, 0x01);
+
+        Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+        Status |= VL53L0_WrByte(Dev, 0x80, 0x00);
+
+        if (Status == VL53L0_ERROR_NONE) {
+        	VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+        			ModuleId, ModuleId);
+
+        	VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+        			Revision, Revision);
+
+        	VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+        			ReferenceSpadCount, ReferenceSpadCount);
+
+        	VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+        			ReferenceSpadType, ReferenceSpadType);
+
+        	ProductId_tmp = VL53L0_GETDEVICESPECIFICPARAMETER(Dev,
+        			ProductId);
+        	VL53L0_COPYSTRING(ProductId_tmp, ProductId);
+
+        	VL53L0_SETDEVICESPECIFICPARAMETER(Dev,
+        	    		ReadDataFromDeviceDone, 1);
+        }
+    }
+
+
+
+
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_device_read_strobe(VL53L0_DEV Dev) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t strobe;
+    uint32_t LoopNb;
+    LOG_FUNCTION_START("");
+
+    Status |= VL53L0_WrByte(Dev, 0x83, 0x00);
+
+    /* polling
+     * use timeout to avoid deadlock*/
+    if (Status == VL53L0_ERROR_NONE) {
+        LoopNb = 0;
+        do {
+            Status =VL53L0_RdByte(Dev, 0x83, &strobe);
+            if ((strobe != 0x00) || Status != VL53L0_ERROR_NONE) {
+                break;
+            }
+            LoopNb = LoopNb + 1;
+        } while (LoopNb < VL53L0_DEFAULT_MAX_LOOP);
+
+        if (LoopNb >= VL53L0_DEFAULT_MAX_LOOP) {
+            Status = VL53L0_ERROR_TIME_OUT;
+        }
+    }
+
+    Status |= VL53L0_WrByte(Dev, 0x83, 0x01);
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+
+}
+
+
+uint32_t VL53L0_isqrt(uint32_t num)
+{
+
+    /*
+     * Implements an integer square root
+     *
+     * From: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
+     */
+
+    uint32_t  res = 0;
+    uint32_t  bit = 1 << 30; /* The second-to-top bit is set:
+                              * 1 << 14 for 16-bits, 1 << 30 for 32 bits */
+
+     /* "bit" starts at the highest power of four <= the argument. */
+    while (bit > num)
+    {
+        bit >>= 2;
+    }
+
+    while (bit != 0)
+    {
+        if (num >= res + bit)
+        {
+            num -= res + bit;
+            res = (res >> 1) + bit;
+        }
+        else
+        {
+            res >>= 1;
+        }
+        bit >>= 2;
+    }
+
+    return res;
+}
+
+
+uint32_t VL53L0_quadrature_sum(uint32_t a,
+                                uint32_t b)
+{
+    /*
+     * Implements a quadrature sum
+     *
+     * rea = sqrt(a^2 + b^2)
+     *
+     * Trap overflow case max input value is 65535 (16-bit value)
+     * as internal calc are 32-bit wide
+     *
+     * If overflow then seta output to maximum
+     */
+    uint32_t  res = 0;
+
+    if( a > 65535 || b > 65535)
+    {
+        res = 65535;
+    }
+    else
+    {
+        res = VL53L0_isqrt(a*a + b*b);
+    }
+
+    return res;
+}
+
+
+
+VL53L0_Error VL53L0_get_jmp_vcsel_ambient_rate(VL53L0_DEV Dev,
+                                               uint32_t *pAmbient_rate_kcps,
+                                               uint32_t *pVcsel_rate_kcps,
+                                               uint32_t *pSignalTotalEventsRtn){
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint16_t encodedTimeOut;
+
+    uint32_t    total_periods_elapsed_rtn__macrop  = 0;
+    uint32_t    result_core__total_periods_elapsed_rtn  = 0;
+    uint32_t    rngb1_config__timeout__macrop = 0;
+    uint32_t    rngb2_config__timeout__macrop = 0;
+    uint32_t    result_core__ambient_window_events_rtn = 0;
+    uint32_t     result_core__signal_total_events_rtn = 0;
+    uint8_t     last_woi_period;
+    uint8_t     rnga_config__vcsel_period;
+    uint8_t     rngb1_config__vcsel_period;
+    uint8_t     rngb2_config__vcsel_period;
+    uint8_t     global_config__vcsel_width;
+
+    uint32_t    ambient_duration_us = 0;
+    uint32_t    vcsel_duration_us = 0;
+
+    uint32_t    pll_period_us  = 0;
+
+    LOG_FUNCTION_START("");
+
+    /* read the following */
+    Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+    Status |= VL53L0_RdDWord(Dev, 0xc0, &result_core__signal_total_events_rtn);
+    Status |= VL53L0_RdDWord(Dev, 0xC8, &result_core__total_periods_elapsed_rtn);
+    Status |= VL53L0_RdDWord(Dev, 0xbc, &result_core__ambient_window_events_rtn);
+    Status |= VL53L0_RdDWord(Dev, 0xF0, &pll_period_us);
+    Status |= VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+
+    if (Status == VL53L0_ERROR_NONE) {
+        result_core__total_periods_elapsed_rtn =
+            (int32_t)(result_core__total_periods_elapsed_rtn & 0x00ffffff);
+        pll_period_us = (int32_t)(pll_period_us & 0x3ffff);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdWord(Dev,
+                               VL53L0_REG_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI,
+                               &encodedTimeOut);
+        if (Status == VL53L0_ERROR_NONE) {
+            rngb1_config__timeout__macrop = VL53L0_decode_timeout(encodedTimeOut) - 1;
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD,
+        		&rnga_config__vcsel_period);
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, VL53L0_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD,
+        		&rngb1_config__vcsel_period);
+        rngb2_config__vcsel_period = rngb1_config__vcsel_period;
+    }
+    if (Status == VL53L0_ERROR_NONE) {
+        Status = VL53L0_RdByte(Dev, 0x32, &global_config__vcsel_width);
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        if (Status == VL53L0_ERROR_NONE) {
+            rngb2_config__timeout__macrop =
+            		VL53L0_decode_timeout(encodedTimeOut) - 1;
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        total_periods_elapsed_rtn__macrop =
+        		result_core__total_periods_elapsed_rtn + 1;
+
+        if (result_core__total_periods_elapsed_rtn ==
+        		rngb1_config__timeout__macrop)
+        {
+           last_woi_period = rngb1_config__vcsel_period;
+        }
+        else if (result_core__total_periods_elapsed_rtn ==
+        		rngb2_config__timeout__macrop)
+        {
+           last_woi_period = rngb2_config__vcsel_period;
+        }
+        else
+        {
+           last_woi_period = rnga_config__vcsel_period;
+
+        }
+        /* 512 = 1<<9  ==> 24-9=15 */
+        ambient_duration_us = last_woi_period *
+        		total_periods_elapsed_rtn__macrop * pll_period_us;
+        ambient_duration_us = ambient_duration_us / 1000;
+
+        if (ambient_duration_us != 0) {
+            *pAmbient_rate_kcps = ((1 << 15) *
+            		result_core__ambient_window_events_rtn) /
+            				ambient_duration_us;
+        } else {
+            Status = VL53L0_ERROR_DIVISION_BY_ZERO;
+        }
+
+        if (Status == VL53L0_ERROR_NONE)
+        {
+
+            /* 2048 = 1<<11  ==> 24-11=13 */
+            vcsel_duration_us = (10*global_config__vcsel_width + 4) *
+            		total_periods_elapsed_rtn__macrop * pll_period_us ;
+            vcsel_duration_us = vcsel_duration_us / 10000 ;
+
+
+            if (vcsel_duration_us != 0) {
+                *pVcsel_rate_kcps = ((1 << 13) *
+                		result_core__signal_total_events_rtn) /
+                				vcsel_duration_us;
+                *pSignalTotalEventsRtn = result_core__signal_total_events_rtn;
+            } else {
+                Status = VL53L0_ERROR_DIVISION_BY_ZERO;
+            }
+
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+
+}
+
+VL53L0_Error VL53L0_calc_sigma_estimate(VL53L0_DEV Dev,
+				VL53L0_RangingMeasurementData_t *pRangingMeasurementData,
+				FixPoint1616_t* pSigmaEstimate)
+{
+	/* Expressed in 100ths of a ns, i.e. centi-ns */
+    const uint32_t cPulseEffectiveWidth_centi_ns   = 800;
+    /* Expressed in 100ths of a ns, i.e. centi-ns */
+    const uint32_t cAmbientEffectiveWidth_centi_ns = 600;
+    const FixPoint1616_t cSigmaEstRef              = 0x00000042;
+    const uint32_t cVcselPulseWidth_ps             = 4700; /* pico secs */
+    const FixPoint1616_t cSigmaEstMax              = 0x028F87AE;
+    /* Time Of Flight per mm (6.6 pico secs) */
+    const FixPoint1616_t cTOF_per_mm_ps            = 0x0006999A;
+    const uint32_t c16BitRoundingParam             = 0x00008000;
+    const FixPoint1616_t cMaxXTalk_kcps            = 0x00320000;
+
+    uint32_t signalTotalEventsRtn;
+    FixPoint1616_t sigmaEstimateP1;
+    FixPoint1616_t sigmaEstimateP2;
+    FixPoint1616_t sigmaEstimateP3;
+    FixPoint1616_t deltaT_ps;
+    FixPoint1616_t pwMult;
+    FixPoint1616_t sigmaEstRtn;
+    FixPoint1616_t sigmaEstimate;
+    FixPoint1616_t xTalkCorrection;
+    uint32_t signalTotalEventsRtnRawVal;
+    FixPoint1616_t ambientRate_kcps;
+    FixPoint1616_t vcselRate_kcps;
+    FixPoint1616_t xTalkCompRate_mcps;
+    uint32_t xTalkCompRate_kcps;
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_DeviceParameters_t CurrentParameters;
+    FixPoint1616_t diff1_mcps;
+    FixPoint1616_t diff2_mcps;
+    FixPoint1616_t sqr1;
+    FixPoint1616_t sqr2;
+    FixPoint1616_t sqrSum;
+    FixPoint1616_t sqrtResult_centi_ns;
+    FixPoint1616_t sqrtResult;
+
+    /*! \addtogroup calc_sigma_estimate
+     * @{
+     *
+     * Estimates the range sigma based on the
+     *
+     *  - vcsel_rate_kcps
+     *  - ambient_rate_kcps
+     *  - signal_total_events
+     *  - xtalk_rate
+     *
+     * and the following parameters
+     *
+     *  - SigmaEstRefArray
+     *  - SigmaEstEffPulseWidth
+     *  - SigmaEstEffAmbWidth
+     */
+
+    LOG_FUNCTION_START("");
+
+    VL53L0_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
+    		xTalkCompRate_mcps);
+
+    /*
+     * We work in kcps rather than mcps as this helps keep within the confines
+     * of the 32 Fix1616 type.
+     */
+
+    xTalkCompRate_kcps = xTalkCompRate_mcps * 1000;
+    if(xTalkCompRate_kcps > cMaxXTalk_kcps)
+    {
+        xTalkCompRate_kcps = cMaxXTalk_kcps;
+    }
+
+    Status =  VL53L0_get_jmp_vcsel_ambient_rate(Dev,
+                                                &ambientRate_kcps,
+                                                &vcselRate_kcps,
+                                                &signalTotalEventsRtnRawVal);
+    if (Status == VL53L0_ERROR_NONE) {
+        if (vcselRate_kcps == 0) {
+            *pSigmaEstimate = 0;
+            PALDevDataSet(Dev, SigmaEstimate, 0);
+        } else {
+            signalTotalEventsRtn = signalTotalEventsRtnRawVal;
+            if(signalTotalEventsRtn < 1)
+            {
+                signalTotalEventsRtn = 1;
+            }
+
+            /*
+             * Calculate individual components of the main equation - replicating
+             * the equation implemented in the script OpenAll_Ewok_ranging_data.jsl.
+             *
+             * sigmaEstimateP1 represents the effective pulse width, which is a tuning
+             * parameter, rather than a real value.
+             *
+             * sigmaEstimateP2 represents the ambient/signal rate ratio expressed as
+             * a multiple of the effective ambient width (tuning parameter).
+             *
+             * sigmaEstimateP3 provides the signal event component, with the knowledge
+             * that
+             *  - Noise of a square pulse is 1/sqrt(12) of the pulse width.
+             *  - at 0Lux, sigma is proportional to
+             *    effectiveVcselPulseWidth/sqrt(12 * signalTotalEvents)
+             *
+             * deltaT_ps represents the time of flight in pico secs for the
+             * current range measurement, using the "TOF per mm" constant (in ps).
+             */
+
+            sigmaEstimateP1 = cPulseEffectiveWidth_centi_ns;
+
+            /* ((FixPoint1616 << 16)* uint32)/FixPoint1616 = FixPoint1616 */
+            sigmaEstimateP2 = (ambientRate_kcps << 16)/vcselRate_kcps;
+            sigmaEstimateP2 *= cAmbientEffectiveWidth_centi_ns;
+
+            sigmaEstimateP3 = 2 * VL53L0_isqrt(signalTotalEventsRtn * 12);
+
+            /* uint32 * FixPoint1616 = FixPoint1616 */
+            deltaT_ps = pRangingMeasurementData->RangeMilliMeter * cTOF_per_mm_ps;
+    
+            /*
+             * vcselRate - xtalkCompRate
+             * (uint32 << 16) - FixPoint1616 = FixPoint1616.
+             * Divide result by 1000 to convert to mcps.
+             * 500 is added to ensure rounding when integer division truncates.
+             */
+            diff1_mcps = (((vcselRate_kcps << 16) - xTalkCompRate_kcps) + 500)/1000;
+
+            /* vcselRate + xtalkCompRate */
+            diff2_mcps = (((vcselRate_kcps << 16) + xTalkCompRate_kcps) + 500)/1000;
+
+            /* Shift by 12 bits to increase resolution prior to the division */
+            diff1_mcps <<= 12;
+
+            /* FixPoint0428/FixPoint1616 = FixPoint2012 */
+            xTalkCorrection  = abs(diff1_mcps/diff2_mcps);
+
+            /* FixPoint2012 << 4 = FixPoint1616 */
+            xTalkCorrection <<= 4;
+
+            /* FixPoint1616/uint32 = FixPoint1616 */
+            pwMult = deltaT_ps/cVcselPulseWidth_ps; /* smaller than 1.0f */
+
+            /*
+             * FixPoint1616 * FixPoint1616 = FixPoint3232, however both values are
+             * small enough such that32 bits will not be exceeded.
+             */
+            pwMult *= ((1 << 16) - xTalkCorrection);
+
+            /* (FixPoint3232 >> 16) = FixPoint1616 */
+            pwMult =  (pwMult + c16BitRoundingParam) >> 16;
+
+            /* FixPoint1616 + FixPoint1616 = FixPoint1616 */
+            pwMult += (1 << 16);
+
+            /*
+             * At this point the value will be 1.xx, therefore if we square the value this will exceed
+             * 32 bits. To address this perform a single shift to the right before the multiplication.
+             */
+            pwMult >>= 1;
+            /* FixPoint1715 * FixPoint1715 = FixPoint3430 */
+            pwMult = pwMult * pwMult;
+
+            /* (FixPoint3430 >> 14) = Fix1616 */
+            pwMult >>= 14;
+
+            /* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+            sqr1 = pwMult * sigmaEstimateP1;
+
+            /* (FixPoint1616 >> 12) = FixPoint2804 */
+            sqr1 = (sqr1 + 0x800) >> 12;
+
+            /* FixPoint2804 * FixPoint2804 = FixPoint5608 */
+            sqr1 *= sqr1;
+
+            sqr2 = sigmaEstimateP2;
+
+            /* (FixPoint1616 >> 12) = FixPoint2804 */
+            sqr2 = (sqr2 + 0x800) >> 12;
+
+            /* FixPoint2804 * FixPoint2804 = FixPoint5608 */
+            sqr2 *= sqr2;
+
+            /* FixPoint5608 + FixPoint5608 = FixPoint5608 */
+            sqrSum = sqr1 + sqr2;
+
+            /* SQRT(FixPoint5608) = FixPoint2804 */
+            sqrtResult_centi_ns = VL53L0_isqrt(sqrSum);
+
+            /* (FixPoint2804 << 12) = FixPoint1616 */
+            sqrtResult_centi_ns <<= 12;
+
+            /*
+             * Note that the Speed Of Light is expressed in um per 1E-10 seconds (2997)
+             * Therefore to get mm/ns we have to divide by 10000
+             */
+            sigmaEstRtn      = ((sqrtResult_centi_ns+50)/100 * VL53L0_SPEED_OF_LIGHT_IN_AIR);
+            sigmaEstRtn      /= (sigmaEstimateP3);
+            sigmaEstRtn      += 5000; /* Add 5000 before dividing by 10000 to ensure rounding. */
+            sigmaEstRtn      /= 10000;
+
+            /* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+            sqr1 = sigmaEstRtn * sigmaEstRtn;
+            /* FixPoint1616 * FixPoint1616 = FixPoint3232 */
+            sqr2 = cSigmaEstRef * cSigmaEstRef;
+
+            /* sqrt(FixPoint3232 << 12) = FixPoint1022 */
+            sqrtResult = VL53L0_isqrt((sqr1 + sqr2) << 12);
+            sqrtResult = (sqrtResult + 0x20) >> 6;
+            /*
+             * Note that the Shift by 12bits increases resolution prior to the sqrt,
+             * therefore the result must be shifted by 6bits to the right to revert
+             * back to the FixPoint1616 format.
+             */
+
+            sigmaEstimate    = 1000 * sqrtResult;
+
+            if((vcselRate_kcps < 1) || (signalTotalEventsRtn < 1) || (sigmaEstimate > cSigmaEstMax))
+            {
+                sigmaEstimate = cSigmaEstMax;
+            }
+        
+            *pSigmaEstimate = (uint32_t)(sigmaEstimate);
+            PALDevDataSet(Dev, SigmaEstimate, *pSigmaEstimate);
+        }
+    }
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_get_pal_range_status(VL53L0_DEV Dev,
+                                         uint8_t DeviceRangeStatus,
+                                         FixPoint1616_t SignalRate,
+                                         FixPoint1616_t CrosstalkCompensation,
+                                         uint16_t EffectiveSpadRtnCount,
+                                         VL53L0_RangingMeasurementData_t *pRangingMeasurementData,
+                                         uint8_t* pPalRangeStatus) {
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t tmpByte;
+    uint8_t SigmaLimitCheckEnable;
+    uint8_t SignalRefClipLimitCheckEnable;
+    FixPoint1616_t SigmaEstimate;
+    FixPoint1616_t SigmaLimitValue;
+    FixPoint1616_t SignalRefClipValue;
+    uint8_t DeviceRangeStatusInternal = 0;
+    uint16_t tmpWord;
+    FixPoint1616_t LastSignalRefMcps;
+
+    LOG_FUNCTION_START("");
+
+    /*
+     * VL53L0 has a good ranging when the value of the DeviceRangeStatus = 11.
+     * This function will replace the value 0 with the value 11 in the
+     * DeviceRangeStatus.
+     * In addition, the SigmaEstimator is not included in the VL53L0
+     * DeviceRangeStatus, this will be added in the PalRangeStatus.
+     */
+
+    DeviceRangeStatusInternal = ((DeviceRangeStatus & 0x78) >> 3);
+
+    if (DeviceRangeStatusInternal == 11) {
+        tmpByte = 0;
+    } else if (DeviceRangeStatusInternal == 0) {
+        tmpByte = 11;
+    } else {
+        tmpByte = DeviceRangeStatusInternal;
+    }
+
+    /* LastSignalRefMcps */
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_RdWord(Dev, VL53L0_REG_RESULT_PEAK_SIGNAL_RATE_REF,
+        		&tmpWord);
+
+    LastSignalRefMcps = VL53L0_FIXPOINT97TOFIXPOINT1616(tmpWord);
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    PALDevDataSet(Dev, LastSignalRefMcps, LastSignalRefMcps);
+
+    /*
+     * Check if Sigma limit is enabled, if yes then do comparison with limit
+     * value and put the result back into pPalRangeStatus.
+     */
+    if (Status == VL53L0_ERROR_NONE)
+    	Status =  VL53L0_GetLimitCheckEnable(Dev,
+    		VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE, &SigmaLimitCheckEnable);
+
+    if ((SigmaLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
+        /*
+         * compute the Sigma and check with limit
+         */
+        Status = VL53L0_calc_sigma_estimate(Dev, pRangingMeasurementData,
+        		&SigmaEstimate);
+
+        if (Status == VL53L0_ERROR_NONE) {
+            Status = VL53L0_GetLimitCheckValue(Dev,
+            		VL53L0_CHECKENABLE_SIGMA_FINAL_RANGE, &SigmaLimitValue);
+
+            if ((SigmaLimitValue > 0) && (SigmaEstimate > SigmaLimitValue)) {
+                /* Limit Fail add 2^4 to range status */
+                tmpByte += 16;
+            }
+        }
+    }
+
+    /*
+     * Check if Signal ref clip limit is enabled, if yes then do comparison
+     * with limit value and put the result back into pPalRangeStatus.
+     */
+    if (Status == VL53L0_ERROR_NONE)
+    	Status =  VL53L0_GetLimitCheckEnable(Dev,
+    			VL53L0_CHECKENABLE_SIGNAL_REF_CLIP,
+    			&SignalRefClipLimitCheckEnable);
+
+    if ((SignalRefClipLimitCheckEnable != 0) && (Status == VL53L0_ERROR_NONE)) {
+
+		Status = VL53L0_GetLimitCheckValue(Dev,
+				VL53L0_CHECKENABLE_SIGNAL_REF_CLIP, &SignalRefClipValue);
+
+		if ((SignalRefClipValue > 0) &&
+				(LastSignalRefMcps > SignalRefClipValue)) {
+			/* Limit Fail add 2^5 to range status */
+			tmpByte += 32;
+		}
+    }
+
+    if (Status == VL53L0_ERROR_NONE) {
+        *pPalRangeStatus = tmpByte;
+    }
+
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+
+}
+
+VL53L0_Error VL53L0_reverse_bytes(uint8_t *data, uint32_t size)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    uint8_t tempData;
+    uint32_t mirrorIndex;
+    uint32_t middle = size/2;
+    uint32_t index;
+
+    for(index = 0; index < middle; index++)
+    {
+        mirrorIndex      = size - index - 1;
+        tempData         = data[index];
+        data[index]      = data[mirrorIndex];
+        data[mirrorIndex] = tempData;
+    }
+    return Status;
+}
+
+
+VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev,
+		uint8_t* pTuningSettingBuffer)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    int i;
+    int Index;
+    uint8_t msb;
+    uint8_t lsb;
+    uint8_t SelectParam;
+    uint8_t NumberOfWrites;
+    uint8_t Address;
+    uint8_t localBuffer[4]; /* max */
+    uint16_t Temp16;
+
+    LOG_FUNCTION_START("");
+
+    Index = 0;
+
+    while ((*(pTuningSettingBuffer+Index) != 0) &&
+    		(Status == VL53L0_ERROR_NONE)) {
+        NumberOfWrites = *(pTuningSettingBuffer+Index);
+        Index++;
+        if (NumberOfWrites == 0xFF) {
+            /* internal parameters */
+            SelectParam = *(pTuningSettingBuffer+Index);
+            Index++;
+            switch (SelectParam) {
+                case 0: /* uint16_t SigmaEstRefArray -> 2 bytes */
+                    msb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    lsb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    Temp16 = VL53L0_MAKEUINT16(lsb, msb);
+                    PALDevDataSet(Dev, SigmaEstRefArray, Temp16);
+                    break;
+                case 1: /* uint16_t SigmaEstEffPulseWidth -> 2 bytes */
+                    msb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    lsb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    Temp16 = VL53L0_MAKEUINT16(lsb, msb);
+                    PALDevDataSet(Dev, SigmaEstEffPulseWidth, Temp16);
+                    break;
+                case 2: /* uint16_t SigmaEstEffAmbWidth -> 2 bytes */
+                    msb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    lsb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    Temp16 = VL53L0_MAKEUINT16(lsb, msb);
+                    PALDevDataSet(Dev, SigmaEstEffAmbWidth, Temp16);
+                    break;
+                case 3: /* uint16_t targetRefRate -> 2 bytes */
+                    msb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    lsb = *(pTuningSettingBuffer+Index);
+                    Index++;
+                    Temp16 = VL53L0_MAKEUINT16(lsb, msb);
+                    PALDevDataSet(Dev, targetRefRate, Temp16);
+                    break;
+                default: /* invalid parameter */
+                    Status = VL53L0_ERROR_INVALID_PARAMS;
+            }
+
+        } else if (NumberOfWrites <= 4) {
+            Address = *(pTuningSettingBuffer+Index);
+            Index++;
+
+            for (i=0; i<NumberOfWrites; i++) {
+                localBuffer[i] = *(pTuningSettingBuffer+Index);
+                Index++;
+            }
+
+            Status = VL53L0_WriteMulti(Dev, Address, localBuffer,
+            		NumberOfWrites);
+
+        } else {
+            Status = VL53L0_ERROR_INVALID_PARAMS;
+        }
+    }
+
+
+    LOG_FUNCTION_END(Status);
+    return Status;
+}
+
+VL53L0_Error VL53L0_apply_ref_spads(VL53L0_DEV Dev, uint8_t apertureSpads, uint32_t count)
+{
+    VL53L0_Error status = VL53L0_ERROR_NONE;
+    uint32_t currentSpadIndex = 0;
+    uint8_t startSelect = 0xB4;
+    uint32_t spadArraySize = 6;
+    uint32_t maxSpadCount = 44;
+    uint32_t lastSpadIndex;
+    uint32_t index;
+
+    /*
+     * This function applies a requested number of reference spads, either aperture or
+     * non-aperture, as requested.
+     * The good spad map will be applied.
+     */
+    
+    status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+    
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_DYNAMIC_SPAD_REF_EN_START_OFFSET,    0x00);
+
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
+
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev, 0xFF, 0x00);
+    
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_GLOBAL_CONFIG_REF_EN_START_SELECT, startSelect);
+
+    for(index = 0; index < spadArraySize; index++)
+    {
+        Dev->Data.SpadData.RefSpadEnables[index] = 0;
+        Dev->Data.SpadData.RefGoodSpadMap[index] = 0xFF;
+    }
+
+    if(apertureSpads)
+    {
+        /* Increment to the first APERTURE spad */
+        while((is_aperture(startSelect + currentSpadIndex) == 0) &&
+              (currentSpadIndex < maxSpadCount))
+        {
+            currentSpadIndex++;
+        }
+    }
+    status = enable_ref_spads(Dev,
+                              apertureSpads,
+                              Dev->Data.SpadData.RefGoodSpadMap,
+                              Dev->Data.SpadData.RefSpadEnables,
+                              spadArraySize,
+                              startSelect,
+                              currentSpadIndex,
+                              count,
+                              &lastSpadIndex);
+    return status;
+}
+
+VL53L0_Error VL53L0_PerformRefSpadManagement(VL53L0_DEV Dev)
+{
+    VL53L0_Error Status = VL53L0_ERROR_NONE;
+    VL53L0_RangingMeasurementData_t rangingMeasurementData;
+    uint8_t lastSpadArray[6];
+    uint8_t startSelect = 0xB4;
+    uint32_t minimumSpadCount = 5;
+    uint32_t maxSpadCount = 44;
+    uint32_t currentSpadIndex = 0;
+    uint32_t lastSpadIndex;
+    int32_t nextGoodSpad;
+    uint16_t targetRefRate = 0x0A00; /* 20 MCPS in 9:7 format */
+    uint16_t peakSignalRateRef;
+    uint32_t needAptSpads = -1;
+    uint32_t index;
+    uint32_t spadArraySize = 6;
+    uint32_t signalRateDiff;
+    uint32_t lastSignalRateDiff;
+    uint8_t complete;
+    uint8_t SequenceConfig = 0;
+
+
+    /*
+     * The reference SPAD initialization procedure determines the minimum
+     * amount of reference spads to be enables to achieve a target reference
+     * signal rate and should be performed once during initialization.
+     *
+     * Either aperture or non-aperture spads are applied but never both.
+     * Firstly non-aperture spads are set, begining with 5 spads, and increased
+     * one spad at a time until the closest measurement to the target rate is
+     * achieved.
+     *
+     * If the target rate is exceeded when 5 non-aperture spads are enabled,
+     * initialization is performed instead with aperture spads.
+     *
+     * When setting spads, a 'Good Spad Map' is applied.
+     *
+     * This procedure operates within a SPAD window of interest of a maximum 44
+     * spads.
+     * The start point is currently fixed to 180, which lies towards the end of
+     * the non-aperture quadrant and runs in to the adjacent aperture quadrant.
+     */
+
+
+    targetRefRate = PALDevDataGet(Dev, targetRefRate);
+
+    /*
+     * Initialize Spad arrays.
+     * Currently the good spad map is initialised to 'All good'.
+     * This is a short term implementation. The good spad map will be provided
+     * as an input.
+     * Note that there are 6 bytes. Only the furst 44 bits will be used to
+     * represent spads.
+     */
+    for(index = 0; index < spadArraySize; index++)
+    {
+        Dev->Data.SpadData.RefSpadEnables[index] = 0;
+        Dev->Data.SpadData.RefGoodSpadMap[index] = 0xFF;
+    }
+
+    Status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+    
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_DYNAMIC_SPAD_REF_EN_START_OFFSET,    0x00);
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev, 0xFF, 0x00);
+    
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_GLOBAL_CONFIG_REF_EN_START_SELECT, startSelect);
+
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_WrByte(Dev,
+        		VL53L0_REG_POWER_MANAGEMENT_GO1_POWER_FORCE, 0);
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        /* store the value of the sequence config,
+         * this will be reset before the end of the function
+         */
+        SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
+
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, 1);
+
+        PALDevDataSet(Dev, SequenceConfig, 0x01);
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+        Status = VL53L0_PerformSingleRangingMeasurement(Dev,
+        		&rangingMeasurementData);
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, 2);
+        PALDevDataSet(Dev, SequenceConfig, 0x02);
+
+    }
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        Status = VL53L0_PerformSingleRangingMeasurement(Dev,
+        		&rangingMeasurementData);
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        /* Enable Minimum NON-APERTURE Spads */
+        currentSpadIndex = 0;
+        lastSpadIndex = currentSpadIndex;
+        needAptSpads = 0;
+        Status = enable_ref_spads(Dev,
+                                  needAptSpads,
+                                  Dev->Data.SpadData.RefGoodSpadMap,
+                                  Dev->Data.SpadData.RefSpadEnables,
+                                  spadArraySize,
+                                  startSelect,
+                                  currentSpadIndex,
+                                  minimumSpadCount,
+                                  &lastSpadIndex);
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        currentSpadIndex = lastSpadIndex;
+
+        if (Status == VL53L0_ERROR_NONE)
+        {
+            Status = perform_ref_signal_measurement(Dev, &peakSignalRateRef);
+            if (Status == VL53L0_ERROR_NONE)
+            {
+                if(peakSignalRateRef > targetRefRate)
+                {
+                    /* Signal rate measurement too high, switch to
+                     * APERTURE SPADs */
+
+                    for(index = 0; index < spadArraySize; index++)
+                    {
+                        Dev->Data.SpadData.RefSpadEnables[index] = 0;
+                    }
+
+                    /* Increment to the first APERTURE spad */
+                    while((is_aperture(startSelect + currentSpadIndex) == 0) &&
+                    		(currentSpadIndex < maxSpadCount))
+                    {
+                        currentSpadIndex++;
+                    }
+
+                    needAptSpads = 1;
+                    Status = enable_ref_spads(Dev,
+									  needAptSpads,
+									  Dev->Data.SpadData.RefGoodSpadMap,
+									  Dev->Data.SpadData.RefSpadEnables,
+									  spadArraySize,
+									  startSelect,
+									  currentSpadIndex,
+									  minimumSpadCount,
+									  &lastSpadIndex);
+                
+                    if (Status == VL53L0_ERROR_NONE)
+                    {
+                        currentSpadIndex = lastSpadIndex;
+                        Status = perform_ref_signal_measurement(Dev,
+                        		&peakSignalRateRef);
+                        
+                        if ((Status == VL53L0_ERROR_NONE) &&
+                            (peakSignalRateRef > targetRefRate))
+                        {
+                            /* Signal rate still too high after setting the
+                             * minimum number of APERTURE spads.
+                             * Can do no more.
+                             */
+                            Status = VL53L0_ERROR_REF_SPAD_INIT;
+                            needAptSpads    = -1;
+                        }
+                    }
+                }
+                else
+                {
+                    needAptSpads = 0;
+                }
+            }
+        }
+    }
+
+    if (Status == VL53L0_ERROR_NONE)
+    {
+        if(peakSignalRateRef < targetRefRate)
+        {
+            /* At this point, the minimum number of either aperture or
+             * non-aperture spads have been set proceed to add spads and
+             * perform measurements until the target reference is reached.
+             *
+             */
+
+            memcpy(lastSpadArray, Dev->Data.SpadData.RefSpadEnables,
+            		spadArraySize);
+            lastSignalRateDiff = abs(peakSignalRateRef - targetRefRate);
+            complete = 0;
+
+            while(!complete)
+            {
+                get_next_good_spad(Dev->Data.SpadData.RefGoodSpadMap,
+                		spadArraySize, currentSpadIndex, &nextGoodSpad);
+                if(nextGoodSpad == -1)
+                {
+                    Status = VL53L0_ERROR_REF_SPAD_INIT;
+                    break;
+                }
+
+                /* Cannot combine Aperture and Non-Aperture spads, so ensure
+                 * the current spad is of the correct type.
+                 */
+                if(is_aperture((uint32_t)startSelect + nextGoodSpad) !=
+                		needAptSpads)
+                {
+                    Status = VL53L0_ERROR_REF_SPAD_INIT;
+                    break;
+                }
+
+                currentSpadIndex = nextGoodSpad;
+                Status = enable_spad_bit(Dev->Data.SpadData.RefSpadEnables,
+                		spadArraySize, currentSpadIndex);
+                if (Status == VL53L0_ERROR_NONE) {
+					currentSpadIndex++;
+					/* Proceed to apply the additional spad and perform
+					 * mesurement. */
+					Status = set_ref_spad_map(Dev,
+							Dev->Data.SpadData.RefSpadEnables);
+                }
+
+                if (Status == VL53L0_ERROR_NONE)
+                {
+                    Status = perform_ref_signal_measurement(Dev,
+                    		&peakSignalRateRef);
+                    if (Status == VL53L0_ERROR_NONE)
+                    {
+                        if(peakSignalRateRef > targetRefRate)
+                        {
+                            /* Select the spad map that provides the measurement
+                             * closest to the target rate, either above or
+                             * below it.
+                             */
+                            signalRateDiff = abs(peakSignalRateRef -
+                            		targetRefRate);
+                            if(signalRateDiff > lastSignalRateDiff)
+                            {
+                                /* Previous spad map produced a closer
+                                 * measurement, so choose this. */
+                                Status = set_ref_spad_map(Dev, lastSpadArray);
+                                memcpy(Dev->Data.SpadData.RefSpadEnables,
+                                		lastSpadArray, spadArraySize);
+                            }
+                            complete = 1;
+                        }
+                        else
+                        {
+                            /* Continue to add spads */
+                            lastSignalRateDiff = signalRateDiff;
+                            memcpy(lastSpadArray,
+                            		Dev->Data.SpadData.RefSpadEnables,
+                            		spadArraySize);
+                        }
+                    }
+                    else
+                        break;
+
+                }
+                else
+                    break;
+            }
+        }
+    }
+
+    if(Status==VL53L0_ERROR_NONE){
+        /* restore the previous Sequence Config */
+        Status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG,
+        		SequenceConfig);
+		if(Status==VL53L0_ERROR_NONE)
+			PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
+    }
+
+    return Status;
+}
+
+VL53L0_Error perform_ref_signal_measurement(VL53L0_DEV Dev,
+		uint16_t *refSignalRate)
+{
+    VL53L0_Error status = VL53L0_ERROR_NONE;
+    VL53L0_RangingMeasurementData_t rangingMeasurementData;
+
+    /*
+     * This function performs a reference signal rate measurement.
+     */
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev, VL53L0_REG_SYSTEM_SEQUENCE_CONFIG, 0xC0);
+        
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_PerformSingleRangingMeasurement(Dev,
+        		&rangingMeasurementData);
+  
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev, 0xFF, 0x01);
+  
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_RdWord(Dev, VL53L0_REG_RESULT_PEAK_SIGNAL_RATE_REF,
+        		refSignalRate);
+    
+    if (status == VL53L0_ERROR_NONE)
+        status = VL53L0_WrByte(Dev, 0xFF, 0x00);
+
+    return status;
+}
+VL53L0_Error enable_ref_spads(VL53L0_DEV Dev,
+                              uint8_t apertureSpads,
+                              uint8_t goodSpadArray[],
+                              uint8_t spadArray[],
+                              uint32_t size,
+                              uint32_t start,
+                              uint32_t offset,
+                              uint32_t spadCount,
+                              uint32_t *lastSpad)
+{
+    VL53L0_Error status = VL53L0_ERROR_NONE;
+    uint32_t index;
+    uint32_t i;
+    int32_t nextGoodSpad = offset;
+    uint32_t currentSpad;
+    uint8_t checkSpadArray[6];
+
+    /*
+     * This function takes in a spad array which may or may not have SPADS
+     * already enabled and appends from a given offset a requested number
+     * of new SPAD enables. The 'good spad map' is applies to
+     * determine the next SPADs to enable.
+     *
+     * This function applies to only aperture or only non-aperture spads.
+     * Checks are performed to ensure this.
+     */
+
+    currentSpad = offset;
+    for(index = 0; index < spadCount; index++)
+    {
+        get_next_good_spad(goodSpadArray, size, currentSpad, &nextGoodSpad);
+        if(nextGoodSpad == -1)
+        {
+            status = VL53L0_ERROR_REF_SPAD_INIT;
+            break;
+        }
+
+        /* Confirm that the next good SPAD is non-aperture */
+        if(is_aperture(start + nextGoodSpad) != apertureSpads)
+        {
+            /* if we can't get the required number of good aperture spads
+             * from the current quadrant then this is an error.
+             */
+            status = VL53L0_ERROR_REF_SPAD_INIT;
+            break;
+        }
+        currentSpad = (uint32_t)nextGoodSpad;
+        enable_spad_bit(spadArray, size, currentSpad);
+        currentSpad++;
+    }
+    *lastSpad = currentSpad;
+    
+    if (status == VL53L0_ERROR_NONE)
+    {
+        status = set_ref_spad_map(Dev, spadArray);
+    }
+    
+    if (status == VL53L0_ERROR_NONE)
+    {
+        status = get_ref_spad_map(Dev, checkSpadArray);
+    
+        i = 0;
+        
+        /* Compare spad maps. If not equal report error. */
+        while(i < size)
+        {
+            if (spadArray[i] != checkSpadArray[i])
+            {
+                status = VL53L0_ERROR_REF_SPAD_INIT;
+                break;
+            }
+            i++;
+        }
+    }
+    return status;
+}
+
+uint8_t is_aperture(uint32_t spadIndex)
+{
+    /*
+     * This function reports if a given spad index is an aperture SPAD by
+     * deriving the quadrant.
+     */
+    uint32_t quadrant;
+    uint8_t isAperture = 1;
+    quadrant = spadIndex >> 6;
+    if(refArrayQuadrants[quadrant] == REF_ARRAY_SPAD_0)
+    {
+        isAperture = 0;
+    }
+    return isAperture;
+}
+
+void get_next_good_spad(uint8_t goodSpadArray[], uint32_t size, uint32_t current1, int32_t *next)
+{
+    uint32_t startIndex;
+    uint32_t fineOffset;
+    uint32_t cSpadsPerByte = 8;
+    uint32_t coarseIndex;
+    uint32_t fineIndex;
+    uint8_t dataByte;
+    uint8_t success = 0;
+
+    /*
+     * Starting with the current good spad, loop through the array to find the next.
+     * i.e. the next bit set in the sequence.
+     *
+     * The coarse index is the byte index of the array and the fine index is the index
+     * of the bit within each byte.
+     */
+
+    *next = -1;
+
+    startIndex = current1 / cSpadsPerByte;
+    fineOffset = current1 % cSpadsPerByte;
+
+    for(coarseIndex = startIndex; ((coarseIndex < size) && !success); coarseIndex++)
+    {
+        fineIndex = 0;
+        dataByte = goodSpadArray[coarseIndex];
+
+        if(coarseIndex == startIndex)
+        {
+            /* locate the bit position of the provided current spad bit before iterating */
+            dataByte >>= fineOffset;
+            fineIndex = fineOffset;
+        }
+
+        while(fineIndex < cSpadsPerByte)
+        {
+            if((dataByte & 0x1) == 1)
+            {
+                success = 1;
+                *next = coarseIndex * cSpadsPerByte + fineIndex;
+                break;
+            }
+            dataByte >>= 1;
+            fineIndex++;
+        }
+    }
+}
+
+VL53L0_Error enable_spad_bit(uint8_t spadArray[], uint32_t size, uint32_t spadIndex)
+{
+    VL53L0_Error status = VL53L0_ERROR_NONE;
+    uint32_t cSpadsPerByte = 8;
+    uint32_t coarseIndex;
+    uint32_t fineIndex;
+
+    coarseIndex = spadIndex / cSpadsPerByte;
+    fineIndex = spadIndex % cSpadsPerByte;
+    if(coarseIndex >= size)
+    {
+        status = VL53L0_ERROR_REF_SPAD_INIT;
+    }
+    spadArray[coarseIndex] |= (1 << fineIndex);
+    return status;
+}
+
+VL53L0_Error set_ref_spad_map(VL53L0_DEV Dev, uint8_t *refSpadArray)
+{
+    VL53L0_Error status = VL53L0_WriteMulti(Dev,
+                                            VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_0,
+                                            refSpadArray, 6);
+    return status;
+}
+
+VL53L0_Error get_ref_spad_map(VL53L0_DEV Dev, uint8_t *refSpadArray)
+{
+    VL53L0_Error status = VL53L0_ReadMulti(Dev,
+                                           VL53L0_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_0,
+                                           refSpadArray,
+                                           6);
+    return status;
+}
diff --git a/drivers/input/misc/vl53L0/src/vl53l0_tuning.c b/drivers/input/misc/vl53L0/src/vl53l0_tuning.c
index e402841be62..2efca96a771 100644
--- a/drivers/input/misc/vl53L0/src/vl53l0_tuning.c
+++ b/drivers/input/misc/vl53L0/src/vl53l0_tuning.c
@@ -26,7 +26,6 @@
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  ******************************************************************************/
 
-#include "vl53l0_tuning.h"
 
 #define LOG_FUNCTION_START(fmt, ...) \
 	_LOG_FUNCTION_START(TRACE_MODULE_API, fmt, ##__VA_ARGS__)
@@ -46,13 +45,12 @@
 ////       DEFAULT TUNING SETTINGS                ////
 //////////////////////////////////////////////////////
 */
-VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev)
+/*VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev)
 {
 	VL53L0_Error Status = VL53L0_ERROR_NONE;
 
 	LOG_FUNCTION_START("");
 
-	/* update 17_06_15_v10 */
 	Status |= VL53L0_WrByte(Dev, 0xFF, 0x01);
 	Status |= VL53L0_WrByte(Dev, 0x00, 0x00);
 	Status |= VL53L0_WrByte(Dev, 0x91, 0x3C);
@@ -136,4 +134,4 @@ VL53L0_Error VL53L0_load_tuning_settings(VL53L0_DEV Dev)
 	LOG_FUNCTION_END(Status);
 	return Status;
 }
-
+*/
-- 
2.11.0

