From e48d3c16503d3725bc4885ba6577393aa9939b6d Mon Sep 17 00:00:00 2001
From: Konstantin Makariev <kmakariev@motorola.com>
Date: Thu, 20 Aug 2015 15:32:53 -0500
Subject: [PATCH 031/959] IKKRNBSP-3337 input: synaptics_dsx_i2c: add MMI
 driver files

Adding files needed to build MMI flavor of Synaptics touch driver

Change-Id: I7a392a1364cbb4e71baa9777a07efaec11c3c92a
Signed-off-by: Konstantin Makariev <kmakariev@motorola.com>
Reviewed-on: http://gerrit.mot.com/778370
SLTApproved: Slta Waiver <sltawvr@motorola.com>
SME-Granted: SME Approvals Granted
Tested-by: Jira Key <jirakey@motorola.com>
Reviewed-by: Igor Kovalenko <igork@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
---
 drivers/input/touchscreen/Kconfig                  |   33 +
 drivers/input/touchscreen/Makefile                 |    4 +
 .../input/touchscreen/synaptics_dsx_fw_update.c    | 1981 ++++++
 drivers/input/touchscreen/synaptics_dsx_i2c.c      | 6520 ++++++++++++++++++++
 drivers/input/touchscreen/synaptics_dsx_i2c.h      |  599 ++
 drivers/input/touchscreen/synaptics_dsx_rmi_dev.c  |  757 +++
 .../touchscreen/synaptics_dsx_test_reporting.c     | 5066 +++++++++++++++
 include/linux/input/synaptics_rmi_dsx.h            |   78 +
 include/linux/mmi_hall_notifier.h                  |   61 +
 include/uapi/linux/input.h                         |    2 +
 10 files changed, 15101 insertions(+)
 create mode 100644 drivers/input/touchscreen/synaptics_dsx_fw_update.c
 create mode 100644 drivers/input/touchscreen/synaptics_dsx_i2c.c
 create mode 100644 drivers/input/touchscreen/synaptics_dsx_i2c.h
 create mode 100644 drivers/input/touchscreen/synaptics_dsx_rmi_dev.c
 create mode 100644 drivers/input/touchscreen/synaptics_dsx_test_reporting.c
 create mode 100644 include/linux/input/synaptics_rmi_dsx.h
 create mode 100644 include/linux/mmi_hall_notifier.h

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index e3a44747fdd..5a918ea6ed4 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1073,4 +1073,37 @@ config TOUCHSCREEN_IT7260_I2C
 	  To compile this driver as a module, choose M here: the
 	  module will be called it7258_ts_i2c.
 
+config TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	tristate "Synaptics DSX I2C touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have a Synaptics DSX I2C touchscreen
+	  connected to your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_i2c.
+
+config TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_MMI
+	tristate "Synaptics DSX touchscreen char device"
+	depends on TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	help
+	  This enables support for direct register access for Synaptics DSX
+	  touchscreens.
+
+config TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING
+	tristate "Synaptics DSX touchscreen test reporting"
+	depends on TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	help
+	  This enables support for test reporting for Synaptics DSX
+	  touchscreens.
+
+config TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_MMI
+	tristate "Synaptics DSX touchscreen firmware update (MMI)"
+	depends on TOUCHSCREEN_SYNAPTICS_DSX_I2C
+	help
+	  This enables support for firmware update for Synaptics DSX
+	  touchscreens via the MMI design.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index f3618cc20b3..4bb2f503e27 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -83,3 +83,7 @@ obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx/
 obj-$(CONFIG_TOUCHSCREEN_BU21150)	+= bu21150.o
 obj-$(CONFIG_INPUT_MT_WRAPPER)		+= input_mt_wrapper.o
 obj-$(CONFIG_TOUCHSCREEN_IT7260_I2C)	+= it7258_ts_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C) += synaptics_dsx_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_MMI) += synaptics_dsx_rmi_dev.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING) += synaptics_dsx_test_reporting.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_MMI) += synaptics_dsx_fw_update.o
diff --git a/drivers/input/touchscreen/synaptics_dsx_fw_update.c b/drivers/input/touchscreen/synaptics_dsx_fw_update.c
new file mode 100644
index 00000000000..755a1b889e9
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx_fw_update.c
@@ -0,0 +1,1981 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/firmware.h>
+#include <linux/semaphore.h>
+#include <linux/wakelock.h>
+#include <linux/input/synaptics_rmi_dsx.h>
+#include "synaptics_dsx_i2c.h"
+
+#define CHECKSUM_OFFSET 0x00
+#define BOOTLOADER_VERSION_OFFSET 0x07
+#define IMAGE_SIZE_OFFSET 0x08
+#define CONFIG_SIZE_OFFSET 0x0C
+#define PRODUCT_ID_OFFSET 0x10
+#define PRODUCT_INFO_OFFSET 0x1E
+#define FW_IMAGE_OFFSET 0x100
+
+#define UI_CONFIG_AREA 0x00
+#define PERM_CONFIG_AREA 0x01
+#define BL_CONFIG_AREA 0x02
+#define DISP_CONFIG_AREA 0x03
+
+enum flash_command {
+	CMD_WRITE_FW_BLOCK		= 0x2,
+	CMD_ERASE_ALL			= 0x3,
+	CMD_READ_CONFIG_BLOCK	= 0x5,
+	CMD_WRITE_CONFIG_BLOCK	= 0x6,
+	CMD_ERASE_CONFIG		= 0x7,
+	CMD_ERASE_BL_CONFIG		= 0x9,
+	CMD_ERASE_DISP_CONFIG	= 0xA,
+	CMD_ENABLE_FLASH_PROG	= 0xF,
+};
+
+#define SLEEP_MODE_NORMAL (0x00)
+#define SLEEP_MODE_SENSOR_SLEEP (0x01)
+#define SLEEP_MODE_RESERVED0 (0x02)
+#define SLEEP_MODE_RESERVED1 (0x03)
+
+#define ENABLE_WAIT_MS (1 * 1000)
+#define WRITE_WAIT_MS (3 * 1000)
+#define ERASE_WAIT_MS (5 * 1000)
+
+#define MIN_SLEEP_TIME_US 500
+#define MAX_SLEEP_TIME_US 1000
+
+static ssize_t fwu_sysfs_show_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t fwu_sysfs_store_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_write_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_read_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_config_area_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_force_reflash_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_image_size_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t fwu_sysfs_block_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_firmware_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_configuration_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_perm_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_bl_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static int fwu_wait_for_idle(int timeout_ms);
+
+static int fwu_scan_pdt(void);
+
+/* F34 packet register description */
+
+static struct {
+	unsigned char id_letter;
+	unsigned char id_digit;
+} f34_bootloader_id;
+
+static struct {
+	unsigned char bl_minor;
+	unsigned char bl_major;
+} f34_bootloader_mm;
+
+static struct {
+	unsigned char fw_id_0_7;
+	unsigned char fw_id_8_15;
+	unsigned char fw_id_16_23;
+	unsigned char fw_id_24_31;
+} f34_firmware_id;
+
+static struct f34_properties flash_properties;
+
+static struct {
+	unsigned char blk_size_lsb;
+	unsigned char blk_size_msb;
+} f34_blk_size;
+
+static struct f34_query3_0 {
+	unsigned char fw_blk_count_lsb;
+	unsigned char fw_blk_count_msb;
+} f34_fw_blk_count;
+
+static struct {
+	unsigned char ui_cfg_blk_count_lsb;
+	unsigned char ui_cfg_blk_count_msb;
+} f34_ui_cfg_blk_count;
+
+static struct {
+	unsigned char perm_cfg_blk_count_lsb;
+	unsigned char perm_cfg_blk_count_msb;
+} f34_perm_cfg_blk_count;
+
+static struct {
+	unsigned char bl_cfg_blk_count_lsb;
+	unsigned char bl_cfg_blk_count_msb;
+} f34_bl_cfg_blk_count;
+
+static struct {
+	unsigned char disp_cfg_blk_count_lsb;
+	unsigned char disp_cfg_blk_count_msb;
+} f34_disp_cfg_blk_count;
+
+static struct {
+	unsigned char ui_cfg_blk_count_msb2;
+} f34_query_8;
+
+static struct synaptics_rmi4_subpkt f34_query_0_v1[] = {
+	RMI4_SUBPKT_STATIC(0, f34_bootloader_id),
+	RMI4_SUBPKT_STATIC(2, f34_bootloader_mm),
+	RMI4_SUBPKT_STATIC(4, f34_firmware_id),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_1_v1[] = {
+	RMI4_SUBPKT_STATIC(0, flash_properties),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_2_v1[] = {
+	RMI4_SUBPKT_STATIC(0, f34_blk_size),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_3_v1[] = {
+	RMI4_SUBPKT_STATIC(0, f34_fw_blk_count),
+	RMI4_SUBPKT_STATIC(2, f34_ui_cfg_blk_count),
+	RMI4_SUBPKT_STATIC(4, f34_perm_cfg_blk_count),
+	RMI4_SUBPKT_STATIC(6, f34_bl_cfg_blk_count),
+	RMI4_SUBPKT_STATIC(8, f34_disp_cfg_blk_count),
+};
+
+static struct synaptics_rmi4_packet_reg f34_query_reg_array_v1[] = {
+	RMI4_REG_STATIC(0, f34_query_0_v1, 8),
+	RMI4_REG_STATIC(1, f34_query_1_v1, 1),
+	RMI4_REG_STATIC(2, f34_query_2_v1, 2),
+	RMI4_REG_STATIC(3, f34_query_3_v1, 10),
+};
+
+static struct synaptics_rmi4_func_packet_regs f34_query_regs_v1 = {
+	.f_number = SYNAPTICS_RMI4_F34,
+	.base_addr = 0,
+	.nr_regs = ARRAY_SIZE(f34_query_reg_array_v1),
+	.regs = f34_query_reg_array_v1,
+};
+
+static struct synaptics_rmi4_subpkt f34_query_0_v0[] = {
+	RMI4_SUBPKT_STATIC(0, f34_bootloader_id),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_2_v0[] = {
+	RMI4_SUBPKT_STATIC(0, flash_properties),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_3_v0[] = {
+	RMI4_SUBPKT_STATIC(0, f34_blk_size),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_5_v0[] = {
+	RMI4_SUBPKT_STATIC(0, f34_fw_blk_count),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_7_v0[] = {
+	RMI4_SUBPKT_STATIC(0, f34_ui_cfg_blk_count),
+	RMI4_SUBPKT_STATIC(2, f34_perm_cfg_blk_count),
+	RMI4_SUBPKT_STATIC(4, f34_bl_cfg_blk_count),
+	RMI4_SUBPKT_STATIC(6, f34_disp_cfg_blk_count),
+};
+
+static struct synaptics_rmi4_subpkt f34_query_8_v0[] = {
+	RMI4_SUBPKT_STATIC(0, f34_query_8),
+};
+
+static struct synaptics_rmi4_packet_reg f34_query_reg_array_v0[] = {
+	RMI4_REG_STATIC(0, f34_query_0_v0, 2), /* bootloader id */
+	RMI4_REG_STATIC(2, f34_query_2_v0, 1), /* flash properties */
+	RMI4_REG_STATIC(3, f34_query_3_v0, 2), /* block size */
+	RMI4_REG_STATIC(5, f34_query_5_v0, 2), /* firmware block count */
+	RMI4_REG_STATIC(7, f34_query_7_v0, 8),
+	RMI4_REG_STATIC(8, f34_query_8_v0, 1),
+};
+
+static struct synaptics_rmi4_func_packet_regs f34_query_regs_v0 = {
+	.f_number = SYNAPTICS_RMI4_F34,
+	.base_addr = 0,
+	.nr_regs = ARRAY_SIZE(f34_query_reg_array_v0),
+	.regs = f34_query_reg_array_v0,
+};
+
+struct image_header {
+	unsigned int checksum;
+	size_t image_size;
+	size_t config_size;
+	unsigned char options;
+	unsigned char bootloader_version;
+	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+};
+
+struct pdt_properties {
+	union {
+		struct {
+			unsigned char reserved_1:6;
+			unsigned char has_bsr:1;
+			unsigned char reserved_2:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f01_device_status {
+	union {
+		struct {
+			unsigned char status_code:4;
+			unsigned char reserved:2;
+			unsigned char flash_prog:1;
+			unsigned char unconfigured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f01_device_control {
+	union {
+		struct {
+			unsigned char sleep_mode:2;
+			unsigned char nosleep:1;
+			unsigned char reserved:2;
+			unsigned char charger_connected:1;
+			unsigned char report_rate:1;
+			unsigned char configured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_fwu_handle {
+	bool initialized;
+	bool irq_enabled;
+	char fw_filename[SYNAPTICS_RMI4_FILENAME_SIZE];
+	unsigned int firmware_id;
+	unsigned int config_id;
+	unsigned int image_size;
+	unsigned int data_pos;
+	unsigned char intr_mask;
+	unsigned char bootloader_id[2];
+	unsigned char *ext_data_source;
+	unsigned char *read_config_buf;
+	const unsigned char *firmware_data;
+	const unsigned char *config_data;
+	unsigned short block_size;
+	unsigned short fw_block_count;
+	unsigned short config_block_count;
+	unsigned short perm_config_block_count;
+	unsigned short bl_config_block_count;
+	unsigned short disp_config_block_count;
+	unsigned short config_size;
+	unsigned short config_area;
+	unsigned short f34_blkdata_addr;
+	unsigned short f34_flash_cmd_addr;
+	unsigned short f34_flash_status_addr;
+	struct synaptics_rmi4_fn_desc f01_fd;
+	struct synaptics_rmi4_fn_desc f34_fd;
+	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
+	struct synaptics_rmi4_data *rmi4_data;
+	struct semaphore sema;
+	struct wake_lock flash_wake_lock;
+};
+
+static struct bin_attribute dev_attr_data = {
+	.attr = {
+		.name = "data",
+		.mode = (S_IRUGO | S_IWUSR | S_IWGRP),
+	},
+	.size = 0,
+	.read = fwu_sysfs_show_image,
+	.write = fwu_sysfs_store_image,
+};
+
+static struct device_attribute attrs[] = {
+	__ATTR(doreflash, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_do_reflash_store),
+	__ATTR(writeconfig, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_write_config_store),
+	__ATTR(readconfig, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_read_config_store),
+	__ATTR(configarea, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_config_area_store),
+	__ATTR(imagesize, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_image_size_store),
+	__ATTR(blocksize, S_IRUSR | S_IRGRP,
+			fwu_sysfs_block_size_show,
+			synaptics_rmi4_store_error),
+	__ATTR(forcereflash, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			fwu_sysfs_force_reflash_store),
+	__ATTR(fwblockcount, S_IRUSR | S_IRGRP,
+			fwu_sysfs_firmware_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(configblockcount, S_IRUSR | S_IRGRP,
+			fwu_sysfs_configuration_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(permconfigblockcount, S_IRUSR | S_IRGRP,
+			fwu_sysfs_perm_config_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(blconfigblockcount, S_IRUSR | S_IRGRP,
+			fwu_sysfs_bl_config_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(dispconfigblockcount, S_IRUSR | S_IRGRP,
+			fwu_sysfs_disp_config_block_count_show,
+			synaptics_rmi4_store_error),
+};
+
+static struct synaptics_rmi4_fwu_handle *fwu;
+static bool force_reflash;
+static struct completion remove_complete;
+
+static unsigned int extract_uint(const unsigned char *ptr)
+{
+	return (unsigned int)ptr[0] +
+			(unsigned int)ptr[1] * 0x100 +
+			(unsigned int)ptr[2] * 0x10000 +
+			(unsigned int)ptr[3] * 0x1000000;
+}
+
+static void parse_header(struct image_header *header,
+		const unsigned char *fw_image)
+{
+	header->checksum = extract_uint(&fw_image[CHECKSUM_OFFSET]);
+	header->bootloader_version = fw_image[BOOTLOADER_VERSION_OFFSET];
+	header->image_size = extract_uint(&fw_image[IMAGE_SIZE_OFFSET]);
+	header->config_size = extract_uint(&fw_image[CONFIG_SIZE_OFFSET]);
+	memcpy(header->product_id, &fw_image[PRODUCT_ID_OFFSET],
+			SYNAPTICS_RMI4_PRODUCT_ID_SIZE);
+	header->product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE] = 0;
+	memcpy(header->product_info, &fw_image[PRODUCT_INFO_OFFSET],
+			SYNAPTICS_RMI4_PRODUCT_INFO_SIZE);
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+		"Firwmare size %zu, config size %zu\n",
+		header->image_size,
+		header->config_size);
+
+	return;
+}
+
+static unsigned int fwu_firmware_id(void)
+{
+	unsigned int firmware_id;
+	struct synaptics_rmi4_device_info *rmi;
+	rmi = &(fwu->rmi4_data->rmi4_mod_info);
+	batohui(&firmware_id, rmi->build_id, sizeof(rmi->build_id));
+	return firmware_id;
+}
+
+static int fwu_read_f01_device_status(struct f01_device_status *status)
+{
+	return fwu->fn_ptr->read(fwu->rmi4_data,
+			fwu->f01_fd.data_base_addr,
+			status->data,
+			sizeof(status->data));
+}
+
+static struct synaptics_rmi4_func_packet_regs
+			*fwu_scan_f34_reg_info(void)
+{
+	struct synaptics_rmi4_func_packet_regs *regs =
+			fwu->bootloader_id[1] == '5' ?
+			&f34_query_regs_v0 : &f34_query_regs_v1;
+	int r;
+	for (r = 0; r < regs->nr_regs; ++r) {
+		struct synaptics_rmi4_packet_reg *reg = regs->regs + r;
+		kfree(reg->data);
+		reg->data = kzalloc(reg->size, GFP_KERNEL);
+		if (!reg->data) {
+			/* prevent reading if memory alloc failed */
+			reg->offset = -1;
+			reg->size = 0;
+		}
+	}
+	return regs;
+}
+
+static int fwu_f34_read_query_regs(void)
+{
+	int retval = -ENODATA;
+	struct synaptics_rmi4_func_packet_regs *f34_regs;
+
+	f34_regs = fwu_scan_f34_reg_info();
+	f34_regs->base_addr = fwu->f34_fd.query_base_addr;
+	retval = synaptics_rmi4_read_packet_regs(fwu->rmi4_data, f34_regs);
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to query F34 registers: rc=%d\n",
+				__func__, retval);
+	}
+	return retval;
+}
+
+static int fwu_read_f34_queries(void)
+{
+	int retval;
+	struct i2c_client *i2c_client = fwu->rmi4_data->i2c_client;
+
+	/* read BL id to determine F34 version */
+	retval = fwu->fn_ptr->read(fwu->rmi4_data,
+			fwu->f34_fd.query_base_addr,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
+	if (retval < 0) {
+		dev_err(&i2c_client->dev,
+				"%s: Failed to read bootloader ID\n",
+				__func__);
+		return retval;
+	}
+
+	retval = fwu_f34_read_query_regs();
+	if (retval < 0) {
+		dev_err(&i2c_client->dev,
+				"%s: Failed to read query regs\n",
+				__func__);
+		return retval;
+	}
+
+	dev_dbg(&i2c_client->dev,
+		"%s perm:%d, bl:%d, display:%d\n",
+		__func__,
+		flash_properties.has_perm_config,
+		flash_properties.has_bl_config,
+		flash_properties.has_display_config);
+
+	batohs(&fwu->block_size, (unsigned char *)&f34_blk_size);
+	batohs(&fwu->fw_block_count, (unsigned char *)&f34_fw_blk_count);
+	batohs(&fwu->config_block_count,
+				(unsigned char *)&f34_ui_cfg_blk_count);
+	batohs(&fwu->perm_config_block_count,
+				(unsigned char *)&f34_perm_cfg_blk_count);
+	batohs(&fwu->bl_config_block_count,
+				(unsigned char *)&f34_bl_cfg_blk_count);
+	batohs(&fwu->disp_config_block_count,
+				(unsigned char *)&f34_disp_cfg_blk_count);
+
+	if (flash_properties.has_config_id) {
+		struct synaptics_rmi4_device_info *rmi;
+		rmi = &(fwu->rmi4_data->rmi4_mod_info);
+		retval = fwu->fn_ptr->read(fwu->rmi4_data,
+				fwu->f34_fd.ctrl_base_addr,
+				rmi->config_id,
+				SYNAPTICS_RMI4_CONFIG_ID_SIZE);
+		if (retval < 0) {
+			dev_err(&i2c_client->dev,
+				"Failed to read config ID (code %d).\n",
+				retval);
+			return retval;
+		}
+	}
+
+	/* fill in version dependent F34 data registers addresses */
+	if (fwu->bootloader_id[1] == '5') {
+		fwu->f34_blkdata_addr = fwu->f34_fd.data_base_addr + 2;
+		fwu->f34_flash_cmd_addr = fwu->f34_fd.data_base_addr +
+							fwu->block_size + 2;
+		fwu->f34_flash_status_addr = fwu->f34_flash_cmd_addr;
+	} else {
+		fwu->f34_blkdata_addr = fwu->f34_fd.data_base_addr + 1;
+		fwu->f34_flash_cmd_addr = fwu->f34_fd.data_base_addr + 2;
+		fwu->f34_flash_status_addr = fwu->f34_fd.data_base_addr + 3;
+	}
+
+	return 0;
+}
+
+static int fwu_read_interrupt_status(void)
+{
+	int retval;
+	unsigned char interrupt_status;
+	retval = fwu->fn_ptr->read(fwu->rmi4_data,
+			fwu->f01_fd.data_base_addr + 1,
+			&interrupt_status,
+			sizeof(interrupt_status));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to read intr status\n",
+				__func__);
+		return retval;
+	}
+	return interrupt_status;
+}
+
+static int fwu_read_f34_flash_status(unsigned char *status,
+					bool program_enabled)
+{
+	int retval;
+	retval = fwu->fn_ptr->read(fwu->rmi4_data,
+			fwu->f34_flash_status_addr,
+			status,
+			sizeof(*status));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to read flash status\n",
+				__func__);
+		return retval;
+	}
+	if (program_enabled)
+		*status &= 0x80;
+	else
+		*status &= 0x3F;
+	return 0;
+}
+
+static int fwu_reset_device(void)
+{
+	int retval;
+
+	retval = fwu->rmi4_data->reset_device(fwu->rmi4_data,
+				&fwu->f01_fd.cmd_base_addr);
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to reset core driver after reflash\n",
+				__func__);
+		goto exit;
+	}
+
+	retval = fwu_scan_pdt();
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to scan PDT after reflash\n",
+				__func__);
+		goto exit;
+	}
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to query F34 after reflash\n",
+				__func__);
+		goto exit;
+	}
+exit:
+	return retval;
+}
+
+static int fwu_write_f34_command(unsigned char cmd)
+{
+	int retval;
+
+	retval = fwu->fn_ptr->write(fwu->rmi4_data,
+			fwu->f34_flash_cmd_addr,
+			&cmd,
+			sizeof(cmd));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to write command 0x%02x\n",
+				__func__, cmd);
+		return retval;
+	}
+	return 0;
+}
+
+static irqreturn_t fwu_irq(int irq, void *data)
+{
+	struct synaptics_rmi4_fwu_handle *fwu_ptr = data;
+	up(&fwu_ptr->sema);
+	return IRQ_HANDLED;
+}
+
+static int fwu_wait_for_idle(int timeout_ms)
+{
+	int retval;
+
+	retval = down_timeout(&fwu->sema, msecs_to_jiffies(timeout_ms));
+	if (retval) {
+		retval = -ETIMEDOUT;
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"timed out waiting for cmd to complete\n");
+	} else
+		retval = fwu_read_interrupt_status();
+	return retval;
+}
+
+static int fwu_scan_pdt(void)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char intr_count = 0;
+	unsigned char intr_off;
+	unsigned char intr_src;
+	unsigned short addr;
+	bool f01found = false;
+	bool f34found = false;
+	struct synaptics_rmi4_fn_desc rmi_fd;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev, "Scan PDT\n");
+
+	for (addr = PDT_START; addr > PDT_END; addr -= PDT_ENTRY_SIZE) {
+		retval = fwu->fn_ptr->read(fwu->rmi4_data,
+					addr,
+					(unsigned char *)&rmi_fd,
+					sizeof(rmi_fd));
+		if (retval < 0)
+			return retval;
+
+		if (rmi_fd.fn_number) {
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+					"%s: Found F%02x\n",
+					__func__, rmi_fd.fn_number);
+			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F01:
+				f01found = true;
+				fwu->f01_fd = rmi_fd;
+				break;
+			case SYNAPTICS_RMI4_F34:
+				f34found = true;
+				fwu->f34_fd = rmi_fd;
+				fwu->intr_mask = 0;
+				intr_src = rmi_fd.intr_src_count;
+				intr_off = intr_count % 8;
+				for (ii = intr_off;
+						ii < ((intr_src & MASK_3BIT) +
+						intr_off);
+						ii++)
+					fwu->intr_mask |= 1 << ii;
+				break;
+			}
+		} else
+			break;
+
+		if (rmi_fd.intr_src_count & 0x60)
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"%s: F%02x alternative version!!!\n",
+				__func__,
+				rmi_fd.fn_number);
+
+		intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
+	}
+
+	if (!f01found || !f34found) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to find both F01 and F34\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	fwu_read_interrupt_status();
+	return 0;
+}
+
+static int fwu_write_blocks(unsigned char *block_ptr, unsigned short block_cnt,
+		unsigned char command)
+{
+	int retval;
+	unsigned char block_offset[] = {0, 0};
+	unsigned short block_num;
+	unsigned int progress = (command == CMD_WRITE_CONFIG_BLOCK) ?
+				10 : 100;
+	block_offset[1] |= (UI_CONFIG_AREA << 5);
+	retval = fwu->fn_ptr->write(fwu->rmi4_data,
+			fwu->f34_fd.data_base_addr,
+			block_offset,
+			sizeof(block_offset));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to write to block number registers\n",
+				__func__);
+		return retval;
+	}
+
+	for (block_num = 0; block_num < block_cnt; block_num++) {
+		unsigned char flash_status = 0;
+		if (block_num % progress == 0)
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"%s: update %s %3d / %3d\n",
+				__func__,
+				command == CMD_WRITE_CONFIG_BLOCK ?
+				"config" : "firmware",
+				block_num,
+				block_cnt);
+
+		retval = fwu->fn_ptr->write(fwu->rmi4_data,
+			fwu->f34_blkdata_addr,
+			block_ptr,
+			fwu->block_size);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to write block data (block %d)\n",
+				__func__, block_num);
+			return retval;
+		}
+
+		retval = fwu_write_f34_command(command);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+					"%s: Failed to write command for block %d\n",
+					__func__, block_num);
+			return retval;
+		}
+
+		retval = fwu_wait_for_idle(WRITE_WAIT_MS);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to wait for idle status \
+				(block %d)\n",
+				__func__, block_num);
+			return retval;
+		}
+
+		fwu_read_f34_flash_status(&flash_status, false);
+		if (flash_status) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Flash block %d status %x\n",
+				__func__,
+				block_num,
+				flash_status);
+			return -EAGAIN;
+		}
+		block_ptr += fwu->block_size;
+	}
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+		"%s: update %s %3d / %3d\n",
+		__func__,
+		command == CMD_WRITE_CONFIG_BLOCK ?
+		"config" : "firmware",
+		block_cnt,
+		block_cnt);
+
+	return 0;
+}
+
+static int fwu_write_firmware(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->firmware_data,
+		fwu->fw_block_count, CMD_WRITE_FW_BLOCK);
+}
+
+static int fwu_write_configuration(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->config_data,
+		fwu->config_block_count, CMD_WRITE_CONFIG_BLOCK);
+}
+
+static int fwu_write_bootloader_id(void)
+{
+	int retval;
+
+	retval = fwu->fn_ptr->read(fwu->rmi4_data,
+			fwu->f34_fd.query_base_addr,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to read bootloader ID\n",
+				__func__);
+		return retval;
+	}
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev, "Write bootloader ID: %c%c\n",
+			fwu->bootloader_id[0], fwu->bootloader_id[1]);
+
+	retval = fwu->fn_ptr->write(fwu->rmi4_data,
+			fwu->f34_blkdata_addr,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to write bootloader ID\n",
+				__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static void fwu_enable_irq(bool enable)
+{
+	int retval;
+
+	if (enable) {
+		if (fwu->irq_enabled)
+			return;
+
+		fwu_read_interrupt_status();
+		sema_init(&fwu->sema, 0);
+
+		retval = request_irq(fwu->rmi4_data->irq, fwu_irq,
+				IRQF_TRIGGER_FALLING, "fwu", fwu);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+					"%s: Failed to request irq: %d\n",
+					__func__, retval);
+		}
+
+		dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+					"enabling F34 IRQ handler\n");
+		fwu->irq_enabled = true;
+	} else {
+		if (!fwu->irq_enabled)
+			return;
+
+		dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+					"disabling F34 IRQ handler\n");
+		disable_irq(fwu->rmi4_data->irq);
+		free_irq(fwu->rmi4_data->irq, fwu);
+		fwu->irq_enabled = false;
+	}
+}
+
+static int fwu_enter_flash_prog(void)
+{
+	int retval;
+	struct f01_device_status f01_device_status;
+	unsigned char program_enabled = 0;
+
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (retval < 0)
+		return retval;
+
+	if (f01_device_status.flash_prog) {
+		dev_info(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Already in flash prog mode\n",
+				__func__);
+		return 0;
+	} else {
+		unsigned int config_id;
+		struct synaptics_rmi4_device_info *rmi;
+
+		rmi = &(fwu->rmi4_data->rmi4_mod_info);
+		batohui(&config_id, rmi->config_id, sizeof(rmi->config_id));
+
+		/* Firmware ID stops changing at some point, thus  */
+		/* config ID is the only id that guaranteed to grow */
+		if (fwu->config_id <= config_id) {
+			/* do not allow downgrade firmware */
+			/* unless specifically instructed to */
+			if (!force_reflash)
+				return -EEXIST;
+
+			force_reflash = false;
+			pr_notice("%s: Reflash enforced\n", __func__);
+		}
+
+		dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Firmware IDs: currently running-%x, in image-%x\n",
+			__func__,
+			fwu_firmware_id(), fwu->firmware_id);
+
+		dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Config IDs: currently running-%x, in image-%x\n",
+			__func__,
+			config_id, fwu->config_id);
+	}
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev, "Enter bootloader mode\n");
+
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		return retval;
+
+	retval = fwu_write_f34_command(CMD_ENABLE_FLASH_PROG);
+	if (retval < 0)
+		return retval;
+
+	retval = fwu_wait_for_idle(ENABLE_WAIT_MS);
+
+	if (retval < 0)
+		return retval;
+
+	fwu_read_f34_flash_status(&program_enabled, true);
+	if (!program_enabled) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Program enabled bit not set\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	retval = fwu_scan_pdt();
+	if (retval < 0)
+		return retval;
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0)
+		return retval;
+
+	dev_info(&fwu->rmi4_data->i2c_client->dev,
+				"Device firmware ID %x\n",
+				fwu_firmware_id());
+
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (retval < 0)
+		return retval;
+
+	if (!f01_device_status.flash_prog) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Not in flash prog mode\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	return retval;
+}
+
+static int fwu_handle_reflash_error(void)
+{
+	int retval, count = 0;
+	int timeout_count = 1000;
+	const struct synaptics_dsx_platform_data *platform_data =
+				fwu->rmi4_data->board;
+	fwu_enable_irq(false);
+
+	do {
+		if (gpio_get_value(platform_data->irq_gpio))
+			break;
+
+		usleep_range(MIN_SLEEP_TIME_US, MAX_SLEEP_TIME_US);
+		count++;
+	} while (count < timeout_count);
+
+	if (count == timeout_count) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Timed out waiting for idle status\n",
+			__func__);
+		return -ETIMEDOUT;
+	}
+
+	fwu_read_interrupt_status();
+
+	retval = fwu_scan_pdt();
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Failed to scan PDT\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Failed to query F34\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	fwu_enable_irq(true);
+
+	return 0;
+}
+
+static int fwu_do_reflash(void)
+{
+	int retval;
+	unsigned char program_enabled = 0;
+
+	fwu_enable_irq(true);
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		goto reflash_failed;
+
+retry:
+	fwu->rmi4_data->set_state(fwu->rmi4_data, STATE_INIT);
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Entered flash prog mode\n",
+			__func__);
+
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		goto reflash_failed;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Bootloader ID written\n",
+			__func__);
+
+	retval = fwu_write_f34_command(CMD_ERASE_ALL);
+	if (retval < 0)
+		goto reflash_failed;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Erase all command written\n",
+			__func__);
+
+	retval = fwu_wait_for_idle(ERASE_WAIT_MS);
+	if (retval < 0)
+		goto reflash_failed;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Idle status detected\n",
+			__func__);
+
+	fwu_read_f34_flash_status(&program_enabled, true);
+	if (!program_enabled) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Program enabled bit not set\n",
+			__func__);
+		retval = -EINVAL;
+		goto reflash_failed;
+	}
+
+	fwu->rmi4_data->set_state(fwu->rmi4_data, STATE_FLASH);
+
+	if (fwu->firmware_data) {
+		retval = fwu_write_firmware();
+		if (retval == -EAGAIN) {
+			retval = fwu_handle_reflash_error();
+			if (!retval) {
+				dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+						"recovered from flash error\n");
+				goto retry;
+			}
+		}
+		if (retval < 0)
+			goto reflash_failed;
+		pr_notice("%s: Firmware programmed\n", __func__);
+	}
+
+	if (fwu->config_data) {
+		retval = fwu_write_configuration();
+		if (retval == -EAGAIN) {
+			retval = fwu_handle_reflash_error();
+			if (!retval) {
+				dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+						"recovered from flash error\n");
+				goto retry;
+			}
+		}
+		if (retval < 0)
+			goto reflash_failed;
+		pr_notice("%s: Configuration programmed\n", __func__);
+	}
+
+
+reflash_failed:
+	fwu_enable_irq(false);
+
+	return retval;
+}
+
+static bool fwu_tdat_image_format(const unsigned char *fw_image)
+{
+	return fw_image[0] == 0x31;
+}
+
+static void fwu_tdat_config_set(const unsigned char *data, size_t size,
+		const unsigned char **image, size_t *image_size)
+{
+	unsigned short id;
+	size_t length, offset;
+
+	for (offset = 0; offset < size; offset += length+5) {
+		id = (data[offset+1] << 8) | data[offset];
+		length = (data[offset+4] << 8) | data[offset+3];
+		if (id == 0x0001) {
+			*image = &data[offset+5];
+			*image_size = length;
+		}
+	}
+}
+
+static void fwu_tdat_section_offset(
+		const unsigned char **image, size_t *image_size)
+{
+	size_t offset;
+	offset = (*image)[0] + 1;
+	*image_size -= offset;
+	*image = &(*image)[offset];
+}
+
+static int fwu_parse_tdat_image(struct image_header *header,
+		const unsigned char *fw_image, size_t fw_size)
+{
+	int ii;
+	unsigned int id;
+	size_t length, offset;
+	const unsigned char *section, *data = fw_image;
+
+	pr_notice("%s: Start TDAT image processing\n", __func__);
+
+	for (ii = 0, offset = 1; offset < fw_size; offset += length+4) {
+		length = (data[offset+3] << 16) |
+			 (data[offset+2] << 8) | data[offset+1];
+
+		dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"Record[%d]: length %zu, offset %zu\n",
+				ii++, length, offset);
+
+		if ((offset+length+4) > fw_size) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+					"Data overflow at offset %zu (%u)\n",
+					offset, data[offset]);
+			return -EINVAL;
+		}
+	}
+
+	if (offset != fw_size) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"Data is misaligned\n");
+		return -EINVAL;
+	}
+
+	for (offset = 1; offset < fw_size; offset += length+4) {
+		id = data[offset];
+		length = (data[offset+3] << 16) |
+			 (data[offset+2] << 8) | data[offset+1];
+		section = &data[offset+4];
+
+		switch (id) {
+		case 1: /* config */
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Config record %d, size %zu\n",
+				__func__, id, length);
+
+			fwu_tdat_config_set(section, length,
+					&fwu->config_data,
+					&header->config_size);
+			fwu_tdat_section_offset(&fwu->config_data,
+						&header->config_size);
+			batohui(&fwu->config_id,
+					(unsigned char *)fwu->config_data,
+					SYNAPTICS_RMI4_CONFIG_ID_SIZE);
+			break;
+
+		case 2: /* firmware */
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Firmware record %d, size %zu\n",
+				__func__,
+				id,
+				length);
+
+			batohui(&fwu->firmware_id,
+					(unsigned char *)&section[1],
+					SYNAPTICS_RMI4_BUILD_ID_SIZE);
+
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Firmware build ID %x\n",
+				__func__,
+				fwu->firmware_id);
+
+			fwu->firmware_data = section;
+			header->image_size = length;
+			fwu_tdat_section_offset(&fwu->firmware_data,
+						&header->image_size);
+			break;
+		default:
+			dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Don't care section id %d\n",
+				__func__,
+				id);
+			break;
+		}
+	}
+
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+		"%s: Firwmare size %zu, config size %zu\n",
+		__func__,
+		header->image_size,
+		header->config_size);
+	return 0;
+}
+
+static int fwu_start_reflash(void)
+{
+	int retval;
+	size_t fw_size = 0;
+	struct image_header header;
+	const unsigned char *fw_image;
+	const struct firmware *fw_entry = NULL;
+	struct f01_device_status f01_device_status;
+	struct i2c_client *i2c_client = fwu->rmi4_data->i2c_client;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(fwu->rmi4_data->rmi4_mod_info);
+
+	pr_notice("%s: Start of reflash process\n", __func__);
+
+	if (fwu->ext_data_source)
+		fw_image = fwu->ext_data_source;
+	else {
+		dev_dbg(&i2c_client->dev,
+				"%s: Requesting firmware image %s\n",
+				__func__, fwu->fw_filename);
+
+		retval = request_firmware(&fw_entry, fwu->fw_filename,
+				&fwu->rmi4_data->i2c_client->dev);
+		if (retval != 0) {
+			dev_err(&i2c_client->dev,
+					"%s: Firmware image %s not available\n",
+					__func__, fwu->fw_filename);
+			retval = -EINVAL;
+			goto exit;
+		}
+
+		dev_dbg(&i2c_client->dev,
+				"%s: Firmware image size = %zu\n",
+				__func__, fw_entry->size);
+
+		fw_image = fw_entry->data;
+		fw_size = fw_entry->size;
+	}
+
+	if (fwu_tdat_image_format(fw_image))
+		fwu_parse_tdat_image(&header, fw_image, fw_size);
+	else {
+		parse_header(&header, fw_image);
+
+		pr_notice("Firmware file has BL version %d\n",
+					header.bootloader_version);
+		if (header.image_size)
+			fwu->firmware_data = fw_image + FW_IMAGE_OFFSET;
+		if (header.config_size)
+			fwu->config_data = fw_image + FW_IMAGE_OFFSET +
+					header.image_size;
+	}
+
+	wake_lock(&fwu->flash_wake_lock);
+	fwu->rmi4_data->irq_enable(fwu->rmi4_data, false);
+
+	dev_dbg(&i2c_client->dev,
+			"Device firmware ID %x\n",
+			fwu_firmware_id());
+	dev_dbg(&i2c_client->dev,
+			"Device config ID 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+			rmi->config_id[0],
+			rmi->config_id[1],
+			rmi->config_id[2],
+			rmi->config_id[3]);
+	/* .img config id */
+	dev_dbg(&i2c_client->dev,
+			".img config ID 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+			fwu->config_data[0],
+			fwu->config_data[1],
+			fwu->config_data[2],
+			fwu->config_data[3]);
+
+	retval = fwu_do_reflash();
+	switch (retval) {
+	case 0:
+		break;
+	case -EEXIST:
+		dev_info(&i2c_client->dev,
+			"%s: Current firmware is up to date\n",
+			__func__);
+		retval = 0;
+	default:
+		if (retval < 0)
+			dev_err(&i2c_client->dev,
+				"%s: Failed to do reflash\n",
+				__func__);
+		fwu->rmi4_data->irq_enable(fwu->rmi4_data, true);
+		goto unlock;
+	}
+
+	fwu->rmi4_data->set_state(fwu->rmi4_data, STATE_UNKNOWN);
+	/* reset device */
+	fwu_reset_device();
+	fwu->rmi4_data->ready_state(fwu->rmi4_data, false);
+
+unlock:
+	/* check device status */
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (!retval)
+		dev_info(&i2c_client->dev,
+			"Device is in %s mode\n",
+			f01_device_status.flash_prog ? "bootloader" : "UI");
+
+	release_firmware(fw_entry);
+	wake_unlock(&fwu->flash_wake_lock);
+exit:
+	return retval;
+}
+
+static int fwu_do_write_config(void)
+{
+	int retval;
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Entered flash prog mode\n",
+			__func__);
+
+	if (fwu->config_area == PERM_CONFIG_AREA) {
+		fwu->config_block_count = fwu->perm_config_block_count;
+		goto write_config;
+	}
+
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Bootloader ID written\n",
+			__func__);
+
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_CONFIG);
+		break;
+	case BL_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_BL_CONFIG);
+		fwu->config_block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_DISP_CONFIG);
+		fwu->config_block_count = fwu->disp_config_block_count;
+		break;
+	}
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Erase command written\n",
+			__func__);
+
+	retval = fwu_wait_for_idle(ERASE_WAIT_MS);
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Idle status detected\n",
+			__func__);
+
+write_config:
+	retval = fwu_write_configuration();
+	if (retval < 0)
+		return retval;
+
+	pr_notice("%s: Config written\n", __func__);
+
+	return retval;
+}
+
+static int fwu_start_write_config(void)
+{
+	int retval;
+	struct image_header header;
+
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		break;
+	case PERM_CONFIG_AREA:
+		if (!flash_properties.has_perm_config)
+			return -EINVAL;
+		break;
+	case BL_CONFIG_AREA:
+		if (!flash_properties.has_bl_config)
+			return -EINVAL;
+		break;
+	case DISP_CONFIG_AREA:
+		if (!flash_properties.has_display_config)
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (fwu->ext_data_source)
+		fwu->config_data = fwu->ext_data_source;
+	else
+		return -EINVAL;
+
+	if (fwu->config_area == UI_CONFIG_AREA) {
+		parse_header(&header, fwu->ext_data_source);
+
+		if (header.config_size) {
+			fwu->config_data = fwu->ext_data_source +
+					FW_IMAGE_OFFSET +
+					header.image_size;
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	pr_notice("%s: Start of write config process\n", __func__);
+
+	retval = fwu_do_write_config();
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to write config\n",
+				__func__);
+	}
+
+	fwu->rmi4_data->reset_device(fwu->rmi4_data,
+				&fwu->f01_fd.cmd_base_addr);
+
+	pr_notice("%s: End of write config process\n", __func__);
+
+	return retval;
+}
+
+static int fwu_do_read_config(void)
+{
+	int retval;
+	unsigned char block_offset[] = {0, 0};
+	unsigned short block_num;
+	unsigned short block_count;
+	unsigned short index = 0;
+
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		goto exit;
+
+	dev_dbg(&fwu->rmi4_data->i2c_client->dev,
+			"%s: Entered flash prog mode\n",
+			__func__);
+
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		block_count = fwu->config_block_count;
+		break;
+	case PERM_CONFIG_AREA:
+		if (!flash_properties.has_perm_config) {
+			retval = -EINVAL;
+			goto exit;
+		}
+		block_count = fwu->perm_config_block_count;
+		break;
+	case BL_CONFIG_AREA:
+		if (!flash_properties.has_bl_config) {
+			retval = -EINVAL;
+			goto exit;
+		}
+		block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		if (!flash_properties.has_display_config) {
+			retval = -EINVAL;
+			goto exit;
+		}
+		block_count = fwu->disp_config_block_count;
+		break;
+	default:
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	fwu->config_size = fwu->block_size * block_count;
+
+	kfree(fwu->read_config_buf);
+	fwu->read_config_buf = kzalloc(fwu->config_size, GFP_KERNEL);
+
+	block_offset[1] |= (fwu->config_area << 5);
+
+	retval = fwu->fn_ptr->write(fwu->rmi4_data,
+			fwu->f34_fd.data_base_addr,
+			block_offset,
+			sizeof(block_offset));
+	if (retval < 0) {
+		dev_err(&fwu->rmi4_data->i2c_client->dev,
+				"%s: Failed to write to block number registers\n",
+				__func__);
+		goto exit;
+	}
+
+	for (block_num = 0; block_num < block_count; block_num++) {
+		retval = fwu_write_f34_command(CMD_READ_CONFIG_BLOCK);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+					"%s: Failed to write read config command\n",
+					__func__);
+			goto exit;
+		}
+
+		retval = fwu_wait_for_idle(WRITE_WAIT_MS);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+					"%s: Failed to wait for idle status\n",
+					__func__);
+			goto exit;
+		}
+
+		retval = fwu->fn_ptr->read(fwu->rmi4_data,
+				fwu->f34_blkdata_addr,
+				&fwu->read_config_buf[index],
+				fwu->block_size);
+		if (retval < 0) {
+			dev_err(&fwu->rmi4_data->i2c_client->dev,
+					"%s: Failed to read block data (block %d)\n",
+					__func__, block_num);
+			goto exit;
+		}
+
+		index += fwu->block_size;
+	}
+
+exit:
+	fwu->rmi4_data->reset_device(fwu->rmi4_data,
+				&fwu->f01_fd.cmd_base_addr);
+	return retval;
+}
+
+int synaptics_fw_updater(unsigned char *fw_data)
+{
+	int retval;
+
+	if (!fwu)
+		return -ENODEV;
+
+	if (!fwu->initialized)
+		return -ENODEV;
+
+	fwu->ext_data_source = fw_data;
+	fwu->config_area = UI_CONFIG_AREA;
+
+	retval = fwu_start_reflash();
+
+	return retval;
+}
+EXPORT_SYMBOL(synaptics_fw_updater);
+
+static ssize_t fwu_sysfs_show_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (count < fwu->config_size) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Not enough space (%zu bytes) in buffer\n",
+				__func__, count);
+		return -EINVAL;
+	}
+
+	memcpy(buf, fwu->read_config_buf, fwu->config_size);
+
+	return fwu->config_size;
+}
+
+static ssize_t fwu_sysfs_store_image(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	memcpy((void *)(&fwu->ext_data_source[fwu->data_pos]),
+			(const void *)buf,
+			count);
+
+	fwu->data_pos += count;
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	char template[SYNAPTICS_RMI4_FILENAME_SIZE];
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	if (count > sizeof(fwu->fw_filename)) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: FW filename is too long\n",
+			__func__);
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	if (!force_reflash) {
+		snprintf(template, sizeof(template), "synaptics-%s-",
+						rmi->product_id_string);
+		if (strncmp(buf, template,
+			strnlen(template, sizeof(template)))) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: FW does not belong to %s\n",
+				__func__,
+				rmi->product_id_string);
+			retval = -EINVAL;
+			goto exit;
+		}
+	}
+
+	strlcpy(fwu->fw_filename, buf, count);
+	dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: FW filename: %s\n",
+			__func__,
+			fwu->fw_filename);
+
+	retval = synaptics_fw_updater(fwu->ext_data_source);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to do reflash\n",
+				__func__);
+		goto exit;
+	}
+
+	retval = count;
+
+exit:
+	kfree(fwu->ext_data_source);
+	fwu->ext_data_source = NULL;
+	return retval;
+}
+
+static ssize_t fwu_sysfs_write_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1) {
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	if (input != 1) {
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	retval = fwu_start_write_config();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write config\n",
+				__func__);
+		goto exit;
+	}
+
+	retval = count;
+
+exit:
+	kfree(fwu->ext_data_source);
+	fwu->ext_data_source = NULL;
+	return retval;
+}
+
+static ssize_t fwu_sysfs_read_config_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	retval = fwu_do_read_config();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read config\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_config_area_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long config_area;
+
+	retval = sstrtoul(buf, 10, &config_area);
+	if (retval)
+		return retval;
+
+	fwu->config_area = config_area;
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_image_size_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long size;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &size);
+	if (retval)
+		return retval;
+
+	fwu->image_size = size;
+	fwu->data_pos = 0;
+
+	kfree(fwu->ext_data_source);
+	fwu->ext_data_source = kzalloc(fwu->image_size, GFP_KERNEL);
+	if (!fwu->ext_data_source) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for image data\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_force_reflash_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	force_reflash = true;
+
+	return count;
+}
+
+static ssize_t fwu_sysfs_block_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%u\n", fwu->block_size);
+}
+
+static ssize_t fwu_sysfs_firmware_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%u\n", fwu->fw_block_count);
+}
+
+static ssize_t fwu_sysfs_configuration_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%u\n", fwu->config_block_count);
+}
+
+static ssize_t fwu_sysfs_perm_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%u\n", fwu->perm_config_block_count);
+}
+
+static ssize_t fwu_sysfs_bl_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%u\n", fwu->bl_config_block_count);
+}
+
+static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%u\n", fwu->disp_config_block_count);
+}
+
+static void synaptics_rmi4_fwu_attn(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char intr_mask)
+{
+	unsigned char flash_status;
+	if (fwu->intr_mask & intr_mask)
+		fwu_read_f34_flash_status(&flash_status, false);
+
+	return;
+}
+
+static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char attr_count;
+	struct pdt_properties pdt_props;
+	struct synaptics_rmi4_device_info *rmi;
+
+	fwu = kzalloc(sizeof(*fwu), GFP_KERNEL);
+	if (!fwu) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for fwu\n",
+				__func__);
+		goto exit;
+	}
+
+	fwu->fn_ptr = kzalloc(sizeof(*(fwu->fn_ptr)), GFP_KERNEL);
+	if (!fwu->fn_ptr) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for fn_ptr\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit_free_fwu;
+	}
+
+	fwu->rmi4_data = rmi4_data;
+	rmi = &(rmi4_data->rmi4_mod_info);
+	fwu->fn_ptr->read = rmi4_data->i2c_read;
+	fwu->fn_ptr->write = rmi4_data->i2c_write;
+	fwu->fn_ptr->enable = rmi4_data->irq_enable;
+
+	retval = fwu->fn_ptr->read(rmi4_data,
+			PDT_PROPS,
+			pdt_props.data,
+			sizeof(pdt_props.data));
+	if (retval < 0) {
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read PDT properties, assuming 0x00\n",
+				__func__);
+	} else if (pdt_props.has_bsr) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Reflash for LTS not currently supported\n",
+				__func__);
+		goto exit_free_mem;
+	}
+
+	retval = fwu_scan_pdt();
+	if (retval < 0)
+		goto exit_free_mem;
+
+	dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: F01 product info: 0x%04x 0x%04x\n", __func__,
+			rmi->product_info[0],
+			rmi->product_info[1]);
+	dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: F01 product ID: %s\n", __func__,
+			rmi->product_id_string);
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0)
+		goto exit_free_mem;
+
+	pr_notice("F34 version %d\n", fwu->bootloader_id[1] - '5');
+
+	wake_lock_init(&fwu->flash_wake_lock,
+				WAKE_LOCK_SUSPEND, "synaptics_fw_flash");
+	fwu->initialized = true;
+
+	retval = sysfs_create_bin_file(&rmi4_data->i2c_client->dev.kobj,
+			&dev_attr_data);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create sysfs bin file\n",
+				__func__);
+		goto exit_free_mem;
+	}
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(&rmi4_data->i2c_client->dev.kobj,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			retval = -ENODEV;
+			goto exit_remove_attrs;
+		}
+	}
+
+	return 0;
+
+exit_remove_attrs:
+for (attr_count--; attr_count >= 0; attr_count--) {
+	sysfs_remove_file(&rmi4_data->i2c_client->dev.kobj,
+			&attrs[attr_count].attr);
+}
+
+sysfs_remove_bin_file(&rmi4_data->i2c_client->dev.kobj, &dev_attr_data);
+
+exit_free_mem:
+	kfree(fwu->fn_ptr);
+
+exit_free_fwu:
+	kfree(fwu);
+
+exit:
+	return 0;
+}
+
+static void synaptics_rmi4_fwu_remove(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char attr_count;
+
+	sysfs_remove_bin_file(&rmi4_data->i2c_client->dev.kobj, &dev_attr_data);
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		sysfs_remove_file(&rmi4_data->i2c_client->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	kfree(fwu->fn_ptr);
+	kfree(fwu);
+
+	complete(&remove_complete);
+
+	return;
+}
+
+static int __init rmi4_fw_update_module_init(void)
+{
+	synaptics_rmi4_new_function(RMI_FW_UPDATER, true,
+			synaptics_rmi4_fwu_init,
+			synaptics_rmi4_fwu_remove,
+			synaptics_rmi4_fwu_attn,
+			IC_MODE_ANY);
+	return 0;
+}
+
+static void __exit rmi4_fw_update_module_exit(void)
+{
+	init_completion(&remove_complete);
+	synaptics_rmi4_new_function(RMI_FW_UPDATER, false,
+			synaptics_rmi4_fwu_init,
+			synaptics_rmi4_fwu_remove,
+			synaptics_rmi4_fwu_attn,
+			IC_MODE_ANY);
+	wait_for_completion(&remove_complete);
+	return;
+}
+
+module_init(rmi4_fw_update_module_init);
+module_exit(rmi4_fw_update_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX FW Update Module");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(SYNAPTICS_DSX_DRIVER_VERSION);
diff --git a/drivers/input/touchscreen/synaptics_dsx_i2c.c b/drivers/input/touchscreen/synaptics_dsx_i2c.c
new file mode 100644
index 00000000000..324b566891e
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx_i2c.c
@@ -0,0 +1,6520 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/ctype.h>
+#include <linux/jiffies.h>
+#include <linux/semaphore.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reboot.h>
+#include <linux/input/synaptics_rmi_dsx.h>
+
+/* define to enable USB charger detection */
+#undef USB_CHARGER_DETECTION
+
+#include "synaptics_dsx_i2c.h"
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+#include "touchx.h"
+#endif
+#include <linux/pinctrl/consumer.h>
+#include <linux/mmi_hall_notifier.h>
+#ifdef KERNEL_ABOVE_2_6_38
+#include <linux/input/mt.h>
+#endif
+
+#define DRIVER_NAME "synaptics_dsx_i2c"
+#define INPUT_PHYS_NAME "synaptics_dsx_i2c/input0"
+#define TYPE_B_PROTOCOL
+
+#define RMI4_WAIT_READY 0
+#define RMI4_HW_RESET 1
+#define RMI4_SW_RESET 2
+
+#define NO_0D_WHILE_2D
+/*
+#define REPORT_2D_Z
+*/
+#define REPORT_2D_W
+
+#define RPT_TYPE (1 << 0)
+#define RPT_X_LSB (1 << 1)
+#define RPT_X_MSB (1 << 2)
+#define RPT_Y_LSB (1 << 3)
+#define RPT_Y_MSB (1 << 4)
+#define RPT_Z (1 << 5)
+#define RPT_WX (1 << 6)
+#define RPT_WY (1 << 7)
+#define RPT_DEFAULT (RPT_TYPE | RPT_X_LSB | RPT_X_MSB | RPT_Y_LSB | RPT_Y_MSB)
+
+#define EXP_FN_DET_INTERVAL 1000 /* ms */
+#define POLLING_PERIOD 1 /* ms */
+#define SYN_I2C_RETRY_TIMES 10
+#define MAX_ABS_MT_TOUCH_MAJOR 15
+#define SYN_MAX_BUTTONS 4
+
+#define F01_STD_QUERY_LEN 21
+#define F01_BUID_ID_OFFSET 18
+#define F01_QUERY1_OFFSET 1
+#define F01_QUERY21_OFFSET 21
+#define F11_STD_QUERY_LEN 9
+#define F11_STD_CTRL_LEN 10
+#define F11_STD_DATA_LEN 12
+#define F12_STD_QUERY_LEN 10
+#define F12_STD_CTRL_LEN 4
+#define F12_STD_DATA_LEN 80
+
+#define RESET_GPIO_NAME "touch_reset"
+#define IRQ_GPIO_NAME "touch_irq"
+
+#define SYDBG(fmt, args...)	printk(KERN_ERR "%s: " fmt, __func__, ##args)
+#define SYDBG_REG(subpkt, fld) SYDBG(#subpkt "." #fld " = 0x%02X\n", subpkt.fld)
+
+#define tk_debug(fmt, args...) pr_err(fmt, ##args)
+
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+static int folio_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data);
+#endif
+static void synaptics_dsx_resumeinfo_start(
+		struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_dsx_resumeinfo_finish(
+		struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_dsx_resumeinfo_isr(
+		struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_dsx_resumeinfo_purgeoff(
+		struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_dsx_resumeinfo_ignore(
+		struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_dsx_resumeinfo_touch(
+		struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_dsx_free_patch(
+		struct synaptics_dsx_patch *patch);
+static struct synaptics_dsx_patch *
+		synaptics_dsx_init_patch(const char *name);
+static int synaptics_rmi4_set_page(
+		struct synaptics_rmi4_data *rmi4_data,
+		unsigned int address);
+
+/* F12 packet register description */
+static struct {
+	unsigned char max_x_lsb;
+	unsigned char max_x_msb;
+	unsigned char max_y_lsb;
+	unsigned char max_y_msb;
+} f12_c08_0;
+
+static struct f12_c20_0_type {
+	unsigned char x_suppression;
+	unsigned char y_suppression;
+} f12_c20_0;
+
+static struct f12_c23_0_type {
+	union {
+		struct {
+			unsigned char finger:1;
+			unsigned char stylus:1;
+			unsigned char palm:1;
+			unsigned char unclassified:1;
+			unsigned char reserved:4;
+		} __packed;
+		unsigned char data[1];
+	};
+} f12_c23_0;
+
+static struct f12_c23_1_type {
+	unsigned char max_num_reported_objects;
+} f12_c23_1;
+
+static struct {
+	unsigned char reported_bytes_per_object;
+} f12_c28_0;
+
+static struct {
+	unsigned char finger_threshold;
+	unsigned char small_finger_threshold;
+	unsigned char small_finger_border;
+	unsigned char negative_finger_threshold;
+} f12_c15_0;
+
+static struct {
+	unsigned char data[128];
+} f12_ctrl_dummy;
+
+static struct synaptics_rmi4_subpkt f12_c15[] = {
+	RMI4_SUBPKT(f12_c15_0),
+};
+
+static struct synaptics_rmi4_subpkt f12_c08[] = {
+	RMI4_SUBPKT(f12_c08_0),
+};
+
+static struct synaptics_rmi4_subpkt f12_c20[] = {
+	RMI4_SUBPKT(f12_c20_0),
+};
+
+static struct synaptics_rmi4_subpkt f12_c23[] = {
+	RMI4_SUBPKT(f12_c23_0),
+	RMI4_SUBPKT(f12_c23_1),
+};
+
+static struct synaptics_rmi4_subpkt f12_c28[] = {
+	RMI4_SUBPKT(f12_c28_0),
+};
+
+static struct synaptics_rmi4_subpkt f12_c09[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c10[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c11[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c12[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c13[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c14[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c16[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c17[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c18[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c19[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c21[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c22[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c24[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c25[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c26[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c27[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c29[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_subpkt f12_c30[] = {
+	RMI4_SUBPKT(f12_ctrl_dummy),
+};
+
+static struct synaptics_rmi4_packet_reg f12_ctrl_reg_array[] = {
+	RMI4_REG(8, f12_c08),
+	RMI4_REG(9, f12_c09),
+	RMI4_REG(10, f12_c10),
+	RMI4_REG(11, f12_c11),
+	RMI4_REG(12, f12_c12),
+	RMI4_REG(13, f12_c13),
+	RMI4_REG(14, f12_c14),
+	RMI4_REG(15, f12_c15),
+	RMI4_REG(16, f12_c16),
+	RMI4_REG(17, f12_c17),
+	RMI4_REG(18, f12_c18),
+	RMI4_REG(19, f12_c19),
+	RMI4_REG(20, f12_c20),
+	RMI4_REG(21, f12_c21),
+	RMI4_REG(22, f12_c22),
+	RMI4_REG(23, f12_c23),
+	RMI4_REG(24, f12_c24),
+	RMI4_REG(25, f12_c25),
+	RMI4_REG(26, f12_c26),
+	RMI4_REG(27, f12_c27),
+	RMI4_REG(28, f12_c28),
+	RMI4_REG(29, f12_c29),
+	RMI4_REG(30, f12_c30),
+};
+
+static struct f12_d1_type {
+	unsigned char type_and_stylus;
+	unsigned char x_lsb;
+	unsigned char x_msb;
+	unsigned char y_lsb;
+	unsigned char y_msb;
+	unsigned char z;
+	unsigned char wx;
+	unsigned char wy;
+} f12_d1_0, f12_d1_1, f12_d1_2, f12_d1_3, f12_d1_4, f12_d1_5, f12_d1_6,
+f12_d1_7, f12_d1_8, f12_d1_9;
+
+static struct synaptics_rmi4_subpkt f12_d1[] = {
+	RMI4_SUBPKT(f12_d1_0),
+	RMI4_SUBPKT(f12_d1_1),
+	RMI4_SUBPKT(f12_d1_2),
+	RMI4_SUBPKT(f12_d1_3),
+	RMI4_SUBPKT(f12_d1_4),
+	RMI4_SUBPKT(f12_d1_5),
+	RMI4_SUBPKT(f12_d1_6),
+	RMI4_SUBPKT(f12_d1_7),
+	RMI4_SUBPKT(f12_d1_8),
+	RMI4_SUBPKT(f12_d1_9),
+};
+
+static struct {
+	unsigned char attn[2];
+} f12_d15_0;
+
+static struct synaptics_rmi4_subpkt f12_d15[] = {
+	RMI4_SUBPKT(f12_d15_0),
+};
+
+static struct synaptics_rmi4_packet_reg f12_data_reg_array[] = {
+	RMI4_REG(1, f12_d1),
+	RMI4_REG(15, f12_d15),
+};
+
+static struct {
+	union {
+		struct {
+			unsigned char sleep_mode:2;
+			unsigned char no_sleep:1;
+			unsigned char reserved:2;
+			unsigned char charger_connected:1;
+			unsigned char report_rate:1;
+			unsigned char configured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+} f01_c0_0;
+
+static struct {
+	unsigned char doze_interval;
+} f01_c2_0;
+
+static struct {
+	unsigned char wakeup_threshold;
+} f01_c3_0;
+
+static struct {
+	unsigned char doze_holdoff;
+} f01_c5_0;
+
+static struct {
+	unsigned char recalibration_interval;
+} f01_c9_0;
+
+static struct synaptics_rmi4_subpkt f01_c0[] = {
+	RMI4_SUBPKT_STATIC(0, f01_c0_0),
+};
+
+static struct synaptics_rmi4_subpkt f01_c2[] = {
+	RMI4_SUBPKT(f01_c2_0),
+};
+
+static struct synaptics_rmi4_subpkt f01_c3[] = {
+	RMI4_SUBPKT(f01_c3_0),
+};
+
+static struct synaptics_rmi4_subpkt f01_c5[] = {
+	RMI4_SUBPKT(f01_c5_0),
+};
+
+static struct synaptics_rmi4_subpkt f01_c9[] = {
+	RMI4_SUBPKT(f01_c9_0),
+};
+
+static struct synaptics_rmi4_packet_reg f01_ctrl_reg_array[] = {
+	RMI4_REG_STATIC(0, f01_c0, 1),
+	RMI4_REG_STATIC(2, f01_c2, 1),
+	RMI4_REG_STATIC(3, f01_c3, 1),
+	RMI4_REG_STATIC(5, f01_c5, 1),
+	RMI4_REG_STATIC(9, f01_c9, 1),
+};
+
+static struct {
+	struct {
+		unsigned short saturation_cap;
+	} __packed;
+} f54_c2_0;
+
+static struct synaptics_rmi4_subpkt f54_c2[] = {
+	RMI4_SUBPKT(f54_c2_0),
+};
+
+static struct f54_control_95n f54_c95_0, f54_c95_1, f54_c95_2,
+	f54_c95_3, f54_c95_4, f54_c95_5, f54_c95_6, f54_c95_7;
+
+static struct synaptics_rmi4_subpkt f54_c95[] = {
+	RMI4_SUBPKT(f54_c95_0),
+	RMI4_SUBPKT(f54_c95_1),
+	RMI4_SUBPKT(f54_c95_2),
+	RMI4_SUBPKT(f54_c95_3),
+	RMI4_SUBPKT(f54_c95_4),
+	RMI4_SUBPKT(f54_c95_5),
+	RMI4_SUBPKT(f54_c95_6),
+	RMI4_SUBPKT(f54_c95_7),
+};
+
+static struct synaptics_rmi4_packet_reg f54_ctrl_reg_array[] = {
+	RMI4_REG(2, f54_c2),
+	RMI4_REG(95, f54_c95),
+};
+
+static struct {
+	unsigned char command;
+} f54_m0_0;
+
+static struct synaptics_rmi4_subpkt f54_m0[] = {
+	RMI4_SUBPKT(f54_m0_0),
+};
+
+static struct synaptics_rmi4_packet_reg f54_cmd_reg_array[] = {
+	RMI4_REG(0, f54_m0),
+};
+
+static struct {
+	union {
+		struct {
+			unsigned char interference_metric_lsb;
+			unsigned char interference_metric_msb;
+		} __packed;
+		unsigned char data[2];
+	};
+} f54_d6_0;
+
+static struct synaptics_rmi4_subpkt f54_d6[] = {
+	RMI4_SUBPKT(f54_d6_0),
+};
+
+static struct {
+	unsigned char noise_state;
+} f54_d10_0;
+
+static struct synaptics_rmi4_subpkt f54_d10[] = {
+	RMI4_SUBPKT(f54_d10_0),
+};
+
+static struct {
+	union {
+		struct {
+			unsigned char cid_im_lsb;
+			unsigned char cid_im_msb;
+		} __packed;
+		unsigned char data[2];
+	};
+} f54_d14_0;
+
+static struct synaptics_rmi4_subpkt f54_d14[] = {
+	RMI4_SUBPKT(f54_d14_0),
+};
+
+static struct {
+	union {
+		struct {
+			unsigned char freq_scan_im_lsb;
+			unsigned char freq_scan_im_msb;
+		} __packed;
+		unsigned char data[2];
+	};
+} f54_d16_0;
+
+static struct synaptics_rmi4_subpkt f54_d16[] = {
+	RMI4_SUBPKT(f54_d16_0),
+};
+
+static struct {
+	union {
+		struct {
+			unsigned char freq:7;
+			unsigned char inhibit_freq_shift:1;
+		}       __packed;
+		unsigned char data[1];
+	};
+} f54_d17_0;
+
+static struct synaptics_rmi4_subpkt f54_d17[] = {
+	RMI4_SUBPKT(f54_d17_0),
+};
+
+static struct synaptics_rmi4_packet_reg f54_data_reg_array[] = {
+	RMI4_REG(6, f54_d6),
+	RMI4_REG(10, f54_d10),
+	RMI4_REG(14, f54_d14),
+	RMI4_REG(16, f54_d16),
+	RMI4_REG(17, f54_d17),
+};
+
+static struct {
+	union {
+		struct {
+		unsigned char cid_check_enable:1;
+		unsigned char fsim_clear_enable:1;
+		unsigned char nsm_intr_enable:1;
+		unsigned char unused:5;
+		} __packed;
+		unsigned char data[1];
+	};
+} f51_c0_0;
+
+static struct {
+	struct {
+		unsigned char dyn_jitter_strength;
+		unsigned char dyn_jitter_gain;
+		unsigned char dyn_jitter_step_size;
+	} __packed;
+} f51_c1_0;
+
+static struct {
+	union {
+		struct {
+		unsigned char md_feature_enable:1;
+		unsigned char md_no_relax:1;
+		unsigned char md_uncond_shutoff:1;
+		unsigned char unused:5;
+		} __packed;
+		unsigned char data[1];
+	};
+	unsigned char md_min_threshold;
+	unsigned char md_max_threshold;
+	unsigned char md_2d_area;
+	unsigned char md_frame_count_in;
+	unsigned char md_frame_count_out;
+} f51_c4_0;
+
+static struct synaptics_rmi4_subpkt f51_c0[] = {
+	RMI4_SUBPKT(f51_c0_0),
+};
+
+static struct synaptics_rmi4_subpkt f51_c1[] = {
+	RMI4_SUBPKT(f51_c1_0),
+};
+
+static struct synaptics_rmi4_subpkt f51_c4[] = {
+	RMI4_SUBPKT(f51_c4_0),
+};
+
+static struct synaptics_rmi4_packet_reg f51_ctrl_reg_array[] = {
+	RMI4_REG(0, f51_c0),
+	RMI4_REG(1, f51_c1),
+	RMI4_REG(4, f51_c4),
+};
+
+struct {
+	union {
+		struct {
+		unsigned char noise_state:1;
+		unsigned char gear_change:1;
+		unsigned char guard_state:1;
+		unsigned char unused:5;
+		unsigned char md_present:1;
+		unsigned char reserved:7;
+		} __packed;
+		unsigned char data[2];
+	};
+} f51_d0_0;
+
+static struct synaptics_rmi4_subpkt f51_d0[] = {
+	RMI4_SUBPKT(f51_d0_0),
+};
+
+static struct synaptics_rmi4_packet_reg f51_data_reg_array[] = {
+	RMI4_REG(0, f51_d0),
+};
+
+static struct {
+	union {
+		struct {
+			unsigned char num_of_scan_freq:4;
+			unsigned char reserved:4;
+		} __packed;
+		unsigned char data[1];
+	};
+} f54_q12_0;
+
+static struct synaptics_rmi4_subpkt f54_q12[] = {
+	RMI4_SUBPKT(f54_q12_0),
+};
+
+static struct synaptics_rmi4_packet_reg f54_query_reg_array[] = {
+	RMI4_REG(12, f54_q12),
+};
+
+#define CTRL_TYPE	(0 << 8)
+#define DATA_TYPE	(1 << 8)
+#define QUERY_TYPE	(2 << 8)
+#define COMMAND_TYPE	(3 << 8)
+
+static inline int register_ascii_to_type(unsigned char *symbol)
+{
+	int reg_type = CTRL_TYPE;
+	switch (*symbol) {
+	case 'Q':
+		reg_type = QUERY_TYPE;
+			break;
+	case 'D':
+		reg_type = DATA_TYPE;
+			break;
+	case 'M':
+		reg_type = COMMAND_TYPE;
+			break;
+	case 'C':
+			break;
+	default: return reg_type;
+	}
+	*symbol = '\0';
+	return reg_type;
+}
+
+static inline unsigned char register_type_to_ascii(int type)
+{
+	unsigned char ascii;
+	switch (type) {
+	case QUERY_TYPE:
+		ascii = 'Q';
+			break;
+	case DATA_TYPE:
+		ascii = 'D';
+			break;
+	case COMMAND_TYPE:
+		ascii = 'M';
+			break;
+	case CTRL_TYPE:
+	default:
+		ascii = 'C';
+	}
+	return ascii;
+}
+
+static struct synaptics_rmi4_func_packet_regs synaptics_cfg_regs[] = {
+	{
+		.f_number = SYNAPTICS_RMI4_F12,
+		.base_addr = 0,
+		.query_offset = 4,
+		.nr_regs = ARRAY_SIZE(f12_ctrl_reg_array),
+		.regs = f12_ctrl_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F01,
+		.base_addr = 0,
+		.query_offset = 0,	/* does not matter */
+		.nr_regs = ARRAY_SIZE(f01_ctrl_reg_array),
+		.regs = f01_ctrl_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F12 | DATA_TYPE,
+		.base_addr = 0,
+		.query_offset = 7,
+		.nr_regs = ARRAY_SIZE(f12_data_reg_array),
+		.regs = f12_data_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F54,
+		.base_addr = 0,
+		.query_offset = 0,	/* does not matter */
+		.nr_regs = ARRAY_SIZE(f54_ctrl_reg_array),
+		.regs = f54_ctrl_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F54 | COMMAND_TYPE,
+		.base_addr = 0,
+		.query_offset = 0,	/* does not matter */
+		.nr_regs = ARRAY_SIZE(f54_cmd_reg_array),
+		.regs = f54_cmd_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F54 | DATA_TYPE,
+		.base_addr = 0,
+		.query_offset = 0,      /* does not matter */
+		.nr_regs = ARRAY_SIZE(f54_data_reg_array),
+		.regs = f54_data_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F54 | QUERY_TYPE,
+		.base_addr = 0,
+		.query_offset = 0,      /* does not matter */
+		.nr_regs = ARRAY_SIZE(f54_query_reg_array),
+		.regs = f54_query_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F51,
+		.base_addr = 0,
+		.query_offset = 0,	/* does not matter */
+		.nr_regs = ARRAY_SIZE(f51_ctrl_reg_array),
+		.regs = f51_ctrl_reg_array,
+	},
+	{
+		.f_number = SYNAPTICS_RMI4_F51 | DATA_TYPE,
+		.base_addr = 0,
+		.query_offset = 0,	/* does not matter */
+		.nr_regs = ARRAY_SIZE(f51_data_reg_array),
+		.regs = f51_data_reg_array,
+	},
+};
+
+static unsigned char tsb_buff_clean_flag = 1;
+
+static char *synaptics_dsx_find_patch(char *head, char *delimiters, char **next)
+{
+	char *patch = head;
+	for (; patch; patch = *next) {
+		*next = strpbrk(patch, delimiters);
+		if (*next)
+			*(*next)++ = '\0';
+		patch = skip_spaces(patch);
+		if (!patch || !*patch || *patch == '#')
+			continue;
+		else
+			break;
+	}
+	return patch;
+}
+
+static int parse_patch_data(char *value_p, u8 data[], long *bitmask_v)
+{
+	int i, error, num_of_bytes = 1;
+	long value_v;
+	char *bitmask_p;
+
+	bitmask_p = strpbrk(value_p, "&");
+	if (bitmask_p) {
+		*bitmask_p++ = '\0';
+		error = kstrtol(bitmask_p, 16, bitmask_v);
+		if (error)
+			pr_err("bitmask conv error\n");
+	}
+
+	/* detect multiple bytes data */
+	if ((strlen(value_p)%2) == 0)
+		num_of_bytes = strlen(value_p)/2;
+
+	for (i = 0; i < num_of_bytes; i++) {
+		char hex_val[3] = {0};
+		hex_val[0] = *value_p;
+		hex_val[1] = *(value_p + 1);
+		error = kstrtol(hex_val, 16, &value_v);
+		if (error)
+			pr_err("value conv error\n");
+		data[i] = (u8)value_v;
+		value_p += 2;
+	}
+
+	return num_of_bytes;
+}
+
+static int synaptics_dsx_parse_patch(int func, char *query,
+		struct synaptics_dsx_patch *patch_ptr, bool expect_data)
+{
+	int i, error, rt_mod, function, num_of_bytes;
+	u8 data[64];
+	char *next, *subpkt_p, *value_p, *pair = query;
+	long regstr_v, bitmask_v, subpkt_v;
+	struct synaptics_dsx_func_patch *patch;
+
+	rt_mod = func & 0xf00;
+	function = func & 0xff;
+	for (i = 0; pair; pair = next, i++) {
+		num_of_bytes = 0;
+		bitmask_v = subpkt_v = 0L;
+
+		pair = synaptics_dsx_find_patch(pair, ",", &next);
+
+		value_p = strpbrk(pair, "=");
+		if (!value_p) {
+			pr_err("F%x[%d]: invalid syntax '%s'\n",
+				function, i, pair);
+			continue;
+		}
+
+		/* make sure string is null terminated */
+		*value_p = '\0';
+
+		subpkt_p = strpbrk(pair, ":");
+		if (subpkt_p) {
+			*subpkt_p++ = '\0';
+			error = kstrtol(subpkt_p, 10, &subpkt_v);
+			if (error) {
+				pr_err("F%x[%d]: subpacket conv error\n",
+					function, i);
+				continue;
+			}
+		}
+
+		error = kstrtol(pair, 10, &regstr_v);
+		if (error) {
+			pr_err("F%x[%d]: register conv error\n",
+				function, i);
+			continue;
+		}
+
+		if (expect_data)
+			num_of_bytes = parse_patch_data(
+						++value_p, data, &bitmask_v);
+		/* primitive data validation */
+		if (function <= 0 || function > 255 ||
+		    regstr_v < 0 || regstr_v > 255) {
+			pr_err("F%x[%d]: invalid values\n", function, i);
+			continue;
+		}
+
+		patch = kzalloc(sizeof(*patch), GFP_KERNEL);
+		if (!patch) {
+			pr_err("failed to alloc mem\n");
+			return -ENOMEM;
+		}
+
+		if (expect_data) {
+			patch->data = kzalloc(num_of_bytes, GFP_KERNEL);
+			if (!patch->data) {
+				pr_err("failed to alloc mem\n");
+				return -ENOMEM;
+			}
+			memcpy(patch->data, data, num_of_bytes);
+		}
+
+		patch->func = (u16)func;
+		patch->regstr = (u8)regstr_v;
+		patch->subpkt = (u8)subpkt_v;
+		patch->size = (u8)num_of_bytes;
+		patch->bitmask = (u8)bitmask_v;
+
+		pr_debug("F%x[%d], register %d, subpkt %d, size %d, mask %x\n",
+			function, i, patch->regstr, patch->subpkt,
+			patch->size, patch->bitmask);
+		patch_ptr->cfg_num++;
+		list_add_tail(&patch->link, &patch_ptr->cfg_head);
+	}
+
+	return 0;
+}
+
+/*
+ * Special settings passed to the driver via device tree
+ * Example: "F12@11:2=1fa0;F1@1=1;"
+ *   Where:
+ *      F12     - decimal object number
+ *      @       - delimits function number and following patch sets
+ *      11:2    - decimal register and subpacket numbers (0 offset)
+ *      26=a    - register number and hex value to assign
+ *      2=1fa0  - 2 bytes of data to write to the register
+ */
+static void synaptics_dsx_parse_string(struct synaptics_rmi4_data *data,
+		const char *patch_ptr,
+		struct synaptics_dsx_patch *patch,
+		bool expect_data)
+{
+	struct device *dev = &data->i2c_client->dev;
+	long number_v;
+	char *patch_string;
+	char *config_p, *next, *patch_set;
+	int i, error, rt_mod = 0;
+
+	patch_string = kstrdup(patch_ptr, GFP_KERNEL);
+	for (i = 0, patch_set = patch_string; patch_set; patch_set = next) {
+		patch_set = synaptics_dsx_find_patch(patch_set, ";\n", &next);
+		if (!patch_set)
+			break;
+
+		dev_dbg(dev, "patch set %d: \"%s\"\n", i, patch_set);
+
+		config_p = strpbrk(patch_set, "@");
+		if ((*patch_set != 'F' && *patch_set != 'f') || !config_p) {
+			dev_err(dev, "invalid syntax '%s'\n", patch_set);
+			continue;
+		}
+
+		rt_mod = register_ascii_to_type(config_p-1);
+		dev_dbg(dev, "register type modifier %d\n", rt_mod);
+
+		/* strip non digits */
+		*config_p++ = '\0';
+
+		error = kstrtol(++patch_set, 16, &number_v);
+		if (error) {
+			dev_err(dev, "kstrtol error %d\n", error);
+			continue;
+		}
+
+		error = synaptics_dsx_parse_patch((int)number_v + rt_mod,
+					config_p, patch, expect_data);
+		if (error < 0) {
+			dev_err(dev, "invalid patch; parse error %d\n", error);
+			continue;
+		}
+
+		i++;
+	}
+	kfree(patch_string);
+	if (patch->cfg_num)
+		dev_info(dev, "processed %d patch sets for %d functions\n",
+			patch->cfg_num, i);
+	else
+		dev_info(dev, "no valid patch sets found\n");
+}
+
+#define LAST_SUBPACKET_ROW_IND_MASK 0x80
+#define NR_SUBPKT_PRESENCE_BITS 7
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+struct touchxs touchxp;
+EXPORT_SYMBOL(touchxp);
+#endif
+
+static struct synaptics_rmi4_func_packet_regs *find_function(int f_number)
+{
+	struct synaptics_rmi4_func_packet_regs *regs = NULL;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(synaptics_cfg_regs); i++)
+		if (synaptics_cfg_regs[i].f_number == f_number) {
+			regs = &synaptics_cfg_regs[i];
+			break;
+		}
+	return regs;
+}
+
+static struct synaptics_rmi4_packet_reg *find_packet_reg(
+	struct synaptics_rmi4_func_packet_regs *regs, int number)
+{
+	struct synaptics_rmi4_packet_reg *reg = NULL;
+	int r;
+	for (r = 0; r < regs->nr_regs; r++)
+		if (number == regs->regs[r].r_number) {
+			reg = &regs->regs[r];
+			break;
+		}
+	return reg;
+}
+
+int synaptics_rmi4_scan_f12_reg_info(
+	struct synaptics_rmi4_data *rmi4_data,
+	unsigned short query_addr,
+	unsigned short regs_base_addr,
+	struct synaptics_rmi4_func_packet_regs *regs)
+{
+	unsigned char sz, mask;
+	int ii, jj, r, s, retval, max_reg_number;
+	unsigned short r_offset;
+	unsigned short addr = query_addr;
+	unsigned char data[255];
+	bool r_exist[128] = {false};
+
+	for (r = 0; r < regs->nr_regs; ++r) {
+		regs->regs[r].offset = -1;
+		regs->regs[r].size = 0;
+		kfree(regs->regs[r].data);
+		for (s = 0; s < regs->regs[r].nr_subpkts; ++s) {
+			regs->regs[r].subpkt[s].present = 0;
+			if (regs->regs[r].subpkt[s].data &&
+					regs->regs[r].subpkt[s].size)
+				memset(regs->regs[r].subpkt[s].data, 0,
+					regs->regs[r].subpkt[s].size);
+		}
+	}
+
+	regs->base_addr = regs_base_addr;
+	retval = rmi4_data->i2c_read(rmi4_data, addr, &sz, 1);
+	pr_debug("size of reg presence = %d, addr 0x%x\n", sz, addr);
+	if (retval < 0)
+		return retval;
+	if (!sz)
+		return -EIO;
+	/* Scan register presence */
+	retval = rmi4_data->i2c_read(rmi4_data, ++addr, data, sz);
+	if (retval < 0)
+		return retval;
+	if (!data[0]) {
+		pr_err("packet register size greater 255 bytes"
+			" not supported\n");
+		return -ENOSYS;
+	}
+	ii = 1;
+	for (r = 0, r_offset = 0; ii < sz; ++ii) {
+		pr_debug("reg presence [%d] = 0x%02x\n", ii, data[ii]);
+		for (jj = 0, mask = 1; jj < 8; ++jj, ++r, mask <<= 1) {
+			struct synaptics_rmi4_packet_reg *reg =
+						find_packet_reg(regs, r);
+			bool present = (data[ii] & mask) != 0;
+			bool allocated = reg ? true : false;
+			if (present != allocated)
+				pr_debug("  reg: r%d is%s present, but was%s"
+						" expected\n", r,
+						present ? "" : " NOT",
+						allocated ? "" : " NOT");
+			if (!present) {
+				r_exist[r] = false;
+				continue;
+			}
+			r_exist[r] = true;
+			if (allocated)
+				reg->offset = r_offset;
+			pr_debug("  r%d offset = %d\n", r, r_offset);
+			r_offset++;
+		}
+	}
+
+	max_reg_number = r;
+	pr_debug("max register number = %d\n", max_reg_number);
+
+	/* Scan register size and subpacket presence*/
+	sz = data[0];
+	pr_debug("subpacket presence sz = %d, addr 0x%x\n", sz, addr+1);
+	retval = rmi4_data->i2c_read(rmi4_data, ++addr, data, sz);
+	if (retval < 0)
+		return retval;
+	for (r = 0, ii = 0; r < max_reg_number && ii < sz; ++r) {
+		unsigned int reg_size, expected_reg_size;
+		struct synaptics_rmi4_packet_reg *reg =
+					find_packet_reg(regs, r);
+		if (!r_exist[r]) {
+			pr_debug("r%d does not exist; go to the next...\n", r);
+			continue;
+		}
+		reg_size = data[ii++];
+		if (!reg_size) {
+			pr_err("packet register size greater 255 bytes"
+				" not supported\n");
+			return -ENOSYS;
+		}
+		if (reg && reg->offset != -1) {
+			reg->data = kzalloc(reg_size, GFP_KERNEL);
+			if (reg->data) {
+				reg->size = reg_size;
+				pr_debug("r%d allocated %d bytes buffer @%p\n",
+					reg->r_number, reg->size, reg->data);
+			} else
+				pr_err("cannot alloc register data buffer\n");
+		}
+		pr_debug("r%d sz = %d\n", r, reg_size);
+		expected_reg_size = 0;
+		for (s = 0; ii < sz;) {
+			pr_debug("  subpkt presence [%d] = 0x%02x\n",
+				ii, data[ii]);
+			for (jj = 0, mask = 1; jj < NR_SUBPKT_PRESENCE_BITS;
+					++jj, ++s, mask <<= 1) {
+				struct synaptics_rmi4_subpkt *subpkt = NULL;
+				bool present = (data[ii] & mask) != 0;
+				bool expected = false;
+				if (reg && s < reg->nr_subpkts) {
+					subpkt = reg->subpkt + s;
+					expected = subpkt->expected;
+				}
+				if (!present || !expected) {
+					if (present != expected)
+						pr_debug("    subpacket:"
+							" r%d s%d is%s present,"
+							" but was%s expected\n",
+							r, s,
+							present ? "" : " NOT",
+							expected ? "" : " NOT");
+					continue;
+				}
+				pr_debug("    r%d.s%d is present\n", r, s);
+				if (subpkt) {
+					subpkt->present = true;
+					expected_reg_size += subpkt->size;
+				}
+			}
+			if ((data[ii++] & LAST_SUBPACKET_ROW_IND_MASK) == 0) {
+				pr_debug("no more subpackets\n");
+				break;
+			}
+		}
+		if (reg && reg->expected && reg->size != expected_reg_size) {
+			pr_debug("  r%d size error:"
+				" expected %d actual is %d\n",
+				r, expected_reg_size, reg->size);
+		}
+	}
+	return 0;
+}
+
+int synaptics_rmi4_read_packet_reg(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_rmi4_func_packet_regs *regs, int r_number)
+{
+	int s, retval, offset;
+	struct synaptics_rmi4_packet_reg *reg = find_packet_reg(regs, r_number);
+
+	if (!reg || !reg->size) {
+		pr_err("register %d not found or zero size\n", r_number);
+		return -EINVAL;
+	}
+
+	if (reg->offset == -1) {
+		pr_err("touch register error: can't read r%d - not present\n",
+			r_number);
+		return -ENOENT;
+	}
+
+	pr_debug("F%02x%c reading r%d{%X}, size %d to @%p\n",
+			regs->f_number & 0xff,
+			register_type_to_ascii(regs->f_number & 0xf00),
+			reg->r_number, regs->base_addr + reg->offset,
+			reg->size, reg->data);
+
+	retval = rmi4_data->i2c_read(rmi4_data,
+			regs->base_addr + reg->offset,
+			reg->data, reg->size);
+	if (retval < 0)
+		return retval;
+
+	for (s = 0, offset = 0; s < reg->nr_subpkts; ++s) {
+		struct synaptics_rmi4_subpkt *subpkt = reg->subpkt + s;
+		if (!subpkt->present)
+			continue;
+
+		if ((reg->size - offset) < subpkt->size) {
+			pr_err("subpkt size error: expected %d bytes,"
+				" only %d present\n", subpkt->size,
+				(reg->size - offset));
+			break;
+		}
+
+		memcpy(subpkt->data, reg->data+offset, subpkt->size);
+		offset += subpkt->size;
+#if defined(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)
+		{
+			int kk;
+			pr_debug("read r%d.s%d =\n", reg->r_number, s);
+			for (kk = 0; kk < subpkt->size; ++kk)
+				pr_debug("%02x\n",
+					((unsigned char *)subpkt->data)[kk]);
+		}
+#endif
+	}
+	return retval;
+}
+
+int synaptics_rmi4_read_packet_regs(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_rmi4_func_packet_regs *regs)
+{
+	int r;
+	int retval = 0;
+
+	for (r = 0; r < regs->nr_regs; ++r) {
+		pr_debug("about to read F%02x%c register %d [%d/%d]\n",
+				regs->f_number & 0xff,
+				register_type_to_ascii(regs->f_number & 0xf00),
+				regs->regs[r].r_number,
+				regs->regs[r].expected,
+				regs->regs[r].offset >= 0);
+		if (regs->regs[r].expected && regs->regs[r].offset >= 0) {
+			retval = synaptics_rmi4_read_packet_reg(
+				rmi4_data, regs, regs->regs[r].r_number);
+			if (retval < 0)
+				break;
+		}
+	}
+	return retval;
+}
+
+static int synaptics_rmi4_write_packet_reg(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_rmi4_func_packet_regs *regs, int r_number)
+{
+	struct synaptics_rmi4_packet_reg *reg = find_packet_reg(regs, r_number);
+	int sz, ii, offset, retval;
+
+	if (!reg || !reg->size) {
+		pr_err("r%d does not exist or zero size\n", r_number);
+		return -EINVAL;
+	}
+	if (reg->offset == -1) {
+		pr_err("touch register error: writing to absent register r%d\n",
+			r_number);
+		return -ENOENT;
+	}
+
+	for (ii = 0, sz = 0, offset = 0; ii < reg->nr_subpkts; ++ii) {
+		struct synaptics_rmi4_subpkt *subpkt = reg->subpkt + ii;
+		if (!subpkt->present)
+			continue;
+
+		if (subpkt->data && subpkt->size &&
+			(offset + subpkt->size) <= reg->size) {
+			if ((reg->size - offset) >= subpkt->size) {
+				memcpy(reg->data + sz, subpkt->data,
+							subpkt->size);
+				sz += subpkt->size;
+			} else {
+				pr_err("expected %d bytes, only %d present\n",
+					offset + subpkt->size, reg->size);
+				break;
+			}
+		} else {
+			retval = -EINVAL;
+			pr_err("cannot update subpacket %d\n", ii);
+			goto out;
+		}
+	}
+
+	pr_debug("writing r%d{%X}, size %d to @%p\n", reg->r_number,
+			regs->base_addr + reg->offset, reg->size, reg->data);
+
+	retval = rmi4_data->i2c_write(rmi4_data,
+			regs->base_addr + reg->offset,
+			reg->data, sz);
+out:
+	return retval;
+}
+
+#ifdef CONFIG_OF
+static int synaptics_dsx_gpio_config(
+		struct synaptics_dsx_platform_data *pdata, bool enable)
+{
+	int retval = 0;
+
+	if (enable) {
+		if (!gpio_is_valid(pdata->irq_gpio)) {
+			pr_err("invalid %s\n", IRQ_GPIO_NAME);
+			retval = -EINVAL;
+		}
+		retval = gpio_request(pdata->irq_gpio, IRQ_GPIO_NAME);
+		if (retval) {
+			pr_err("unable to request %s [%d]: rc=%d\n",
+				IRQ_GPIO_NAME, pdata->irq_gpio, retval);
+			goto err_gpio;
+		}
+		retval = gpio_direction_input(pdata->irq_gpio);
+		if (retval) {
+			pr_err("unable to set %s [%d] dir: rc=%d\n",
+				IRQ_GPIO_NAME, pdata->irq_gpio, retval);
+			goto err_gpio;
+		}
+
+		if (!gpio_is_valid(pdata->reset_gpio)) {
+			pr_err("invalid %s\n", RESET_GPIO_NAME);
+			retval = -EINVAL;
+		}
+		retval = gpio_request(pdata->reset_gpio, RESET_GPIO_NAME);
+		if (retval) {
+			pr_err("unable to request %s [%d]: rc=%d\n",
+				RESET_GPIO_NAME, pdata->reset_gpio, retval);
+			goto err_gpio;
+		}
+		retval = gpio_direction_output(pdata->reset_gpio, 1);
+		if (retval) {
+			pr_err("unable to set %s [%d] dir: rc=%d\n",
+				RESET_GPIO_NAME, pdata->reset_gpio, retval);
+			goto err_gpio;
+		}
+	} else {
+		gpio_free(pdata->irq_gpio);
+		gpio_free(pdata->reset_gpio);
+	}
+
+err_gpio:
+	return retval;
+}
+
+int synaptics_dsx_dt_parse_state(struct synaptics_rmi4_data *data,
+		struct device_node *np_config,
+		struct synaptics_dsx_patch *state)
+{
+	const char *patch_data;
+	struct device_node *np_state;
+	int err;
+
+	np_state = of_node_get(np_config);
+	err = of_property_read_string(np_config, "patch-data",
+				(const char **)&patch_data);
+	if (err < 0) {
+		pr_err("unable to read patch-data\n");
+		return err;
+	}
+
+	synaptics_dsx_parse_string(data, patch_data, state, true);
+
+	return 0;
+}
+
+int synaptics_dsx_dt_parse_mode(struct synaptics_rmi4_data *data,
+		const char *mode_name, struct synaptics_dsx_patchset *mode)
+{
+	struct device *dev = &data->i2c_client->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *np_modes;
+	int ret;
+	char *propname;
+	struct property *prop;
+	const __be32 *list;
+	int size, config;
+	phandle phandle;
+	struct device_node *np_config;
+
+	np_modes = of_find_node_by_name(np, "touchstate_modes");
+	if (!np_modes) {
+		pr_warn("can't find touchstate modes node\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	pr_debug("processing mode %s\n", mode_name);
+	propname = kasprintf(GFP_KERNEL, "touchmode-%s", mode_name);
+	prop = of_find_property(np_modes, propname, &size);
+	kfree(propname);
+	of_node_put(np_modes);
+	if (!prop) {
+		pr_err("can't find mode %s\n", mode_name);
+		ret = -EINVAL;
+		goto err;
+	}
+	list = prop->value;
+	size /= sizeof(*list);
+
+	if (size > MAX_NUM_STATES) {
+		pr_err("unexpected number of states %d\n", size);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	for (config = 0; config < size; config++) {
+		phandle = be32_to_cpup(list++);
+
+		/* Look up the touchstate configuration node */
+		np_config = of_find_node_by_phandle(phandle);
+		if (!np_config) {
+			dev_err(dev,
+				"prop %s index %i invalid phandle\n",
+				prop->name, config);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		/* Parse the node */
+		ret = synaptics_dsx_dt_parse_state(data, np_config,
+				 mode->patch_data[config]);
+		of_node_put(np_config);
+		if (ret < 0)
+			goto err;
+	}
+err:
+	return ret;
+}
+
+static struct synaptics_dsx_platform_data *
+		synaptics_dsx_of_init(struct i2c_client *client,
+				struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned key_codes[SYN_MAX_BUTTONS];
+	struct synaptics_dsx_platform_data *pdata;
+	struct device_node *np = client->dev.of_node;
+	struct synaptics_dsx_cap_button_map *button_map = NULL;
+
+	pr_err("entered of_init function\n");
+
+	rmi4_data->patching_enabled = 1;
+	retval = synaptics_dsx_dt_parse_mode(rmi4_data, "default",
+			rmi4_data->default_mode);
+	if (retval) {
+		pr_warn("failed to load default mode\n");
+		rmi4_data->patching_enabled = 0;
+	}
+
+	if (rmi4_data->patching_enabled) {
+		retval = synaptics_dsx_dt_parse_mode(rmi4_data, "alternate",
+				rmi4_data->alternate_mode);
+		if (retval) {
+			pr_warn("alternate mode not found;"
+				" using default instead\n");
+			rmi4_data->alternate_mode = rmi4_data->default_mode;
+		}
+	}
+
+	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(&client->dev, "pdata allocation failure\n");
+		return NULL;
+	}
+
+	pdata->irq_gpio = of_get_gpio(np, 0);
+	pdata->reset_gpio = of_get_gpio(np, 1);
+
+	memset(key_codes, 0, sizeof(key_codes));
+	retval = of_property_read_u32_array(np, "synaptics,key-buttons",
+			 key_codes, SYN_MAX_BUTTONS);
+	if (!retval) {
+		int ii;
+		unsigned char *button_codes;
+
+		button_map = kzalloc(sizeof(*button_map), GFP_KERNEL);
+		if (IS_ERR_OR_NULL(button_map)) {
+			dev_err(&client->dev, "button allocation failure\n");
+			return NULL;
+		}
+
+		for (ii = 0; ii < SYN_MAX_BUTTONS; ii++)
+			if (key_codes[ii])
+				button_map->nbuttons++;
+
+		button_codes = kzalloc(button_map->nbuttons, GFP_KERNEL);
+		if (IS_ERR_OR_NULL(button_codes)) {
+			dev_err(&client->dev, "button allocation failure\n");
+			kfree(button_map);
+			return NULL;
+		}
+
+		for (ii = 0; ii < button_map->nbuttons; ii++)
+			*(button_codes + ii) = (unsigned char)key_codes[ii];
+
+		button_map->map = button_codes;
+	}
+
+	pdata->irq_flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	pdata->cap_button_map = button_map;
+
+	if (of_property_read_bool(np, "synaptics,gpio-config")) {
+		pr_notice("using gpio config\n");
+		pdata->gpio_config = synaptics_dsx_gpio_config;
+	}
+
+	if (of_property_read_bool(np, "synaptics,x-flip")) {
+		pr_notice("using flipped X axis\n");
+		pdata->x_flip = true;
+	}
+
+	if (of_property_read_bool(np, "synaptics,y-flip")) {
+		pr_notice("using flipped Y axis\n");
+		pdata->y_flip = true;
+	}
+
+	if (of_property_read_bool(np, "synaptics,purge-enabled")) {
+		pr_notice("using purge\n");
+		rmi4_data->purge_enabled = true;
+	}
+
+	if (of_property_read_bool(np, "synaptics,charger-detection")) {
+		pr_notice("using charger detection\n");
+		rmi4_data->charger_detection = true;
+	}
+
+	return pdata;
+}
+#else
+static inline struct synaptics_dsx_platform_data *
+		synaptics_dsx_of_init(struct i2c_client *client)
+{
+	return NULL;
+}
+#endif
+
+static void synaptics_dsx_validate_product_string(unsigned char *id)
+{
+	unsigned char *s, *wc;
+	bool do_once = false, do_all = false;
+
+	for (s = wc = id; *s; s++) {
+		if (*s == '-') {
+			do_all = true;
+			continue;
+		}
+		if (!isdigit(*s) && isupper(*s)) {
+			*s = tolower(*s);
+			do_once = true;
+		}
+		if (do_all || do_once) {
+			*wc = *s;
+			do_once = false;
+		}
+		wc++;
+	}
+	*wc = 0;
+}
+
+#define NANO_SEC	1000000000
+#define SEC_TO_MSEC	1000
+#define NANO_TO_MSEC	1000000
+
+#define CIRCULAR_BUFFER 1
+#define ONE_BASED_INDEX 2
+
+static struct synaptics_dsx_stats gStat;
+
+static inline unsigned long long timediff_ms(
+		struct timespec start, struct timespec end)
+{
+	struct timespec temp;
+
+	if ((end.tv_nsec - start.tv_nsec) < 0) {
+		temp.tv_sec = end.tv_sec - start.tv_sec - 1;
+		temp.tv_nsec = NANO_SEC + end.tv_nsec - start.tv_nsec;
+	} else {
+		temp.tv_sec = end.tv_sec - start.tv_sec;
+		temp.tv_nsec = end.tv_nsec - start.tv_nsec;
+	}
+	return (temp.tv_sec * SEC_TO_MSEC) + (temp.tv_nsec / NANO_TO_MSEC);
+}
+
+static inline void timekeeping_reset(struct statistics *sp)
+{
+	int ii;
+
+	sp->active = -1;
+	sp->clk_run = false;
+	for (ii = 0; ii < sp->max; ii++) {
+		sp->keeper[ii].id = -1;
+		sp->keeper[ii].duration = (unsigned long long)0;
+	}
+}
+
+static void statistics_reset(void)
+{
+	gStat.uptime_dur = (unsigned long long)0;
+	gStat.uptime_run = false;
+	timekeeping_reset(gStat.dur);
+	timekeeping_reset(gStat.hop);
+	timekeeping_reset(gStat.nms);
+}
+
+static struct statistics *timekeeping_alloc(int max,
+		unsigned char abbr, unsigned int flags)
+{
+	ssize_t data_size = sizeof(struct time_keeping) * max;
+	struct statistics *stats;
+
+	tk_debug("allocating [%zu/%zu] for %c\n",
+			sizeof(struct statistics), data_size, abbr);
+	stats = kzalloc(sizeof(struct statistics) + data_size, GFP_KERNEL);
+	if (!stats)
+		return NULL;
+	stats->active = -1;
+	stats->max = max;
+	stats->flags = flags;
+	stats->abbr = abbr;
+	timekeeping_reset(stats);
+	return stats;
+}
+
+static int statistics_alloc(int max_gear, int max_hop, int max_nms, int max_mpd)
+{
+	gStat.dur = timekeeping_alloc(max_gear, 'G', 0);
+	if (!gStat.dur)
+		return -ENOMEM;
+	gStat.hop = timekeeping_alloc(max_hop, 'H', CIRCULAR_BUFFER);
+	if (!gStat.hop) {
+		kfree(gStat.hop);
+		return -ENOMEM;
+	}
+	gStat.nms = timekeeping_alloc(max_nms, 'N', ONE_BASED_INDEX);
+	if (!gStat.nms) {
+		kfree(gStat.dur);
+		kfree(gStat.hop);
+		return -ENOMEM;
+	}
+	gStat.mpd = timekeeping_alloc(max_mpd, 'M', 0);
+	if (!gStat.nms) {
+		kfree(gStat.dur);
+		kfree(gStat.hop);
+		kfree(gStat.nms);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void statistics_log_time_end(struct statistics *stats, ktime_t end)
+{
+	struct time_keeping *keeper = NULL;
+	unsigned long long duration;
+	int c_idx;
+
+	if (stats->active == -1)
+		return;
+
+	keeper = &stats->keeper[stats->active];
+	c_idx = keeper->id;
+	duration = timediff_ms(ktime_to_timespec(stats->start),
+					ktime_to_timespec(end));
+	keeper->duration += duration;
+	tk_debug("%c[%d].%d logged +%llu/%llu\n", stats->abbr, stats->active,
+					c_idx, duration, keeper->duration);
+	stats->clk_run = false;
+}
+
+static void statistics_log_time(struct statistics *stats, int idx, ktime_t log)
+{
+	struct time_keeping *keeper = NULL;
+	int c_idx = stats->active;
+
+	/* c_idx stays -1 or gets set to id of the current cell */
+	if (stats->active != -1) {
+		keeper = &stats->keeper[stats->active];
+		c_idx = keeper->id;
+	}
+
+	/* new idx and timer was running */
+	if (keeper && c_idx != idx && stats->clk_run) {
+		unsigned long long duration;
+
+		duration = timediff_ms(ktime_to_timespec(stats->start),
+					ktime_to_timespec(log));
+		keeper->duration += duration;
+		/* clock is ticking already, just update time */
+		stats->start = log;
+		tk_debug("%c[%d].%d logged +%llu/%llu\n", stats->abbr,
+			stats->active, c_idx, duration, keeper->duration);
+	}
+
+	/* move to the next cell if idx is changing */
+	if (c_idx != idx) {
+		/* shift index with overflow control */
+		if (stats->flags & CIRCULAR_BUFFER) {
+			if (++stats->active == stats->max)
+				stats->active = 0;
+		} else if (stats->flags & ONE_BASED_INDEX) {
+			stats->active = idx - 1;
+		} else
+			stats->active = idx;
+
+		/* store index in the cell */
+		stats->keeper[stats->active].id = idx;
+		tk_debug("%c new %sindex %d\n", stats->abbr,
+			stats->flags & CIRCULAR_BUFFER ? "RR_" :
+			stats->flags & ONE_BASED_INDEX ? "1B_" : "",
+			stats->active);
+	}
+
+	if (!stats->clk_run) {
+		stats->start = log;
+		stats->clk_run = true;
+	}
+}
+
+static int statistics_start_timekeeping(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_func_packet_regs *regs;
+	struct synaptics_rmi4_packet_reg *reg, *reg_17, *reg_10;
+	ktime_t log;
+	int ii, error;
+
+	if (gStat.uptime_run) {
+		pr_debug("timekeeping already running\n");
+		return 1;
+	}
+
+	regs = find_function(SYNAPTICS_RMI4_F51 | DATA_TYPE);
+	if (!regs) {
+		pr_err("F51 data: not found\n");
+		return -ENOENT;
+	}
+
+	reg = &regs->regs[0];
+	if (!reg || reg->offset < 0) {
+		pr_err("F51 data: invalid offset\n");
+		return -ENOENT;
+	}
+
+	error = synaptics_rmi4_read_packet_reg(rmi4_data, regs,	reg->r_number);
+	if (error < 0) {
+		pr_err("F51 data[%d]: read error\n", reg->r_number);
+		return -EIO;
+	}
+
+	regs = find_function(SYNAPTICS_RMI4_F54 | DATA_TYPE);
+	if (!regs) {
+		pr_err("F54 data not found\n");
+		return -ENOENT;
+	}
+
+	reg_17 = find_packet_reg(regs, 17);
+	reg_10 = find_packet_reg(regs, 10);
+	if ((!reg_17 || reg_17->offset < 0) ||
+		(!reg_10 || reg_10->offset < 0)) {
+		pr_err("F54 data: invalid offset\n");
+		return -ENOENT;
+	}
+
+	for (ii = 0; ii < 10; ii++) {
+		error = synaptics_rmi4_read_packet_reg(rmi4_data,
+					regs, reg_17->r_number);
+		if (error < 0) {
+			pr_err("F51 data[%d]: read error\n", reg_17->r_number);
+			return -EIO;
+		}
+
+		error = synaptics_rmi4_read_packet_reg(rmi4_data,
+					regs, reg_10->r_number);
+		if (error < 0) {
+			pr_err("F51 data[%d]: read error\n", reg_10->r_number);
+			return -EIO;
+		}
+
+		/* FIXME: it takes several attempts to read "real" value */
+		/* noise state cannot be 0, thus use it as exit condition */
+		if (!(int)f54_d10_0.noise_state)
+			msleep(50);
+		else
+			break;
+	}
+
+	log = ktime_get();
+	gStat.uptime = log;
+	gStat.uptime_run = true;
+	statistics_log_time(gStat.dur, (int)f54_d17_0.freq, log);
+	statistics_log_time(gStat.hop, (int)f54_d17_0.freq, log);
+	statistics_log_time(gStat.nms, (int)f54_d10_0.noise_state, log);
+	statistics_log_time(gStat.mpd, (int)f51_d0_0.md_present, log);
+	tk_debug("uptime notch; G%d:N%d:M%d\n", (int)f54_d17_0.freq,
+			(int)f54_d10_0.noise_state, (int)f51_d0_0.md_present);
+	return 0;
+}
+
+static int statistics_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_func_packet_regs *regs;
+	struct synaptics_rmi4_packet_reg *reg;
+	int error;
+
+	regs = find_function(SYNAPTICS_RMI4_F54 | QUERY_TYPE);
+	if (!regs)
+		return -ENOENT;
+
+	reg = find_packet_reg(regs, 12);
+	if (!reg || reg->offset < 0)
+		return -ENOENT;
+
+	error = synaptics_rmi4_read_packet_reg(rmi4_data, regs, reg->r_number);
+	if (error < 0)
+		return -EIO;
+
+	/* allocate frequencies by the number of gears in gear table */
+	error = statistics_alloc(
+			(int)f54_q12_0.num_of_scan_freq & 0xf,
+			100,	/* 100 last gear hops */
+			2,	/* 2 NMS modes */
+			2);	/* 2 guard presence modes */
+	if (error < 0)
+		return -ENOMEM;
+
+	error = statistics_start_timekeeping(rmi4_data);
+	if (error < 0)
+		pr_err("statistics init failed\n");
+	else
+		gStat.enabled = true;
+
+	return error;
+}
+
+static inline void statistics_stop_timekeeping(void)
+{
+	/* avoid being executed twice on firmware reflash */
+	if (gStat.uptime_run) {
+		ktime_t end = ktime_get();
+		gStat.uptime_dur += timediff_ms(
+					ktime_to_timespec(gStat.uptime),
+					ktime_to_timespec(end));
+		gStat.uptime_run = false;
+		statistics_log_time_end(gStat.dur, end);
+		statistics_log_time_end(gStat.hop, end);
+		statistics_log_time_end(gStat.nms, end);
+		statistics_log_time_end(gStat.mpd, end);
+		tk_debug("uptime %llu\n", gStat.uptime_dur);
+	} else
+		pr_debug("timekeeping already stopped\n");
+
+}
+
+static int synaptics_rmi4_i2c_read(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data,
+		unsigned short length);
+
+static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data,
+		unsigned short length);
+
+static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char *f01_cmd_base_addr);
+
+static int synaptics_rmi4_irq_enable(struct synaptics_rmi4_data *rmi4_data,
+		bool enable);
+
+static void synaptics_dsx_sensor_state(struct synaptics_rmi4_data *rmi4_data,
+		int state);
+
+static void synaptics_dsx_release_all(struct synaptics_rmi4_data *rmi4_data);
+
+#if defined(CONFIG_FB) && !defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+static int synaptics_dsx_panel_cb(struct notifier_block *nb,
+		unsigned long event, void *data);
+#endif
+
+static int synaptics_rmi4_suspend(struct device *dev);
+
+static int synaptics_rmi4_resume(struct device *dev);
+
+static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_f01_productinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_f01_buildid_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_f01_flashprog_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_0dbutton_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_resume_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_irqtimes_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_drv_irq_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_drv_irq_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_hw_irqstat_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_ic_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_poweron_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_query_idx_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_query_idx_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_query_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_query_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_patch_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_reporting_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_reporting_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_stats_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_stats_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+struct synaptics_rmi4_f01_device_status {
+	union {
+		struct {
+			unsigned char status_code:4;
+			unsigned char reserved:2;
+			unsigned char flash_prog:1;
+			unsigned char unconfigured:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_f01_query1 {
+	union {
+		struct {
+			unsigned char custom_map:1;
+			unsigned char non_compliant:1;
+			unsigned char reserved:1;
+			unsigned char has_sensor_id:1;
+			unsigned char has_charger_input:1;
+			unsigned char has_adjustable_doze:1;
+			unsigned char has_doze_holdoff:1;
+			unsigned char has_query42:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_f01_query42 {
+	union {
+		struct {
+			unsigned char has_ds4_queries:1;
+			unsigned char has_multi_physical:1;
+			unsigned char has_guest:1;
+			unsigned char has_swr:1;
+			unsigned char has_report_rate:1;
+			unsigned char has_recalibration:1;
+			unsigned char reserved:2;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_f1a_query {
+	union {
+		struct {
+			unsigned char max_button_count:3;
+			unsigned char reserved:5;
+			unsigned char has_general_control:1;
+			unsigned char has_interrupt_enable:1;
+			unsigned char has_multibutton_select:1;
+			unsigned char has_tx_rx_map:1;
+			unsigned char has_perbutton_threshold:1;
+			unsigned char has_release_threshold:1;
+			unsigned char has_strongestbtn_hysteresis:1;
+			unsigned char has_filter_strength:1;
+		} __packed;
+		unsigned char data[2];
+	};
+};
+
+struct synaptics_rmi4_f1a_control_0 {
+	union {
+		struct {
+			unsigned char multibutton_report:2;
+			unsigned char filter_mode:2;
+			unsigned char reserved:4;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct synaptics_rmi4_f1a_control_3_4 {
+	unsigned char transmitterbutton;
+	unsigned char receiverbutton;
+};
+
+struct synaptics_rmi4_f1a_control {
+	struct synaptics_rmi4_f1a_control_0 general_control;
+	unsigned char *button_int_enable;
+	unsigned char *multi_button;
+	struct synaptics_rmi4_f1a_control_3_4 *electrode_map;
+	unsigned char *button_threshold;
+	unsigned char button_release_threshold;
+	unsigned char strongest_button_hysteresis;
+	unsigned char filter_strength;
+};
+
+struct synaptics_rmi4_f1a_handle {
+	int button_bitmask_size;
+	unsigned char button_count;
+	unsigned char valid_button_count;
+	unsigned char *button_data_buffer;
+	unsigned char *button_map;
+	struct synaptics_rmi4_f1a_query button_query;
+	struct synaptics_rmi4_f1a_control button_control;
+};
+
+struct synaptics_rmi4_exp_fn {
+	enum exp_fn fn_type;
+	enum ic_modes mode;
+	bool inserted;
+	int (*func_init)(struct synaptics_rmi4_data *rmi4_data);
+	void (*func_remove)(struct synaptics_rmi4_data *rmi4_data);
+	void (*func_attn)(struct synaptics_rmi4_data *rmi4_data,
+			unsigned char intr_mask);
+	struct list_head link;
+};
+
+static struct device_attribute attrs[] = {
+	__ATTR(reset, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			synaptics_rmi4_f01_reset_store),
+	__ATTR(productinfo, S_IRUGO,
+			synaptics_rmi4_f01_productinfo_show,
+			synaptics_rmi4_store_error),
+	__ATTR(buildid, S_IRUGO,
+			synaptics_rmi4_f01_buildid_show,
+			synaptics_rmi4_store_error),
+	__ATTR(flashprog, S_IRUSR | S_IRGRP,
+			synaptics_rmi4_f01_flashprog_show,
+			synaptics_rmi4_store_error),
+	__ATTR(0dbutton, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_0dbutton_show,
+			synaptics_rmi4_0dbutton_store),
+	__ATTR(resumeinfo, S_IRUSR | S_IRGRP,
+			synaptics_rmi4_resume_show,
+			synaptics_rmi4_store_error),
+	__ATTR(drv_irq, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_drv_irq_show,
+			synaptics_rmi4_drv_irq_store),
+	__ATTR(reporting, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_reporting_show,
+			synaptics_rmi4_reporting_store),
+	__ATTR(stats, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_stats_show,
+			synaptics_rmi4_stats_store),
+	__ATTR(hw_irqstat, S_IRUSR | S_IRGRP,
+			synaptics_rmi4_hw_irqstat_show,
+			synaptics_rmi4_store_error),
+	__ATTR(ic_ver, S_IRUGO,
+			synaptics_rmi4_ic_ver_show,
+			synaptics_rmi4_store_error),
+	__ATTR(irqinfo, S_IRUSR | S_IRGRP,
+			synaptics_rmi4_irqtimes_show,
+			synaptics_rmi4_store_error),
+	__ATTR(poweron, S_IRUSR | S_IRGRP,
+			synaptics_rmi4_poweron_show,
+			synaptics_rmi4_store_error),
+	__ATTR(query_idx, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_query_idx_show,
+			synaptics_rmi4_query_idx_store),
+	__ATTR(query, (S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_query_show,
+			synaptics_rmi4_query_store),
+	__ATTR(patch, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			synaptics_rmi4_patch_store),
+};
+
+struct synaptics_exp_fn_ctrl {
+	bool inited;
+	struct mutex list_mutex;
+	struct list_head fn_list;
+	struct delayed_work det_work;
+	struct workqueue_struct *det_workqueue;
+	struct synaptics_rmi4_data *rmi4_data_ptr;
+};
+
+DEFINE_MUTEX(exp_fn_ctrl_mutex);
+static struct synaptics_exp_fn_ctrl exp_fn_ctrl;
+static struct semaphore reset_semaphore;
+
+static irqreturn_t synaptics_dsx_reset_irq(int irq, void *data)
+{
+	struct semaphore *sema = data;
+	up(sema);
+	return IRQ_HANDLED;
+}
+
+int synaptics_rmi4_sw_reset(struct synaptics_rmi4_data *rmi4_data,
+				bool requery) {
+	int retval;
+	unsigned char page_number;
+	unsigned short pdt_entry_addr;
+	struct synaptics_rmi4_fn_desc rmi_fd;
+	unsigned short cmd_reg_addr;
+	bool cmd_reg_found = false;
+
+	if (!requery) {
+		cmd_reg_addr = rmi4_data->f01_cmd_base_addr;
+		cmd_reg_found = true;
+		goto sw_reset;
+	}
+
+	for (page_number = 0; !cmd_reg_found && page_number < PAGES_TO_SERVICE;
+			page_number++) {
+		for (pdt_entry_addr = PDT_START; pdt_entry_addr > PDT_END;
+				pdt_entry_addr -= PDT_ENTRY_SIZE) {
+			pdt_entry_addr |= (page_number << 8);
+
+			retval = synaptics_rmi4_i2c_read(rmi4_data,
+					pdt_entry_addr,
+					(unsigned char *)&rmi_fd,
+					sizeof(rmi_fd));
+			if (retval < 0)
+				return retval;
+
+			if (rmi_fd.fn_number == 0) {
+				dev_dbg(&rmi4_data->i2c_client->dev,
+						"%s: Reached end of PDT\n",
+						__func__);
+				break;
+			}
+
+			dev_dbg(&rmi4_data->i2c_client->dev,
+					"%s: F%02x found (page %d)\n",
+					__func__, rmi_fd.fn_number,
+					page_number);
+
+			if (rmi_fd.fn_number == SYNAPTICS_RMI4_F01) {
+				cmd_reg_addr = rmi_fd.cmd_base_addr;
+				cmd_reg_found = true;
+				break;
+			}
+		}
+	}
+
+sw_reset:
+	if (cmd_reg_found) {
+		uint8_t command = 1;
+		retval = synaptics_rmi4_i2c_write(rmi4_data,
+			cmd_reg_addr,
+			&command, sizeof(command));
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to issue SW reset command, error = %d\n",
+				__func__, retval);
+			return retval;
+		}
+		return 0;
+	} else
+		return -ENOENT;
+
+}
+
+
+static int synaptics_dsx_ic_reset(
+		struct synaptics_rmi4_data *rmi4_data, int reset)
+{
+	int retval;
+	unsigned long start = jiffies;
+	const struct synaptics_dsx_platform_data *platform_data =
+			rmi4_data->board;
+
+	sema_init(&reset_semaphore, 0);
+
+	if (reset == RMI4_HW_RESET) {
+		gpio_set_value(platform_data->reset_gpio, 0);
+		udelay(1500);
+	} else if (reset == RMI4_SW_RESET) {
+		retval = synaptics_rmi4_sw_reset(rmi4_data, true);
+		if (retval < 0)
+			return retval;
+	}
+
+	retval = request_irq(rmi4_data->irq, synaptics_dsx_reset_irq,
+			IRQF_TRIGGER_RISING, "synaptics_reset",
+			&reset_semaphore);
+	if (retval < 0)
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to request irq: %d\n",
+				__func__, retval);
+
+	if (reset == RMI4_HW_RESET)
+		gpio_set_value(platform_data->reset_gpio, 1);
+
+	retval = down_timeout(&reset_semaphore, msecs_to_jiffies(100));
+	if (retval) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"timed out waiting for reset to complete\n");
+		retval = -ETIMEDOUT;
+	} else {
+		retval = (int)jiffies_to_msecs(jiffies-start);
+		/* insert delay to ensure 1st i2c bus access succeeds */
+		udelay(1000);
+	}
+
+	free_irq(rmi4_data->irq, &reset_semaphore);
+
+	/* perform SW reset if HW reset failed */
+	if (reset != RMI4_SW_RESET && retval == -ETIMEDOUT)
+		retval = synaptics_dsx_ic_reset(rmi4_data, RMI4_SW_RESET);
+
+	return retval;
+}
+
+static int synaptics_dsx_alloc_input(struct synaptics_rmi4_data *rmi4_data)
+{
+	rmi4_data->input_dev = input_allocate_device();
+	if (IS_ERR_OR_NULL(rmi4_data->input_dev))
+		return PTR_ERR(rmi4_data->input_dev);
+
+	rmi4_data->input_dev->name = DRIVER_NAME;
+	rmi4_data->input_dev->phys = INPUT_PHYS_NAME;
+	rmi4_data->input_dev->id.bustype = BUS_I2C;
+	rmi4_data->input_dev->dev.parent = &rmi4_data->i2c_client->dev;
+
+	set_bit(EV_SYN, rmi4_data->input_dev->evbit);
+
+	pr_debug("allocated input device\n");
+
+	return 0;
+}
+
+static void synaptics_dsx_patch_func(
+		struct synaptics_rmi4_data *rmi4_data,
+		int f_number,
+		struct synaptics_dsx_patch *patch)
+{
+	int r, error, function;
+	unsigned char *value, rt_mod;
+	struct device *dev = &rmi4_data->i2c_client->dev;
+	struct synaptics_rmi4_subpkt *subpkt;
+	struct synaptics_dsx_func_patch *fp;
+	struct synaptics_rmi4_packet_reg *reg;
+	struct synaptics_rmi4_func_packet_regs *regs = find_function(f_number);
+
+	function = regs->f_number & 0xff;
+	rt_mod = register_type_to_ascii(regs->f_number & 0xf00);
+	pr_debug("patching F%x%c\n",  function, rt_mod);
+	list_for_each_entry(fp, &patch->cfg_head, link) {
+		if (fp->func != f_number)
+			continue;
+		reg = find_packet_reg(regs, fp->regstr);
+		if (!reg || reg->offset < 0) {
+			pr_err("F%x%c@%d not present\n",
+				function, rt_mod, fp->regstr);
+			continue;
+		}
+		if (fp->subpkt >= reg->nr_subpkts) {
+			pr_err("F%x%c@%d:%d not present\n",
+				function, rt_mod, fp->regstr, fp->subpkt);
+			continue;
+		}
+
+		/* read register only once */
+		if (!reg->updated) {
+			error =	synaptics_rmi4_read_packet_reg(
+					rmi4_data, regs, reg->r_number);
+			if (error < 0)
+				return;
+#if defined(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)
+			{
+				int ss, kk;
+				pr_debug("F%x%c@%d before patching:\n",
+					function, rt_mod, reg->r_number);
+				for (ss = 0; ss < reg->nr_subpkts; ss++) {
+					subpkt = reg->subpkt + ss;
+					for (kk = 0; kk < subpkt->size; ++kk)
+						pr_debug("%02x\n",
+					((unsigned char *)subpkt->data)[kk]);
+				}
+			}
+#endif
+			/* value has been updated */
+			reg->updated = true;
+		}
+
+		subpkt = reg->subpkt + fp->subpkt;
+		if (!subpkt->present || !subpkt->data ||
+			subpkt->size < fp->size) {
+			pr_debug("F%x%c@%d:%d improperly allocated\n",
+				function, rt_mod, fp->regstr, fp->subpkt);
+			continue;
+		}
+		if (fp->bitmask && fp->size == 1) {
+			value = (unsigned char *)subpkt->data;
+			pr_debug("patching by mask: source 0x%x\n", *value);
+			*value &= ~(fp->bitmask);
+			pr_debug("patching by mask: clear-ed 0x%x\n", *value);
+			*value |= *fp->data;
+			pr_debug("patching by mask: result 0x%x\n", *value);
+		} else
+			memcpy(subpkt->data, fp->data, fp->size);
+
+		/* value has been changed */
+		reg->modified = true;
+
+		dev_dbg(dev, "patched F%x%c@%d:%d, sz=%d\n",
+			function, rt_mod, fp->regstr, fp->subpkt, fp->size);
+	}
+
+	/* update loop */
+	for (r = 0; r < regs->nr_regs; r++) {
+		reg = &regs->regs[r];
+		if (reg->updated && reg->modified) {
+#if defined(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)
+			{
+				int ss, kk;
+				pr_debug("F%x%c@%d after patching:\n",
+						function, rt_mod, reg->r_number);
+				for (ss = 0; ss < reg->nr_subpkts; ss++) {
+					subpkt = reg->subpkt + ss;
+					for (kk = 0; kk < subpkt->size; ++kk)
+						pr_debug("%02x\n",
+					((unsigned char *)subpkt->data)[kk]);
+				}
+			}
+#endif
+			error = synaptics_rmi4_write_packet_reg(rmi4_data,
+							regs, reg->r_number);
+			if (error < 0)
+				dev_warn(dev, "F%x%c@%d patch write failed\n",
+					function, rt_mod, reg->r_number);
+			reg->modified = false;
+		}
+		reg->updated = false;
+	}
+}
+
+static void synaptics_dsx_enable_wakeup_source(
+		struct synaptics_rmi4_data *rmi4_data, bool enable)
+{
+	int error;
+	error = irq_set_irq_wake(rmi4_data->irq, (int)enable);
+	pr_debug("%s wakeup; rc=%d\n", enable ? "enabled" : "disabled", error);
+}
+
+static inline void synaptics_dsx_set_alternate_mode(
+		struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_dsx_patchset *mode,
+		bool wakeable, bool persistent)
+{
+	rmi4_data->mode_is_wakeable = wakeable;
+	rmi4_data->mode_is_persistent = persistent;
+	rmi4_data->current_mode = mode;
+	if (wakeable)
+		synaptics_dsx_enable_wakeup_source(rmi4_data, true);
+	pr_debug("set alternate mode\n");
+}
+
+static inline void synaptics_dsx_restore_default_mode(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	if (rmi4_data->mode_is_wakeable)
+		synaptics_dsx_enable_wakeup_source(rmi4_data, false);
+	rmi4_data->mode_is_wakeable = false;
+	rmi4_data->mode_is_persistent = true;
+	rmi4_data->current_mode = rmi4_data->default_mode;
+	pr_debug("set default mode\n");
+}
+
+static void synaptics_dsx_state_config(
+		struct synaptics_rmi4_data *rmi4_data, int state)
+{
+	int i;
+	struct synaptics_dsx_patch *patch =
+			rmi4_data->current_mode->patch_data[state];
+
+	if (!patch || !patch->cfg_num) {
+		pr_debug("patchset is empty!\n");
+		goto nothing_to_patch;
+	}
+
+	if (rmi4_data->mode_is_wakeable)
+		synaptics_dsx_enable_wakeup_source(rmi4_data, true);
+
+	if (rmi4_data->patching_enabled) {
+		for (i = 0; i < ARRAY_SIZE(synaptics_cfg_regs); i++)
+			synaptics_dsx_patch_func(rmi4_data,
+				synaptics_cfg_regs[i].f_number, patch);
+
+		pr_debug("applied %s in mode %s\n",
+			state == ACTIVE_IDX ? "ACTIVE" : "SUSPEND",
+			rmi4_data->current_mode == rmi4_data->default_mode ?
+			"DEFAULT" : "OTHER");
+	}
+
+nothing_to_patch:
+	/* keep page 0 active */
+	synaptics_rmi4_set_page(rmi4_data, 0);
+}
+
+static const char * const synaptics_state_names[] = {"UNKNOWN",
+	"ACTIVE", "SUSPEND", "UNUSED", "STANDBY", "BL", "INIT",
+	"FLASH", "QUERY", "INVALID" };
+
+static const char *synaptics_dsx_state_name(int state)
+{
+	int index = state < 0 || state > STATE_INVALID ? STATE_INVALID : state;
+	return synaptics_state_names[index];
+}
+
+static int synaptics_dsx_get_state_safe(struct synaptics_rmi4_data *rmi4_data)
+{
+	int state;
+	mutex_lock(&(rmi4_data->state_mutex));
+	state = rmi4_data->state;
+	mutex_unlock(&(rmi4_data->state_mutex));
+	return state;
+}
+
+static void synaptics_dsx_set_state_safe(struct synaptics_rmi4_data *rmi4_data,
+		int state)
+{
+	mutex_lock(&(rmi4_data->state_mutex));
+	rmi4_data->state = state;
+	mutex_unlock(&(rmi4_data->state_mutex));
+}
+
+static int synaptics_dsx_wait_for_idle(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned long start_wait_jiffies = jiffies;
+
+	do {
+		int current_state;
+
+		current_state = synaptics_dsx_get_state_safe(rmi4_data);
+		if (!(current_state == STATE_INIT ||
+			current_state == STATE_FLASH ||
+			current_state == STATE_UNKNOWN))
+			break;
+
+		usleep_range(1000, 1000);
+
+	} while (1);
+
+	if ((jiffies - start_wait_jiffies))
+		pr_info("entering suspend delayed for %ums\n",
+			jiffies_to_msecs(jiffies - start_wait_jiffies));
+	return 0;
+}
+
+static int synaptics_dsx_sensor_ready_state(
+		struct synaptics_rmi4_data *rmi4_data, bool standby)
+{
+	bool ui_mode;
+	int retval, state, i;
+	struct synaptics_rmi4_f01_device_status status;
+
+	for (i = 0; i < 10; ++i) {
+		retval = synaptics_rmi4_i2c_read(rmi4_data,
+					rmi4_data->f01_data_base_addr,
+					status.data,
+					sizeof(status.data));
+		if (retval < 0) {
+			pr_err("(%d) Failed to query touch ic status\n", i);
+			return retval;
+		}
+
+		ui_mode = status.flash_prog == 0;
+		pr_debug("(%d) UI mode: %s\n", i, ui_mode ? "true" : "false");
+
+		if (ui_mode)
+			break;
+
+		msleep(20);
+	}
+
+	state = synaptics_dsx_get_state_safe(rmi4_data);
+	if (!ui_mode && state == STATE_SUSPEND && rmi4_data->input_registered) {
+		/* expecting touch IC to enter UI mode based on */
+		/* its previous known good state */
+		pr_err("Timed out waiting for UI mode - UI mode forced\n");
+		ui_mode = 1;
+	}
+
+	if (ui_mode) {
+		state = standby ? STATE_STANDBY : STATE_ACTIVE;
+	} else
+		if (!(state == STATE_INIT || state == STATE_FLASH))
+			state = STATE_BL;
+
+	synaptics_dsx_sensor_state(rmi4_data, state);
+
+	return 0;
+}
+
+static void synaptics_dsx_sensor_state(struct synaptics_rmi4_data *rmi4_data,
+		int state)
+{
+	if (synaptics_dsx_get_state_safe(rmi4_data) == state)
+		return;
+
+	switch (state) {
+	case STATE_UNKNOWN:
+	case STATE_FLASH:
+		/* no special handling for these states */
+			break;
+
+	case STATE_SUSPEND:
+		synaptics_dsx_wait_for_idle(rmi4_data);
+		if (!rmi4_data->mode_is_wakeable)
+			synaptics_rmi4_irq_enable(rmi4_data, false);
+		if (!rmi4_data->in_bootloader)
+			synaptics_dsx_state_config(rmi4_data, SUSPEND_IDX);
+			break;
+
+	case STATE_ACTIVE:
+		if (!rmi4_data->in_bootloader)
+			synaptics_dsx_state_config(rmi4_data, ACTIVE_IDX);
+
+		if (rmi4_data->input_registered)
+			synaptics_rmi4_irq_enable(rmi4_data, true);
+		else {
+			synaptics_rmi4_irq_enable(rmi4_data, true);
+			pr_err("Active state without input device\n");
+		}
+
+		if (!rmi4_data->mode_is_persistent) {
+			synaptics_dsx_restore_default_mode(rmi4_data);
+			pr_debug("Non-persistent mode; restoring default\n");
+		}
+
+		if (gStat.enabled)
+			statistics_start_timekeeping(rmi4_data);
+			break;
+
+	case STATE_STANDBY:
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+			break;
+
+	case STATE_BL:
+		if (!rmi4_data->in_bootloader)
+			rmi4_data->in_bootloader = true;
+	case STATE_INIT:
+		/* de-allocate input device earlier to allow */
+		/* EventHub become notified of input removal */
+		if (rmi4_data->input_registered) {
+			input_unregister_device(rmi4_data->input_dev);
+			rmi4_data->input_dev = NULL;
+			rmi4_data->input_registered = false;
+
+			pr_debug("de-allocated input device\n");
+		}
+
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+
+		if (gStat.enabled)
+			statistics_stop_timekeeping();
+			break;
+	}
+
+	pr_info("state change %s -> %s\n",
+			synaptics_dsx_state_name(rmi4_data->state),
+			synaptics_dsx_state_name(state));
+
+	synaptics_dsx_set_state_safe(rmi4_data, state);
+}
+
+static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int reset;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+
+	if (sscanf(buf, "%u", &reset) != 1)
+		return -EINVAL;
+
+	if (reset != 1)
+		return -EINVAL;
+
+	retval = synaptics_dsx_ic_reset(rmi4_data, RMI4_HW_RESET);
+	if (retval > 0)
+		pr_debug("successful reset took %dms\n", retval);
+	else
+		dev_warn(&rmi4_data->i2c_client->dev, "%s: timed out waiting for idle\n",
+			__func__);
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f01_productinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	return scnprintf(buf, PAGE_SIZE, "%s\n",
+			rmi4_data->rmi4_mod_info.product_id_string);
+}
+
+static ssize_t synaptics_rmi4_f01_buildid_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned int firmware_id;
+	unsigned int config_id;
+	struct synaptics_rmi4_device_info *rmi;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	batohui(&firmware_id, rmi->build_id, sizeof(rmi->build_id));
+	batohui(&config_id, rmi->config_id, sizeof(rmi->config_id));
+
+	return scnprintf(buf, PAGE_SIZE, "%x-%08x\n", firmware_id, config_id);
+}
+
+static ssize_t synaptics_rmi4_resume_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int i;
+	int c_res;
+	int offset = 0;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	c_res = rmi4_data->last_resume;
+	/* Resume buffer not allocated or there were no resumes yet */
+	if (rmi4_data->number_resumes <= 0 || c_res < 0)
+		return scnprintf(buf, PAGE_SIZE,
+				"No resume information found.\n");
+
+	offset += scnprintf(buf + offset, PAGE_SIZE - offset,
+		"Count\tStart\t\tFinish\t# ignored\t"
+		"ISR\t\tpurge off\tsendevent\n");
+
+	for (i = 0; i < rmi4_data->number_resumes; i++) {
+		offset += scnprintf(buf + offset, PAGE_SIZE - offset,
+			"%d\t%4ld.%03ld\t%4ld.%03ld\t%d\t%4ld.%03ld\t"
+			"%4ld.%03ld\t%4ld.%03ld\n",
+		i+1,
+		rmi4_data->resume_info[c_res].start.tv_sec%1000,
+		rmi4_data->resume_info[c_res].start.tv_nsec/1000000,
+		rmi4_data->resume_info[c_res].finish.tv_sec%1000,
+		rmi4_data->resume_info[c_res].finish.tv_nsec/1000000,
+		rmi4_data->resume_info[c_res].ignored_events,
+		rmi4_data->resume_info[c_res].isr.tv_sec%1000,
+		rmi4_data->resume_info[c_res].isr.tv_nsec/1000000,
+		rmi4_data->resume_info[c_res].purge_off.tv_sec%1000,
+		rmi4_data->resume_info[c_res].purge_off.tv_nsec/1000000,
+		rmi4_data->resume_info[c_res].send_touch.tv_sec%1000,
+		rmi4_data->resume_info[c_res].send_touch.tv_nsec/1000000);
+
+		if (c_res <= 0)
+			c_res = rmi4_data->number_resumes-1;
+		else
+			c_res--;
+	}
+	return offset;
+}
+
+static ssize_t synaptics_rmi4_irqtimes_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int i;
+	int c_res;
+	int offset = 0;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	c_res = rmi4_data->last_irq;
+	/* Resume buffer not allocated or there were no irq data collected yet*/
+	if (rmi4_data->number_irq <= 0 || c_res < 0)
+		return scnprintf(buf, PAGE_SIZE,
+				"No resume information found.\n");
+
+	offset += scnprintf(buf + offset, PAGE_SIZE - offset,
+		"Count\tIRQ Start\n");
+
+	for (i = 0; i < rmi4_data->number_irq; i++) {
+		offset += scnprintf(buf + offset, PAGE_SIZE - offset,
+			"%d\t%4ld.%03ld\n",
+		i+1,
+		rmi4_data->irq_info[i].irq_time.tv_sec%1000,
+		rmi4_data->irq_info[i].irq_time.tv_nsec/1000000);
+
+		if (c_res <= 0)
+			c_res = rmi4_data->number_irq-1;
+		else
+			c_res--;
+	}
+	return offset;
+}
+
+static ssize_t synaptics_rmi4_f01_flashprog_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	struct synaptics_rmi4_f01_device_status device_status;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			rmi4_data->f01_data_base_addr,
+			device_status.data,
+			sizeof(device_status.data));
+	if (retval < 0) {
+		dev_err(dev,
+				"%s: Failed to read device status, error = %d\n",
+				__func__, retval);
+		return retval;
+	}
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			device_status.flash_prog);
+}
+
+static ssize_t synaptics_rmi4_hw_irqstat_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	switch (gpio_get_value(rmi4_data->board->irq_gpio)) {
+	case 0:
+		return scnprintf(buf, PAGE_SIZE, "Low\n");
+	case 1:
+		return scnprintf(buf, PAGE_SIZE, "High\n");
+	default:
+		pr_err("Failed to get GPIO for irq %d\n", rmi4_data->irq);
+		return scnprintf(buf, PAGE_SIZE, "Unknown\n");
+	}
+}
+
+#define SPRINTF_PAGE(fmt, args...) {\
+		blen += scnprintf(buf + blen, PAGE_SIZE - blen, fmt, ##args);\
+	}
+
+#include <asm/div64.h>
+
+static ssize_t synaptics_rmi4_stats_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int ii, gear, state, percentage;
+	bool count_time_since;
+	ssize_t blen = 0;
+	unsigned long long gear_time, check_point, perc_u64;
+	unsigned long long total = gStat.uptime_dur;
+	unsigned long long duration = (unsigned long long)0;
+	struct statistics *stats;
+	struct timespec end = ktime_to_timespec(ktime_get());
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	if (gStat.enabled == false) {
+		pr_warn("statistics is not enabled\n");
+		return blen;
+	}
+
+	/* if statistics fetched while driver in suspend, time */
+	/* since phone has entered suspend should not be added */
+	count_time_since = atomic_read(&rmi4_data->touch_stopped) == 0;
+	if (count_time_since) {
+		duration = timediff_ms(ktime_to_timespec(gStat.uptime), end);
+		tk_debug("uptime since last resume %llu\n", duration);
+		total += duration;
+	}
+	tk_debug("total sweep time %llums\n", total);
+
+	/* currently active gear */
+	gear = gStat.dur->active;
+	stats = gStat.dur;
+	check_point = (unsigned long long)0;
+	if (count_time_since) {
+		duration = timediff_ms(ktime_to_timespec(stats->start), end);
+		pr_debug("%c time since last resume %llu\n",
+						stats->abbr, duration);
+	}
+	for (ii = 0; ii < stats->max; ii++) {
+		gear_time = stats->keeper[ii].duration;
+		if (ii == gear)
+			gear_time += duration;
+		perc_u64 = 10000*gear_time;
+		do_div(perc_u64, total);
+		percentage = (int)perc_u64;
+		SPRINTF_PAGE("%c%d: %d%%\n", stats->abbr, ii,
+				percentage/1000);
+		check_point += gear_time;
+		tk_debug("%c%d: %d%% %llu/%llu\n", stats->abbr,
+				(stats->flags & ONE_BASED_INDEX) ? ii+1 : ii,
+				percentage/1000, gear_time, total);
+	}
+	tk_debug("gear time check point: %llu <-> %llu\n", check_point, total);
+
+	/* currently active NSM state */
+	state = gStat.nms->active;
+	stats = gStat.nms;
+	check_point = (unsigned long long)0;
+	if (count_time_since) {
+		duration = timediff_ms(ktime_to_timespec(stats->start), end);
+		pr_debug("%c time since last resume %llu\n",
+						stats->abbr, duration);
+	}
+	for (ii = 0; ii < stats->max; ii++) {
+		gear_time = stats->keeper[ii].duration;
+		if (ii == state)
+			gear_time += duration;
+		perc_u64 = 10000*gear_time;
+		do_div(perc_u64, total);
+		percentage = (int)perc_u64;
+		SPRINTF_PAGE("%c%d: %d%%\n", stats->abbr,
+				(stats->flags & ONE_BASED_INDEX) ? ii+1 : ii,
+				percentage/1000);
+		check_point += gear_time;
+		tk_debug("%c%d: %d%% %llu/%llu\n", stats->abbr, ii,
+					percentage/1000, gear_time, total);
+	}
+	tk_debug("NMS time check point: %llu <-> %llu\n", check_point, total);
+
+	/* current guard state */
+	state = gStat.mpd->active;
+	stats = gStat.mpd;
+	check_point = (unsigned long long)0;
+	if (count_time_since) {
+		duration = timediff_ms(ktime_to_timespec(stats->start), end);
+		pr_debug("%c time since last resume %llu\n",
+						stats->abbr, duration);
+	}
+	for (ii = 0; ii < stats->max; ii++) {
+		gear_time = stats->keeper[ii].duration;
+		if (ii == state)
+			gear_time += duration;
+		perc_u64 = 10000*gear_time;
+		do_div(perc_u64, total);
+		percentage = (int)perc_u64;
+		SPRINTF_PAGE("%c%d: %d%%\n", stats->abbr,
+				(stats->flags & ONE_BASED_INDEX) ? ii+1 : ii,
+				percentage/1000);
+		check_point += gear_time;
+		tk_debug("%c%d: %d%% %llu/%llu\n", stats->abbr, ii,
+					percentage/1000, gear_time, total);
+	}
+	tk_debug("MPG time check point: %llu <-> %llu\n", check_point, total);
+
+	stats = gStat.hop;
+	check_point = (unsigned long long)0;
+	if (count_time_since) {
+		duration = timediff_ms(ktime_to_timespec(stats->start), end);
+		pr_debug("%c time since last resume %llu\n",
+						stats->abbr, duration);
+	}
+	/* show starting from the oldest hops */
+	for (ii = 1; ii <= stats->max; ii++) {
+		int idx = stats->active + ii;
+
+		if (idx >= stats->max)
+			idx -= stats->max;
+		if (idx < 0 || idx > stats->max) {
+			pr_warn("idx outside the range\n");
+			break;
+		}
+		pr_debug("idx[%d], id[%d]\n", idx, stats->keeper[idx].id);
+		if (stats->keeper[idx].id != -1) {
+			gear_time = stats->keeper[idx].duration;
+			/* add extra time to the last hop record only */
+			if (ii == stats->max && stats->keeper[idx].id == gear)
+				gear_time += duration;
+			SPRINTF_PAGE("%c%d: %llums\n", stats->abbr,
+					stats->keeper[idx].id, gear_time);
+			check_point += gear_time;
+		}
+	}
+	tk_debug("uptime check point: %llu <-> %llu\n", check_point, total);
+	return blen;
+}
+
+static ssize_t synaptics_rmi4_stats_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (gStat.enabled) {
+		struct synaptics_rmi4_data *rmi4_data =
+				i2c_get_clientdata(to_i2c_client(dev));
+		statistics_reset();
+		pr_info("statistics reset\n");
+		statistics_start_timekeeping(rmi4_data);
+	}
+	return count;
+}
+
+static bool reporting_stopped;
+static unsigned int events_cnt;
+
+static ssize_t synaptics_rmi4_reporting_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t length;
+	if (reporting_stopped)
+		length = scnprintf(buf, PAGE_SIZE, "STOPPED(%u)\n", events_cnt);
+	else
+		length = scnprintf(buf, PAGE_SIZE, "RUNNING\n");
+	return length;
+}
+
+static ssize_t synaptics_rmi4_reporting_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long value = 0;
+	int err = 0;
+
+	if (*buf == 's' || *buf == 'S') {
+		reporting_stopped = true;
+	} else if (*buf == 'r' || *buf == 'R') {
+		reporting_stopped = false;
+	} else {
+		err = kstrtoul(buf, 10, &value);
+		if (err < 0) {
+			pr_err("Failed to convert value\n");
+			return -EINVAL;
+		}
+		reporting_stopped = value == 0;
+	}
+	if (reporting_stopped)
+		events_cnt = 0;
+	return count;
+}
+
+static ssize_t synaptics_rmi4_drv_irq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	return scnprintf(buf, PAGE_SIZE, "%s\n",
+			rmi4_data->irq_enabled ? "ENABLED" : "DISABLED");
+}
+
+static ssize_t synaptics_rmi4_drv_irq_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long value = 0;
+	int err = 0;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	err = kstrtoul(buf, 10, &value);
+	if (err < 0) {
+		pr_err("Failed to convert value\n");
+		return -EINVAL;
+	}
+
+	switch (value) {
+	case 0:
+		/* Disable irq */
+		synaptics_rmi4_irq_enable(rmi4_data, false);
+		break;
+	case 1:
+		/* Enable irq */
+		synaptics_rmi4_irq_enable(rmi4_data, true);
+		break;
+	default:
+		pr_err("Invalid value\n");
+		return -EINVAL;
+	}
+	return count;
+}
+
+static ssize_t synaptics_rmi4_0dbutton_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			rmi4_data->button_0d_enabled);
+}
+
+static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+	unsigned char ii;
+	unsigned char intr_enable;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	if (sscanf(buf, "%u", &input) != 1)
+		return -EINVAL;
+
+	input = input > 0 ? 1 : 0;
+
+	if (rmi4_data->button_0d_enabled == input)
+		return count;
+
+	list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+		if (fhandler->fn_number == SYNAPTICS_RMI4_F1A) {
+			ii = fhandler->intr_reg_num;
+
+			retval = synaptics_rmi4_i2c_read(rmi4_data,
+					rmi4_data->f01_ctrl_base_addr + 1 + ii,
+					&intr_enable,
+					sizeof(intr_enable));
+			if (retval < 0)
+				return retval;
+
+			if (input == 1)
+				intr_enable |= fhandler->intr_mask;
+			else
+				intr_enable &= ~fhandler->intr_mask;
+
+			retval = synaptics_rmi4_i2c_write(rmi4_data,
+					rmi4_data->f01_ctrl_base_addr + 1 + ii,
+					&intr_enable,
+					sizeof(intr_enable));
+			if (retval < 0)
+				return retval;
+		}
+	}
+
+	rmi4_data->button_0d_enabled = input;
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_ic_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned int build_id, config_id;
+	struct synaptics_rmi4_device_info *rmi;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	rmi = &(rmi4_data->rmi4_mod_info);
+	batohui(&build_id, rmi->build_id, sizeof(rmi->build_id));
+	batohui(&config_id, rmi->config_id, sizeof(rmi->config_id));
+	return scnprintf(buf, PAGE_SIZE,
+			"%s%s\n%s%x\n%s%x\n",
+			"Product ID: ", rmi->product_id_string,
+			"Build ID: ", build_id,
+			"Config ID: ", config_id);
+}
+
+static ssize_t synaptics_rmi4_poweron_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	return scnprintf(buf, PAGE_SIZE, "%d\n",
+		atomic_read(&rmi4_data->touch_stopped) == 0 &&
+		rmi4_data->flash_enabled);
+}
+
+static struct synaptics_dsx_patch *query_data;
+static unsigned int query_index;
+
+#define SPRINTF_RANGE(fmt, args...) {\
+		blen += scnprintf(out + blen, count - blen, fmt, ##args);\
+	}
+
+static ssize_t synaptics_dsx_patch_dump(
+	struct synaptics_rmi4_data *rmi4_data, char *out, ssize_t count)
+{
+	int i;
+	const char *name;
+	struct synaptics_dsx_func_patch *fp;
+	ssize_t blen = 0;
+
+	if (!query_data) {
+		SPRINTF_RANGE("nothing to query\n");
+		goto time_to_leave;
+	}
+	name = query_data->name ? query_data->name : "noname";
+	SPRINTF_RANGE("[%s", name);
+	if (!strnstr(name, "runtime", 7))
+		SPRINTF_RANGE("-%s", !query_index ? "active" : "suspended");
+	SPRINTF_RANGE("] ");
+	list_for_each_entry(fp, &query_data->cfg_head, link) {
+		struct synaptics_rmi4_func_packet_regs *regs;
+		struct synaptics_rmi4_packet_reg *reg;
+		int error;
+		unsigned short data_addr;
+		unsigned int data_size;
+		unsigned char *value;
+
+		regs = find_function(fp->func);
+		if (!regs)
+			continue;
+		reg = find_packet_reg(regs, fp->regstr);
+		if (!reg || reg->offset < 0) {
+			pr_err("F%x@%d not present\n", fp->func, fp->regstr);
+			continue;
+		}
+
+		error = synaptics_rmi4_read_packet_reg(rmi4_data,
+				regs, reg->r_number);
+		if (error < 0) {
+			pr_err("F%x@%d register read failed\n",
+				fp->func, fp->regstr);
+			continue;
+		}
+		/* calculate register address */
+		data_addr = regs->base_addr + reg->offset;
+		/* dump whole register if subpacket is 255 */
+		if (fp->subpkt == 0xff) {
+			value = reg->data;
+			data_size = reg->size;
+			SPRINTF_RANGE("F%x@%d{%X}=",
+				fp->func, fp->regstr, data_addr);
+		} else {
+			struct synaptics_rmi4_subpkt *subpkt;
+			subpkt = reg->subpkt + fp->subpkt;
+			value = (unsigned char *)subpkt->data;
+			data_size = subpkt->size;
+			data_addr += subpkt->offset;
+			SPRINTF_RANGE("F%x@%d:%d{%X}=",
+				fp->func, fp->regstr, fp->subpkt, data_addr);
+		}
+
+		for (i = 0; i < data_size; i++)
+			SPRINTF_RANGE("%02x", *value++);
+		SPRINTF_RANGE("; ");
+	}
+	SPRINTF_RANGE("\n");
+time_to_leave:
+	return blen;
+}
+
+static ssize_t synaptics_rmi4_query_idx_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int index;
+	if (sscanf(buf, "%u", &index) != 1)
+		return -EINVAL;
+	query_index = index > 0 ? 1 : 0;
+	pr_debug("index setup to %u\n", query_index);
+	return count;
+}
+
+static ssize_t synaptics_rmi4_query_idx_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%s\n",
+			!query_index ? "active" : "suspended");
+}
+
+static ssize_t synaptics_rmi4_query_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct synaptics_dsx_patch *patch;
+
+	if (*buf == '\n') {
+		if (query_data) {
+			synaptics_dsx_free_patch(query_data);
+			query_data = NULL;
+			pr_debug("discarded current query\n");
+		}
+		goto leave_now;
+	}
+	if (*buf != 'F') {
+		pr_err("invalid query syntax\n");
+		return -EINVAL;
+	}
+	patch = synaptics_dsx_init_patch("sysfs-runtime");
+	if (!patch)
+		return -ENOMEM;
+	synaptics_dsx_parse_string(rmi4_data, buf, patch, false);
+	if (query_data) {
+		synaptics_dsx_free_patch(query_data);
+		pr_debug("previous query discarded\n");
+	}
+	query_data = patch;
+	pr_debug("new query added\n");
+leave_now:
+	return count;
+}
+
+static ssize_t synaptics_rmi4_query_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	bool clear_after_use = false;
+	ssize_t length;
+
+	if (!query_data) {
+		query_data = rmi4_data->current_mode->patch_data[query_index];
+		clear_after_use = true;
+	}
+	length = synaptics_dsx_patch_dump(rmi4_data, buf, PAGE_SIZE);
+	if (clear_after_use)
+		query_data = NULL;
+	return length;
+}
+
+static ssize_t synaptics_rmi4_patch_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct synaptics_dsx_patch *patch;
+
+	if (*buf == '\n') {
+		pr_debug("discarding %s patch set from %s mode\n",
+			!query_index ? "active" : "suspended",
+			rmi4_data->current_mode == rmi4_data->default_mode ?
+			"default" : "alternate");
+		synaptics_dsx_free_patch(
+			rmi4_data->current_mode->patch_data[query_index]);
+		patch = synaptics_dsx_init_patch("sysfs");
+		rmi4_data->current_mode->patch_data[query_index] = patch;
+		goto leave_now;
+	}
+	if (*buf != 'F') {
+		pr_err("invalid patch syntax\n");
+		return -EINVAL;
+	}
+	patch = synaptics_dsx_init_patch("sysfs");
+	if (!patch)
+		return -ENOMEM;
+	synaptics_dsx_parse_string(rmi4_data, buf, patch, true);
+	synaptics_dsx_free_patch(
+		rmi4_data->current_mode->patch_data[query_index]);
+	rmi4_data->current_mode->patch_data[query_index] = patch;
+	pr_debug("[sysfs-%s] patch set added to %s mode\n",
+		!query_index ? "active" : "suspended",
+		rmi4_data->current_mode == rmi4_data->default_mode ?
+				"default" : "alternate");
+leave_now:
+	return count;
+}
+
+ /**
+ * synaptics_rmi4_set_page()
+ *
+ * Called by synaptics_rmi4_i2c_read() and synaptics_rmi4_i2c_write().
+ *
+ * This function writes to the page select register to switch to the
+ * assigned page.
+ */
+static int synaptics_rmi4_set_page(struct synaptics_rmi4_data *rmi4_data,
+		unsigned int address)
+{
+	int retval = 0;
+	unsigned char retry;
+	unsigned char buf[PAGE_SELECT_LEN];
+	unsigned char page;
+	struct i2c_client *i2c = rmi4_data->i2c_client;
+
+	page = ((address >> 8) & MASK_8BIT);
+	if (page != rmi4_data->current_page) {
+		buf[0] = MASK_8BIT;
+		buf[1] = page;
+		for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+			retval = i2c_master_send(i2c, buf, PAGE_SELECT_LEN);
+			if (retval != PAGE_SELECT_LEN) {
+				dev_err(&i2c->dev,
+						"%s: I2C retry %d\n",
+						__func__, retry + 1);
+				msleep(20);
+			} else {
+				rmi4_data->current_page = page;
+				break;
+			}
+		}
+	} else
+		return PAGE_SELECT_LEN;
+	return (retval == PAGE_SELECT_LEN) ? retval : -EIO;
+}
+
+ /**
+ * synaptics_rmi4_i2c_read()
+ *
+ * Called by various functions in this driver, and also exported to
+ * other expansion Function modules such as rmi_dev.
+ *
+ * This function reads data of an arbitrary length from the sensor,
+ * starting from an assigned register address of the sensor, via I2C
+ * with a retry mechanism.
+ */
+static int synaptics_rmi4_i2c_read(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data, unsigned short length)
+{
+	int retval;
+	unsigned char retry;
+	unsigned char buf;
+	struct i2c_msg msg[] = {
+		{
+			.addr = rmi4_data->i2c_client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &buf,
+		},
+		{
+			.addr = rmi4_data->i2c_client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = data,
+		},
+	};
+
+	buf = addr & MASK_8BIT;
+
+	mutex_lock(&(rmi4_data->rmi4_io_ctrl_mutex));
+
+	retval = synaptics_rmi4_set_page(rmi4_data, addr);
+	if (retval != PAGE_SELECT_LEN)
+		goto exit;
+
+	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+		if (i2c_transfer(rmi4_data->i2c_client->adapter, msg, 2) == 2) {
+			retval = length;
+			break;
+		}
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: I2C retry %d\n",
+				__func__, retry + 1);
+		msleep(20);
+	}
+
+	if (retry == SYN_I2C_RETRY_TIMES) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: I2C read %db@x%x over retry limit\n",
+				__func__, length, addr);
+		retval = -EIO;
+	}
+
+exit:
+	mutex_unlock(&(rmi4_data->rmi4_io_ctrl_mutex));
+
+	return retval;
+}
+
+ /**
+ * synaptics_rmi4_i2c_write()
+ *
+ * Called by various functions in this driver, and also exported to
+ * other expansion Function modules such as rmi_dev.
+ *
+ * This function writes data of an arbitrary length to the sensor,
+ * starting from an assigned register address of the sensor, via I2C with
+ * a retry mechanism.
+ */
+static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short addr, unsigned char *data, unsigned short length)
+{
+	int retval;
+	unsigned char retry;
+	unsigned char buf[length + 1];
+	struct i2c_msg msg[] = {
+		{
+			.addr = rmi4_data->i2c_client->addr,
+			.flags = 0,
+			.len = length + 1,
+			.buf = buf,
+		}
+	};
+
+	mutex_lock(&(rmi4_data->rmi4_io_ctrl_mutex));
+
+	retval = synaptics_rmi4_set_page(rmi4_data, addr);
+	if (retval != PAGE_SELECT_LEN)
+		goto exit;
+
+	buf[0] = addr & MASK_8BIT;
+	memcpy(&buf[1], &data[0], length);
+
+	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+		if (i2c_transfer(rmi4_data->i2c_client->adapter, msg, 1) == 1) {
+			retval = length;
+			break;
+		}
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: I2C retry %d\n",
+				__func__, retry + 1);
+		msleep(20);
+	}
+
+	if (retry == SYN_I2C_RETRY_TIMES) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: I2C write %db@x%x over retry limit\n",
+				__func__, length, addr);
+		retval = -EIO;
+	}
+
+exit:
+	mutex_unlock(&(rmi4_data->rmi4_io_ctrl_mutex));
+
+	return retval;
+}
+
+ /**
+ * synaptics_rmi4_f12_abs_report()
+ *
+ * Called by synaptics_rmi4_report_touch() when valid Function $12
+ * finger data has been detected.
+ *
+ * This function reads the Function $12 data registers, determines the
+ * status of each finger supported by the Function, processes any
+ * necessary coordinate manipulation, reports the finger data to
+ * the input subsystem, and returns the number of fingers detected.
+ */
+static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char touch_count = 0; /* number of touch points */
+	unsigned char finger;
+	unsigned char fingers_to_process;
+	unsigned char finger_status;
+	unsigned short data_addr;
+	unsigned short data_size;
+	int x;
+	int y;
+	int p;
+	int w;
+	int id;
+	static unsigned char active_touch_max_idx;
+	struct timespec hw_time = ktime_to_timespec(ktime_get());
+	struct f12_d1_type *finger_data;
+	struct synaptics_rmi4_packet_reg *reg_data_1 =
+				&rmi4_data->f12_data_registers_ptr->regs[0];
+	struct synaptics_rmi4_packet_reg *reg_data_15 =
+				&rmi4_data->f12_data_registers_ptr->regs[1];
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	unsigned char number_of_fingers_actually_touching = 0;
+#endif
+
+	if (atomic_read(&rmi4_data->panel_off_flag)) {
+		synaptics_dsx_resumeinfo_ignore(rmi4_data);
+		return 0;
+	} else
+		synaptics_dsx_resumeinfo_purgeoff(rmi4_data);
+
+	fingers_to_process = fhandler->num_of_data_points;
+	data_addr = fhandler->full_addr.data_base;
+
+	if (reg_data_15->offset != -1) {
+		int temp;
+		retval = synaptics_rmi4_i2c_read(rmi4_data,
+				data_addr + reg_data_15->offset,
+				f12_d15_0.attn,
+				sizeof(f12_d15_0));
+		if (retval < 0)
+			return 0;
+
+		/* Start checking from the highest bit */
+		temp = reg_data_15->size - 1; /* Highest byte */
+		finger = (fingers_to_process - 1) % 8; /* Highest bit */
+		do {
+			if (f12_d15_0.attn[temp] & (1 << finger))
+				break;
+
+			if (finger) {
+				finger--;
+			} else {
+				temp--; /* Move to the next lower byte */
+				finger = 7;
+			}
+
+			fingers_to_process--;
+		} while (fingers_to_process);
+
+		pr_debug("fingers to process %d\n", fingers_to_process);
+	}
+
+	fingers_to_process = max(fingers_to_process, active_touch_max_idx);
+
+	if (fingers_to_process == 0) {
+		/* count release event */
+		events_cnt++;
+		synaptics_dsx_release_all(rmi4_data);
+		return 0;
+	}
+
+	data_size = fingers_to_process * fhandler->size_of_data_register_block;
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			data_addr + reg_data_1->offset,
+			reg_data_1->data,
+			data_size);
+	if (retval < 0)
+		return 0;
+	/* count valid event */
+	events_cnt++;
+	if (reporting_stopped)
+		return 0;
+
+	input_event(rmi4_data->input_dev, EV_SYN,
+			SYN_TIME_SEC, hw_time.tv_sec);
+	input_event(rmi4_data->input_dev, EV_SYN,
+			SYN_TIME_NSEC, hw_time.tv_nsec);
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	if (touchxp.touchx)
+		mutex_lock(&touchxp.virtual_touch_mutex);
+
+	finger_data = (struct f12_d1_type *)reg_data_1->data;
+	for (finger = 0; finger < fingers_to_process; finger++, finger_data++) {
+		finger_status = finger_data->type_and_stylus;
+		if (finger_status == 0)
+			continue;
+		number_of_fingers_actually_touching++;
+	}
+#endif
+
+	finger_data = (struct f12_d1_type *)reg_data_1->data;
+	for (finger = 0; finger < fingers_to_process; finger++, finger_data++) {
+		finger_status = finger_data->type_and_stylus;
+#ifdef TYPE_B_PROTOCOL
+		input_mt_slot(rmi4_data->input_dev, finger);
+		input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, finger_status);
+#endif
+		if (finger_status) {
+			x = finger_data->x_lsb | (finger_data->x_msb << 8);
+			y = finger_data->y_lsb | (finger_data->y_msb << 8);
+			p = w = finger_data->z;
+			id = finger;
+
+			if (rmi4_data->board->x_flip)
+				x = rmi4_data->sensor_max_x - x;
+			if (rmi4_data->board->y_flip)
+				y = rmi4_data->sensor_max_y - y;
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+			touchxp.touch_magic_dev = rmi4_data->input_dev;
+			if (touchxp.touchx)
+				touchxp.touchx(&x, &y, finger,
+					       number_of_fingers_actually_touching);
+#endif
+
+			dev_dbg(&rmi4_data->i2c_client->dev,
+						"%s: Finger %d:\n"
+						"x = %d\n"
+						"y = %d\n"
+						"p = %d\n"
+						"w = %d\n",
+						__func__, finger,
+						x, y, p, w);
+
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_X, x);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_Y, y);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_PRESSURE, p);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MAJOR, w);
+#ifndef TYPE_B_PROTOCOL
+			input_mt_sync(rmi4_data->input_dev);
+#endif
+			touch_count++;
+			active_touch_max_idx = finger + 1;
+#ifdef TYPE_B_PROTOCOL
+		} else {
+			/* Touch no longer active, close out slot */
+			input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, 0);
+#endif
+		}
+
+		synaptics_dsx_resumeinfo_touch(rmi4_data);
+	}
+
+	if (!touch_count) {
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+		touchxp.finger_down = 0;
+#endif
+		active_touch_max_idx = 0;
+#ifndef TYPE_B_PROTOCOL
+		input_mt_sync(rmi4_data->input_dev);
+#endif
+	}
+
+	input_mt_report_pointer_emulation(rmi4_data->input_dev, false);
+	input_sync(rmi4_data->input_dev);
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	if (touchxp.touchx)
+		mutex_unlock(&touchxp.virtual_touch_mutex);
+#endif
+
+	return touch_count;
+}
+
+ /**
+ * synaptics_rmi4_f11_abs_report()
+ *
+ * Called by synaptics_rmi4_report_touch() when valid Function $11
+ * finger data has been detected.
+ *
+ * This function reads the Function $11 data registers, determines the
+ * status of each finger supported by the Function, processes any
+ * necessary coordinate manipulation, reports the finger data to
+ * the input subsystem, and returns the number of fingers detected.
+ */
+static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char touch_count = 0; /* number of touch points */
+	unsigned char reg_index;
+	unsigned char finger;
+	unsigned char fingers_supported;
+	unsigned char num_of_finger_status_regs;
+	unsigned char finger_shift;
+	unsigned char finger_status;
+	unsigned char data_reg_blk_size;
+	unsigned char finger_status_reg[3];
+	unsigned char data[F11_STD_DATA_LEN];
+	unsigned short data_addr;
+	unsigned short data_offset;
+	int x;
+	int y;
+	int wx;
+	int wy;
+	int z;
+	struct timespec hw_time = ktime_to_timespec(ktime_get());
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	unsigned char number_of_fingers_actually_touching = 0;
+#endif
+
+	/*
+	 * The number of finger status registers is determined by the
+	 * maximum number of fingers supported - 2 bits per finger. So
+	 * the number of finger status registers to read is:
+	 * register_count = ceil(max_num_of_fingers / 4)
+	 */
+	fingers_supported = fhandler->num_of_data_points;
+	num_of_finger_status_regs = (fingers_supported + 3) / 4;
+	data_addr = fhandler->full_addr.data_base;
+	data_reg_blk_size = fhandler->size_of_data_register_block;
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			data_addr,
+			finger_status_reg,
+			num_of_finger_status_regs);
+	if (retval < 0)
+		return 0;
+	/* count valid event */
+	events_cnt++;
+	if (reporting_stopped)
+		return 0;
+
+	if (atomic_read(&rmi4_data->panel_off_flag)) {
+		synaptics_dsx_resumeinfo_ignore(rmi4_data);
+		return 0;
+	} else
+		synaptics_dsx_resumeinfo_purgeoff(rmi4_data);
+
+	input_event(rmi4_data->input_dev, EV_SYN,
+			SYN_TIME_SEC, hw_time.tv_sec);
+	input_event(rmi4_data->input_dev, EV_SYN,
+			SYN_TIME_NSEC, hw_time.tv_nsec);
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	if (touchxp.touchx)
+		mutex_lock(&touchxp.virtual_touch_mutex);
+
+	for (finger = 0; finger < fingers_supported; finger++) {
+		reg_index = finger / 4;
+		finger_shift = (finger % 4) * 2;
+		finger_status = (finger_status_reg[reg_index] >> finger_shift)
+				& MASK_2BIT;
+		if (finger_status)
+			number_of_fingers_actually_touching++;
+	}
+#endif
+
+	for (finger = 0; finger < fingers_supported; finger++) {
+		reg_index = finger / 4;
+		finger_shift = (finger % 4) * 2;
+		finger_status = (finger_status_reg[reg_index] >> finger_shift)
+				& MASK_2BIT;
+
+		/*
+		 * Each 2-bit finger status field represents the following:
+		 * 00 = finger not present
+		 * 01 = finger present and data accurate
+		 * 10 = finger present but data may be inaccurate
+		 * 11 = reserved
+		 */
+#ifdef TYPE_B_PROTOCOL
+		input_mt_slot(rmi4_data->input_dev, finger);
+		input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, finger_status);
+#endif
+		if (finger_status) {
+			data_offset = data_addr +
+					num_of_finger_status_regs +
+					(finger * data_reg_blk_size);
+			retval = synaptics_rmi4_i2c_read(rmi4_data,
+					data_offset,
+					data,
+					data_reg_blk_size);
+			if (retval < 0)
+				return 0;
+
+			x = (data[0] << 4) | (data[2] & MASK_4BIT);
+			y = (data[1] << 4) | ((data[2] >> 4) & MASK_4BIT);
+			wx = (data[3] & MASK_4BIT);
+			wy = (data[3] >> 4) & MASK_4BIT;
+			z = data[4];
+
+			if (rmi4_data->board->x_flip)
+				x = rmi4_data->sensor_max_x - x;
+			if (rmi4_data->board->y_flip)
+				y = rmi4_data->sensor_max_y - y;
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+			touchxp.touch_magic_dev = rmi4_data->input_dev;
+			if (touchxp.touchx)
+				touchxp.touchx(&x, &y, finger,
+					number_of_fingers_actually_touching);
+#endif
+
+			dev_dbg(&rmi4_data->i2c_client->dev,
+					"%s: Finger %d:\n"
+					"x = %d\n"
+					"y = %d\n"
+					"wx = %d\n"
+					"wy = %d\n"
+					"z = %d\n",
+					__func__, finger,
+					x, y, wx, wy, z);
+
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_X, x);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_POSITION_Y, y);
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_PRESSURE, z);
+
+#ifdef REPORT_2D_W
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MAJOR, max(wx, wy));
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MINOR, min(wx, wy));
+#endif
+#ifndef TYPE_B_PROTOCOL
+			input_mt_sync(rmi4_data->input_dev);
+#endif
+			touch_count++;
+#ifdef TYPE_B_PROTOCOL
+		} else {
+			/* Touch no longer active, close out slot */
+			input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, 0);
+#endif
+		}
+
+		synaptics_dsx_resumeinfo_touch(rmi4_data);
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	if (!touch_count)
+		touchxp.finger_down = 0;
+#endif
+
+#ifndef TYPE_B_PROTOCOL
+	if (!touch_count)
+		input_mt_sync(rmi4_data->input_dev);
+#endif
+
+	input_mt_report_pointer_emulation(rmi4_data->input_dev, false);
+	input_sync(rmi4_data->input_dev);
+
+#ifdef CONFIG_TOUCHSCREEN_TOUCHX_BASE
+	if (touchxp.touchx)
+		mutex_unlock(&touchxp.virtual_touch_mutex);
+#endif
+
+	return touch_count;
+}
+
+static void synaptics_rmi4_f1a_report(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned char button;
+	unsigned char index;
+	unsigned char shift;
+	unsigned char status;
+	unsigned char *data;
+	unsigned short data_addr = fhandler->full_addr.data_base;
+	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
+	static bool current_status[MAX_NUMBER_OF_BUTTONS];
+#ifdef NO_0D_WHILE_2D
+	static bool before_2d_status[MAX_NUMBER_OF_BUTTONS];
+	static bool while_2d_status[MAX_NUMBER_OF_BUTTONS];
+#endif
+
+	if (tsb_buff_clean_flag) {
+		memset(current_status, 0, sizeof(current_status));
+#ifdef NO_0D_WHILE_2D
+		memset(before_2d_status, 0, sizeof(before_2d_status));
+		memset(while_2d_status, 0, sizeof(while_2d_status));
+#endif
+		tsb_buff_clean_flag = 0;
+	}
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			data_addr,
+			f1a->button_data_buffer,
+			f1a->button_bitmask_size);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read button data registers\n",
+				__func__);
+		return;
+	}
+
+	if (atomic_read(&rmi4_data->panel_off_flag)) {
+		synaptics_dsx_resumeinfo_ignore(rmi4_data);
+		return;
+	} else
+		synaptics_dsx_resumeinfo_purgeoff(rmi4_data);
+
+	data = f1a->button_data_buffer;
+
+	for (button = 0; button < f1a->valid_button_count; button++) {
+		index = button / 8;
+		shift = button % 8;
+		status = ((data[index] >> shift) & MASK_1BIT);
+
+		if (current_status[button] == status)
+			continue;
+		else
+			current_status[button] = status;
+
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Button %d (code %d) ->%d\n",
+				__func__, button,
+				f1a->button_map[button],
+				status);
+#ifdef NO_0D_WHILE_2D
+		if (rmi4_data->fingers_on_2d == false) {
+			if (status == 1) {
+				before_2d_status[button] = 1;
+			} else {
+				if (while_2d_status[button] == 1) {
+					while_2d_status[button] = 0;
+					continue;
+				} else {
+					before_2d_status[button] = 0;
+				}
+			}
+			input_report_key(rmi4_data->input_dev,
+					f1a->button_map[button],
+					status);
+		} else {
+			if (before_2d_status[button] == 1) {
+				before_2d_status[button] = 0;
+				input_report_key(rmi4_data->input_dev,
+						f1a->button_map[button],
+						status);
+			} else {
+				if (status == 1)
+					while_2d_status[button] = 1;
+				else
+					while_2d_status[button] = 0;
+			}
+		}
+#else
+		input_report_key(rmi4_data->input_dev,
+				f1a->button_map[button],
+				status);
+#endif
+		synaptics_dsx_resumeinfo_touch(rmi4_data);
+	}
+
+	input_sync(rmi4_data->input_dev);
+
+	return;
+}
+
+static void synaptics_rmi4_f01_handler(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	unsigned short data_addr = fhandler->full_addr.data_base;
+	struct synaptics_rmi4_f01_device_status status;
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			data_addr,
+			status.data,
+			sizeof(status.data));
+	if (retval < 0)
+		return;
+
+	switch (status.status_code) {
+	case 0x00:
+		printk(KERN_INFO "%s: No error.\n", __func__);
+		break;
+
+	case 0x01:
+		printk(KERN_INFO "%s: Touch IC reset complete.\n", __func__);
+		break;
+
+	case 0x02:
+		printk(KERN_ERR "%s: Touch IC configuration error--%s.\n",
+			__func__, "check platform settings");
+		break;
+
+	case 0x03:
+		printk(KERN_ERR "%s: Touch IC device failure.\n", __func__);
+		break;
+
+	case 0x04:
+		printk(KERN_ERR "%s: Configuration CRC failure.\n", __func__);
+		break;
+
+	case 0x05:
+		printk(KERN_ERR "%s: Firmware CRC failure.\n", __func__);
+		break;
+
+	case 0x06:
+		printk(KERN_ERR "%s: CRC in progress.\n", __func__);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: Unknown error 0x%02X received.\n",
+			__func__, status.status_code);
+		break;
+	}
+}
+
+#define IM_BIT 0
+#define NMS_BIT 1
+#define CID_IM_BIT 2
+#define FS_IM_BIT 3
+#define FREQ_BIT 4
+#define GUARD_BIT 5
+
+static void synaptics_rmi4_f51_handler(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	struct synaptics_rmi4_func_packet_regs *regs;
+	struct synaptics_rmi4_packet_reg *reg;
+	unsigned char presence_mask = 0;
+	ktime_t log = ktime_get();
+	int ii, error;
+
+	regs = find_function(SYNAPTICS_RMI4_F51 | DATA_TYPE);
+	if (!regs)
+		return;
+
+	reg = &regs->regs[0];
+	error = synaptics_rmi4_read_packet_reg(rmi4_data, regs,	reg->r_number);
+	if (error < 0)
+		pr_err("F%x@D%d register read failed\n",
+					regs->f_number & 0xff, reg->r_number);
+	else {
+		presence_mask |= (1 << GUARD_BIT);
+		pr_debug("F%x@D%d: int status [0]=0x%x, [1]=0x%x\n",
+				regs->f_number & 0xff, reg->r_number,
+				f51_d0_0.data[0], f51_d0_0.data[1]);
+		tk_debug("F%x@D%d: int status [%s][%s][%s] md = %d\n",
+				regs->f_number & 0xff, reg->r_number,
+				f51_d0_0.noise_state ? "N" : "-",
+				f51_d0_0.gear_change ? "H" : "-",
+				f51_d0_0.guard_state ? "M" : "-",
+				f51_d0_0.md_present);
+	}
+
+	regs = find_function(SYNAPTICS_RMI4_F54 | DATA_TYPE);
+	if (!regs)
+		return;
+	for (ii = 0; ii < regs->nr_regs; ii++) {
+		reg = &regs->regs[ii];
+		if (!reg || reg->offset < 0) {
+			pr_err("F%x@D%d not present\n",
+					regs->f_number & 0xff, reg->r_number);
+			continue;
+		}
+		error = synaptics_rmi4_read_packet_reg(rmi4_data, regs,
+					reg->r_number);
+		if (error < 0) {
+			pr_err("F%x@D%d register read failed\n",
+					regs->f_number & 0xff, reg->r_number);
+			continue;
+		}
+		presence_mask |= (1 << ii);
+	}
+
+	if (presence_mask & (1 << FREQ_BIT)) {
+		statistics_log_time(gStat.dur, (int)f54_d17_0.freq, log);
+		statistics_log_time(gStat.hop, (int)f54_d17_0.freq, log);
+	}
+
+	if (presence_mask & (1 << NMS_BIT))
+		statistics_log_time(gStat.nms, (int)f54_d10_0.noise_state, log);
+
+	if (presence_mask & (1 << GUARD_BIT))
+		statistics_log_time(gStat.mpd, (int)f51_d0_0.md_present, log);
+
+	tk_debug("F%x: %d:%d %5d:%5d:%5d\n",
+		regs->f_number & 0xff,
+		presence_mask & (1 << FREQ_BIT) ?
+			(int)f54_d17_0.freq : -1,
+		presence_mask & (1 << NMS_BIT) ?
+			(int)f54_d10_0.noise_state : -1,
+		presence_mask & (1 << CID_IM_BIT) ?
+			(int)f54_d14_0.cid_im_lsb |
+				(f54_d14_0.cid_im_msb << 4) : -1,
+		presence_mask & (1 << IM_BIT) ?
+			(int)f54_d6_0.interference_metric_lsb |
+				(f54_d6_0.interference_metric_msb << 4) : -1,
+		presence_mask & (1 << FS_IM_BIT) ?
+			(int)f54_d16_0.freq_scan_im_lsb |
+				(f54_d16_0.freq_scan_im_msb << 4) : -1);
+}
+
+ /**
+ * synaptics_rmi4_report_touch()
+ *
+ * Called by synaptics_rmi4_sensor_report().
+ *
+ * This function calls the appropriate finger data reporting function
+ * based on the function handler it receives and returns the number of
+ * fingers detected.
+ */
+static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		unsigned char *touch_count)
+{
+	unsigned char touch_count_2d;
+
+	dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: Function %02x reporting\n",
+			__func__, fhandler->fn_number);
+
+	switch (fhandler->fn_number) {
+	case SYNAPTICS_RMI4_F01:
+		synaptics_rmi4_f01_handler(rmi4_data, fhandler);
+		break;
+
+	case SYNAPTICS_RMI4_F51:
+		synaptics_rmi4_f51_handler(rmi4_data, fhandler);
+		break;
+
+	case SYNAPTICS_RMI4_F11:
+		synaptics_dsx_resumeinfo_isr(rmi4_data);
+
+		touch_count_2d = synaptics_rmi4_f11_abs_report(rmi4_data,
+				fhandler);
+
+		*touch_count += touch_count_2d;
+
+		if (touch_count_2d)
+			rmi4_data->fingers_on_2d = true;
+		else
+			rmi4_data->fingers_on_2d = false;
+		break;
+
+	case SYNAPTICS_RMI4_F12:
+		synaptics_dsx_resumeinfo_isr(rmi4_data);
+
+		touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,
+				fhandler);
+
+		*touch_count += touch_count_2d;
+
+		if (touch_count_2d)
+			rmi4_data->fingers_on_2d = true;
+		else
+			rmi4_data->fingers_on_2d = false;
+		break;
+
+	case SYNAPTICS_RMI4_F1A:
+		synaptics_dsx_resumeinfo_isr(rmi4_data);
+
+		synaptics_rmi4_f1a_report(rmi4_data, fhandler);
+		break;
+
+	default:
+		break;
+	}
+
+	return;
+}
+
+ /**
+ * synaptics_rmi4_sensor_report()
+ *
+ * Called by synaptics_rmi4_irq().
+ *
+ * This function determines the interrupt source(s) from the sensor
+ * and calls synaptics_rmi4_report_touch() with the appropriate
+ * function handler for each function with valid data inputs.
+ */
+static int synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char touch_count = 0;
+	unsigned char intr[MAX_INTR_REGISTERS];
+	unsigned int intr_status_mask;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_exp_fn *exp_fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	/*
+	 * Get interrupt status information from F01 Data1 register to
+	 * determine the source(s) that are flagging the interrupt.
+	 */
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			rmi4_data->f01_data_base_addr + 1,
+			intr,
+			rmi4_data->num_of_intr_regs);
+	if (retval < 0)
+		return retval;
+
+	/*
+	 * Traverse the function handler list and service the source(s)
+	 * of the interrupt accordingly.
+	 */
+	list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+		if (fhandler->num_of_data_sources) {
+			if (fhandler->intr_mask &
+					intr[fhandler->intr_reg_num]) {
+				synaptics_rmi4_report_touch(rmi4_data,
+						fhandler, &touch_count);
+			}
+		}
+	}
+
+	batohui(&intr_status_mask, intr, rmi4_data->num_of_intr_regs);
+	/*
+	 * Go through external handlers list only when interrupt
+	 * is not handled by currently active internal functions.
+	 */
+	if (intr_status_mask & (~rmi4_data->active_fn_intr_mask)) {
+		mutex_lock(&exp_fn_ctrl.list_mutex);
+		if (!list_empty(&exp_fn_ctrl.fn_list)) {
+			list_for_each_entry(exp_fhandler,
+					&exp_fn_ctrl.fn_list, link) {
+				if (exp_fhandler->inserted &&
+					(exp_fhandler->func_attn != NULL))
+					exp_fhandler->func_attn(
+							rmi4_data, intr[0]);
+			}
+		}
+		mutex_unlock(&exp_fn_ctrl.list_mutex);
+	}
+
+	return touch_count;
+}
+
+ /**
+ * synaptics_rmi4_irq()
+ *
+ * Called by the kernel when an interrupt occurs (when the sensor
+ * asserts the attention irq).
+ *
+ * This function is the ISR thread and handles the acquisition
+ * and the reporting of finger data when the presence of fingers
+ * is detected.
+ */
+static irqreturn_t synaptics_rmi4_irq(int irq, void *data)
+{
+	struct synaptics_rmi4_data *rmi4_data = data;
+	struct synaptics_rmi4_irq_info *tmp_q;
+
+	if (rmi4_data->number_irq > 0) {
+		rmi4_data->last_irq++;
+		if (rmi4_data->last_irq >= rmi4_data->number_irq)
+			rmi4_data->last_irq = 0;
+		tmp_q =
+			&(rmi4_data->irq_info[rmi4_data->last_irq]);
+		getnstimeofday(&(tmp_q->irq_time));
+	}
+
+	synaptics_rmi4_sensor_report(rmi4_data);
+
+	return IRQ_HANDLED;
+}
+
+ /**
+ * synaptics_rmi4_irq_enable()
+ *
+ * Called by synaptics_rmi4_probe() and the power management functions
+ * in this driver and also exported to other expansion Function modules
+ * such as rmi_dev.
+ *
+ * This function handles the enabling and disabling of the attention
+ * irq including the setting up of the ISR thread.
+ */
+static int synaptics_rmi4_irq_enable(struct synaptics_rmi4_data *rmi4_data,
+		bool enable)
+{
+	int retval = 0;
+	unsigned char intr_status;
+	const struct synaptics_dsx_platform_data *platform_data =
+			rmi4_data->board;
+
+	if (enable) {
+		if (rmi4_data->irq_enabled)
+			return retval;
+
+		/* Clear interrupts first */
+		retval = synaptics_rmi4_i2c_read(rmi4_data,
+				rmi4_data->f01_data_base_addr + 1,
+				&intr_status,
+				rmi4_data->num_of_intr_regs);
+		if (retval < 0)
+			return retval;
+
+		retval = request_threaded_irq(rmi4_data->irq, NULL,
+				synaptics_rmi4_irq, platform_data->irq_flags,
+				DRIVER_NAME, rmi4_data);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Failed to create irq thread\n",
+					__func__);
+			return retval;
+		}
+
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Started irq thread\n", __func__);
+
+		rmi4_data->irq_enabled = true;
+	} else {
+		if (rmi4_data->irq_enabled) {
+			disable_irq(rmi4_data->irq);
+			free_irq(rmi4_data->irq, rmi4_data);
+			rmi4_data->irq_enabled = false;
+
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Stopped irq thread\n", __func__);
+		}
+	}
+
+	return retval;
+}
+
+ /**
+ * synaptics_rmi4_f11_init()
+ *
+ * Called by synaptics_rmi4_query_device().
+ *
+ * This funtion parses information from the Function 11 registers
+ * and determines the number of fingers supported, x and y data ranges,
+ * offset to the associated interrupt status register, interrupt bit
+ * mask, and gathers finger data acquisition capabilities from the query
+ * registers.
+ */
+static int synaptics_rmi4_f11_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char intr_offset;
+	unsigned char abs_data_size;
+	unsigned char abs_data_blk_size;
+	unsigned char query[F11_STD_QUERY_LEN];
+	unsigned char control[F11_STD_CTRL_LEN];
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = (fd->intr_src_count  & MASK_3BIT);
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			fhandler->full_addr.query_base,
+			query,
+			sizeof(query));
+	if (retval < 0)
+		return retval;
+
+	/* Maximum number of fingers supported */
+	if ((query[1] & MASK_3BIT) <= 4)
+		fhandler->num_of_data_points = (query[1] & MASK_3BIT) + 1;
+	else if ((query[1] & MASK_3BIT) == 5)
+		fhandler->num_of_data_points = 10;
+
+	rmi4_data->num_of_fingers = fhandler->num_of_data_points;
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			fhandler->full_addr.ctrl_base,
+			control,
+			sizeof(control));
+	if (retval < 0)
+		return retval;
+
+	/* Maximum x and y */
+	rmi4_data->sensor_max_x = ((control[6] & MASK_8BIT) << 0) |
+			((control[7] & MASK_4BIT) << 8);
+	rmi4_data->sensor_max_y = ((control[8] & MASK_8BIT) << 0) |
+			((control[9] & MASK_4BIT) << 8);
+	dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: Function %02x max x = %d max y = %d\n",
+			__func__, fhandler->fn_number,
+			rmi4_data->sensor_max_x,
+			rmi4_data->sensor_max_y);
+
+	/* Reporting mode */
+	if (!(control[0] & MASK_3BIT)) {
+		pr_warn("Reporting mode: continuous\n");
+	} else {
+		dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: thresholds: x=0x%x, y=0x%x\n",
+			__func__, control[2], control[3]);
+	}
+
+	fhandler->intr_reg_num = (intr_count + 7) / 8;
+	if (fhandler->intr_reg_num != 0)
+		fhandler->intr_reg_num -= 1;
+
+	/* Set an enable bit for each data source */
+	intr_offset = intr_count % 8;
+	fhandler->intr_mask = 0;
+	for (ii = intr_offset;
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++)
+		fhandler->intr_mask |= 1 << ii;
+
+	abs_data_size = query[5] & MASK_2BIT;
+	abs_data_blk_size = 3 + (2 * (abs_data_size == 0 ? 1 : 0));
+	fhandler->size_of_data_register_block = abs_data_blk_size;
+
+#ifdef INPUT_PROP_DIRECT
+	set_bit(INPUT_PROP_DIRECT, rmi4_data->input_dev->propbit);
+#endif
+	set_bit(EV_ABS, rmi4_data->input_dev->evbit);
+
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_POSITION_X, 0,
+			rmi4_data->sensor_max_x, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_POSITION_Y, 0,
+			rmi4_data->sensor_max_y, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_PRESSURE, 0,
+			255, 0, 0);
+#ifdef REPORT_2D_W
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TOUCH_MAJOR, 0,
+			15, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TOUCH_MINOR, 0,
+			15, 0, 0);
+#endif
+#ifdef TYPE_B_PROTOCOL
+	input_mt_init_slots(rmi4_data->input_dev,
+			rmi4_data->num_of_fingers, 0);
+#else
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TRACKING_ID, 0,
+			rmi4_data->num_of_fingers - 1, 0, 0);
+	input_set_events_per_packet(rmi4_data->input_dev, 64);
+#endif
+	return retval;
+}
+
+static int synaptics_rmi4_f1a_alloc_mem(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler)
+{
+	int retval;
+	struct synaptics_rmi4_f1a_handle *f1a;
+
+	f1a = kzalloc(sizeof(*f1a), GFP_KERNEL);
+	if (!f1a) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for function handle\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	fhandler->data = (void *)f1a;
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			fhandler->full_addr.query_base,
+			f1a->button_query.data,
+			sizeof(f1a->button_query.data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read query registers\n",
+				__func__);
+		return retval;
+	}
+
+	f1a->button_count = f1a->button_query.max_button_count + 1;
+	f1a->button_bitmask_size = (f1a->button_count + 7) / 8;
+
+	f1a->button_data_buffer = kcalloc(f1a->button_bitmask_size,
+			sizeof(*(f1a->button_data_buffer)), GFP_KERNEL);
+	if (!f1a->button_data_buffer) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for data buffer\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	f1a->button_map = kcalloc(f1a->button_count,
+			sizeof(*(f1a->button_map)), GFP_KERNEL);
+	if (!f1a->button_map) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for button map\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_f51_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char intr_offset;
+	struct synaptics_rmi4_func_packet_regs *regs;
+	unsigned char *data;
+	struct synaptics_rmi4_packet_reg *reg;
+	struct synaptics_rmi4_subpkt *subpkt;
+	struct {
+		unsigned char num_of_query_regs;
+		unsigned char num_of_data_regs;
+		unsigned char num_of_ctrl_regs;
+		} f51_query = {0};
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+				fhandler->full_addr.query_base,
+				(unsigned char *)&f51_query,
+				sizeof(f51_query));
+	pr_debug("F%x: # of query=%d, data=%d, ctrl=%d\n",
+				fd->fn_number,
+				f51_query.num_of_query_regs,
+				f51_query.num_of_data_regs,
+				f51_query.num_of_ctrl_regs);
+	/* check for error and mandatory registers presense */
+	if (retval < 0 || f51_query.num_of_query_regs < 3) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Error querying F51\n",
+			__func__);
+		return -EIO;
+	}
+	/* check for mandatory registers presense */
+	if (f51_query.num_of_data_regs < 2 ||
+		f51_query.num_of_ctrl_regs < 10) {
+		return -ENODEV;
+	}
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = (fd->intr_src_count  & MASK_3BIT);
+	fhandler->intr_reg_num = (intr_count + 7) / 8;
+	if (fhandler->intr_reg_num != 0)
+		fhandler->intr_reg_num -= 1;
+	/* Set an enable bit for each data source */
+	intr_offset = intr_count % 8;
+	fhandler->intr_mask = 0;
+	for (ii = intr_offset;
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++)
+		fhandler->intr_mask |= 1 << ii;
+	/* FIXME: interrupt bit 5 (belongs F54) is used for some reason */
+	fhandler->intr_mask = 0x40;
+
+	regs = find_function(SYNAPTICS_RMI4_F51 | DATA_TYPE);
+	if (!regs) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: F%x data not found\n",
+			__func__, fd->fn_number);
+		return 0;
+	}
+
+	regs->base_addr = fhandler->full_addr.data_base;
+	reg = &regs->regs[0];
+	subpkt = &reg->subpkt[0];
+	pr_debug("F%x@D%d size %u\n",
+			fd->fn_number, reg->r_number, subpkt->size);
+	data = kzalloc(subpkt->size, GFP_KERNEL);
+	if (data) {
+		reg->offset = reg->r_number;
+		reg->size = subpkt->size;
+		reg->data = data;
+		subpkt->present = true;
+		subpkt->offset = 0;
+	}
+
+	regs = find_function(SYNAPTICS_RMI4_F51);
+	if (!regs) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: F%x ctrl not found\n",
+			__func__, fd->fn_number);
+		return 0;
+	}
+
+	regs->base_addr = fhandler->full_addr.ctrl_base;
+	for (ii = 0; ii < regs->nr_regs; ii++) {
+		reg = &regs->regs[ii];
+		subpkt = &reg->subpkt[0];
+		pr_debug("F%x@C%d size %u\n",
+				fd->fn_number, reg->r_number, subpkt->size);
+		data = kzalloc(subpkt->size, GFP_KERNEL);
+		if (data) {
+			reg->offset = reg->r_number;
+			reg->size = subpkt->size;
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+		}
+	}
+
+	retval = synaptics_rmi4_read_packet_regs(rmi4_data, regs);
+	if (retval < 0)
+		dev_err(&rmi4_data->i2c_client->dev, "Error reading F51\n");
+	else {
+		dev_info(&rmi4_data->i2c_client->dev,
+			"F%x ctrl[0]=%02x\n", fd->fn_number, f51_c0_0.data[0]);
+		dev_info(&rmi4_data->i2c_client->dev,
+			"F%x ctrl[4]=%02x\n", fd->fn_number, f51_c4_0.data[0]);
+	}
+	return 0;
+}
+
+ /**
+ * synaptics_rmi4_f12_init()
+ *
+ * Called by synaptics_rmi4_query_device().
+ *
+ * This funtion parses information from the Function 12 registers
+ * and determines the number of fingers supported, x and y data ranges,
+ * offset to the associated interrupt status register, interrupt bit
+ * mask, and gathers finger data acquisition capabilities from the query
+ * registers.
+ */
+static int synaptics_rmi4_f12_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char intr_offset;
+	struct synaptics_rmi4_func_packet_regs *regs;
+
+	regs = rmi4_data->f12_data_registers_ptr;
+	retval = synaptics_rmi4_scan_f12_reg_info(rmi4_data,
+			fhandler->full_addr.query_base + regs->query_offset,
+			fhandler->full_addr.data_base, regs);
+	if (retval < 0)
+		return retval;
+
+	if (f12_d15[0].present)
+		pr_debug("F12 has data register 15\n");
+
+	regs = find_function(SYNAPTICS_RMI4_F12);
+	retval = synaptics_rmi4_scan_f12_reg_info(rmi4_data,
+			fhandler->full_addr.query_base + regs->query_offset,
+			fhandler->full_addr.ctrl_base, regs);
+	if (retval < 0)
+		return retval;
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = (fd->intr_src_count  & MASK_3BIT);
+
+	retval = synaptics_rmi4_read_packet_regs(rmi4_data, regs);
+	if (retval < 0)
+		return retval;
+
+	/* Maximum number of fingers supported */
+	if (f12_c23[1].present) {
+		fhandler->num_of_data_points =
+			f12_c23_1.max_num_reported_objects;
+		rmi4_data->num_of_fingers = f12_c23_1.max_num_reported_objects;
+	} else
+		return -ENOENT;
+
+	if (f12_c08[0].present) {
+		rmi4_data->sensor_max_x =
+			(f12_c08_0.max_x_msb << 8) | f12_c08_0.max_x_lsb;
+		rmi4_data->sensor_max_y =
+			(f12_c08_0.max_y_msb << 8) | f12_c08_0.max_y_lsb;
+	} else
+		return -ENOENT;
+
+	fhandler->intr_reg_num = (intr_count + 7) / 8;
+	if (fhandler->intr_reg_num != 0)
+		fhandler->intr_reg_num -= 1;
+
+	/* Set an enable bit for each data source */
+	intr_offset = intr_count % 8;
+	fhandler->intr_mask = 0;
+	for (ii = intr_offset;
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++)
+		fhandler->intr_mask |= 1 << ii;
+
+	/* Data size per touch */
+	if (f12_c28[0].present) {
+		for (ii = 0; ii < 8; ii++)
+			if (f12_c28_0.reported_bytes_per_object & (1 << ii))
+				fhandler->size_of_data_register_block++;
+	} else
+		return -ENOENT;
+
+#ifdef INPUT_PROP_DIRECT
+	set_bit(INPUT_PROP_DIRECT, rmi4_data->input_dev->propbit);
+#endif
+	set_bit(EV_ABS, rmi4_data->input_dev->evbit);
+
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_POSITION_X, 0,
+			rmi4_data->sensor_max_x, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_POSITION_Y, 0,
+			rmi4_data->sensor_max_y, 0, 0);
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_PRESSURE, 0,
+			255, 0, 0);
+#ifdef REPORT_2D_W
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TOUCH_MAJOR, 0,
+			255, 0, 0);
+#endif
+#ifdef TYPE_B_PROTOCOL
+	input_mt_init_slots(rmi4_data->input_dev,
+			rmi4_data->num_of_fingers, 0);
+#else
+	input_set_abs_params(rmi4_data->input_dev,
+			ABS_MT_TRACKING_ID, 0,
+			rmi4_data->num_of_fingers - 1, 0, 0);
+	input_set_events_per_packet(rmi4_data->input_dev, 64);
+#endif
+	return retval;
+}
+
+static int synaptics_rmi4_cap_button_map(
+				struct synaptics_rmi4_data *rmi4_data,
+				struct synaptics_rmi4_fn *fhandler)
+{
+	unsigned char ii;
+	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
+	const struct synaptics_dsx_platform_data *pdata = rmi4_data->board;
+
+	if (!pdata->cap_button_map) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: cap_button_map is \
+				NULL in board file\n",
+				__func__);
+		return -ENODEV;
+	} else if (!pdata->cap_button_map->map) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Button map is missing in board file\n",
+				__func__);
+		return -ENODEV;
+	} else {
+		if (pdata->cap_button_map->nbuttons !=
+			f1a->button_count) {
+			f1a->valid_button_count = min(f1a->button_count,
+				pdata->cap_button_map->nbuttons);
+		} else {
+			f1a->valid_button_count = f1a->button_count;
+		}
+
+		set_bit(EV_KEY, rmi4_data->input_dev->evbit);
+
+		for (ii = 0; ii < f1a->valid_button_count; ii++) {
+			f1a->button_map[ii] =
+					pdata->cap_button_map->map[ii];
+			set_bit(f1a->button_map[ii],
+					rmi4_data->input_dev->keybit);
+			input_set_capability(rmi4_data->input_dev,
+					EV_KEY, f1a->button_map[ii]);
+		}
+	}
+
+	return 0;
+}
+
+static void synaptics_rmi4_f1a_kfree(struct synaptics_rmi4_fn *fhandler)
+{
+	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
+
+	if (f1a) {
+		kfree(f1a->button_data_buffer);
+		kfree(f1a->button_map);
+		kfree(f1a);
+		fhandler->data = NULL;
+	}
+
+	return;
+}
+
+static int synaptics_rmi4_f1a_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char ii;
+	unsigned short intr_offset;
+
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = (fd->intr_src_count  & MASK_3BIT);
+
+	fhandler->intr_reg_num = (intr_count + 7) / 8;
+	if (fhandler->intr_reg_num != 0)
+		fhandler->intr_reg_num -= 1;
+
+	/* Set an enable bit for each data source */
+	intr_offset = intr_count % 8;
+	fhandler->intr_mask = 0;
+	for (ii = intr_offset;
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++)
+		fhandler->intr_mask |= 1 << ii;
+
+	retval = synaptics_rmi4_f1a_alloc_mem(rmi4_data, fhandler);
+	if (retval < 0)
+		goto error_exit;
+
+	retval = synaptics_rmi4_cap_button_map(rmi4_data, fhandler);
+	if (retval < 0)
+		goto error_exit;
+
+	rmi4_data->button_0d_enabled = 1;
+
+	return 0;
+
+error_exit:
+	synaptics_rmi4_f1a_kfree(fhandler);
+
+	return retval;
+}
+
+static int synaptics_rmi4_alloc_fh(struct synaptics_rmi4_fn **fhandler,
+		struct synaptics_rmi4_fn_desc *rmi_fd, int page_number)
+{
+	*fhandler = kzalloc(sizeof(**fhandler), GFP_KERNEL);
+	if (!(*fhandler))
+		return -ENOMEM;
+
+	(*fhandler)->full_addr.data_base =
+			(rmi_fd->data_base_addr |
+			(page_number << 8));
+	(*fhandler)->full_addr.ctrl_base =
+			(rmi_fd->ctrl_base_addr |
+			(page_number << 8));
+	(*fhandler)->full_addr.cmd_base =
+			(rmi_fd->cmd_base_addr |
+			(page_number << 8));
+	(*fhandler)->full_addr.query_base =
+			(rmi_fd->query_base_addr |
+			(page_number << 8));
+
+	return 0;
+}
+
+static unsigned char *simple_init_packet_reg(
+		struct synaptics_rmi4_packet_reg *reg, short r_offset)
+{
+	unsigned char *data_ptr = NULL;
+	if (reg->subpkt[0].data && reg->subpkt[0].size) {
+		reg->subpkt[0].present = true;
+		reg->subpkt[0].offset = 0;
+		memset(reg->subpkt[0].data, 0, reg->subpkt[0].size);
+
+		reg->offset = r_offset;
+		kfree(reg->data);
+		data_ptr = kzalloc(reg->size, GFP_KERNEL);
+	}
+	return data_ptr;
+}
+
+static void simple_deinit_packet_reg(struct synaptics_rmi4_packet_reg *reg)
+{
+	reg->expected = false;
+	reg->offset = -1;
+	reg->size = 0;
+	reg->subpkt[0].expected = false;
+	reg->subpkt[0].offset = -1;
+}
+
+#define F01_RMI_Ctrl0	0
+#define F01_RMI_Ctrl2	2
+#define F01_RMI_Ctrl3	3
+#define F01_RMI_Ctrl5	5
+#define F01_RMI_Ctrl9	9
+
+static void synaptics_rmi4_scan_f01_reg_info(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	int r, s, retval;
+	unsigned short query42_offset = F01_QUERY21_OFFSET;
+	unsigned short query43_size = 0;
+	unsigned short current_ctrl_offset = rmi4_data->num_of_intr_regs;
+	bool has_recalibration = false;
+	bool can_access_ctrl9 = false;
+	u8 query43[4];
+	struct synaptics_rmi4_f01_query42 query42;
+	struct synaptics_rmi4_f01_query1 query1;
+	struct synaptics_rmi4_func_packet_regs *regs;
+	struct synaptics_rmi4_packet_reg *reg;
+
+	regs = find_function(SYNAPTICS_RMI4_F01);
+	if (unlikely(regs == NULL)) {
+		dev_info(&rmi4_data->i2c_client->dev,
+			"%s: F01 registers not defined\n", __func__);
+		return;
+	}
+	/* invalidate offsets only and keep statically defined register size */
+	for (r = 0; r < regs->nr_regs; ++r) {
+		regs->regs[r].offset = -1;
+		kfree(regs->regs[r].data);
+		regs->regs[r].data = NULL;
+		for (s = 0; s < regs->regs[r].nr_subpkts; ++s) {
+			regs->regs[r].subpkt[s].present = 0;
+			if (regs->regs[r].subpkt[s].data &&
+					regs->regs[r].subpkt[s].size)
+				memset(regs->regs[r].subpkt[s].data, 0,
+					regs->regs[r].subpkt[s].size);
+		}
+	}
+
+	regs->base_addr = rmi4_data->f01_ctrl_base_addr;
+	pr_debug("F01_RMI_Ctrl base addr 0x%x\n", regs->base_addr);
+
+	reg = find_packet_reg(regs, F01_RMI_Ctrl0);
+	if (unlikely(reg == NULL)) {
+		dev_warn(&rmi4_data->i2c_client->dev,
+			"%s: F01_RMI_Ctrl0 not defined\n",
+			__func__);
+		return;
+	}
+
+	if (regs && reg && reg->nr_subpkts) {
+		reg->data = simple_init_packet_reg(reg, 0);
+		if (!reg->data) {
+			simple_deinit_packet_reg(reg);
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: remove r%d.s0 from the list\n",
+				__func__, reg->r_number);
+		}
+	}
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			rmi4_data->f01_query_base_addr + F01_QUERY1_OFFSET,
+			query1.data,
+			sizeof(query1.data));
+	if (retval < 0) {
+		dev_warn(&rmi4_data->i2c_client->dev,
+			"%s: error reading F01_RMI_Query1\n", __func__);
+		return;
+	}
+
+	if (query1.has_sensor_id) {
+		query42_offset++;	/* has F01_RMI_Query22 */
+		pr_debug("has F01_RMI_Query22\n");
+	}
+
+	if (query1.has_adjustable_doze) {
+		pr_debug("has F01_RMI_Ctrl2 and F01_RMI_Ctrl3\n");
+		current_ctrl_offset++;
+		reg = find_packet_reg(regs, F01_RMI_Ctrl2);
+		if (reg) {
+			reg->data = simple_init_packet_reg(reg,
+						current_ctrl_offset);
+			if (!reg->data) {
+				simple_deinit_packet_reg(reg);
+				dev_err(&rmi4_data->i2c_client->dev,
+					"%s: remove r%d.s0 from the list\n",
+					__func__, reg->r_number);
+			}
+		}
+		current_ctrl_offset++;
+		reg = find_packet_reg(regs, F01_RMI_Ctrl3);
+		if (reg) {
+			reg->data = simple_init_packet_reg(reg,
+						current_ctrl_offset);
+			if (!reg->data) {
+				simple_deinit_packet_reg(reg);
+				dev_err(&rmi4_data->i2c_client->dev,
+					"%s: remove r%d.s0 from the list\n",
+					__func__, reg->r_number);
+			}
+		}
+	}
+
+	if (query1.reserved) {
+		current_ctrl_offset++;		/* has F01_RMI_Ctrl4 */
+		query42_offset++;	/* has F01_RMI_Query21 */
+		query42_offset += 18;	/* has F01_RMI_Query23-41 */
+		pr_debug("has F01_RMI_Query21,23-41 and F01_RMI_Ctrl4\n");
+	}
+
+	if (query1.has_doze_holdoff) {
+		pr_debug("has F01_RMI_Ctrl5\n");
+		current_ctrl_offset++;
+		reg = find_packet_reg(regs, F01_RMI_Ctrl5);
+		if (reg) {
+			reg->data = simple_init_packet_reg(reg,
+						current_ctrl_offset);
+			if (!reg->data) {
+				simple_deinit_packet_reg(reg);
+				dev_err(&rmi4_data->i2c_client->dev,
+					"%s: remove r%d.s0 from the list\n",
+					__func__, reg->r_number);
+			}
+		}
+	}
+
+	query42.data[0] = 0;
+	if (query1.has_query42) {
+		pr_debug("F01_RMI_Query42 offset %d\n", query42_offset);
+		retval = synaptics_rmi4_i2c_read(rmi4_data,
+				rmi4_data->f01_query_base_addr +
+				query42_offset,
+				query42.data,
+				sizeof(query42.data));
+		if (retval < 0) {
+			dev_warn(&rmi4_data->i2c_client->dev,
+				"%s: error reading F01_RMI_Query42\n",
+				__func__);
+		} else
+			has_recalibration = query42.has_recalibration;
+	}
+
+	if (query42.has_ds4_queries) {
+		retval = synaptics_rmi4_i2c_read(rmi4_data,
+				rmi4_data->f01_query_base_addr +
+				query42_offset + 1,
+				query43,
+				sizeof(query43));
+		if (retval < 0) {
+			dev_warn(&rmi4_data->i2c_client->dev,
+				"%s: error reading F01_RMI_Query43\n",
+				__func__);
+		} else {
+			can_access_ctrl9 = true;
+			query43_size = query43[0] & 0xf;
+			pr_debug("F01_RMI_Query43 size: %d\n", query43_size);
+		}
+	}
+
+	if (query43_size) {
+		if (query43[2] & 0x1) {
+			current_ctrl_offset++;	/* has F01_RMI_Ctrl6 */
+			pr_debug("has F01_RMI_Ctrl6\n");
+		}
+		if (query43[2] & 0x2) {
+			current_ctrl_offset++;	/* has F01_RMI_Ctrl7 */
+			pr_debug("has F01_RMI_Ctrl7\n");
+		}
+		if (query43[2] & 0x4) {
+			current_ctrl_offset++;	/* has F01_RMI_Ctrl8 */
+			pr_debug("has F01_RMI_Ctrl8\n");
+		}
+	}
+
+	reg = find_packet_reg(regs, F01_RMI_Ctrl9);
+	if (unlikely(reg == NULL)) {
+		dev_warn(&rmi4_data->i2c_client->dev,
+			"%s: F01_RMI_Ctrl9 not present\n", __func__);
+		return;
+	}
+
+	if (regs && reg) {
+		if (has_recalibration == false || can_access_ctrl9 == false) {
+			simple_deinit_packet_reg(reg);
+			dev_warn(&rmi4_data->i2c_client->dev,
+				"%s: remove r%d.s0 from the list\n",
+				__func__, reg->r_number);
+			return;
+		}
+
+		current_ctrl_offset++;
+		pr_debug("F01_RMI_Ctrl9 offset %d\n", current_ctrl_offset);
+
+		reg->data = simple_init_packet_reg(reg, current_ctrl_offset);
+		if (!reg->data) {
+			simple_deinit_packet_reg(reg);
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: remove r%d.s0 from the list\n",
+				__func__, reg->r_number);
+		}
+	}
+}
+
+ /**
+ * synaptics_rmi4_query_device()
+ *
+ * Called by synaptics_rmi4_probe().
+ *
+ * This funtion scans the page description table, records the offsets
+ * to the register types of Function $01, sets up the function handlers
+ * for Function $11 and Function $12, determines the number of interrupt
+ * sources from the sensor, adds valid Functions with data inputs to the
+ * Function linked list, parses information from the query registers of
+ * Function $01, and enables the interrupt sources from the valid Functions
+ * with data inputs.
+ */
+static int synaptics_rmi4_query_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char page_number;
+	unsigned char intr_count = 0;
+	unsigned char data_sources = 0;
+	unsigned char f01_query[F01_STD_QUERY_LEN] = {0};
+	unsigned short pdt_entry_addr;
+	struct synaptics_rmi4_fn_desc rmi_fd;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_device_info *rmi;
+	struct f34_properties f34_query;
+	struct synaptics_rmi4_f01_device_status status;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	INIT_LIST_HEAD(&rmi->support_fn_list);
+
+	/* Scan the page description tables of the pages to service */
+	for (page_number = 0; page_number < PAGES_TO_SERVICE; page_number++) {
+		for (pdt_entry_addr = PDT_START; pdt_entry_addr > PDT_END;
+				pdt_entry_addr -= PDT_ENTRY_SIZE) {
+			pdt_entry_addr |= (page_number << 8);
+
+			retval = synaptics_rmi4_i2c_read(rmi4_data,
+					pdt_entry_addr,
+					(unsigned char *)&rmi_fd,
+					sizeof(rmi_fd));
+			if (retval < 0)
+				return retval;
+
+			fhandler = NULL;
+
+			if (rmi_fd.fn_number == 0) {
+				dev_dbg(&rmi4_data->i2c_client->dev,
+						"%s: Reached end of PDT\n",
+						__func__);
+				break;
+			}
+
+			dev_dbg(&rmi4_data->i2c_client->dev,
+					"%s: F%02x found (page %d)\n",
+					__func__, rmi_fd.fn_number,
+					page_number);
+
+			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F51:
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(&rmi4_data->i2c_client->dev,
+						"%s: Failed to alloc for F%x\n",
+						__func__, rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f51_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0) {
+					/* not critical, just continue */
+					kfree(fhandler);
+					fhandler = NULL;
+					dev_err(&rmi4_data->i2c_client->dev,
+						"%s: No handler for F%x\n",
+						__func__, rmi_fd.fn_number);
+				}
+					break;
+
+			case SYNAPTICS_RMI4_F34:
+				retval = synaptics_rmi4_i2c_read(rmi4_data,
+						rmi_fd.query_base_addr +
+							F34_PROPERTIES_OFFSET,
+						&f34_query.data[0],
+						sizeof(f34_query));
+				if (retval < 0)
+					return retval;
+
+				if (f34_query.has_config_id) {
+					retval = synaptics_rmi4_i2c_read(
+							rmi4_data,
+							rmi_fd.ctrl_base_addr,
+							rmi->config_id,
+							sizeof(rmi->config_id));
+					if (retval < 0)
+						return retval;
+				}
+				break;
+
+			case SYNAPTICS_RMI4_F01:
+				rmi4_data->f01_query_base_addr =
+						rmi_fd.query_base_addr;
+				rmi4_data->f01_ctrl_base_addr =
+						rmi_fd.ctrl_base_addr;
+				rmi4_data->f01_data_base_addr =
+						rmi_fd.data_base_addr;
+				rmi4_data->f01_cmd_base_addr =
+						rmi_fd.cmd_base_addr;
+				pr_debug("query_base_addr 0x%04x\n",
+					rmi4_data->f01_query_base_addr);
+				pr_debug("ctrl_base_addr 0x%04x\n",
+					rmi4_data->f01_ctrl_base_addr);
+				pr_debug("data_base_addr 0x%04x\n",
+					rmi4_data->f01_data_base_addr);
+				pr_debug("cmd_base_addr 0x%04x\n",
+					rmi4_data->f01_cmd_base_addr);
+
+				retval = synaptics_rmi4_i2c_read(rmi4_data,
+						rmi4_data->f01_data_base_addr,
+						status.data,
+						sizeof(status.data));
+				if (retval < 0)
+					return retval;
+
+				rmi4_data->in_bootloader =
+						status.flash_prog == 1;
+				break;
+
+			case SYNAPTICS_RMI4_F11:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(&rmi4_data->i2c_client->dev,
+						"%s: Failed to alloc for F%x\n",
+						__func__, rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f11_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0)
+					return retval;
+				break;
+
+			case SYNAPTICS_RMI4_F12:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(&rmi4_data->i2c_client->dev,
+						"%s: Failed to alloc for F%x\n",
+						__func__, rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f12_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				if (retval < 0)
+					return retval;
+
+				break;
+
+			case SYNAPTICS_RMI4_F1A:
+				if (rmi_fd.intr_src_count == 0)
+					break;
+
+				retval = synaptics_rmi4_alloc_fh(&fhandler,
+						&rmi_fd, page_number);
+				if (retval < 0) {
+					dev_err(&rmi4_data->i2c_client->dev,
+						"%s: Failed to alloc for F%x\n",
+						__func__, rmi_fd.fn_number);
+					return retval;
+				}
+
+				retval = synaptics_rmi4_f1a_init(rmi4_data,
+						fhandler, &rmi_fd, intr_count);
+				switch (retval) {
+				case -ENOMEM:
+					return retval;
+				case -ENODEV:
+					/* removing buttons handler if there */
+					/* were no key codes in platform data */
+					kfree(fhandler);
+					fhandler = NULL;
+					rmi_fd.intr_src_count = 0;
+					break;
+				}
+				break;
+			}
+
+			/* Accumulate the interrupt count */
+			intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
+
+			if (fhandler && rmi_fd.intr_src_count) {
+				pr_debug("adding handler for F%x\n",
+						fhandler->fn_number);
+				list_add_tail(&fhandler->link,
+						&rmi->support_fn_list);
+			}
+		}
+	}
+
+	rmi4_data->num_of_intr_regs = (intr_count + 7) / 8;
+	dev_dbg(&rmi4_data->i2c_client->dev,
+			"%s: Number of interrupt registers = %d\n",
+			__func__, rmi4_data->num_of_intr_regs);
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			rmi4_data->f01_query_base_addr,
+			f01_query,
+			sizeof(f01_query));
+	if (retval < 0)
+		return retval;
+
+	/* RMI Version 4.0 currently supported */
+	rmi->version_major = 4;
+	rmi->version_minor = 0;
+
+	rmi->manufacturer_id = f01_query[0];
+	rmi->product_props = f01_query[1];
+	memcpy(&rmi->product_info[0], &f01_query[2],
+					SYNAPTICS_RMI4_PRODUCT_INFO_SIZE);
+	memcpy(rmi->serial, &f01_query[4], SYNAPTICS_RMI4_SERIAL_SIZE);
+	memcpy(rmi->product_id_string, &f01_query[11],
+					SYNAPTICS_RMI4_PRODUCT_ID_SIZE);
+	rmi->product_id_string[SYNAPTICS_RMI4_PRODUCT_ID_SIZE] = 0;
+
+	synaptics_dsx_validate_product_string(rmi->product_id_string);
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			rmi4_data->f01_query_base_addr+PACKAGE_ID_OFFSET,
+			rmi->package_id,
+			sizeof(rmi->package_id));
+	if (retval < 0)
+		return retval;
+
+	retval = synaptics_rmi4_i2c_read(rmi4_data,
+			rmi4_data->f01_query_base_addr+FW_VERSION_OFFSET,
+			rmi->build_id,
+			sizeof(rmi->build_id));
+	if (retval < 0)
+		return retval;
+
+	if (rmi->manufacturer_id != 1) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Non-Synaptics device found,"
+			"manufacturer ID = %d\n",
+			__func__, rmi->manufacturer_id);
+	}
+
+	if (!rmi4_data->in_bootloader && !rmi4_data->input_registered) {
+		retval = input_register_device(rmi4_data->input_dev);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to register input device\n",
+				__func__);
+			return retval;
+		}
+		rmi4_data->input_registered = true;
+	}
+
+	memset(rmi4_data->intr_mask, 0x00, sizeof(rmi4_data->intr_mask));
+
+	/*
+	 * Map out the interrupt bit masks for the interrupt sources
+	 * from the registered function handlers.
+	 */
+	list_for_each_entry(fhandler, &rmi->support_fn_list, link)
+		data_sources += fhandler->num_of_data_sources;
+	if (data_sources) {
+		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+			if (fhandler->num_of_data_sources) {
+				rmi4_data->intr_mask[fhandler->intr_reg_num] |=
+						fhandler->intr_mask;
+			}
+		}
+	}
+
+	/* interrupt mask for currently active functions */
+	batohui(&rmi4_data->active_fn_intr_mask,
+			rmi4_data->intr_mask, rmi4_data->num_of_intr_regs);
+	pr_debug("active func intr_mask 0x%x\n",
+			rmi4_data->active_fn_intr_mask);
+
+	if (rmi4_data->in_bootloader)
+		pr_info("Product: %s is in bootloader mode\n",
+			rmi->product_id_string);
+	else {
+		unsigned int config_id, firmware_id;
+
+		batohui(&firmware_id, rmi->build_id, sizeof(rmi->build_id));
+		batohui(&config_id, rmi->config_id, sizeof(config_id));
+		pr_info("Product: %s, firmware id: %x, config id: %08x\n",
+			rmi->product_id_string, firmware_id, config_id);
+		/* has to be called after determining */
+		/* the number of interrupt registers */
+		synaptics_rmi4_scan_f01_reg_info(rmi4_data);
+	}
+
+	return 0;
+}
+
+static void synaptics_rmi4_cleanup(struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_fn *fhandler, *next_list_entry;
+	struct synaptics_rmi4_device_info *rmi;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	list_for_each_entry_safe(fhandler, next_list_entry,
+					&rmi->support_fn_list, link) {
+		if (fhandler->fn_number == SYNAPTICS_RMI4_F1A)
+			synaptics_rmi4_f1a_kfree(fhandler);
+		else
+			kfree(fhandler->data);
+		list_del(&fhandler->link);
+		kfree(fhandler);
+	}
+}
+
+static void synaptics_dsx_release_all(struct synaptics_rmi4_data *rmi4_data)
+{
+	/* reset some TSB global vars like fingers_on_2d after resume
+	 * of reset touch IC
+	 */
+	if (rmi4_data->button_0d_enabled) {
+		tsb_buff_clean_flag = 1;
+		rmi4_data->fingers_on_2d = false;
+	}
+
+	if (rmi4_data->input_dev) {
+		/*
+		 * Enforce touch release event report to work-around
+		 * such event missing while touch IC is off.
+		*/
+#ifdef TYPE_B_PROTOCOL
+		int i;
+		for (i = 0; i < rmi4_data->num_of_fingers; i++) {
+			input_mt_slot(rmi4_data->input_dev, i);
+			input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, false);
+		}
+#else
+		input_mt_sync(rmi4_data->input_dev);
+#endif
+		input_sync(rmi4_data->input_dev);
+	}
+}
+
+static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char *f01_cmd_base_addr)
+{
+	int current_state, retval;
+	bool need_to_query = false;
+
+	current_state = synaptics_dsx_get_state_safe(rmi4_data);
+	if (current_state == STATE_UNKNOWN) {
+		synaptics_rmi4_cleanup(rmi4_data);
+		need_to_query = true;
+	}
+
+	retval = synaptics_dsx_ic_reset(rmi4_data, RMI4_HW_RESET);
+	if (retval > 0)
+		pr_debug("successful reset took %dms\n", retval);
+	else
+		dev_warn(&rmi4_data->i2c_client->dev, "%s: timed out waiting for idle\n",
+			__func__);
+
+	if (need_to_query) {
+		if (!rmi4_data->input_dev) {
+			retval = synaptics_dsx_alloc_input(rmi4_data);
+			if (retval < 0) {
+				dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Failed to allocate input device\n",
+					__func__);
+				return retval;
+			}
+		}
+
+		retval = synaptics_rmi4_query_device(rmi4_data);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to query device\n",
+				__func__);
+			return retval;
+		}
+		/* kick off detection work after touch ic changes its mode */
+		if (exp_fn_ctrl.det_workqueue)
+			queue_delayed_work(exp_fn_ctrl.det_workqueue,
+					&exp_fn_ctrl.det_work, 0);
+	}
+
+	return 0;
+}
+
+/**
+* synaptics_rmi4_detection_work()
+*
+* Called by the kernel at the scheduled time.
+*
+* This function is armed by synaptics_new_function call. It checks for
+* the insertion and removal of other expansion Function modules such as
+* rmi_dev and calls their initialization and removal callback functions
+* accordingly.
+*/
+static void synaptics_rmi4_detection_work(struct work_struct *work)
+{
+	struct synaptics_rmi4_exp_fn *exp_fhandler, *next_list_entry;
+	struct synaptics_rmi4_data *rmi4_data;
+	int state;
+
+	mutex_lock(&exp_fn_ctrl_mutex);
+	rmi4_data = exp_fn_ctrl.rmi4_data_ptr;
+	mutex_unlock(&exp_fn_ctrl_mutex);
+
+	if (rmi4_data == NULL) {
+		if (exp_fn_ctrl.det_workqueue)
+			queue_delayed_work(exp_fn_ctrl.det_workqueue,
+				&exp_fn_ctrl.det_work,
+				msecs_to_jiffies(EXP_FN_DET_INTERVAL));
+		return;
+	}
+
+	mutex_lock(&exp_fn_ctrl.list_mutex);
+	if (list_empty(&exp_fn_ctrl.fn_list))
+		goto release_mutex;
+
+	list_for_each_entry_safe(exp_fhandler,
+				next_list_entry,
+				&exp_fn_ctrl.fn_list,
+				link) {
+		if (exp_fhandler->func_init == NULL) {
+			if (exp_fhandler->inserted == true) {
+				exp_fhandler->func_remove(rmi4_data);
+				list_del(&exp_fhandler->link);
+				kfree(exp_fhandler);
+			}
+			continue;
+		}
+
+		if (exp_fhandler->inserted == true)
+			continue;
+
+		if (rmi4_data->in_bootloader &&
+			(exp_fhandler->mode == IC_MODE_UI))
+			continue;
+
+		exp_fhandler->func_init(rmi4_data);
+		state = synaptics_dsx_get_state_safe(rmi4_data);
+		exp_fhandler->inserted = true;
+		if (exp_fhandler->fn_type == RMI_F54) {
+			int error, scan_failures = 0;
+			struct synaptics_rmi4_func_packet_regs *regs;
+
+			regs = find_function(SYNAPTICS_RMI4_F54);
+			if (!regs)
+				continue;
+
+			error = synaptics_rmi4_scan_f54_ctrl_reg_info(regs);
+			if (error) {
+				regs->nr_regs = 0;
+				pr_err("F54_Ctrl scan failed\n");
+			}
+
+			regs = find_function(SYNAPTICS_RMI4_F54 | COMMAND_TYPE);
+			error = synaptics_rmi4_scan_f54_cmd_reg_info(regs);
+			if (error) {
+				regs->nr_regs = 0;
+				pr_err("F54_Cmd scan failed\n");
+			}
+
+			regs = find_function(SYNAPTICS_RMI4_F54 | DATA_TYPE);
+			error = synaptics_rmi4_scan_f54_data_reg_info(regs);
+			if (error) {
+				regs->nr_regs = 0;
+				pr_err("F54_Data scan failed\n");
+				scan_failures++;
+			}
+
+			regs = find_function(SYNAPTICS_RMI4_F54 | QUERY_TYPE);
+			error = synaptics_rmi4_scan_f54_query_reg_info(regs);
+			if (error) {
+				regs->nr_regs = 0;
+				pr_err("F54_Query scan failed\n");
+				scan_failures++;
+			}
+
+			if (!scan_failures)
+				statistics_init(rmi4_data);
+		}
+	}
+
+release_mutex:
+	mutex_unlock(&exp_fn_ctrl.list_mutex);
+
+	return;
+}
+
+/**
+* synaptics_rmi4_new_function()
+*
+* Called by other expansion Function modules in their module init and
+* module exit functions.
+*
+* This function is used by other expansion Function modules such as
+* rmi_dev to register themselves with the driver by providing their
+* initialization and removal callback function pointers so that they
+* can be inserted or removed dynamically at module init and exit times,
+* respectively.
+*/
+void synaptics_rmi4_new_function(enum exp_fn fn_type, bool insert,
+		int (*func_init)(struct synaptics_rmi4_data *rmi4_data),
+		void (*func_remove)(struct synaptics_rmi4_data *rmi4_data),
+		void (*func_attn)(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char intr_mask), enum ic_modes mode)
+{
+	struct synaptics_rmi4_exp_fn *exp_fhandler;
+
+	mutex_lock(&exp_fn_ctrl_mutex);
+	if (!exp_fn_ctrl.inited) {
+		mutex_init(&exp_fn_ctrl.list_mutex);
+		INIT_LIST_HEAD(&exp_fn_ctrl.fn_list);
+		exp_fn_ctrl.det_workqueue =
+			create_singlethread_workqueue("rmi_det_workqueue");
+		if (IS_ERR_OR_NULL(exp_fn_ctrl.det_workqueue))
+			pr_err("unable to create a workqueue\n");
+		INIT_DELAYED_WORK(&exp_fn_ctrl.det_work,
+			synaptics_rmi4_detection_work);
+		exp_fn_ctrl.inited = true;
+	}
+	mutex_unlock(&exp_fn_ctrl_mutex);
+
+	mutex_lock(&exp_fn_ctrl.list_mutex);
+	if (insert) {
+		exp_fhandler = kzalloc(sizeof(*exp_fhandler), GFP_KERNEL);
+		if (!exp_fhandler) {
+			pr_err("failed to alloc mem for expansion function\n");
+			goto exit;
+		}
+		exp_fhandler->fn_type = fn_type;
+		exp_fhandler->func_init = func_init;
+		exp_fhandler->func_attn = func_attn;
+		exp_fhandler->func_remove = func_remove;
+		exp_fhandler->inserted = false;
+		exp_fhandler->mode = mode;
+		list_add_tail(&exp_fhandler->link, &exp_fn_ctrl.fn_list);
+	} else {
+		list_for_each_entry(exp_fhandler, &exp_fn_ctrl.fn_list, link) {
+			if (exp_fhandler->func_init == func_init) {
+				exp_fhandler->inserted = false;
+				exp_fhandler->func_init = NULL;
+				exp_fhandler->func_attn = NULL;
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	mutex_unlock(&exp_fn_ctrl.list_mutex);
+	if (exp_fn_ctrl.det_workqueue)
+		queue_delayed_work(exp_fn_ctrl.det_workqueue,
+					&exp_fn_ctrl.det_work, 0);
+	return;
+}
+EXPORT_SYMBOL(synaptics_rmi4_new_function);
+
+static void synaptics_dsx_free_patch(struct synaptics_dsx_patch *patch)
+{
+	struct synaptics_dsx_func_patch *fp;
+	list_for_each_entry(fp, &patch->cfg_head, link)
+		kfree(fp->data);
+	kfree(patch);
+}
+
+static struct synaptics_dsx_patch *synaptics_dsx_init_patch(const char *name)
+{
+	struct synaptics_dsx_patch *patch;
+	patch = kzalloc(sizeof(struct synaptics_dsx_patch), GFP_KERNEL);
+	if (patch) {
+		patch->name = name;
+		INIT_LIST_HEAD(&patch->cfg_head);
+	}
+	return patch;
+}
+
+static int synaptics_dsx_init_mode(struct synaptics_rmi4_data *data,
+		struct synaptics_dsx_patchset **pmode)
+{
+	int i;
+	struct synaptics_dsx_patchset *mode = *pmode =
+		kzalloc(sizeof(struct synaptics_dsx_patchset), GFP_KERNEL);
+	if (!mode)
+		return -ENOMEM;
+
+	mode->patch_num = MAX_NUM_STATES;
+	for (i = 0; i < mode->patch_num; i++) {
+		struct synaptics_dsx_patch *patch;
+		patch = synaptics_dsx_init_patch("dts");
+		if (!patch) {
+			kfree(mode);
+			return -ENOMEM;
+		}
+		mode->patch_data[i] = patch;
+	}
+	return 0;
+}
+
+static int synaptics_dsx_free_modes(struct synaptics_rmi4_data *data)
+{
+	int m, i;
+	struct synaptics_dsx_patchset *mode;
+
+	for (m = 0; m < 2; m++) {
+		switch (m) {
+		case 0:
+			mode = data->default_mode;
+			break;
+		case 1:
+			/* If alt mode was not present, and set to default
+			 * mode, don't double free it.
+			 */
+			if (data->default_mode == data->alternate_mode)
+				continue;
+			mode = data->alternate_mode;
+			break;
+		}
+		if (!mode)
+			continue;
+		for (i = 0; i < mode->patch_num; i++) {
+			struct synaptics_dsx_patch *patch = mode->patch_data[i];
+			synaptics_dsx_free_patch(patch);
+		}
+		kfree(mode);
+	}
+	data->current_mode = NULL;
+	data->default_mode = NULL;
+	data->alternate_mode = NULL;
+	return 0;
+}
+
+static void synaptics_dsx_queued_resume(struct work_struct *w)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+		container_of(w, struct synaptics_rmi4_data, resume_work);
+	synaptics_rmi4_resume(&(rmi4_data->i2c_client->dev));
+}
+
+static inline int synaptics_dsx_display_off(struct device *dev)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	cancel_work_sync(&rmi4_data->resume_work);
+	return synaptics_rmi4_suspend(dev);
+}
+
+static inline int synaptics_dsx_display_on(struct device *dev)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	pr_debug("queue resume\n");
+	queue_work(system_wq, &rmi4_data->resume_work);
+	return 0;
+}
+
+static int rmi_reboot(struct notifier_block *nb,
+			unsigned long event,
+			void *unused)
+{
+	struct synaptics_rmi4_data *rmi4_data =
+		container_of(nb, struct synaptics_rmi4_data, rmi_reboot);
+	const struct synaptics_dsx_platform_data *platform_data =
+			rmi4_data->board;
+#if defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+	mmi_panel_unregister_notifier(&rmi4_data->panel_nb);
+#elif defined(CONFIG_FB)
+	fb_unregister_client(&rmi4_data->panel_nb);
+#endif
+	if (platform_data->regulator_en) {
+		pr_debug("touch reboot - disable regulators\n");
+		regulator_force_disable(rmi4_data->regulator);
+		regulator_put(rmi4_data->regulator);
+		msleep(1000);
+	}
+
+	return NOTIFY_DONE;
+}
+
+#if defined(USB_CHARGER_DETECTION)
+/***************************************************************/
+/* USB charging source info from power_supply driver directly  */
+/***************************************************************/
+static enum power_supply_property ps_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static const char * const ps_usb_supply[] = { "usb", };
+static bool ps_usb_present;
+static unsigned char ps_data[2] = { 0x20, 0 };
+static struct synaptics_dsx_func_patch ps_active = {
+	.func = 1,
+	.regstr = 0,
+	.subpkt = 0,
+	.size = 1,
+	.bitmask = 0x20,
+	.data = &ps_data[0],
+};
+static struct synaptics_dsx_func_patch ps_set = {
+	.func = 1,
+	.regstr = 0,
+	.subpkt = 0,
+	.size = 1,
+	.bitmask = 0x20,
+	.data = &ps_data[0],
+};
+static struct synaptics_dsx_func_patch ps_clear = {
+	.func = 1,
+	.regstr = 0,
+	.subpkt = 0,
+	.size = 1,
+	.bitmask = 0x20,
+	.data = &ps_data[1],
+};
+static int ps_get_property(struct power_supply *psy,
+	enum power_supply_property psp, union power_supply_propval *val)
+{
+	val->intval = 0;
+	return 0;
+}
+static struct synaptics_dsx_patch ps_patch[] = {
+	{
+		.name = "ps_clear",
+		.cfg_num = 1,
+	},
+	{
+		.name = "ps_set",
+		.cfg_num = 1,
+	},
+};
+
+static void ps_external_power_changed(struct power_supply *psy)
+{
+	struct power_supply *usb_psy = power_supply_get_by_name("usb");
+	union power_supply_propval pval = {0};
+	struct synaptics_rmi4_data *rmi4_data = container_of(psy,
+				struct synaptics_rmi4_data, psy);
+	struct device *dev = &rmi4_data->i2c_client->dev;
+
+	if (!usb_psy || !usb_psy->get_property)
+		return;
+
+	usb_psy->get_property(usb_psy, POWER_SUPPLY_PROP_PRESENT, &pval);
+	dev_dbg(dev, "external_power_changed: %d\n", pval.intval);
+
+	if (ps_usb_present != (pval.intval == 1)) {
+		int index = !!pval.intval;
+		struct synaptics_dsx_patch *patch_ptr =
+				rmi4_data->default_mode->patch_data[ACTIVE_IDX];
+		if (index == 1) {
+			list_add_tail(&ps_active.link, &patch_ptr->cfg_head);
+			patch_ptr->cfg_num++;
+		} else {
+			list_del(&ps_active.link);
+			patch_ptr->cfg_num--;
+		}
+		synaptics_dsx_patch_func(rmi4_data,
+				SYNAPTICS_RMI4_F01, &ps_patch[index]);
+		dev_info(dev, "power supply presence %d\n", pval.intval);
+	}
+	ps_usb_present = pval.intval == 1;
+}
+
+#define ps_notifier_unregister(r) power_supply_unregister(&r->psy)
+
+static int ps_notifier_register(struct synaptics_rmi4_data *rmi4_data)
+{
+	int error;
+	struct device *dev = &rmi4_data->i2c_client->dev;
+
+	rmi4_data->psy.num_supplies = 1;
+	rmi4_data->psy.supplied_from = ((char **) ps_usb_supply);
+	rmi4_data->psy.name = "synaptics-psy";
+	rmi4_data->psy.type = POWER_SUPPLY_TYPE_UNKNOWN;
+	rmi4_data->psy.properties = ps_props;
+	rmi4_data->psy.num_properties = ARRAY_SIZE(ps_props);
+	rmi4_data->psy.get_property = ps_get_property;
+	rmi4_data->psy.external_power_changed = ps_external_power_changed;
+
+	INIT_LIST_HEAD(&ps_patch[0].cfg_head);
+	list_add_tail(&ps_clear.link, &ps_patch[0].cfg_head);
+
+	INIT_LIST_HEAD(&ps_patch[1].cfg_head);
+	list_add_tail(&ps_set.link, &ps_patch[1].cfg_head);
+
+	error = power_supply_register(dev, &rmi4_data->psy);
+	if (error < 0) {
+		dev_err(dev, "power_supply_register failed rc=%d\n", error);
+		return error;
+	}
+	return 0;
+}
+#else
+#define ps_notifier_register(r)
+#define ps_notifier_unregister(r)
+#endif
+
+ /**
+ * synaptics_rmi4_probe()
+ *
+ * Called by the kernel when an association with an I2C device of the
+ * same name is made (after doing i2c_add_driver).
+ *
+ * This funtion allocates and initializes the resources for the driver
+ * as an input driver, turns on the power to the sensor, queries the
+ * sensor for its supported Functions and characteristics, registers
+ * the driver to the input subsystem, sets up the interrupt, and creates
+ * a work queue for detection of other expansion Function modules.
+ */
+static int synaptics_rmi4_probe(struct i2c_client *client,
+		const struct i2c_device_id *dev_id)
+{
+	int retval;
+	struct pinctrl *pinctrl;
+	unsigned char attr_count;
+	struct synaptics_rmi4_data *rmi4_data;
+	struct synaptics_rmi4_device_info *rmi;
+	struct synaptics_dsx_platform_data *platform_data;
+
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev,
+				"%s: SMBus byte data not supported\n",
+				__func__);
+		return -EIO;
+	}
+
+	rmi4_data = kzalloc(sizeof(*rmi4_data), GFP_KERNEL);
+	if (!rmi4_data) {
+		dev_err(&client->dev,
+				"%s: Failed to alloc mem for rmi4_data\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	/* assign pointer to client structure right away for further use */
+	rmi4_data->i2c_client = client;
+
+	retval = synaptics_dsx_init_mode(rmi4_data, &rmi4_data->default_mode);
+	if (retval) {
+		dev_err(&client->dev, "%s: Failed to alloc dflt mode mem\n",
+				__func__);
+		return retval;
+	}
+
+	retval = synaptics_dsx_init_mode(rmi4_data, &rmi4_data->alternate_mode);
+	if (retval) {
+		dev_err(&client->dev, "%s: Failed to alloc alt mode mem\n",
+				__func__);
+		return retval;
+	}
+
+	if (client->dev.of_node)
+		platform_data = synaptics_dsx_of_init(client, rmi4_data);
+	else
+		platform_data = client->dev.platform_data;
+
+	if (!platform_data) {
+		dev_err(&client->dev,
+				"%s: No platform data found\n",
+				__func__);
+		kfree(rmi4_data);
+		return -EINVAL;
+	}
+
+	rmi4_data->current_mode = rmi4_data->default_mode;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	rmi4_data->current_page = MASK_8BIT;
+	rmi4_data->board = platform_data;
+	rmi4_data->irq_enabled = false;
+	atomic_set(&rmi4_data->touch_stopped, 1);
+	rmi4_data->ic_on = true;
+	rmi4_data->flash_enabled = false;
+	rmi4_data->f12_data_registers_ptr =
+				find_function(SYNAPTICS_RMI4_F12 | DATA_TYPE);
+	rmi4_data->i2c_read = synaptics_rmi4_i2c_read;
+	rmi4_data->i2c_write = synaptics_rmi4_i2c_write;
+	rmi4_data->set_state = synaptics_dsx_sensor_state;
+	rmi4_data->ready_state = synaptics_dsx_sensor_ready_state;
+	rmi4_data->irq_enable = synaptics_rmi4_irq_enable;
+	rmi4_data->reset_device = synaptics_rmi4_reset_device;
+
+	/* Initialize some resume debug information */
+	rmi4_data->resume_info = kzalloc(
+		sizeof(struct synaptics_rmi4_resume_info) *
+			 MAX_NUMBER_TRACKED_RESUMES,
+		GFP_KERNEL);
+	if (!rmi4_data->resume_info) {
+		dev_err(&client->dev,
+		"%s: Failed to allocate memory for resume information\n",
+				__func__);
+		rmi4_data->number_resumes = 0;
+	} else
+		rmi4_data->number_resumes = MAX_NUMBER_TRACKED_RESUMES;
+	rmi4_data->last_resume = -1;
+
+	/* Initialize some interrupit timing debug information */
+	rmi4_data->irq_info = kzalloc(
+		sizeof(struct synaptics_rmi4_irq_info) *
+			 MAX_NUMBER_TRACKED_IRQS,
+		GFP_KERNEL);
+	if (!rmi4_data->irq_info) {
+		dev_err(&client->dev,
+		"%s: Failed to allocate memory for IRQ debug information\n",
+				__func__);
+		rmi4_data->number_irq = 0;
+	} else
+		rmi4_data->number_irq = MAX_NUMBER_TRACKED_IRQS;
+	rmi4_data->last_irq = -1;
+
+	mutex_init(&(rmi4_data->rmi4_io_ctrl_mutex));
+	mutex_init(&(rmi4_data->state_mutex));
+
+	pinctrl = devm_pinctrl_get_select(&rmi4_data->i2c_client->dev,
+		"active");
+	if (IS_ERR(pinctrl)) {
+		long int error = PTR_ERR(pinctrl);
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: pinctrl failed err %ld\n", __func__, error);
+		goto err_input_device;
+	}
+
+	if (platform_data->gpio_config)
+		retval = platform_data->gpio_config(platform_data, true);
+	else {
+		retval = gpio_request(platform_data->reset_gpio,
+						RESET_GPIO_NAME);
+		if (!retval)
+			retval = gpio_direction_output(
+						platform_data->reset_gpio, 1);
+	}
+	if (retval < 0) {
+		dev_err(&client->dev,
+				"%s: Failed to configure GPIO\n",
+				__func__);
+		goto err_input_device;
+	}
+
+	/* get irq number initialized before calling reset */
+	rmi4_data->irq = gpio_to_irq(platform_data->irq_gpio);
+
+	i2c_set_clientdata(client, rmi4_data);
+
+	retval = synaptics_dsx_alloc_input(rmi4_data);
+	if (retval < 0) {
+		dev_err(&client->dev,
+				"%s: Failed to allocate input device\n",
+				__func__);
+		goto err_free_gpio;
+	}
+
+	rmi4_data->regulator = regulator_get(&client->dev, "touch_vdd");
+	if (IS_ERR(rmi4_data->regulator)) {
+		if (PTR_ERR(rmi4_data->regulator) == -EPROBE_DEFER) {
+			retval = PTR_ERR(rmi4_data->regulator);
+			goto err_regulator_defer;
+		}
+		dev_warn(&client->dev,
+				"%s: Failed to get regulator\n",
+				__func__);
+	} else {
+		int error = regulator_enable(rmi4_data->regulator);
+		if (error) {
+			regulator_put(rmi4_data->regulator);
+			dev_err(&client->dev,
+				"%s: Error %d enabling touch-vdd regulator\n",
+				__func__, error);
+			goto err_regulator_enable;
+		}
+		platform_data->regulator_en = true;
+		pr_debug("touch-vdd regulator is %s\n",
+			regulator_is_enabled(rmi4_data->regulator) ?
+			"on" : "off");
+	}
+
+	rmi4_data->vdd_quirk = devm_regulator_get(&client->dev, "vdd_quirk");
+	if (!IS_ERR(rmi4_data->vdd_quirk)) {
+		retval = regulator_enable(rmi4_data->vdd_quirk);
+		if (retval) {
+			dev_err(&client->dev, "Failed to enable vdd-quirk\n");
+			goto vdd_quirk_error;
+		}
+	} else {
+		retval = PTR_ERR(rmi4_data->regulator);
+		if (retval == -EPROBE_DEFER)
+			goto vdd_quirk_error;
+	}
+
+	retval = synaptics_dsx_ic_reset(rmi4_data, RMI4_HW_RESET);
+	if (retval > 0)
+		pr_debug("successful reset took %dms\n", retval);
+	else
+		dev_warn(&rmi4_data->i2c_client->dev, "%s: timed out waiting for idle\n",
+			__func__);
+
+	retval = synaptics_rmi4_query_device(rmi4_data);
+	if (retval < 0) {
+		dev_err(&client->dev,
+				"%s: Failed to query device\n",
+				__func__);
+		goto err_query_device;
+	}
+
+	init_waitqueue_head(&rmi4_data->wait);
+	INIT_WORK(&rmi4_data->resume_work, synaptics_dsx_queued_resume);
+
+#if defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+	rmi4_data->panel_nb.pre_display_off = synaptics_rmi4_suspend;
+	rmi4_data->panel_nb.display_on = synaptics_rmi4_resume;
+	rmi4_data->panel_nb.dev = &client->dev;
+	if (!mmi_panel_register_notifier(&rmi4_data->panel_nb))
+		pr_info("registered MMI panel notifier\n");
+	else
+		dev_err(&client->dev,
+				"%s: Unable to register MMI notifier\n",
+				__func__);
+#elif defined(CONFIG_FB)
+	rmi4_data->panel_nb.notifier_call = synaptics_dsx_panel_cb;
+	if (!fb_register_client(&rmi4_data->panel_nb))
+		pr_debug("registered FB notifier\n");
+	else
+		dev_err(&client->dev,
+				"%s: Unable to register FB notifier\n",
+				__func__);
+#endif
+	mutex_lock(&exp_fn_ctrl_mutex);
+	if (!exp_fn_ctrl.inited) {
+		mutex_init(&exp_fn_ctrl.list_mutex);
+		INIT_LIST_HEAD(&exp_fn_ctrl.fn_list);
+		exp_fn_ctrl.det_workqueue =
+			create_singlethread_workqueue("rmi_det_workqueue");
+		if (IS_ERR_OR_NULL(exp_fn_ctrl.det_workqueue))
+			pr_err("unable to create a workqueue\n");
+		INIT_DELAYED_WORK(&exp_fn_ctrl.det_work,
+			synaptics_rmi4_detection_work);
+		exp_fn_ctrl.inited = true;
+	}
+	mutex_unlock(&exp_fn_ctrl_mutex);
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(&rmi4_data->i2c_client->dev.kobj,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(&client->dev,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			goto err_sysfs;
+		}
+	}
+
+	synaptics_dsx_sensor_ready_state(rmi4_data, true);
+
+	rmi4_data->rmi_reboot.notifier_call = rmi_reboot;
+	rmi4_data->rmi_reboot.next = NULL;
+	rmi4_data->rmi_reboot.priority = 1;
+	retval = register_reboot_notifier(&rmi4_data->rmi_reboot);
+	if (retval)
+		dev_err(&client->dev, "register for reboot failed\n");
+
+	mutex_lock(&exp_fn_ctrl_mutex);
+	exp_fn_ctrl.rmi4_data_ptr = rmi4_data;
+	mutex_unlock(&exp_fn_ctrl_mutex);
+
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+	/* register notifier at the end of probe to */
+	/* avoid unnecessary reset in STANDBY state */
+	rmi4_data->folio_notif.notifier_call = folio_notifier_callback;
+	dev_dbg(&client->dev, "registering folio notifier\n");
+	retval = mmi_hall_register_notifier(&rmi4_data->folio_notif,
+				MMI_HALL_FOLIO, true);
+	if (retval) {
+		dev_err(&client->dev,
+			"Error registering folio_notifier: %d\n", retval);
+		/* inability to register folio notifications handler */
+		/* is not fatal, thus reset return value to success */
+		retval = 0;
+	}
+#endif
+
+	if (rmi4_data->charger_detection)
+		ps_notifier_register(rmi4_data);
+
+	return retval;
+
+err_sysfs:
+	for (attr_count--; attr_count >= 0; attr_count--) {
+		sysfs_remove_file(&rmi4_data->i2c_client->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+#if defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+	mmi_panel_unregister_notifier(&rmi4_data->panel_nb);
+#elif defined(CONFIG_FB)
+	fb_unregister_client(&rmi4_data->panel_nb);
+#endif
+
+err_query_device:
+	if (rmi4_data->input_registered) {
+		input_unregister_device(rmi4_data->input_dev);
+		rmi4_data->input_dev = NULL;
+	}
+
+	if (!IS_ERR(rmi4_data->vdd_quirk))
+		regulator_disable(rmi4_data->vdd_quirk);
+
+vdd_quirk_error:
+	if (platform_data->regulator_en) {
+		regulator_disable(rmi4_data->regulator);
+		regulator_put(rmi4_data->regulator);
+	}
+
+err_regulator_enable:
+	synaptics_rmi4_cleanup(rmi4_data);
+
+err_regulator_defer:
+	input_free_device(rmi4_data->input_dev);
+err_free_gpio:
+	if (platform_data->gpio_config)
+		gpio_free(platform_data->irq_gpio);
+	gpio_set_value(platform_data->reset_gpio, 0);
+	gpio_free(platform_data->reset_gpio);
+err_input_device:
+	synaptics_dsx_free_modes(rmi4_data);
+	if (rmi4_data->charger_detection)
+		ps_notifier_unregister(rmi4_data);
+	kfree(rmi4_data);
+
+	return retval;
+}
+
+ /**
+ * synaptics_rmi4_remove()
+ *
+ * Called by the kernel when the association with an I2C device of the
+ * same name is broken (when the driver is unloaded).
+ *
+ * This funtion terminates the work queue, stops sensor data acquisition,
+ * frees the interrupt, unregisters the driver from the input subsystem,
+ * turns off the power to the sensor, and frees other allocated resources.
+ */
+static int synaptics_rmi4_remove(struct i2c_client *client)
+{
+	unsigned char attr_count;
+	struct synaptics_rmi4_data *rmi4_data = i2c_get_clientdata(client);
+	struct synaptics_rmi4_device_info *rmi;
+	const struct synaptics_dsx_platform_data *platform_data =
+			rmi4_data->board;
+
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	if (exp_fn_ctrl.inited) {
+		cancel_delayed_work_sync(&exp_fn_ctrl.det_work);
+		flush_workqueue(exp_fn_ctrl.det_workqueue);
+		destroy_workqueue(exp_fn_ctrl.det_workqueue);
+	}
+
+	atomic_set(&rmi4_data->touch_stopped, 1);
+	wake_up(&rmi4_data->wait);
+
+	synaptics_rmi4_irq_enable(rmi4_data, false);
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		sysfs_remove_file(&rmi4_data->i2c_client->dev.kobj,
+				&attrs[attr_count].attr);
+	}
+
+	if (rmi4_data->input_registered) {
+		input_unregister_device(rmi4_data->input_dev);
+		rmi4_data->input_dev = NULL;
+	}
+
+	if (!IS_ERR(rmi4_data->vdd_quirk))
+		regulator_disable(rmi4_data->vdd_quirk);
+
+	if (platform_data->regulator_en) {
+		regulator_disable(rmi4_data->regulator);
+		regulator_put(rmi4_data->regulator);
+	}
+
+#if defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+	mmi_panel_unregister_notifier(&rmi4_data->panel_nb);
+#elif defined(CONFIG_FB)
+	fb_unregister_client(&rmi4_data->panel_nb);
+#endif
+	synaptics_rmi4_cleanup(rmi4_data);
+	synaptics_dsx_free_modes(rmi4_data);
+	if (rmi4_data->charger_detection)
+		ps_notifier_unregister(rmi4_data);
+	kfree(rmi4_data);
+
+	return 0;
+}
+
+#if defined(CONFIG_FB) && !defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+static int synaptics_dsx_panel_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	struct synaptics_rmi4_data *rmi4_data =
+		container_of(nb, struct synaptics_rmi4_data, panel_nb);
+
+	if ((event == FB_EARLY_EVENT_BLANK || event == FB_EVENT_BLANK) &&
+			evdata && evdata->info && evdata->info->node == 0 &&
+			evdata->data && rmi4_data) {
+		int *blank = evdata->data;
+		pr_debug("fb notification: event = %lu blank = %d\n", event, *blank);
+		/* entering suspend upon early blank event */
+		/* to ensure shared power supply is still on */
+		/* for in-cell design touch solutions */
+		if (event == FB_EARLY_EVENT_BLANK) {
+			if (*blank != FB_BLANK_POWERDOWN)
+				return 0;
+			synaptics_dsx_display_off(&rmi4_data->i2c_client->dev);
+		} else if (*blank == FB_BLANK_UNBLANK ||
+			(*blank == FB_BLANK_VSYNC_SUSPEND &&
+			atomic_read(&rmi4_data->touch_stopped))) {
+			synaptics_dsx_display_on(&rmi4_data->i2c_client->dev);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+static int folio_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	int state, folio_state = *(int *)data;
+	struct synaptics_rmi4_data *rmi4_data =
+		container_of(self, struct synaptics_rmi4_data, folio_notif);
+
+	if (rmi4_data && event == MMI_HALL_FOLIO &&
+			rmi4_data && rmi4_data->i2c_client) {
+
+		state = synaptics_dsx_get_state_safe(rmi4_data);
+		dev_dbg(&rmi4_data->i2c_client->dev,
+			"state: %s(%d), suspend flag: %d, BL flag: %d\n",
+			synaptics_dsx_state_name(state), state,
+			atomic_read(&rmi4_data->touch_stopped),
+			rmi4_data->in_bootloader);
+		if (folio_state)
+			/* close */
+			synaptics_dsx_set_alternate_mode(rmi4_data,
+				rmi4_data->alternate_mode, false, true);
+		else	/* open */
+			synaptics_dsx_restore_default_mode(rmi4_data);
+
+		dev_info(&rmi4_data->i2c_client->dev, "folio: %s\n",
+			folio_state ? "CLOSED" : "OPENED");
+
+		if (!(state & STATE_UI)) {
+			dev_dbg(&rmi4_data->i2c_client->dev, "Not in UI\n");
+			goto done;
+		}
+
+		if (!rmi4_data->in_bootloader) {
+			if (state == STATE_ACTIVE) {
+				int retval;
+				/* set unknown state to ensure IRQ gets */
+				/* enabled on state transition to active */
+				synaptics_dsx_sensor_state(
+						rmi4_data, STATE_UNKNOWN);
+				/* disable IRQ to handle reset */
+				synaptics_rmi4_irq_enable(rmi4_data, false);
+				/* perform SW reset to restore defaults */
+				retval = synaptics_dsx_ic_reset(
+						rmi4_data, RMI4_SW_RESET);
+				if (retval < 0)
+					dev_err(&rmi4_data->i2c_client->dev,
+						"folio: sw reset failed %d\n",
+						retval);
+				synaptics_dsx_sensor_ready_state(
+							rmi4_data, false);
+			}
+
+			synaptics_dsx_state_config(rmi4_data,
+					(state == STATE_SUSPEND) ?
+					SUSPEND_IDX : ACTIVE_IDX);
+		}
+	}
+done:
+	return 0;
+}
+#endif
+
+static void synaptics_dsx_resumeinfo_start(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_resume_info *tmp;
+
+	if (rmi4_data->number_resumes > 0) {
+		rmi4_data->last_resume++;
+		if (rmi4_data->last_resume >= rmi4_data->number_resumes)
+			rmi4_data->last_resume = 0;
+
+		tmp = &(rmi4_data->resume_info[rmi4_data->last_resume]);
+		getnstimeofday(&(tmp->start));
+		tmp->ignored_events = 0;
+		tmp->isr.tv_sec = 0;
+		tmp->isr.tv_nsec = 0;
+		tmp->send_touch.tv_sec = 0;
+		tmp->send_touch.tv_nsec = 0;
+		tmp->purge_off.tv_sec = 0;
+		tmp->purge_off.tv_nsec = 0;
+	}
+}
+
+static void synaptics_dsx_resumeinfo_finish(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_resume_info *tmp;
+
+	if (rmi4_data->number_resumes > 0 && rmi4_data->last_resume >= 0) {
+		tmp = &(rmi4_data->resume_info[rmi4_data->last_resume]);
+		getnstimeofday(&(tmp->finish));
+	}
+}
+
+static void synaptics_dsx_resumeinfo_isr(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_resume_info *tmp;
+
+	if (rmi4_data->number_resumes > 0 && rmi4_data->last_resume >= 0) {
+		tmp = &(rmi4_data->resume_info[rmi4_data->last_resume]);
+		if (tmp->isr.tv_sec == 0)
+			getnstimeofday(&(tmp->isr));
+	}
+}
+
+static void synaptics_dsx_resumeinfo_purgeoff(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_resume_info *tmp;
+
+	if (rmi4_data->number_resumes > 0 && rmi4_data->last_resume >= 0) {
+		tmp = &(rmi4_data->resume_info[rmi4_data->last_resume]);
+
+		if (tmp->purge_off.tv_sec == 0)
+			getnstimeofday(&(tmp->purge_off));
+	}
+}
+
+static void synaptics_dsx_resumeinfo_ignore(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_resume_info *tmp;
+
+	if (rmi4_data->number_resumes > 0 && rmi4_data->last_resume >= 0) {
+		tmp = &(rmi4_data->resume_info[rmi4_data->last_resume]);
+
+		tmp->ignored_events++;
+	}
+}
+
+static void synaptics_dsx_resumeinfo_touch(
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_resume_info *tmp;
+
+	if (rmi4_data->number_resumes > 0 && rmi4_data->last_resume >= 0) {
+		tmp = &(rmi4_data->resume_info[rmi4_data->last_resume]);
+
+		if (tmp->send_touch.tv_sec == 0)
+			getnstimeofday(&(tmp->send_touch));
+	}
+}
+ /**
+ * synaptics_rmi4_suspend()
+ *
+ * Called by the kernel during the suspend phase when the system
+ * enters suspend.
+ *
+ * This function stops finger data acquisition and puts the sensor to
+ * sleep, disables the interrupt, and turns off the power to the sensor.
+ */
+static int synaptics_rmi4_suspend(struct device *dev)
+{
+	struct pinctrl *pinctrl;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	const struct synaptics_dsx_platform_data *platform_data =
+			rmi4_data->board;
+
+	if (atomic_cmpxchg(&rmi4_data->touch_stopped, 0, 1) == 1)
+		return 0;
+
+	rmi4_data->flash_enabled = false;
+	synaptics_dsx_sensor_state(rmi4_data, STATE_SUSPEND);
+	synaptics_dsx_release_all(rmi4_data);
+
+	if (gStat.enabled)
+		statistics_stop_timekeeping();
+
+	if (rmi4_data->purge_enabled) {
+		int value = 1; /* set flag */
+		atomic_set(&rmi4_data->panel_off_flag, value);
+		pr_debug("touches purge is %s\n", value ? "ON" : "OFF");
+	}
+
+	if (rmi4_data->ic_on) {
+		/* use pinctrl to put touch RESET GPIO into SUSPEND state */
+		gpio_free(platform_data->reset_gpio);
+		pinctrl = devm_pinctrl_get_select_default(
+			&rmi4_data->i2c_client->dev);
+		if (IS_ERR(pinctrl))
+			dev_err(&rmi4_data->i2c_client->dev,
+				"pinctrl failed err %ld\n", PTR_ERR(pinctrl));
+
+		/* if touch REGULATOR is available - turn it OFF */
+		if (platform_data->regulator_en) {
+			regulator_disable(rmi4_data->regulator);
+			pr_debug("touch-vdd regulator is %s\n",
+				regulator_is_enabled(rmi4_data->regulator) ?
+				"on" : "off");
+		}
+
+		rmi4_data->ic_on = false;
+	}
+
+	return 0;
+}
+
+ /**
+ * synaptics_rmi4_resume()
+ *
+ * Called by the kernel during the resume phase when the system
+ * wakes up from suspend.
+ *
+ * This function turns on the power to the sensor, wakes the sensor
+ * from sleep, enables the interrupt, and starts finger data
+ * acquisition.
+ */
+static int synaptics_rmi4_resume(struct device *dev)
+{
+	int retval;
+	int reset = RMI4_HW_RESET;
+	struct pinctrl *pinctrl;
+	struct synaptics_rmi4_data *rmi4_data =
+					i2c_get_clientdata(to_i2c_client(dev));
+	const struct synaptics_dsx_platform_data *platform_data =
+					rmi4_data->board;
+
+	if (atomic_cmpxchg(&rmi4_data->touch_stopped, 1, 0) == 0)
+		return 0;
+
+	synaptics_dsx_resumeinfo_start(rmi4_data);
+
+	if (!rmi4_data->ic_on) {
+		/* if touch REGULATOR is avaialble - turn it ON */
+		if (platform_data->regulator_en) {
+			int error = regulator_enable(rmi4_data->regulator);
+			if (error) {
+				pr_err("Error %d enabling touch-vdd regulator\n",
+					error);
+				return error;
+			}
+			pr_debug("touch-vdd regulator is %s\n",
+				regulator_is_enabled(rmi4_data->regulator) ?
+				"on" : "off");
+		}
+
+		/* if RESET GPIO is in SUSPEND state - no HW reset */
+		retval = gpio_get_value(platform_data->reset_gpio);
+		pr_debug("reset gpio state: %d\n", retval);
+		if (retval == 0)
+			reset = RMI4_WAIT_READY;
+
+		pinctrl = devm_pinctrl_get_select(&rmi4_data->i2c_client->dev,
+			"active");
+		if (IS_ERR(pinctrl)) {
+			long int error = PTR_ERR(pinctrl);
+			dev_err(&rmi4_data->i2c_client->dev,
+				"pinctrl failed err %ld\n", error);
+		}
+
+		if (gpio_request(platform_data->reset_gpio,
+						RESET_GPIO_NAME) < 0)
+			pr_err("failed to request reset gpio\n");
+
+		gpio_direction_output(platform_data->reset_gpio, 1);
+		rmi4_data->ic_on = true;
+	}
+
+	/* perform HW reset if needed and wait for touch IC boot completion */
+	retval = synaptics_dsx_ic_reset(rmi4_data, reset);
+	if (retval > 0)
+		pr_debug("waited for idle %dms\n", retval);
+	else
+		dev_warn(&rmi4_data->i2c_client->dev, "%s: timed out waiting for idle\n",
+			__func__);
+
+	/* read touch IC state */
+	synaptics_dsx_sensor_ready_state(rmi4_data, false);
+	/* transition to active state is completed - allow flashing */
+	rmi4_data->flash_enabled = true;
+
+	if (rmi4_data->purge_enabled) {
+		int value = 0; /* clear flag */
+		atomic_set(&rmi4_data->panel_off_flag, value);
+		pr_debug("touches purge is %s\n", value ? "ON" : "OFF");
+	}
+
+	if (gStat.enabled)
+		statistics_start_timekeeping(rmi4_data);
+
+	synaptics_dsx_resumeinfo_finish(rmi4_data);
+	return 0;
+}
+
+static const struct dev_pm_ops synaptics_rmi4_dev_pm_ops = {
+	.suspend = synaptics_rmi4_suspend,
+	.resume  = synaptics_rmi4_resume,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id synaptics_rmi4_match_tbl[] = {
+	{ .compatible = "synaptics," DRIVER_NAME },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, synaptics_rmi4_match_tbl);
+#endif
+
+static const struct i2c_device_id synaptics_rmi4_id_table[] = {
+	{DRIVER_NAME, 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, synaptics_rmi4_id_table);
+
+static struct i2c_driver synaptics_rmi4_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+#if !defined(CONFIG_FB) && defined(CONFIG_PM)
+		.pm = &synaptics_rmi4_dev_pm_ops,
+#endif
+	},
+	.probe = synaptics_rmi4_probe,
+	.remove = synaptics_rmi4_remove,
+	.id_table = synaptics_rmi4_id_table,
+};
+
+ /**
+ * synaptics_rmi4_init()
+ *
+ * Called by the kernel during do_initcalls (if built-in)
+ * or when the driver is loaded (if a module).
+ *
+ * This function registers the driver to the I2C subsystem.
+ *
+ */
+static int __init synaptics_rmi4_init(void)
+{
+	return i2c_add_driver(&synaptics_rmi4_driver);
+}
+
+ /**
+ * synaptics_rmi4_exit()
+ *
+ * Called by the kernel when the driver is unloaded.
+ *
+ * This funtion unregisters the driver from the I2C subsystem.
+ *
+ */
+static void __exit synaptics_rmi4_exit(void)
+{
+	i2c_del_driver(&synaptics_rmi4_driver);
+}
+
+module_init(synaptics_rmi4_init);
+module_exit(synaptics_rmi4_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX I2C Touch Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(SYNAPTICS_DSX_DRIVER_VERSION);
diff --git a/drivers/input/touchscreen/synaptics_dsx_i2c.h b/drivers/input/touchscreen/synaptics_dsx_i2c.h
new file mode 100644
index 00000000000..ac6e59f7d92
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx_i2c.h
@@ -0,0 +1,599 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SYNAPTICS_DSX_RMI4_H_
+#define _SYNAPTICS_DSX_RMI4_H_
+
+#define SYNAPTICS_DSX_DRIVER_VERSION "DSX 1.1"
+
+#include <linux/version.h>
+#include <linux/ktime.h>
+#if defined(USB_CHARGER_DETECTION)
+#include <linux/usb.h>
+#include <linux/power_supply.h>
+#endif
+#if defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+#include <linux/mmi_panel_notifier.h>
+#elif defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 38))
+#define KERNEL_ABOVE_2_6_38
+#endif
+
+#ifdef KERNEL_ABOVE_2_6_38
+#define sstrtoul(...) kstrtoul(__VA_ARGS__)
+#else
+#define sstrtoul(...) strict_strtoul(__VA_ARGS__)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 0))
+#define KERNEL_ABOVE_3_7
+#endif
+
+#define PDT_PROPS (0x00EF)
+#define PDT_START (0x00E9)
+#define PDT_END (0x000A)
+#define PDT_ENTRY_SIZE (0x0006)
+#define PAGES_TO_SERVICE (10)
+#define PAGE_SELECT_LEN (2)
+
+#define SYNAPTICS_RMI4_F01 (0x01)
+#define SYNAPTICS_RMI4_F11 (0x11)
+#define SYNAPTICS_RMI4_F12 (0x12)
+#define SYNAPTICS_RMI4_F1A (0x1a)
+#define SYNAPTICS_RMI4_F34 (0x34)
+#define SYNAPTICS_RMI4_F51 (0x51)
+#define SYNAPTICS_RMI4_F54 (0x54)
+#define SYNAPTICS_RMI4_F55 (0x55)
+
+#define SYNAPTICS_RMI4_PRODUCT_INFO_SIZE 2
+#define SYNAPTICS_RMI4_PRODUCT_ID_SIZE 10
+#define SYNAPTICS_RMI4_BUILD_ID_SIZE 3
+#define SYNAPTICS_RMI4_SERIAL_SIZE 7
+#define SYNAPTICS_RMI4_CONFIG_ID_SIZE 4
+#define SYNAPTICS_RMI4_PACKAGE_ID_SIZE 4
+#define SYNAPTICS_RMI4_FILENAME_SIZE 80
+
+#define PACKAGE_ID_OFFSET 17
+#define FW_VERSION_OFFSET 18
+#define F34_PROPERTIES_OFFSET 1
+
+#define MAX_NUMBER_OF_FINGERS 10
+#define MAX_NUMBER_OF_BUTTONS 4
+#define MAX_INTR_REGISTERS 4
+
+#define MASK_16BIT 0xFFFF
+#define MASK_8BIT 0xFF
+#define MASK_7BIT 0x7F
+#define MASK_6BIT 0x3F
+#define MASK_5BIT 0x1F
+#define MASK_4BIT 0x0F
+#define MASK_3BIT 0x07
+#define MASK_2BIT 0x03
+#define MASK_1BIT 0x01
+
+#define MAX_NUMBER_TRACKED_RESUMES 10
+/*
+ * struct synaptics_rmi4_resume_info - information about a resume
+ * @start: time when resume started
+ * @finish: time when resume finished
+ * @isr: time of the first isr after resume
+ * @send_touch: time of the first send touch event after resume
+ * @purge_off: time when events are no longer ignored after resume
+ */
+struct synaptics_rmi4_resume_info {
+	struct timespec start;
+	struct timespec finish;
+	struct timespec isr;
+	struct timespec send_touch;
+	struct timespec purge_off;
+	int    ignored_events;
+};
+#define MAX_NUMBER_TRACKED_IRQS 150
+/*
+ * struct synaptics_rmi4_irq_info - information about an interrupt
+ * Using structure (instead of 1 variable) in case we want to add
+ * more debugging information.
+ * @irq_time: time when isr starts
+ */
+struct synaptics_rmi4_irq_info {
+	struct timespec irq_time;
+};
+/*
+ * struct synaptics_rmi4_fn_desc - function descriptor fields in PDT
+ * @query_base_addr: base address for query registers
+ * @cmd_base_addr: base address for command registers
+ * @ctrl_base_addr: base address for control registers
+ * @data_base_addr: base address for data registers
+ * @intr_src_count: number of interrupt sources
+ * @fn_number: function number
+ */
+struct synaptics_rmi4_fn_desc {
+	unsigned char query_base_addr;
+	unsigned char cmd_base_addr;
+	unsigned char ctrl_base_addr;
+	unsigned char data_base_addr;
+	unsigned char intr_src_count;
+	unsigned char fn_number;
+};
+
+/*
+ * synaptics_rmi4_fn_full_addr - full 16-bit base addresses
+ * @query_base: 16-bit base address for query registers
+ * @cmd_base: 16-bit base address for data registers
+ * @ctrl_base: 16-bit base address for command registers
+ * @data_base: 16-bit base address for control registers
+ */
+struct synaptics_rmi4_fn_full_addr {
+	unsigned short query_base;
+	unsigned short cmd_base;
+	unsigned short ctrl_base;
+	unsigned short data_base;
+};
+
+/*
+ * struct synaptics_rmi4_fn - function handler data structure
+ * @fn_number: function number
+ * @num_of_data_sources: number of data sources
+ * @num_of_data_points: maximum number of fingers supported
+ * @size_of_data_register_block: data register block size
+ * @data1_offset: offset to data1 register from data base address
+ * @intr_reg_num: index to associated interrupt register
+ * @intr_mask: interrupt mask
+ * @full_addr: full 16-bit base addresses of function registers
+ * @link: linked list for function handlers
+ * @data_size: size of private data
+ * @data: pointer to private data
+ */
+struct synaptics_rmi4_fn {
+	unsigned char fn_number;
+	unsigned char num_of_data_sources;
+	unsigned char num_of_data_points;
+	unsigned char size_of_data_register_block;
+	unsigned char data1_offset;
+	unsigned char intr_reg_num;
+	unsigned char intr_mask;
+	struct synaptics_rmi4_fn_full_addr full_addr;
+	struct list_head link;
+	int data_size;
+	void *data;
+};
+
+/*
+ * struct synaptics_rmi4_device_info - device information
+ * @version_major: rmi protocol major version number
+ * @version_minor: rmi protocol minor version number
+ * @manufacturer_id: manufacturer id
+ * @product_props: product properties information
+ * @product_info: product info array
+ * @date_code: device manufacture date
+ * @tester_id: tester id array
+ * @serial_number: device serial number
+ * @product_id_string: device product id
+ * @support_fn_list: linked list for function handlers
+ */
+struct synaptics_rmi4_device_info {
+	unsigned int version_major;
+	unsigned int version_minor;
+	unsigned char manufacturer_id;
+	unsigned char product_props;
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+	unsigned char serial[SYNAPTICS_RMI4_SERIAL_SIZE];
+	unsigned char package_id[SYNAPTICS_RMI4_PACKAGE_ID_SIZE];
+	unsigned char product_id_string[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	unsigned char build_id[SYNAPTICS_RMI4_BUILD_ID_SIZE];
+	unsigned char config_id[SYNAPTICS_RMI4_CONFIG_ID_SIZE];
+	struct list_head support_fn_list;
+};
+
+struct synaptics_dsx_func_patch {
+	unsigned short func;
+	unsigned char regstr;
+	unsigned char subpkt;
+	unsigned char size;
+	unsigned char bitmask;
+	unsigned char *data;
+	struct list_head link;
+};
+
+struct synaptics_dsx_patch {
+	const char *name;
+	int	cfg_num;
+	struct list_head cfg_head;
+};
+
+#define ACTIVE_IDX	0
+#define SUSPEND_IDX	1
+#define MAX_NUM_STATES	2
+
+struct synaptics_dsx_patchset {
+	int	patch_num;
+	struct synaptics_dsx_patch *patch_data[MAX_NUM_STATES];
+};
+
+struct f34_properties {
+	union {
+		struct {
+			unsigned char regmap:1;
+			unsigned char unlocked:1;
+			unsigned char has_config_id:1;
+			unsigned char has_perm_config:1;
+			unsigned char has_bl_config:1;
+			unsigned char has_display_config:1;
+			unsigned char has_blob_config:1;
+			unsigned char reserved:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_control_95n {
+	union {
+		struct {
+			/* byte 0 - flags*/
+			unsigned char c95_filter_bw:3;
+			unsigned char c95_byte0_b3_b6:4;
+			unsigned char c95_disable:1;
+
+			/* bytes 1 - 10 */
+			unsigned char c95_first_burst_length_lsb;
+			unsigned char c95_first_burst_length_msb;
+			unsigned char c95_addl_burst_length_lsb;
+			unsigned char c95_addl_burst_length_msb;
+			unsigned char c95_i_stretch;
+			unsigned char c95_r_stretch;
+			unsigned char c95_noise_control1;
+			unsigned char c95_noise_control2;
+			unsigned char c95_noise_control3;
+			unsigned char c95_noise_control4;
+		} __packed;
+		struct {
+			unsigned char data[11];
+		} __packed;
+	};
+};
+
+enum {
+	STATE_UNKNOWN,
+	STATE_ACTIVE,
+	STATE_SUSPEND,
+	STATE_STANDBY = 4,
+	STATE_BL,
+	STATE_INIT,
+	STATE_FLASH,
+	STATE_QUERY,
+	STATE_INVALID
+};
+
+#define STATE_UI       (STATE_ACTIVE | STATE_SUSPEND)
+
+enum ic_modes {
+	IC_MODE_ANY = 0,
+	IC_MODE_BL,
+	IC_MODE_UI
+};
+
+enum exp_fn {
+	RMI_DEV = 0,
+	RMI_F34,
+	RMI_F54,
+	RMI_FW_UPDATER,
+	RMI_LAST,
+};
+
+static inline ssize_t synaptics_rmi4_show_error(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	dev_warn(dev, "%s Attempted to read from write-only attribute %s\n",
+			__func__, attr->attr.name);
+	return -EPERM;
+}
+
+static inline ssize_t synaptics_rmi4_store_error(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	dev_warn(dev, "%s Attempted to write to read-only attribute %s\n",
+			__func__, attr->attr.name);
+	return -EPERM;
+}
+
+static inline void batohs(unsigned short *dest, unsigned char *src)
+{
+	*dest = src[1] * 0x100 + src[0];
+}
+
+static inline void hstoba(unsigned char *dest, unsigned short src)
+{
+	dest[0] = src % 0x100;
+	dest[1] = src / 0x100;
+}
+
+static inline void batohui(unsigned int *dest, unsigned char *src, size_t size)
+{
+	int si = size;
+	*dest = 0;
+	for (; --si >= 0;)
+		*dest += src[si] << (si << 3);
+}
+
+struct synaptics_rmi4_subpkt {
+	bool present;
+	bool expected;
+	short offset;
+	unsigned int size;
+	void *data;
+};
+
+#define RMI4_SUBPKT(a)\
+	{.present = 0, .expected = 1, .size = sizeof(a), .data = &a}
+#define RMI4_SUBPKT_STATIC(o, a)\
+	{.present = 1, .expected = 1,\
+			.offset = o, .size = sizeof(a), .data = &a}
+
+struct synaptics_rmi4_packet_reg {
+	unsigned short r_number;
+	bool updated;	/* indicate that value in *data has been updated */
+	bool modified;	/* indicate that value in *data has been modified */
+	bool expected;
+	short offset;
+	unsigned int size;
+	unsigned char *data;
+	unsigned char nr_subpkts;
+	struct synaptics_rmi4_subpkt *subpkt;
+};
+
+#define RMI4_NO_REG(r) {\
+	.r_number = r, .offset = -1, .updated = 0, .modified = 0,\
+	.expected = 0, .size = 0, .data = NULL,\
+	.nr_subpkts = 0, .subpkt = NULL}
+#define RMI4_REG(r, s) {\
+	.r_number = r, .offset = -1, .updated = 0, .modified = 0,\
+	.expected = 1, .size = 0, .data = NULL,\
+	.nr_subpkts = ARRAY_SIZE(s), .subpkt = s}
+#define RMI4_REG_STATIC(r, s, sz) {\
+	.r_number = r, .offset = r, .updated = 0, .modified = 0,\
+	.expected = 1, .size = sz, .data = NULL,\
+	.nr_subpkts = ARRAY_SIZE(s), .subpkt = s}
+
+struct synaptics_rmi4_func_packet_regs {
+	unsigned short f_number;
+	unsigned short base_addr;
+	unsigned short query_offset;
+	int nr_regs;
+	struct synaptics_rmi4_packet_reg *regs;
+};
+
+/*
+ * struct synaptics_rmi4_data - rmi4 device instance data
+ * @i2c_client: pointer to associated i2c client
+ * @input_dev: pointer to associated input device
+ * @board: constant pointer to platform data
+ * @rmi4_mod_info: device information
+ * @regulator: pointer to associated regulator
+ * @vdd_quirk: pointer to associated regulator for 'quirk' config
+ * @rmi4_io_ctrl_mutex: mutex for i2c i/o control
+ * @det_work: work thread instance for expansion function detection
+ * @det_workqueue: pointer to work queue for work thread instance
+ * @early_suspend: instance to support early suspend power management
+ * @current_page: current page in sensor to acess
+ * @button_0d_enabled: flag for 0d button support
+ * @full_pm_cycle: flag for full power management cycle in early suspend stage
+ * @num_of_intr_regs: number of interrupt registers
+ * @f01_query_base_addr: query base address for f01
+ * @f01_cmd_base_addr: command base address for f01
+ * @f01_ctrl_base_addr: control base address for f01
+ * @f01_data_base_addr: data base address for f01
+ * @irq: attention interrupt
+ * @sensor_max_x: sensor maximum x value
+ * @sensor_max_y: sensor maximum y value
+ * @irq_enabled: flag for indicating interrupt enable status
+ * @touch_stopped: touch is in suspend state
+ * @flash_enabled: allow flashing once transition to active state is complete
+ * @ic_on: touch ic power state
+ * @fingers_on_2d: flag to indicate presence of fingers in 2d area
+ * @wait: wait queue for touch data polling in interrupt thread
+ * @number_resumes: total number of remembered resumes
+ * @last_resume: last resume's number (index of the location of resume)
+ * @resume_info:  information about last few resumes
+ * @number_irq: total number of remembered interrupt times
+ * @last_irq: last interrup time's number (index of the location of interrupt)
+ * @irq_info:  information about last few interrupt times
+ * @i2c_read: pointer to i2c read function
+ * @i2c_write: pointer to i2c write function
+ * @irq_enable: pointer to irq enable function
+ */
+struct synaptics_rmi4_data {
+	struct i2c_client *i2c_client;
+	struct input_dev *input_dev;
+	const struct synaptics_dsx_platform_data *board;
+	struct synaptics_rmi4_device_info rmi4_mod_info;
+	struct regulator *regulator;
+	struct regulator *vdd_quirk;
+	struct mutex rmi4_io_ctrl_mutex;
+	struct mutex state_mutex;
+#if defined(CONFIG_MMI_PANEL_NOTIFICATIONS)
+	struct mmi_notifier panel_nb;
+#elif defined(CONFIG_FB)
+	struct notifier_block panel_nb;
+#endif
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+	struct notifier_block folio_notif;
+#endif
+	atomic_t panel_off_flag;
+	unsigned char current_page;
+	unsigned char button_0d_enabled;
+	unsigned char num_of_rx;
+	unsigned char num_of_tx;
+	unsigned char num_of_fingers;
+	unsigned char f01_ctrl_register_0;
+	unsigned char intr_mask[MAX_INTR_REGISTERS];
+	unsigned short num_of_intr_regs;
+	unsigned short f01_query_base_addr;
+	unsigned short f01_cmd_base_addr;
+	unsigned short f01_ctrl_base_addr;
+	unsigned short f01_data_base_addr;
+	unsigned int active_fn_intr_mask;
+	int state;
+	int irq;
+	int sensor_max_x;
+	int sensor_max_y;
+	bool irq_enabled;
+	atomic_t touch_stopped;
+	bool flash_enabled;
+	bool ic_on;
+	bool fingers_on_2d;
+	bool input_registered;
+	bool in_bootloader;
+	bool purge_enabled;
+	bool charger_detection;
+	wait_queue_head_t wait;
+	int (*i2c_read)(struct synaptics_rmi4_data *pdata, unsigned short addr,
+			unsigned char *data, unsigned short length);
+	int (*i2c_write)(struct synaptics_rmi4_data *pdata, unsigned short addr,
+			unsigned char *data, unsigned short length);
+	void (*set_state)(struct synaptics_rmi4_data *rmi4_data, int state);
+	int (*ready_state)(struct synaptics_rmi4_data *rmi4_data, bool standby);
+	int (*irq_enable)(struct synaptics_rmi4_data *rmi4_data, bool enable);
+	int (*reset_device)(struct synaptics_rmi4_data *rmi4_data,
+			unsigned char *f01_cmd_base_addr);
+	int number_resumes;
+	int last_resume;
+	struct synaptics_rmi4_resume_info *resume_info;
+	int number_irq;
+	int last_irq;
+	struct synaptics_rmi4_irq_info *irq_info;
+
+	bool mode_is_wakeable;
+	bool mode_is_persistent;
+
+	bool patching_enabled;
+	struct synaptics_dsx_patchset *default_mode;
+	struct synaptics_dsx_patchset *alternate_mode;
+	struct synaptics_dsx_patchset *current_mode;
+
+	struct work_struct resume_work;
+
+	struct synaptics_rmi4_func_packet_regs *f12_data_registers_ptr;
+	struct notifier_block rmi_reboot;
+#if defined(USB_CHARGER_DETECTION)
+	struct power_supply psy;
+#endif
+};
+
+struct time_keeping {
+	int id;
+	unsigned long long duration;
+} __packed;
+
+struct statistics {
+	int		active;	/* current index within keeper array */
+	int		max;	/* keeper array dimension */
+	bool		clk_run;/* flag to indicate whether clock is ticking */
+	unsigned int	flags;	/* time keeping flags */
+	unsigned char	abbr;	/* abbreviation letter */
+	ktime_t		start;	/* time notch */
+	struct time_keeping keeper[0];
+} __packed;
+
+enum {
+	FREQ_DURATION,		/* scanning frequencies duration */
+	FREQ_HOPPING,		/* scanning frequencies hopping */
+	MODE_NMS,		/* noise mitigation mode */
+	MODE_METAL_PLATE,	/* metal plate detection */
+	STATISTICS_MAX
+};
+
+struct synaptics_dsx_stats {
+	bool enabled;
+	ktime_t	uptime;
+	bool uptime_run;
+	unsigned long long uptime_dur;
+	struct statistics *stats[STATISTICS_MAX];
+#define dur stats[FREQ_DURATION]
+#define hop stats[FREQ_HOPPING]
+#define nms stats[MODE_NMS]
+#define mpd stats[MODE_METAL_PLATE]
+} __packed;
+
+struct synaptics_rmi4_exp_fn_ptr {
+	int (*read)(struct synaptics_rmi4_data *rmi4_data, unsigned short addr,
+			unsigned char *data, unsigned short length);
+	int (*write)(struct synaptics_rmi4_data *rmi4_data, unsigned short addr,
+			unsigned char *data, unsigned short length);
+	int (*enable)(struct synaptics_rmi4_data *rmi4_data, bool enable);
+};
+
+void synaptics_rmi4_new_function(enum exp_fn fn_type, bool insert,
+		int (*func_init)(struct synaptics_rmi4_data *rmi4_data),
+		void (*func_remove)(struct synaptics_rmi4_data *rmi4_data),
+		void (*func_attn)(struct synaptics_rmi4_data *rmi4_data,
+				unsigned char intr_mask),
+		enum ic_modes mode);
+
+int synaptics_rmi4_scan_packet_reg_info(
+	struct synaptics_rmi4_data *rmi4_data,
+	unsigned short query_addr,
+	unsigned short regs_base_addr,
+	struct synaptics_rmi4_func_packet_regs *regs);
+
+int synaptics_rmi4_read_packet_reg(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_rmi4_func_packet_regs *regs, int idx);
+
+int synaptics_rmi4_read_packet_regs(
+	struct synaptics_rmi4_data *rmi4_data,
+	struct synaptics_rmi4_func_packet_regs *regs);
+
+#if defined(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING)
+int synaptics_rmi4_scan_f54_ctrl_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs);
+
+int synaptics_rmi4_scan_f54_cmd_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs);
+
+int synaptics_rmi4_scan_f54_data_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs);
+
+int synaptics_rmi4_scan_f54_query_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs);
+#else
+static inline int synaptics_rmi4_scan_f54_ctrl_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs) {
+	return -ENOSYS;
+}
+
+static inline int synaptics_rmi4_scan_f54_cmd_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs) {
+	return -ENOSYS;
+}
+
+static inline int synaptics_rmi4_scan_f54_data_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs) {
+	return -ENOSYS;
+}
+
+static inline int synaptics_rmi4_scan_f54_query_reg_info(
+	struct synaptics_rmi4_func_packet_regs *regs) {
+	return -ENOSYS;
+}
+#endif
+#endif
diff --git a/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c b/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c
new file mode 100644
index 00000000000..f10815c510c
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx_rmi_dev.c
@@ -0,0 +1,757 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/input/synaptics_rmi_dsx.h>
+#include "synaptics_dsx_i2c.h"
+
+#define CHAR_DEVICE_NAME "rmi"
+#define DEVICE_CLASS_NAME "rmidev"
+#define DEV_NUMBER 1
+#define REG_ADDR_LIMIT 0xFFFF
+
+static ssize_t rmidev_sysfs_data_show(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t rmidev_sysfs_data_store(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static ssize_t rmidev_sysfs_open_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t rmidev_sysfs_release_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t rmidev_sysfs_address_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t rmidev_sysfs_length_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t rmidev_sysfs_attn_state_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+struct rmidev_handle {
+	dev_t dev_no;
+	unsigned short address;
+	unsigned int length;
+	struct device dev;
+	struct synaptics_rmi4_data *rmi4_data;
+	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
+	struct kobject *sysfs_dir;
+	void *data;
+};
+
+struct rmidev_data {
+	int ref_count;
+	struct cdev main_dev;
+	struct class *device_class;
+	struct mutex file_mutex;
+	struct rmidev_handle *rmi_dev;
+};
+
+static struct bin_attribute attr_data = {
+	.attr = {
+		.name = "data",
+		.mode = (S_IRUGO | S_IWUSR | S_IWGRP),
+	},
+	.size = 0,
+	.read = rmidev_sysfs_data_show,
+	.write = rmidev_sysfs_data_store,
+};
+
+static struct device_attribute attrs[] = {
+	__ATTR(open, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			rmidev_sysfs_open_store),
+	__ATTR(release, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			rmidev_sysfs_release_store),
+	__ATTR(address, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			rmidev_sysfs_address_store),
+	__ATTR(length, S_IWUSR | S_IWGRP,
+			synaptics_rmi4_show_error,
+			rmidev_sysfs_length_store),
+	__ATTR(attn_state, S_IRUSR | S_IRGRP,
+			rmidev_sysfs_attn_state_show,
+			synaptics_rmi4_store_error),
+};
+
+static int rmidev_major_num;
+
+static struct class *rmidev_device_class;
+
+static struct rmidev_handle *rmidev;
+
+static struct completion remove_complete;
+
+static ssize_t rmidev_sysfs_data_show(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	int retval;
+	unsigned int data_length = rmidev->length;
+
+	if (data_length > (REG_ADDR_LIMIT - rmidev->address))
+		data_length = REG_ADDR_LIMIT - rmidev->address;
+
+	if (count < data_length) {
+		dev_err(&rmidev->rmi4_data->i2c_client->dev,
+				"%s: Not enough space (%zu bytes) in buffer\n",
+				__func__, count);
+		return -EINVAL;
+	}
+
+	if (data_length) {
+		retval = rmidev->fn_ptr->read(rmidev->rmi4_data,
+				rmidev->address,
+				(unsigned char *)buf,
+				data_length);
+		if (retval < 0) {
+			dev_err(&rmidev->rmi4_data->i2c_client->dev,
+					"%s: Failed to read data\n",
+					__func__);
+			return retval;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return data_length;
+}
+
+static ssize_t rmidev_sysfs_data_store(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	int retval;
+	unsigned int data_length = rmidev->length;
+
+	if (data_length > (REG_ADDR_LIMIT - rmidev->address))
+		data_length = REG_ADDR_LIMIT - rmidev->address;
+
+	if (data_length) {
+		retval = rmidev->fn_ptr->write(rmidev->rmi4_data,
+				rmidev->address,
+				(unsigned char *)buf,
+				data_length);
+		if (retval < 0) {
+			dev_err(&rmidev->rmi4_data->i2c_client->dev,
+					"%s: Failed to write data\n",
+					__func__);
+			return retval;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_open_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+			return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	rmidev->fn_ptr->enable(rmidev->rmi4_data, false);
+	dev_dbg(&rmidev->rmi4_data->i2c_client->dev,
+			"%s: Attention interrupt disabled\n",
+			__func__);
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_release_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+			return -EINVAL;
+
+	if (input != 1)
+		return -EINVAL;
+
+	rmidev->fn_ptr->enable(rmidev->rmi4_data, true);
+	dev_dbg(&rmidev->rmi4_data->i2c_client->dev,
+			"%s: Attention interrupt enabled\n",
+			__func__);
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_address_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+			return -EINVAL;
+
+	if (input > REG_ADDR_LIMIT)
+		return -EINVAL;
+
+	rmidev->address = (unsigned short)input;
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_length_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+			return -EINVAL;
+
+	if (input > REG_ADDR_LIMIT)
+		return -EINVAL;
+
+	rmidev->length = input;
+
+	return count;
+}
+
+static ssize_t rmidev_sysfs_attn_state_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int attn_state;
+	const struct synaptics_dsx_platform_data *platform_data =
+			rmidev->rmi4_data->board;
+
+	attn_state = gpio_get_value(platform_data->irq_gpio);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", attn_state);
+}
+
+/*
+ * rmidev_llseek - used to set up register address
+ *
+ * @filp: file structure for seek
+ * @off: offset
+ *   if whence == SEEK_SET,
+ *     high 16 bits: page address
+ *     low 16 bits: register address
+ *   if whence == SEEK_CUR,
+ *     offset from current position
+ *   if whence == SEEK_END,
+ *     offset from end position (0xFFFF)
+ * @whence: SEEK_SET, SEEK_CUR, or SEEK_END
+ */
+static loff_t rmidev_llseek(struct file *filp, loff_t off, int whence)
+{
+	loff_t newpos;
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (IS_ERR(dev_data)) {
+		pr_err("%s: Pointer of char device data is invalid", __func__);
+		return -EBADF;
+	}
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	switch (whence) {
+	case SEEK_SET:
+		newpos = off;
+		break;
+	case SEEK_CUR:
+		newpos = filp->f_pos + off;
+		break;
+	case SEEK_END:
+		newpos = REG_ADDR_LIMIT + off;
+		break;
+	default:
+		newpos = -EINVAL;
+		goto clean_up;
+	}
+
+	if (newpos < 0 || newpos > REG_ADDR_LIMIT) {
+		dev_err(&rmidev->rmi4_data->i2c_client->dev,
+				"%s: New position 0x%04x is invalid\n",
+				__func__, (unsigned int)newpos);
+		newpos = -EINVAL;
+		goto clean_up;
+	}
+
+	filp->f_pos = newpos;
+
+clean_up:
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return newpos;
+}
+
+/*
+ * rmidev_read: - use to read data from rmi device
+ *
+ * @filp: file structure for read
+ * @buf: user space buffer pointer
+ * @count: number of bytes to read
+ * @f_pos: offset (starting register address)
+ */
+static ssize_t rmidev_read(struct file *filp, char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+	ssize_t retval;
+	unsigned char tmpbuf[count + 1];
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (IS_ERR(dev_data)) {
+		pr_err("%s: Pointer of char device data is invalid", __func__);
+		return -EBADF;
+	}
+
+	if (count == 0)
+		return 0;
+
+	if (count > (REG_ADDR_LIMIT - *f_pos))
+		count = REG_ADDR_LIMIT - *f_pos;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	retval = rmidev->fn_ptr->read(rmidev->rmi4_data,
+			*f_pos,
+			tmpbuf,
+			count);
+	if (retval < 0)
+		goto clean_up;
+
+	if (copy_to_user(buf, tmpbuf, count))
+		retval = -EFAULT;
+	else
+		*f_pos += retval;
+
+clean_up:
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return retval;
+}
+
+/*
+ * rmidev_write: - used to write data to rmi device
+ *
+ * @filep: file structure for write
+ * @buf: user space buffer pointer
+ * @count: number of bytes to write
+ * @f_pos: offset (starting register address)
+ */
+static ssize_t rmidev_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+	ssize_t retval;
+	unsigned char tmpbuf[count + 1];
+	struct rmidev_data *dev_data = filp->private_data;
+
+	if (IS_ERR(dev_data)) {
+		pr_err("%s: Pointer of char device data is invalid", __func__);
+		return -EBADF;
+	}
+
+	if (count == 0)
+		return 0;
+
+	if (count > (REG_ADDR_LIMIT - *f_pos))
+		count = REG_ADDR_LIMIT - *f_pos;
+
+	if (copy_from_user(tmpbuf, buf, count))
+		return -EFAULT;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	retval = rmidev->fn_ptr->write(rmidev->rmi4_data,
+			*f_pos,
+			tmpbuf,
+			count);
+	if (retval >= 0)
+		*f_pos += retval;
+
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return retval;
+}
+
+/*
+ * rmidev_open: enable access to rmi device
+ * @inp: inode struture
+ * @filp: file structure
+ */
+static int rmidev_open(struct inode *inp, struct file *filp)
+{
+	int retval = 0;
+	struct rmidev_data *dev_data =
+			container_of(inp->i_cdev, struct rmidev_data, main_dev);
+
+	if (!dev_data)
+		return -EACCES;
+
+	filp->private_data = dev_data;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	rmidev->fn_ptr->enable(rmidev->rmi4_data, false);
+	dev_dbg(&rmidev->rmi4_data->i2c_client->dev,
+			"%s: Attention interrupt disabled\n",
+			__func__);
+
+	if (dev_data->ref_count < 1)
+		dev_data->ref_count++;
+	else
+		retval = -EACCES;
+
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return retval;
+}
+
+/*
+ * rmidev_release: - release access to rmi device
+ * @inp: inode structure
+ * @filp: file structure
+ */
+static int rmidev_release(struct inode *inp, struct file *filp)
+{
+	struct rmidev_data *dev_data =
+			container_of(inp->i_cdev, struct rmidev_data, main_dev);
+
+	if (!dev_data)
+		return -EACCES;
+
+	mutex_lock(&(dev_data->file_mutex));
+
+	dev_data->ref_count--;
+	if (dev_data->ref_count < 0)
+		dev_data->ref_count = 0;
+
+	rmidev->fn_ptr->enable(rmidev->rmi4_data, true);
+	dev_dbg(&rmidev->rmi4_data->i2c_client->dev,
+			"%s: Attention interrupt enabled\n",
+			__func__);
+
+	mutex_unlock(&(dev_data->file_mutex));
+
+	return 0;
+}
+
+static const struct file_operations rmidev_fops = {
+	.owner = THIS_MODULE,
+	.llseek = rmidev_llseek,
+	.read = rmidev_read,
+	.write = rmidev_write,
+	.open = rmidev_open,
+	.release = rmidev_release,
+};
+
+static void rmidev_device_cleanup(struct rmidev_data *dev_data)
+{
+	dev_t devno;
+
+	if (dev_data) {
+		devno = dev_data->main_dev.dev;
+
+		if (dev_data->device_class)
+			device_destroy(dev_data->device_class, devno);
+
+		cdev_del(&dev_data->main_dev);
+
+		unregister_chrdev_region(devno, 1);
+
+		dev_dbg(&rmidev->rmi4_data->i2c_client->dev,
+				"%s: rmidev device removed\n",
+				__func__);
+	}
+
+	return;
+}
+
+static char *rmi_char_devnode(struct device *dev, umode_t *mode)
+{
+	if (!mode)
+		return NULL;
+
+	*mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
+
+	return kasprintf(GFP_KERNEL, "rmi/%s", dev_name(dev));
+}
+
+static int rmidev_create_device_class(void)
+{
+	rmidev_device_class = class_create(THIS_MODULE, DEVICE_CLASS_NAME);
+
+	if (IS_ERR(rmidev_device_class)) {
+		pr_err("%s: Failed to create /dev/%s\n",
+				__func__, CHAR_DEVICE_NAME);
+		return -ENODEV;
+	}
+
+	rmidev_device_class->devnode = rmi_char_devnode;
+
+	return 0;
+}
+
+static int rmidev_init_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	dev_t dev_no;
+	unsigned char attr_count;
+	struct rmidev_data *dev_data;
+	struct device *device_ptr;
+
+	rmidev = kzalloc(sizeof(*rmidev), GFP_KERNEL);
+	if (!rmidev) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for rmidev\n",
+				__func__);
+		retval = -ENOMEM;
+		goto err_rmidev;
+	}
+
+	rmidev->fn_ptr =  kzalloc(sizeof(*(rmidev->fn_ptr)), GFP_KERNEL);
+	if (!rmidev) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for fn_ptr\n",
+				__func__);
+		retval = -ENOMEM;
+		goto err_fn_ptr;
+	}
+
+	rmidev->fn_ptr->read = rmi4_data->i2c_read;
+	rmidev->fn_ptr->write = rmi4_data->i2c_write;
+	rmidev->fn_ptr->enable = rmi4_data->irq_enable;
+	rmidev->rmi4_data = rmi4_data;
+
+	retval = rmidev_create_device_class();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create device class\n",
+				__func__);
+		goto err_device_class;
+	}
+
+	if (rmidev_major_num) {
+		dev_no = MKDEV(rmidev_major_num, DEV_NUMBER);
+		retval = register_chrdev_region(dev_no, 1, CHAR_DEVICE_NAME);
+	} else {
+		retval = alloc_chrdev_region(&dev_no, 0, 1, CHAR_DEVICE_NAME);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Failed to allocate char device region\n",
+					__func__);
+			goto err_device_region;
+		}
+
+		rmidev_major_num = MAJOR(dev_no);
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Major number of rmidev = %d\n",
+				__func__, rmidev_major_num);
+	}
+
+	dev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);
+	if (!dev_data) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for dev_data\n",
+				__func__);
+		retval = -ENOMEM;
+		goto err_dev_data;
+	}
+
+	mutex_init(&dev_data->file_mutex);
+	dev_data->rmi_dev = rmidev;
+	rmidev->data = dev_data;
+
+	cdev_init(&dev_data->main_dev, &rmidev_fops);
+
+	retval = cdev_add(&dev_data->main_dev, dev_no, 1);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to add rmi char device\n",
+				__func__);
+		goto err_char_device;
+	}
+
+	dev_set_name(&rmidev->dev, "rmidev%d", MINOR(dev_no));
+	dev_data->device_class = rmidev_device_class;
+
+	device_ptr = device_create(dev_data->device_class, NULL, dev_no,
+			NULL, CHAR_DEVICE_NAME"%d", MINOR(dev_no));
+	if (IS_ERR(device_ptr)) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create rmi char device\n",
+				__func__);
+		retval = -ENODEV;
+		goto err_char_device;
+	}
+
+	retval = gpio_export(rmi4_data->board->irq_gpio, false);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to export attention gpio\n",
+				__func__);
+	} else {
+		retval = gpio_export_link(&(rmi4_data->i2c_client->dev),
+				"attn", rmi4_data->board->irq_gpio);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s Failed to create gpio symlink\n",
+					__func__);
+		} else {
+			dev_dbg(&rmi4_data->i2c_client->dev,
+					"%s: Exported attention gpio %d\n",
+					__func__, rmi4_data->board->irq_gpio);
+		}
+	}
+
+	rmidev->sysfs_dir = kobject_create_and_add("rmidev",
+			&rmi4_data->i2c_client->dev.kobj);
+	if (!rmidev->sysfs_dir) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create sysfs directory\n",
+				__func__);
+		goto err_sysfs_dir;
+	}
+
+	retval = sysfs_create_bin_file(rmidev->sysfs_dir,
+			&attr_data);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create sysfs bin file\n",
+				__func__);
+		goto err_sysfs_bin;
+	}
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
+		retval = sysfs_create_file(rmidev->sysfs_dir,
+				&attrs[attr_count].attr);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Failed to create sysfs attributes\n",
+					__func__);
+			retval = -ENODEV;
+			goto err_sysfs_attrs;
+		}
+	}
+
+	return 0;
+
+err_sysfs_attrs:
+	for (attr_count--; attr_count >= 0; attr_count--)
+		sysfs_remove_file(rmidev->sysfs_dir, &attrs[attr_count].attr);
+
+	sysfs_remove_bin_file(rmidev->sysfs_dir, &attr_data);
+
+err_sysfs_bin:
+	kobject_put(rmidev->sysfs_dir);
+
+err_sysfs_dir:
+err_char_device:
+	rmidev_device_cleanup(dev_data);
+	kfree(dev_data);
+
+err_dev_data:
+	unregister_chrdev_region(dev_no, 1);
+
+err_device_region:
+	class_destroy(rmidev_device_class);
+
+err_device_class:
+	kfree(rmidev->fn_ptr);
+
+err_fn_ptr:
+	kfree(rmidev);
+
+err_rmidev:
+	return retval;
+}
+
+static void rmidev_remove_device(struct synaptics_rmi4_data *rmi4_data)
+{
+	unsigned char attr_count;
+	struct rmidev_data *dev_data;
+
+	if (!rmidev)
+		return;
+
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++)
+		sysfs_remove_file(rmidev->sysfs_dir, &attrs[attr_count].attr);
+
+	sysfs_remove_bin_file(rmidev->sysfs_dir, &attr_data);
+
+	kobject_put(rmidev->sysfs_dir);
+
+	dev_data = rmidev->data;
+	if (dev_data) {
+		rmidev_device_cleanup(dev_data);
+		kfree(dev_data);
+	}
+
+	unregister_chrdev_region(rmidev->dev_no, 1);
+
+	class_destroy(rmidev_device_class);
+
+	kfree(rmidev->fn_ptr);
+	kfree(rmidev);
+
+	complete(&remove_complete);
+
+	return;
+}
+
+static int __init rmidev_module_init(void)
+{
+	synaptics_rmi4_new_function(RMI_DEV, true,
+			rmidev_init_device,
+			rmidev_remove_device,
+			NULL, IC_MODE_ANY);
+	return 0;
+}
+
+static void __exit rmidev_module_exit(void)
+{
+	init_completion(&remove_complete);
+	synaptics_rmi4_new_function(RMI_DEV, false,
+			rmidev_init_device,
+			rmidev_remove_device,
+			NULL, IC_MODE_ANY);
+	wait_for_completion(&remove_complete);
+	return;
+}
+
+module_init(rmidev_module_init);
+module_exit(rmidev_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX RMI Dev Module");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(SYNAPTICS_DSX_DRIVER_VERSION);
diff --git a/drivers/input/touchscreen/synaptics_dsx_test_reporting.c b/drivers/input/touchscreen/synaptics_dsx_test_reporting.c
new file mode 100644
index 00000000000..4a35286cc50
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_dsx_test_reporting.c
@@ -0,0 +1,5066 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/ctype.h>
+#include <linux/hrtimer.h>
+#include <linux/wakelock.h>
+#include <linux/input/synaptics_rmi_dsx.h>
+#include "synaptics_dsx_i2c.h"
+
+#define WATCHDOG_HRTIMER
+#define WATCHDOG_TIMEOUT_S 1
+#define STATUS_WORK_INTERVAL 20 /* ms */
+
+/*
+#define RAW_HEX
+#define HUMAN_READABLE
+*/
+
+#define STATUS_IDLE 0
+#define STATUS_BUSY 1
+
+#define DATA_REPORT_INDEX_OFFSET 1
+#define DATA_REPORT_DATA_OFFSET 3
+
+#define COMMAND_GET_REPORT 1
+#define COMMAND_FORCE_CAL 2
+#define COMMAND_FORCE_UPDATE 4
+#define COMMAND_ENTER_IN_CELL_TESTMODE 16
+
+#define HIGH_RESISTANCE_DATA_SIZE 6
+#define FULL_RAW_CAP_MIN_MAX_DATA_SIZE 4
+#define TREX_DATA_SIZE 7
+
+#define NO_AUTO_CAL_MASK 0x01
+
+#define concat(a, b) a##b
+
+#define GROUP(_attrs) {\
+	.attrs = _attrs,\
+}
+
+#define attrify(propname) (&dev_attr_##propname.attr)
+
+#define show_prototype_ext(propname, perm)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf);\
+\
+struct device_attribute dev_attr_##propname =\
+		__ATTR(propname, (perm),\
+		concat(synaptics_rmi4_f54, _##propname##_show),\
+		synaptics_rmi4_store_error);
+
+#define show_prototype(propname)\
+	show_prototype_ext(propname, S_IRUSR | S_IRGRP)
+
+#define store_prototype(propname)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count);\
+\
+struct device_attribute dev_attr_##propname =\
+		__ATTR(propname, S_IWUSR | S_IWGRP,\
+		synaptics_rmi4_show_error,\
+		concat(synaptics_rmi4_f54, _##propname##_store));
+
+#define show_store_prototype_ext(propname, perm)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf);\
+\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count);\
+\
+struct device_attribute dev_attr_##propname =\
+		__ATTR(propname, (perm),\
+		concat(synaptics_rmi4_f54, _##propname##_show),\
+		concat(synaptics_rmi4_f54, _##propname##_store));
+
+#define show_store_prototype(propname)\
+	show_store_prototype_ext(propname, \
+		S_IRUSR | S_IRGRP | S_IWUSR | S_IWGRP)
+
+#define simple_show_func(rtype, propname, fmt)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf)\
+{\
+	return snprintf(buf, PAGE_SIZE, fmt, f54->rtype.propname);\
+} \
+
+#define simple_show_func_unsigned(rtype, propname)\
+simple_show_func(rtype, propname, "%u\n")
+
+#define show_func(rtype, rgrp, propname, fmt)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf)\
+{\
+	int retval;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+\
+	retval = f54->fn_ptr->read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			f54->rtype.rgrp->data,\
+			sizeof(f54->rtype.rgrp->data));\
+	mutex_unlock(&f54->rtype##_mutex);\
+	if (retval < 0) {\
+		dev_err(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	return snprintf(buf, PAGE_SIZE, fmt,\
+			f54->rtype.rgrp->propname);\
+} \
+
+#define show_func_unsigned(rtype, rgrp, propname)\
+show_func(rtype, rgrp, propname, "%u\n")
+
+#define show_store_func(rtype, rgrp, propname, fmt)\
+show_func(rtype, rgrp, propname, fmt)\
+\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count)\
+{\
+	int retval;\
+	unsigned long setting;\
+	unsigned long o_setting;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	retval = sstrtoul(buf, 10, &setting);\
+	if (retval)\
+		return retval;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+	retval = f54->fn_ptr->read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			f54->rtype.rgrp->data,\
+			sizeof(f54->rtype.rgrp->data));\
+	if (retval < 0) {\
+		mutex_unlock(&f54->rtype##_mutex);\
+		dev_err(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	if (f54->rtype.rgrp->propname == setting) {\
+		mutex_unlock(&f54->rtype##_mutex);\
+		return count;\
+	} \
+\
+	o_setting = f54->rtype.rgrp->propname;\
+	f54->rtype.rgrp->propname = setting;\
+\
+	retval = f54->fn_ptr->write(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			f54->rtype.rgrp->data,\
+			sizeof(f54->rtype.rgrp->data));\
+	if (retval < 0) {\
+		dev_err(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to write " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		f54->rtype.rgrp->propname = o_setting;\
+		mutex_unlock(&f54->rtype##_mutex);\
+		return retval;\
+	} \
+\
+	mutex_unlock(&f54->rtype##_mutex);\
+	return count;\
+} \
+
+#define show_store_func_unsigned(rtype, rgrp, propname)\
+show_store_func(rtype, rgrp, propname, "%u\n")
+
+#define show_replicated_func(rtype, rgrp, propname, fmt)\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		char *buf)\
+{\
+	int retval;\
+	int size = 0;\
+	unsigned char ii;\
+	unsigned char length;\
+	unsigned char element_count;\
+	unsigned char *temp;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+\
+	length = f54->rtype.rgrp->length;\
+	element_count = length / sizeof(*f54->rtype.rgrp->data);\
+\
+	retval = f54->fn_ptr->read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			(unsigned char *)f54->rtype.rgrp->data,\
+			length);\
+	mutex_unlock(&f54->rtype##_mutex);\
+	if (retval < 0) {\
+		dev_dbg(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+	} \
+\
+	temp = buf;\
+\
+	for (ii = 0; ii < element_count; ii++) {\
+		retval = snprintf(temp, PAGE_SIZE - size, fmt " ",\
+				f54->rtype.rgrp->data[ii].propname);\
+		if (retval < 0) {\
+			dev_err(&rmi4_data->i2c_client->dev,\
+					"%s: Failed to write output\n",\
+					__func__);\
+			return retval;\
+		} \
+		size += retval;\
+		temp += retval;\
+	} \
+\
+	retval = snprintf(temp, PAGE_SIZE - size, "\n");\
+	if (retval < 0) {\
+		dev_err(&rmi4_data->i2c_client->dev,\
+				"%s: Faild to write null terminator\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	return size + retval;\
+} \
+
+#define show_replicated_func_unsigned(rtype, rgrp, propname)\
+show_replicated_func(rtype, rgrp, propname, "%u")
+
+#define show_store_replicated_func(rtype, rgrp, propname, fmt)\
+show_replicated_func(rtype, rgrp, propname, fmt)\
+\
+static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
+		struct device *dev,\
+		struct device_attribute *attr,\
+		const char *buf, size_t count)\
+{\
+	int retval;\
+	unsigned int setting;\
+	unsigned char ii;\
+	unsigned char length;\
+	unsigned char element_count;\
+	const unsigned char *temp;\
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
+\
+	mutex_lock(&f54->rtype##_mutex);\
+\
+	length = f54->rtype.rgrp->length;\
+	element_count = length / sizeof(*f54->rtype.rgrp->data);\
+\
+	retval = f54->fn_ptr->read(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			(unsigned char *)f54->rtype.rgrp->data,\
+			length);\
+	if (retval < 0) {\
+		dev_dbg(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to read " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+	} \
+\
+	temp = buf;\
+\
+	for (ii = 0; ii < element_count; ii++) {\
+		if (sscanf(temp, fmt, &setting) == 1) {\
+			f54->rtype.rgrp->data[ii].propname = setting;\
+		} else {\
+			mutex_unlock(&f54->rtype##_mutex);\
+			return -EINVAL;\
+		} \
+\
+		while (*temp != 0) {\
+			temp++;\
+			if (isspace(*(temp - 1)) && !isspace(*temp))\
+				break;\
+		} \
+	} \
+\
+	retval = f54->fn_ptr->write(rmi4_data,\
+			f54->rtype.rgrp->address,\
+			(unsigned char *)f54->rtype.rgrp->data,\
+			length);\
+	mutex_unlock(&f54->rtype##_mutex);\
+	if (retval < 0) {\
+		dev_err(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to write " #rtype\
+				" " #rgrp "\n",\
+				__func__);\
+		return retval;\
+	} \
+\
+	return count;\
+} \
+
+#define show_store_replicated_func_unsigned(rtype, rgrp, propname)\
+show_store_replicated_func(rtype, rgrp, propname, "%u")
+
+#define CTRL_REG_ADD(reg, skip, cond) \
+	do { if (cond) { \
+		attrs_ctrl_regs_exist[reg_num] = true;\
+		control->reg_##reg = kzalloc(sizeof(*control->reg_##reg),\
+			GFP_KERNEL);\
+		if (!control->reg_##reg)\
+			goto exit_no_mem;\
+		pr_debug("c%s addr = 0x%02x added\n",\
+			 #reg, reg_addr);\
+		control->reg_##reg->address = reg_addr;\
+		reg_addr += skip;\
+	} \
+	reg_num++;\
+	} while (0)
+
+#define CTRL_REG_ADD_EXT(reg, skip, cond, size) \
+	do { if (cond) { \
+		attrs_ctrl_regs_exist[reg_num] = true;\
+		control->reg_##reg = kzalloc(sizeof(*control->reg_##reg),\
+			GFP_KERNEL);\
+		if (!control->reg_##reg)\
+			goto exit_no_mem;\
+		control->reg_##reg->data = kzalloc(size, GFP_KERNEL);\
+		if (!control->reg_##reg->data)\
+			goto exit_no_mem;\
+		pr_debug("c%s addr = 0x%02x size = %zu added\n",\
+			 #reg, reg_addr, size);\
+		control->reg_##reg->length = size;\
+		control->reg_##reg->address = reg_addr;\
+		reg_addr += skip;\
+	} \
+	reg_num++;\
+	} while (0)
+
+#define CTRL_REG_PRESENCE(reg, skip, cond) \
+	do { if ((cond)) {\
+		pr_debug("c%s addr = 0x%02x\n",\
+			 #reg, reg_addr);\
+		reg_addr += (skip);\
+	} } while (0)
+
+#define CTRL_REG_RESERVED_PRESENCE(reg, skip, cond) \
+	do { if ((cond)) {\
+		pr_debug("c%s addr = 0x%02x (reserved)\n",\
+			 #reg, reg_addr);\
+		reg_addr += skip;\
+	} } while (0)
+
+#define QUERY_REG_READ(reg, cond)\
+	do { if (cond) {\
+		retval = f54->fn_ptr->read(rmi4_data,\
+				reg_addr,\
+				f54->query##reg.data,\
+				sizeof(f54->query##reg.data));\
+		if (retval < 0) {\
+			dev_err(&rmi4_data->i2c_client->dev,\
+				"%s: Failed to read query %s register\n",\
+					#reg, __func__);\
+			goto err;\
+		} \
+		pr_debug("q%s addr = 0x%02x, val = 0x%02x\n",\
+			#reg, reg_addr, f54->query##reg.data[0]);\
+		reg_addr += 1;\
+	} \
+	else {\
+		memset(&f54->query##reg.data, 0, sizeof(f54->query##reg.data));\
+	} } while (0)
+
+enum f54_report_types {
+	F54_8BIT_IMAGE = 1,
+	F54_16BIT_IMAGE = 2,
+	F54_RAW_16BIT_IMAGE = 3,
+	F54_HIGH_RESISTANCE = 4,
+	F54_TX_TO_TX_SHORT = 5,
+	F54_RX_TO_RX1 = 7,
+	F54_TRUE_BASELINE = 9,
+	F54_FULL_RAW_CAP_MIN_MAX = 13,
+	F54_RX_OPENS1 = 14,
+	F54_TX_OPEN = 15,
+	F54_TX_TO_GROUND = 16,
+	F54_RX_TO_RX2 = 17,
+	F54_RX_OPENS2 = 18,
+	F54_FULL_RAW_CAP = 19,
+	F54_FULL_RAW_CAP_RX_COUPLING_COMP = 20,
+	F54_SENSOR_SPEED = 22,
+	F54_ADC_RANGE = 23,
+	F54_TREX_OPENS = 24,
+	F54_TREX_TO_GND = 25,
+	F54_TREX_SHORTS = 26,
+	INVALID_REPORT_TYPE = -1,
+};
+
+struct f54_query {
+	union {
+		struct {
+			/* query 0 */
+			unsigned char num_of_rx_electrodes;
+
+			/* query 1 */
+			unsigned char num_of_tx_electrodes;
+
+			/* query 2 */
+			unsigned char f54_query2_b0__1:2;
+			unsigned char has_baseline:1;
+			unsigned char has_image8:1;
+			unsigned char f54_query2_b4__5:2;
+			unsigned char has_image16:1;
+			unsigned char f54_query2_b7:1;
+
+			/* queries 3.0 and 3.1 */
+			unsigned short clock_rate;
+
+			/* query 4 */
+			unsigned char touch_controller_family;
+
+			/* query 5 */
+			unsigned char has_pixel_touch_threshold_adjustment:1;
+			unsigned char f54_query5_b1__7:7;
+
+			/* query 6 */
+			unsigned char has_sensor_assignment:1;
+			unsigned char has_interference_metric:1;
+			unsigned char has_sense_frequency_control:1;
+			unsigned char has_firmware_noise_mitigation:1;
+			unsigned char has_ctrl11:1;
+			unsigned char has_two_byte_report_rate:1;
+			unsigned char has_one_byte_report_rate:1;
+			unsigned char has_relaxation_control:1;
+
+			/* query 7 */
+			unsigned char curve_compensation_mode:2;
+			unsigned char f54_query7_b2__7:6;
+
+			/* query 8 */
+			unsigned char f54_query8_b0:1;
+			unsigned char has_iir_filter:1;
+			unsigned char has_cmn_removal:1;
+			unsigned char has_cmn_maximum:1;
+			unsigned char has_touch_hysteresis:1;
+			unsigned char has_edge_compensation:1;
+			unsigned char has_per_frequency_noise_control:1;
+			unsigned char has_enhanced_stretch:1;
+
+			/* query 9 */
+			unsigned char has_force_fast_relaxation:1;
+			unsigned char has_multi_metric_state_machine:1;
+			unsigned char has_signal_clarity:1;
+			unsigned char has_variance_metric:1;
+			unsigned char has_0d_relaxation_control:1;
+			unsigned char has_0d_acquisition_control:1;
+			unsigned char has_status:1;
+			unsigned char has_slew_metric:1;
+
+			/* query 10 */
+			unsigned char has_h_blank:1;
+			unsigned char has_v_blank:1;
+			unsigned char has_long_h_blank:1;
+			unsigned char has_startup_fast_relaxation:1;
+			unsigned char has_esd_control:1;
+			unsigned char has_noise_mitigation2:1;
+			unsigned char has_noise_state:1;
+			unsigned char has_energy_ratio_relaxation:1;
+
+			/* query 11 */
+			unsigned char has_excessive_noise_reporting:1;
+			unsigned char has_slew_option:1;
+			unsigned char has_two_overhead_bursts:1;
+			unsigned char has_query13:1;
+			unsigned char has_one_overhead_burst:1;
+			unsigned char f54_query11_b5:1;
+			unsigned char has_ctrl88:1;
+			unsigned char has_query15:1;
+		} __packed;
+		unsigned char data[13];
+	};
+};
+
+struct f54_query12 {
+	union {
+		struct {
+			unsigned char number_of_sensing_frequencies:4;
+			unsigned char f54_query12_b4__7:4;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query13 {
+	union {
+		struct {
+			unsigned char has_ctrl86:1;
+			unsigned char has_ctrl87:1;
+			unsigned char has_ctrl87_sub0:1;
+			unsigned char has_ctrl87_sub1:1;
+			unsigned char has_ctrl87_sub2:1;
+			unsigned char has_cid_im:1;
+			unsigned char has_noise_mitigation_enh:1;
+			unsigned char has_rail_im:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query14 {
+	union {
+		struct {
+			unsigned char size_of_ctr87;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query15 {
+	union {
+		struct {
+			unsigned char has_ctrl90:1;
+			unsigned char has_traismit_strength:1;
+			unsigned char has_ctrl87_sub3:1;
+			unsigned char has_query16:1;
+			unsigned char has_query20:1;
+			unsigned char has_query21:1;
+			unsigned char has_query22:1;
+			unsigned char has_query25:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query16 {
+	union {
+		struct {
+			unsigned char has_query17:1;
+			unsigned char has_data17:1;
+			unsigned char has_ctrl92:1;
+			unsigned char has_ctrl93:1;
+			unsigned char has_ctrl94_query18:1;
+			unsigned char has_ctrl95_query19:1;
+			unsigned char has_ctrl99:1;
+			unsigned char has_ctrl100:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query17 {
+	union {
+		struct {
+			unsigned char q17_num_of_sense_freqs;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query18 {
+	union {
+		struct {
+			unsigned char has_ctrl94_sub0:1;
+			unsigned char has_ctrl94_sub1:1;
+			unsigned char has_ctrl94_sub2:1;
+			unsigned char has_ctrl94_sub3:1;
+			unsigned char has_ctrl94_sub4:1;
+			unsigned char has_ctrl94_sub5:1;
+			unsigned char has_ctrl94_sub6:1;
+			unsigned char has_ctrl94_sub7:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query19 {
+	union {
+		struct {
+			unsigned char size_of_ctrl95;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query20 {
+	union {
+		struct {
+			unsigned char adc_clock_divisor;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query21 {
+	union {
+		struct {
+			unsigned char has_abs_rx:1;
+			unsigned char has_abs_tx:1;
+			unsigned char has_ctrl91:1;
+			unsigned char has_ctrl96:1;
+			unsigned char has_ctrl97:1;
+			unsigned char has_ctrl98:1;
+			unsigned char has_data19:1;
+			unsigned char has_query24_data18:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query22 {
+	union {
+		struct {
+			unsigned char has_packed_image:1;
+			unsigned char has_ctrl101:1;
+			unsigned char has_dynamic_sense_display_ratio:1;
+			unsigned char has_query23:1;
+			unsigned char has_ctrl103_query26:1;
+			unsigned char has_ctrl104:1;
+			unsigned char has_ctrl105:1;
+			unsigned char has_query28:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query23 {
+	union {
+		struct {
+			unsigned char has_ctrl102:1;
+			unsigned char has_ctrl102_sub1:1;
+			unsigned char has_ctrl102_sub2:1;
+			unsigned char has_ctrl102_sub4:1;
+			unsigned char has_ctrl102_sub5:1;
+			unsigned char has_ctrl102_sub9:1;
+			unsigned char has_ctrl102_sub10:1;
+			unsigned char has_ctrl102_sub11:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query24 {
+	union {
+		struct {
+			unsigned char size_of_data18;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query25 {
+	union {
+		struct {
+			unsigned char has_ctrl106:1;
+			unsigned char has_ctrl102_sub12:1;
+			unsigned char has_ctrl107:1;
+			unsigned char has_ctrl108:1;
+			unsigned char has_ctrl109:1;
+			unsigned char has_data20:1;
+			unsigned char has_tags_for_moisture:1;
+			unsigned char has_query27:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query26 {
+	union {
+		struct {
+			unsigned char has_ctrl103_sub0:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query27 {
+	union {
+		struct {
+			unsigned char has_ctrl110:1;
+			unsigned char has_data21:1;
+			unsigned char has_ctrl111:1;
+			unsigned char has_ctrl112:1;
+			unsigned char has_ctrl113:1;
+			unsigned char has_data22:1;
+			unsigned char has_ctrl114:1;
+			unsigned char has_query29:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query28 {
+	union {
+		struct {
+			unsigned char has_capacitance_correction;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query29 {
+	union {
+		struct {
+			unsigned char has_ctrl115:1;
+			unsigned char has_ground_ring_options:1;
+			unsigned char has_lost_burst_tuning:1;
+			unsigned char has_aux_exvcom2_select:1;
+			unsigned char has_ctrl116:1;
+			unsigned char has_data23:1;
+			unsigned char has_ctrl117:1;
+			unsigned char has_query30:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query30 {
+	union {
+		struct {
+			unsigned char has_ctrl118:1;
+			unsigned char has_ctrl119:1;
+			unsigned char has_ctrl120:1;
+			unsigned char has_ctrl121:1;
+			unsigned char has_ctrl122_query31:1;
+			unsigned char has_ctrl123:1;
+			unsigned char has_ctrl124:1;
+			unsigned char has_query32:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query31 {
+	union {
+		struct {
+			unsigned char num_of_active_stylus_sensing_freqs;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query32 {
+	union {
+		struct {
+			unsigned char has_ctrl125:1;
+			unsigned char has_ctrl126:1;
+			unsigned char has_ctrl127:1;
+			unsigned char has_abs_charge_pump_disable:1;
+			unsigned char has_query33:1;
+			unsigned char has_data24:1;
+			unsigned char has_query34:1;
+			unsigned char has_query35:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query33 {
+	union {
+		struct {
+			unsigned char has_ctrl128:1;
+			unsigned char has_ctrl129:1;
+			unsigned char has_ctrl130:1;
+			unsigned char has_ctrl131:1;
+			unsigned char has_ctrl132:1;
+			unsigned char has_ctrl133:1;
+			unsigned char has_ctrl134:1;
+			unsigned char has_query36:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query34 {
+	union {
+		struct {
+			unsigned char max_fnm_sliding_window_width;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query35 {
+	union {
+		struct {
+			unsigned char has_data25:1;
+			unsigned char has_ctrl135:1;
+			unsigned char has_ctrl136:1;
+			unsigned char has_ctrl137:1;
+			unsigned char has_ctrl138:1;
+			unsigned char has_ctrl139:1;
+			unsigned char has_data26:1;
+			unsigned char has_ctrl140:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query36 {
+	union {
+		struct {
+			unsigned char has_ctrl141:1;
+			unsigned char has_ctrl142:1;
+			unsigned char has_query37:1;
+			unsigned char has_ctrl143:1;
+			unsigned char has_ctrl144:1;
+			unsigned char has_ctrl145:1;
+			unsigned char has_ctrl146:1;
+			unsigned char has_query38:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query38 {
+	union {
+		struct {
+			unsigned char has_ctrl147:1;
+			unsigned char has_ctrl148:1;
+			unsigned char has_ctrl149:1;
+			unsigned char f54_q38_b3:1;
+			unsigned char has_ctrl151:1;
+			unsigned char f54_q38_b5b6:2;
+			unsigned char has_query39:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query39 {
+	union {
+		struct {
+			unsigned char f54_b0_to_b6:7;
+			unsigned char has_query40:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query40 {
+	union {
+		struct {
+			unsigned char f54_q40_b0:1;
+			unsigned char has_ctrl163_query41:1;
+			unsigned char f54_q40_b2:1;
+			unsigned char has_ctrl165_query42:1;
+			unsigned char f54_q40_b4:1;
+			unsigned char has_ctrl167:1;
+			unsigned char f54_q40_b6:1;
+			unsigned char has_query43:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query41 {
+	union {
+		struct {
+			unsigned char size_of_ctrl163;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query42 {
+	union {
+		struct {
+			unsigned char size_of_ctrl165;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query43 {
+	union {
+		struct {
+			unsigned char f54_q43_b0_to_b6:7;
+			unsigned char has_query46:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_query46 {
+	union {
+		struct {
+			unsigned char f54_q46_b0b1:2;
+			unsigned char has_ctrl179:1;
+			unsigned char f54_q46_b3:1;
+			unsigned char has_data27:1;
+			unsigned char has_data28:1;
+			unsigned char f54_q46_b6b7:2;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f54_control_0 {
+	union {
+		struct {
+			unsigned char no_relax:1;
+			unsigned char no_scan:1;
+			unsigned char force_fast_relaxation:1;
+			unsigned char startup_fast_relaxation:1;
+			unsigned char gesture_cancels_sfr:1;
+			unsigned char enable_energy_ratio_relaxation:1;
+			unsigned char excessive_noise_attn_enable:1;
+			unsigned char f54_control0_b7:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_1 {
+	union {
+		struct {
+			unsigned char bursts_per_cluster:4;
+			unsigned char f54_ctrl1_b4__7:4;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_2 {
+	union {
+		struct {
+			unsigned short saturation_cap;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_3 {
+	union {
+		struct {
+			unsigned char pixel_touch_threshold;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_4__6 {
+	union {
+		struct {
+			/* control 4 */
+			unsigned char rx_feedback_cap:2;
+			unsigned char bias_current:2;
+			unsigned char f54_ctrl4_b4__7:4;
+
+			/* control 5 */
+			unsigned char low_ref_cap:2;
+			unsigned char low_ref_feedback_cap:2;
+			unsigned char low_ref_polarity:1;
+			unsigned char f54_ctrl5_b5__7:3;
+
+			/* control 6 */
+			unsigned char high_ref_cap:2;
+			unsigned char high_ref_feedback_cap:2;
+			unsigned char high_ref_polarity:1;
+			unsigned char f54_ctrl6_b5__7:3;
+		} __packed;
+		struct {
+			unsigned char data[3];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_7 {
+	union {
+		struct {
+			unsigned char cbc_cap:2;
+			unsigned char cbc_polarity:2;
+			unsigned char cbc_tx_carrier_selection:1;
+			unsigned char f54_ctrl7_b5__7:3;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_8__9 {
+	union {
+		struct {
+			/* control 8 */
+			unsigned short integration_duration:10;
+			unsigned short f54_ctrl8_b10__15:6;
+
+			/* control 9 */
+			unsigned char reset_duration;
+		} __packed;
+		struct {
+			unsigned char data[3];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_10 {
+	union {
+		struct {
+			unsigned char noise_sensing_bursts_per_image:4;
+			unsigned char f54_ctrl10_b4__7:4;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_11 {
+	union {
+		struct {
+			unsigned short f54_ctrl11;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_12__13 {
+	union {
+		struct {
+			/* control 12 */
+			unsigned char slow_relaxation_rate;
+
+			/* control 13 */
+			unsigned char fast_relaxation_rate;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_14 {
+	union {
+		struct {
+				unsigned char rxs_on_xaxis:1;
+				unsigned char curve_comp_on_txs:1;
+				unsigned char f54_ctrl14_b2__7:6;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_15n {
+		unsigned char sensor_rx_assignment;
+};
+
+struct f54_control_15 {
+	struct f54_control_15n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_16n {
+	unsigned char sensor_tx_assignment;
+};
+
+struct f54_control_16 {
+	struct f54_control_16n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_17n {
+	unsigned char burst_count_b8__10:3;
+	unsigned char disable:1;
+	unsigned char f54_ctrl17_b4:1;
+	unsigned char filter_bandwidth:3;
+};
+
+struct f54_control_17 {
+	struct f54_control_17n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_18n {
+	unsigned char burst_count_b0__7;
+};
+
+struct f54_control_18 {
+	struct f54_control_18n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_19n {
+	unsigned char stretch_duration;
+};
+
+struct f54_control_19 {
+	struct f54_control_19n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_20 {
+	union {
+		struct {
+			unsigned char disable_noise_mitigation:1;
+			unsigned char f54_ctrl20_b2__7:7;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_21 {
+	union {
+		struct {
+			unsigned short freq_shift_noise_threshold;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_22__26 {
+	union {
+		struct {
+			/* control 22 */
+			unsigned char f54_ctrl22;
+
+			/* control 23 */
+			unsigned short medium_noise_threshold;
+
+			/* control 24 */
+			unsigned short high_noise_threshold;
+
+			/* control 25 */
+			unsigned char noise_density;
+
+			/* control 26 */
+			unsigned char frame_count;
+		} __packed;
+		struct {
+			unsigned char data[7];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_27 {
+	union {
+		struct {
+			unsigned char iir_filter_coef;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_28 {
+	union {
+		struct {
+			unsigned short quiet_threshold;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_29 {
+	union {
+		struct {
+			/* control 29 */
+			unsigned char f54_ctrl29_b0__6:7;
+			unsigned char cmn_filter_disable:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_30 {
+	union {
+		struct {
+			unsigned char cmn_filter_max;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_31 {
+	union {
+		struct {
+			unsigned char touch_hysteresis;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_32__35 {
+	union {
+		struct {
+			/* control 32 */
+			unsigned short rx_low_edge_comp;
+
+			/* control 33 */
+			unsigned short rx_high_edge_comp;
+
+			/* control 34 */
+			unsigned short tx_low_edge_comp;
+
+			/* control 35 */
+			unsigned short tx_high_edge_comp;
+		} __packed;
+		struct {
+			unsigned char data[8];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_36n {
+	unsigned char axis1_comp;
+};
+
+struct f54_control_36 {
+	struct f54_control_36n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_37n {
+	unsigned char axis2_comp;
+};
+
+struct f54_control_37 {
+	struct f54_control_37n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_38n {
+	unsigned char noise_control_1;
+};
+
+struct f54_control_38 {
+	struct f54_control_38n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_39n {
+	unsigned char noise_control_2;
+};
+
+struct f54_control_39 {
+	struct f54_control_39n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_40n {
+	unsigned char noise_control_3;
+};
+
+struct f54_control_40 {
+	struct f54_control_40n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_89 {
+	union {
+		struct {
+			unsigned char c89_cid_sel_opt:2;
+			unsigned char c89_cid_voltage_sel:3;
+			unsigned char c89_byte0_b5_b7:3;
+			unsigned char c89_cid_im_noise_threshold_lsb;
+			unsigned char c89_cid_im_noise_threshold_msb;
+			unsigned char c89_fnm_pixel_touch_mult;
+			unsigned char c89_freq_scan_threshold_lsb;
+			unsigned char c89_freq_scan_threshold_msb;
+			unsigned char c89_quiet_im_threshold_lsb;
+			unsigned char c89_quiet_im_threshold_msb;
+		} __packed;
+		struct {
+			unsigned char data[8];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_93 {
+	union {
+		struct {
+			unsigned char c93_freq_shift_noise_threshold_lsb;
+			unsigned char c93_freq_shift_noise_threshold_msb;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_95 {
+	struct f54_control_95n *data;
+	unsigned short address;
+	unsigned char length;
+};
+
+struct f54_control_99 {
+	union {
+		struct {
+			unsigned char c99_int_dur_lsb;
+			unsigned char c99_int_dur_msb;
+			unsigned char c99_reset_dur;
+		} __packed;
+		struct {
+			unsigned char data[3];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_107 {
+	union {
+		struct {
+			unsigned char c107_abs_int_dur;
+			unsigned char c107_abs_reset_dur;
+			unsigned char c107_abs_filter_bw;
+			unsigned char c107_abs_rstretch;
+			unsigned char c107_abs_burst_count_1;
+			unsigned char c107_abs_burst_count_2;
+			unsigned char c107_abs_stretch_dur;
+			unsigned char c107_abs_adc_clock_div;
+			unsigned char c107_abs_sub_burtst_size;
+			unsigned char c107_abs_trigger_delay;
+		} __packed;
+		struct {
+			unsigned char data[10];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control_137 {
+	union {
+		struct {
+			unsigned char c137_cmnr_adjust;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_control {
+	struct f54_control_0 *reg_0;
+	struct f54_control_1 *reg_1;
+	struct f54_control_2 *reg_2;
+	struct f54_control_3 *reg_3;
+	struct f54_control_4__6 *reg_4__6;
+	struct f54_control_7 *reg_7;
+	struct f54_control_8__9 *reg_8__9;
+	struct f54_control_10 *reg_10;
+	struct f54_control_11 *reg_11;
+	struct f54_control_12__13 *reg_12__13;
+	struct f54_control_14 *reg_14;
+	struct f54_control_15 *reg_15;
+	struct f54_control_16 *reg_16;
+	struct f54_control_17 *reg_17;
+	struct f54_control_18 *reg_18;
+	struct f54_control_19 *reg_19;
+	struct f54_control_20 *reg_20;
+	struct f54_control_21 *reg_21;
+	struct f54_control_22__26 *reg_22__26;
+	struct f54_control_27 *reg_27;
+	struct f54_control_28 *reg_28;
+	struct f54_control_29 *reg_29;
+	struct f54_control_30 *reg_30;
+	struct f54_control_31 *reg_31;
+	struct f54_control_32__35 *reg_32__35;
+	struct f54_control_36 *reg_36;
+	struct f54_control_37 *reg_37;
+	struct f54_control_38 *reg_38;
+	struct f54_control_39 *reg_39;
+	struct f54_control_40 *reg_40;
+	struct f54_control_89 *reg_89;
+	struct f54_control_93 *reg_93;
+	struct f54_control_95 *reg_95;
+	struct f54_control_99 *reg_99;
+	struct f54_control_107 *reg_107;
+	struct f54_control_137 *reg_137;
+	struct f55_control_0 *reg_0_f55;
+	struct f55_control_8 *reg_8_f55;
+};
+
+struct f54_data_4 {
+	union {
+		struct {
+			unsigned char d4_sense_freq_sel:4;
+			unsigned char d4_baseline_sel:2;
+			unsigned char d4_b6:1;
+			unsigned char d4_inhibit_freq_shift:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+struct f54_data_6 {
+	union {
+		struct {
+			unsigned char d6_interference_metric_lsb;
+			unsigned char d6_interference_metric_msb;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+
+	};
+};
+
+struct f54_data_7_0 {
+	union {
+		struct {
+			unsigned char d7_current_report_rate_lsb;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_7_1 {
+	union {
+		struct {
+			unsigned char d7_current_report_rate_msb;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_8 {
+	union {
+		struct {
+			unsigned char d8_variance_metric_lsb;
+			unsigned char d8_variance_metric_msb;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_9 {
+	union {
+		struct {
+			unsigned char d9_averaged_im_lsb;
+			unsigned char d9_averaged_im_msb;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_10 {
+	union {
+		struct {
+			unsigned char d10_noise_state;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_14 {
+	union {
+		struct {
+			unsigned char d14_cid_im_lsb;
+			unsigned char d14_cid_im_msb;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_16 {
+	union {
+		struct {
+			unsigned char d16_freq_scan_im_lsb;
+			unsigned char d16_freq_scan_im_msb;
+		} __packed;
+		struct {
+			unsigned char data[2];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data_17 {
+	union {
+		struct {
+			unsigned char d17_freq:7;
+			unsigned char d17_inhibit_freq_shift:1;
+		} __packed;
+		struct {
+			unsigned char data[1];
+			unsigned short address;
+		} __packed;
+	};
+};
+
+struct f54_data {
+	struct f54_data_4 *reg_4;
+	struct f54_data_6 *reg_6;
+	struct f54_data_7_0 *reg_7_0;
+	struct f54_data_7_1 *reg_7_1;
+	struct f54_data_8 *reg_8;
+	struct f54_data_9 *reg_9;
+	struct f54_data_10 *reg_10;
+	struct f54_data_14 *reg_14;
+	struct f54_data_16 *reg_16;
+	struct f54_data_17 *reg_17;
+};
+
+struct f55_query_0_2 {
+	union {
+		struct {
+			/* query 0 */
+			unsigned char num_of_rx_electrodes;
+
+			/* query 1 */
+			unsigned char num_of_tx_electrodes;
+
+			/* query 2 */
+			unsigned char has_sensor_assignment:1;
+			unsigned char has_edge_compensation:1;
+			unsigned char curve_compensation_mode:2;
+			unsigned char has_ctrl6:1;
+			unsigned char has_alternate_tx_assignment:1;
+			unsigned char f55_q2_has_single_layer_multitouch:1;
+			unsigned char has_query5:1;
+		} __packed;
+		unsigned char data[3];
+	};
+};
+
+struct f55_query_3 {
+	union {
+		struct {
+			unsigned char f55_q3_has_ctrl8:1;
+			unsigned char has_ctrl9:1;
+			unsigned char has_on_cell_pattern:1;
+			unsigned char has_data0:1;
+			unsigned char has_single_wide_pattern:1;
+			unsigned char has_mirrored_tx_pattern:1;
+			unsigned char has_discrete_pattern:1;
+			unsigned char has_query9:1;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct f55_control_0 {
+	union {
+		struct {
+			unsigned char f55_c0_receivers_on_x:1;
+			unsigned char f55_c0_curve_compensation_on_tx:1;
+			unsigned char f55_c0_trx_sense:1;
+			unsigned char f55_c0_trx_config:1;
+			unsigned char f55_c0_guard_disable:1;
+			unsigned char f55_c0_b5_b7:3;
+		} __packed;
+		unsigned char data[1];
+		unsigned short address;
+	};
+};
+
+struct f55_control_8 {
+	union {
+		struct {
+			unsigned char f55_c8_pattern_type;
+		} __packed;
+		unsigned char data[1];
+		unsigned short address;
+	};
+};
+
+struct synaptics_rmi4_fn55_desc {
+	unsigned short query_base_addr;
+	unsigned short control_base_addr;
+};
+
+struct synaptics_rmi4_f54_handle {
+	bool no_auto_cal;
+	int status;
+	unsigned char intr_mask;
+	unsigned char intr_reg_num;
+	unsigned char *report_data;
+	unsigned short query_base_addr;
+	unsigned short control_base_addr;
+	unsigned short data_base_addr;
+	unsigned short command_base_addr;
+	unsigned short fifoindex;
+	unsigned int report_size;
+	unsigned int data_buffer_size;
+	enum f54_report_types report_type;
+	enum f54_report_types user_report_type1;
+	enum f54_report_types user_report_type2;
+	struct mutex status_mutex;
+	struct mutex data_mutex;
+	struct mutex control_mutex;
+	struct f54_query query;
+	struct f54_query12 query12;
+	struct f54_query13 query13;
+	struct f54_query14 query14;
+	struct f54_query15 query15;
+	struct f54_query16 query16;
+	struct f54_query17 query17;
+	struct f54_query18 query18;
+	struct f54_query19 query19;
+	struct f54_query20 query20;
+	struct f54_query21 query21;
+	struct f54_query22 query22;
+	struct f54_query23 query23;
+	struct f54_query24 query24;
+	struct f54_query25 query25;
+	struct f54_query26 query26;
+	struct f54_query27 query27;
+	struct f54_query28 query28;
+	struct f54_query29 query29;
+	struct f54_query30 query30;
+	struct f54_query31 query31;
+	struct f54_query32 query32;
+	struct f54_query33 query33;
+	struct f54_query34 query34;
+	struct f54_query35 query35;
+	struct f54_query36 query36;
+	struct f54_query38 query38;
+	struct f54_query39 query39;
+	struct f54_query40 query40;
+	struct f54_query41 query41;
+	struct f54_query42 query42;
+	struct f54_query43 query43;
+	struct f54_query46 query46;
+	struct f54_control control;
+	struct f54_data data;
+	struct kobject *attr_dir;
+	struct hrtimer watchdog;
+	struct work_struct timeout_work;
+	struct delayed_work status_work;
+	struct workqueue_struct *status_workqueue;
+	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
+	struct synaptics_rmi4_data *rmi4_data;
+	struct synaptics_rmi4_fn55_desc *fn55;
+	struct f55_query_0_2 query_f55_0_2;
+	struct f55_query_3 query_f55_3;
+	struct wake_lock test_wake_lock;
+};
+
+store_prototype(reset)
+show_prototype_ext(status, S_IRUGO)
+show_prototype_ext(report_size, S_IRUGO)
+show_prototype_ext(num_of_mapped_rx, S_IRUGO)
+show_prototype_ext(num_of_mapped_tx, S_IRUGO)
+show_store_prototype(no_auto_cal)
+show_store_prototype_ext(report_type, S_IRUGO | S_IWUSR | S_IWGRP)
+show_store_prototype_ext(user_report_type1, S_IRUGO | S_IWUSR | S_IWGRP)
+show_store_prototype_ext(user_report_type2, S_IRUGO | S_IWUSR | S_IWGRP)
+show_prototype_ext(user_get_report1, S_IRUGO)
+show_prototype_ext(user_get_report2, S_IRUGO)
+show_store_prototype(fifoindex)
+store_prototype(get_report)
+show_store_prototype(force_update)
+store_prototype(force_cal)
+show_store_prototype(enter_in_cell_test_mode)
+show_prototype_ext(num_of_rx_electrodes, S_IRUGO)
+show_prototype_ext(num_of_tx_electrodes, S_IRUGO)
+show_prototype(has_image16)
+show_prototype(has_image8)
+show_prototype(has_baseline)
+show_prototype(clock_rate)
+show_prototype(touch_controller_family)
+show_prototype(has_pixel_touch_threshold_adjustment)
+show_prototype(has_sensor_assignment)
+show_prototype(has_interference_metric)
+show_prototype(has_sense_frequency_control)
+show_prototype(has_firmware_noise_mitigation)
+show_prototype(has_two_byte_report_rate)
+show_prototype(has_one_byte_report_rate)
+show_prototype(has_relaxation_control)
+show_prototype(curve_compensation_mode)
+show_prototype(has_iir_filter)
+show_prototype(has_cmn_removal)
+show_prototype(has_cmn_maximum)
+show_prototype(has_touch_hysteresis)
+show_prototype(has_edge_compensation)
+show_prototype(has_per_frequency_noise_control)
+show_prototype(has_enhanced_stretch)
+show_prototype(has_force_fast_relaxation)
+show_prototype(has_multi_metric_state_machine)
+show_prototype(has_signal_clarity)
+show_prototype(has_variance_metric)
+show_prototype(has_0d_relaxation_control)
+show_prototype(has_0d_acquisition_control)
+show_prototype(has_status)
+show_prototype(has_slew_metric)
+show_prototype(has_h_blank)
+show_prototype(has_v_blank)
+show_prototype(has_long_h_blank)
+show_prototype(has_startup_fast_relaxation)
+show_prototype(has_esd_control)
+show_prototype(has_noise_mitigation2)
+show_prototype(has_noise_state)
+show_prototype(has_energy_ratio_relaxation)
+show_prototype(number_of_sensing_frequencies)
+show_prototype(q17_num_of_sense_freqs)
+show_store_prototype(no_relax)
+show_store_prototype(no_scan)
+show_store_prototype(bursts_per_cluster)
+show_store_prototype(saturation_cap)
+show_store_prototype(pixel_touch_threshold)
+show_store_prototype(rx_feedback_cap)
+show_store_prototype(low_ref_cap)
+show_store_prototype(low_ref_feedback_cap)
+show_store_prototype(low_ref_polarity)
+show_store_prototype(high_ref_cap)
+show_store_prototype(high_ref_feedback_cap)
+show_store_prototype(high_ref_polarity)
+show_store_prototype(cbc_cap)
+show_store_prototype(cbc_polarity)
+show_store_prototype(cbc_tx_carrier_selection)
+show_store_prototype(integration_duration)
+show_store_prototype(reset_duration)
+show_store_prototype(noise_sensing_bursts_per_image)
+show_store_prototype(slow_relaxation_rate)
+show_store_prototype(fast_relaxation_rate)
+show_store_prototype(rxs_on_xaxis)
+show_store_prototype(curve_comp_on_txs)
+show_prototype(sensor_rx_assignment)
+show_prototype(sensor_tx_assignment)
+show_prototype(burst_count)
+show_prototype(disable)
+show_prototype(filter_bandwidth)
+show_prototype(stretch_duration)
+show_store_prototype(disable_noise_mitigation)
+show_store_prototype(freq_shift_noise_threshold)
+show_store_prototype(medium_noise_threshold)
+show_store_prototype(high_noise_threshold)
+show_store_prototype(noise_density)
+show_store_prototype(frame_count)
+show_store_prototype(iir_filter_coef)
+show_store_prototype(quiet_threshold)
+show_store_prototype(cmn_filter_disable)
+show_store_prototype(cmn_filter_max)
+show_store_prototype(touch_hysteresis)
+show_store_prototype(rx_low_edge_comp)
+show_store_prototype(rx_high_edge_comp)
+show_store_prototype(tx_low_edge_comp)
+show_store_prototype(tx_high_edge_comp)
+show_store_prototype(axis1_comp)
+show_store_prototype(axis2_comp)
+show_prototype(noise_control_1)
+show_prototype(noise_control_2)
+show_prototype(noise_control_3)
+show_store_prototype(d4_sense_freq_sel)
+show_store_prototype(d4_baseline_sel)
+show_store_prototype(d4_inhibit_freq_shift)
+show_prototype(d6_interference_metric_lsb)
+show_prototype(d6_interference_metric_msb)
+show_prototype(d7_current_report_rate_lsb)
+show_prototype(d7_current_report_rate_msb)
+show_prototype(d8_variance_metric_lsb)
+show_prototype(d8_variance_metric_msb)
+show_prototype(d9_averaged_im_lsb)
+show_prototype(d9_averaged_im_msb)
+show_prototype(d10_noise_state)
+show_store_prototype(d16_freq_scan_im_lsb)
+show_store_prototype(d16_freq_scan_im_msb)
+show_prototype(d14_cid_im_lsb)
+show_prototype(d14_cid_im_msb)
+show_store_prototype(d17_inhibit_freq_shift)
+show_store_prototype(d17_freq)
+show_store_prototype(c89_cid_sel_opt)
+show_store_prototype(c89_cid_voltage_sel)
+show_store_prototype(c89_cid_im_noise_threshold_lsb)
+show_store_prototype(c89_cid_im_noise_threshold_msb)
+show_store_prototype(c89_fnm_pixel_touch_mult)
+show_store_prototype(c89_freq_scan_threshold_lsb)
+show_store_prototype(c89_freq_scan_threshold_msb)
+show_store_prototype(c89_quiet_im_threshold_lsb)
+show_store_prototype(c89_quiet_im_threshold_msb)
+show_store_prototype(c93_freq_shift_noise_threshold_lsb)
+show_store_prototype(c93_freq_shift_noise_threshold_msb)
+show_store_prototype(c95_disable)
+show_store_prototype(c95_filter_bw)
+show_store_prototype(c95_first_burst_length_lsb)
+show_store_prototype(c95_first_burst_length_msb)
+show_store_prototype(c95_addl_burst_length_lsb)
+show_store_prototype(c95_addl_burst_length_msb)
+show_store_prototype(c95_i_stretch)
+show_store_prototype(c95_r_stretch)
+show_store_prototype(c95_noise_control1)
+show_store_prototype(c95_noise_control2)
+show_store_prototype(c95_noise_control3)
+show_store_prototype(c95_noise_control4)
+show_store_prototype(c99_int_dur_lsb)
+show_store_prototype(c99_int_dur_msb)
+show_store_prototype(c99_reset_dur)
+show_store_prototype(c107_abs_int_dur)
+show_store_prototype(c107_abs_reset_dur)
+show_store_prototype(c107_abs_filter_bw)
+show_store_prototype(c107_abs_rstretch)
+show_store_prototype(c107_abs_burst_count_1)
+show_store_prototype(c107_abs_burst_count_2)
+show_store_prototype(c107_abs_stretch_dur)
+show_store_prototype(c107_abs_adc_clock_div)
+show_store_prototype(c107_abs_sub_burtst_size)
+show_store_prototype(c107_abs_trigger_delay)
+show_store_prototype(c137_cmnr_adjust)
+show_prototype(f55_q2_has_single_layer_multitouch)
+show_prototype(f55_c0_receivers_on_x)
+show_prototype(f55_c8_pattern_type)
+
+static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count);
+
+static struct attribute *attrs[] = {
+	attrify(reset),
+	attrify(status),
+	attrify(report_size),
+	attrify(num_of_mapped_rx),
+	attrify(num_of_mapped_tx),
+	attrify(no_auto_cal),
+	attrify(report_type),
+	attrify(user_report_type1),
+	attrify(user_report_type2),
+	attrify(user_get_report1),
+	attrify(user_get_report2),
+	attrify(fifoindex),
+	attrify(get_report),
+	attrify(force_update),
+	attrify(force_cal),
+	attrify(enter_in_cell_test_mode),
+	attrify(num_of_rx_electrodes),
+	attrify(num_of_tx_electrodes),
+	attrify(has_image16),
+	attrify(has_image8),
+	attrify(has_baseline),
+	attrify(clock_rate),
+	attrify(touch_controller_family),
+	attrify(has_pixel_touch_threshold_adjustment),
+	attrify(has_sensor_assignment),
+	attrify(has_interference_metric),
+	attrify(has_sense_frequency_control),
+	attrify(has_firmware_noise_mitigation),
+	attrify(has_two_byte_report_rate),
+	attrify(has_one_byte_report_rate),
+	attrify(has_relaxation_control),
+	attrify(curve_compensation_mode),
+	attrify(has_iir_filter),
+	attrify(has_cmn_removal),
+	attrify(has_cmn_maximum),
+	attrify(has_touch_hysteresis),
+	attrify(has_edge_compensation),
+	attrify(has_per_frequency_noise_control),
+	attrify(has_enhanced_stretch),
+	attrify(has_force_fast_relaxation),
+	attrify(has_multi_metric_state_machine),
+	attrify(has_signal_clarity),
+	attrify(has_variance_metric),
+	attrify(has_0d_relaxation_control),
+	attrify(has_0d_acquisition_control),
+	attrify(has_status),
+	attrify(has_slew_metric),
+	attrify(has_h_blank),
+	attrify(has_v_blank),
+	attrify(has_long_h_blank),
+	attrify(has_startup_fast_relaxation),
+	attrify(has_esd_control),
+	attrify(has_noise_mitigation2),
+	attrify(has_noise_state),
+	attrify(has_energy_ratio_relaxation),
+	attrify(number_of_sensing_frequencies),
+	attrify(q17_num_of_sense_freqs),
+	attrify(f55_q2_has_single_layer_multitouch),
+	NULL,
+};
+
+static struct attribute_group attr_group = GROUP(attrs);
+
+static struct attribute *attrs_reg_0[] = {
+	attrify(no_relax),
+	attrify(no_scan),
+	NULL,
+};
+
+static struct attribute *attrs_reg_1[] = {
+	attrify(bursts_per_cluster),
+	NULL,
+};
+
+static struct attribute *attrs_reg_2[] = {
+	attrify(saturation_cap),
+	NULL,
+};
+
+static struct attribute *attrs_reg_3[] = {
+	attrify(pixel_touch_threshold),
+	NULL,
+};
+
+static struct attribute *attrs_reg_4__6[] = {
+	attrify(rx_feedback_cap),
+	attrify(low_ref_cap),
+	attrify(low_ref_feedback_cap),
+	attrify(low_ref_polarity),
+	attrify(high_ref_cap),
+	attrify(high_ref_feedback_cap),
+	attrify(high_ref_polarity),
+	NULL,
+};
+
+static struct attribute *attrs_reg_7[] = {
+	attrify(cbc_cap),
+	attrify(cbc_polarity),
+	attrify(cbc_tx_carrier_selection),
+	NULL,
+};
+
+static struct attribute *attrs_reg_8__9[] = {
+	attrify(integration_duration),
+	attrify(reset_duration),
+	NULL,
+};
+
+static struct attribute *attrs_reg_10[] = {
+	attrify(noise_sensing_bursts_per_image),
+	NULL,
+};
+
+static struct attribute *attrs_reg_11[] = {
+	NULL,
+};
+
+static struct attribute *attrs_reg_12__13[] = {
+	attrify(slow_relaxation_rate),
+	attrify(fast_relaxation_rate),
+	NULL,
+};
+
+static struct attribute *attrs_reg_14__16[] = {
+	attrify(rxs_on_xaxis),
+	attrify(curve_comp_on_txs),
+	attrify(sensor_rx_assignment),
+	attrify(sensor_tx_assignment),
+	NULL,
+};
+
+static struct attribute *attrs_reg_17__19[] = {
+	attrify(burst_count),
+	attrify(disable),
+	attrify(filter_bandwidth),
+	attrify(stretch_duration),
+	NULL,
+};
+
+static struct attribute *attrs_reg_20[] = {
+	attrify(disable_noise_mitigation),
+	NULL,
+};
+
+static struct attribute *attrs_reg_21[] = {
+	attrify(freq_shift_noise_threshold),
+	NULL,
+};
+
+static struct attribute *attrs_reg_22__26[] = {
+	attrify(medium_noise_threshold),
+	attrify(high_noise_threshold),
+	attrify(noise_density),
+	attrify(frame_count),
+	NULL,
+};
+
+static struct attribute *attrs_reg_27[] = {
+	attrify(iir_filter_coef),
+	NULL,
+};
+
+static struct attribute *attrs_reg_28[] = {
+	attrify(quiet_threshold),
+	NULL,
+};
+
+static struct attribute *attrs_reg_29[] = {
+	attrify(cmn_filter_disable),
+	NULL,
+};
+
+static struct attribute *attrs_reg_30[] = {
+	attrify(cmn_filter_max),
+	NULL,
+};
+
+static struct attribute *attrs_reg_31[] = {
+	attrify(touch_hysteresis),
+	NULL,
+};
+
+static struct attribute *attrs_reg_32__35[] = {
+	attrify(rx_low_edge_comp),
+	attrify(rx_high_edge_comp),
+	attrify(tx_low_edge_comp),
+	attrify(tx_high_edge_comp),
+	NULL,
+};
+
+static struct attribute *attrs_reg_36[] = {
+	attrify(axis1_comp),
+	NULL,
+};
+
+static struct attribute *attrs_reg_37[] = {
+	attrify(axis2_comp),
+	NULL,
+};
+
+static struct attribute *attrs_reg_38__40[] = {
+	attrify(noise_control_1),
+	attrify(noise_control_2),
+	attrify(noise_control_3),
+	NULL,
+};
+
+static struct attribute *attrs_reg_89[] = {
+	attrify(c89_cid_sel_opt),
+	attrify(c89_cid_voltage_sel),
+	attrify(c89_cid_im_noise_threshold_lsb),
+	attrify(c89_cid_im_noise_threshold_msb),
+	attrify(c89_fnm_pixel_touch_mult),
+	attrify(c89_freq_scan_threshold_lsb),
+	attrify(c89_freq_scan_threshold_msb),
+	attrify(c89_quiet_im_threshold_lsb),
+	attrify(c89_quiet_im_threshold_msb),
+	NULL,
+};
+
+static struct attribute *attrs_reg_93[] = {
+	attrify(c93_freq_shift_noise_threshold_lsb),
+	attrify(c93_freq_shift_noise_threshold_msb),
+	NULL,
+};
+
+static struct attribute *attrs_reg_95[] = {
+	attrify(c95_disable),
+	attrify(c95_filter_bw),
+	attrify(c95_first_burst_length_lsb),
+	attrify(c95_first_burst_length_msb),
+	attrify(c95_addl_burst_length_lsb),
+	attrify(c95_addl_burst_length_msb),
+	attrify(c95_i_stretch),
+	attrify(c95_r_stretch),
+	attrify(c95_noise_control1),
+	attrify(c95_noise_control2),
+	attrify(c95_noise_control3),
+	attrify(c95_noise_control4),
+	NULL,
+};
+
+static struct attribute *attrs_reg_99[] = {
+	attrify(c99_int_dur_lsb),
+	attrify(c99_int_dur_msb),
+	attrify(c99_reset_dur),
+	NULL,
+};
+
+static struct attribute *attrs_reg_107[] = {
+	attrify(c107_abs_int_dur),
+	attrify(c107_abs_reset_dur),
+	attrify(c107_abs_filter_bw),
+	attrify(c107_abs_rstretch),
+	attrify(c107_abs_burst_count_1),
+	attrify(c107_abs_burst_count_2),
+	attrify(c107_abs_stretch_dur),
+	attrify(c107_abs_adc_clock_div),
+	attrify(c107_abs_sub_burtst_size),
+	attrify(c107_abs_trigger_delay),
+	NULL,
+};
+
+static struct attribute *attrs_reg_137[] = {
+	attrify(c137_cmnr_adjust),
+	NULL,
+};
+
+static struct attribute *attrs_f55_c0[] = {
+	attrify(f55_c0_receivers_on_x),
+	NULL,
+};
+
+static struct attribute *attrs_f55_c8[] = {
+	attrify(f55_c8_pattern_type),
+	NULL,
+};
+
+static struct attribute_group attrs_ctrl_regs[] = {
+	GROUP(attrs_reg_0),
+	GROUP(attrs_reg_1),
+	GROUP(attrs_reg_2),
+	GROUP(attrs_reg_3),
+	GROUP(attrs_reg_4__6),
+	GROUP(attrs_reg_7),
+	GROUP(attrs_reg_8__9),
+	GROUP(attrs_reg_10),
+	GROUP(attrs_reg_11),
+	GROUP(attrs_reg_12__13),
+	GROUP(attrs_reg_14__16),
+	GROUP(attrs_reg_17__19),
+	GROUP(attrs_reg_20),
+	GROUP(attrs_reg_21),
+	GROUP(attrs_reg_22__26),
+	GROUP(attrs_reg_27),
+	GROUP(attrs_reg_28),
+	GROUP(attrs_reg_29),
+	GROUP(attrs_reg_30),
+	GROUP(attrs_reg_31),
+	GROUP(attrs_reg_32__35),
+	GROUP(attrs_reg_36),
+	GROUP(attrs_reg_37),
+	GROUP(attrs_reg_38__40),
+	GROUP(attrs_reg_89),
+	GROUP(attrs_reg_93),
+	GROUP(attrs_reg_95),
+	GROUP(attrs_reg_99),
+	GROUP(attrs_reg_107),
+	GROUP(attrs_reg_137),
+	GROUP(attrs_f55_c0),
+	GROUP(attrs_f55_c8),
+};
+
+static bool attrs_ctrl_regs_exist[ARRAY_SIZE(attrs_ctrl_regs)];
+
+static struct attribute *data_attrs_reg_4[] = {
+	attrify(d4_sense_freq_sel),
+	attrify(d4_baseline_sel),
+	attrify(d4_inhibit_freq_shift),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_6[] = {
+	attrify(d6_interference_metric_lsb),
+	attrify(d6_interference_metric_msb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_7_0[] = {
+	attrify(d7_current_report_rate_lsb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_7_1[] = {
+	attrify(d7_current_report_rate_msb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_8[] = {
+	attrify(d8_variance_metric_lsb),
+	attrify(d8_variance_metric_msb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_9[] = {
+	attrify(d9_averaged_im_lsb),
+	attrify(d9_averaged_im_msb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_10[] = {
+	attrify(d10_noise_state),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_14[] = {
+	attrify(d14_cid_im_lsb),
+	attrify(d14_cid_im_msb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_16[] = {
+	attrify(d16_freq_scan_im_lsb),
+	attrify(d16_freq_scan_im_msb),
+	NULL,
+};
+
+static struct attribute *data_attrs_reg_17[] = {
+	attrify(d17_freq),
+	attrify(d17_inhibit_freq_shift),
+	NULL,
+};
+
+static struct attribute_group attrs_data_regs[] = {
+	GROUP(data_attrs_reg_4),
+	GROUP(data_attrs_reg_6),
+	GROUP(data_attrs_reg_7_0),
+	GROUP(data_attrs_reg_7_1),
+	GROUP(data_attrs_reg_8),
+	GROUP(data_attrs_reg_9),
+	GROUP(data_attrs_reg_10),
+	GROUP(data_attrs_reg_14),
+	GROUP(data_attrs_reg_16),
+	GROUP(data_attrs_reg_17),
+};
+
+static bool attrs_data_regs_exist[ARRAY_SIZE(attrs_data_regs)];
+
+static struct bin_attribute dev_report_data = {
+	.attr = {
+		.name = "report_data",
+		.mode = S_IRUGO,
+	},
+	.size = 0,
+	.read = synaptics_rmi4_f54_data_read,
+};
+
+static struct synaptics_rmi4_f54_handle *f54;
+
+static struct completion remove_complete;
+
+static bool is_report_type_valid(enum f54_report_types report_type)
+{
+	switch (report_type) {
+	case F54_8BIT_IMAGE:
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_HIGH_RESISTANCE:
+	case F54_TX_TO_TX_SHORT:
+	case F54_RX_TO_RX1:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP_MIN_MAX:
+	case F54_RX_OPENS1:
+	case F54_TX_OPEN:
+	case F54_TX_TO_GROUND:
+	case F54_RX_TO_RX2:
+	case F54_RX_OPENS2:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+	case F54_SENSOR_SPEED:
+	case F54_ADC_RANGE:
+	case F54_TREX_OPENS:
+	case F54_TREX_TO_GND:
+	case F54_TREX_SHORTS:
+		return true;
+		break;
+	default:
+		return false;
+	}
+}
+
+static int set_user_report_type(enum f54_report_types *user_report_type,
+	const char *buf, size_t count)
+{
+	unsigned int report_type;
+	int retval = 0;
+	retval = kstrtouint(buf, 10, &report_type);
+	if (retval)
+		goto out;
+
+	if (!is_report_type_valid((enum f54_report_types)report_type)) {
+		dev_err(&f54->rmi4_data->i2c_client->dev,
+				"%s: Report type not supported by driver\n",
+				__func__);
+		retval = -EINVAL;
+	}
+
+out:
+	if (retval == 0) {
+		*user_report_type = report_type;
+		retval = count;
+	} else
+		*user_report_type = INVALID_REPORT_TYPE;
+
+	return retval;
+}
+
+static ssize_t synaptics_rmi4_f54_user_report_type1_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_user_report_type(&f54->user_report_type1, buf, count);
+}
+
+static ssize_t synaptics_rmi4_f54_user_report_type2_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_user_report_type(&f54->user_report_type2, buf, count);
+}
+
+static void set_report_size(void)
+{
+	unsigned char rx = f54->rmi4_data->num_of_rx;
+	unsigned char tx = f54->rmi4_data->num_of_tx;
+
+	switch (f54->report_type) {
+	case F54_8BIT_IMAGE:
+		f54->report_size = rx * tx;
+		break;
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+	case F54_SENSOR_SPEED:
+	case F54_ADC_RANGE:
+		f54->report_size = 2 * rx * tx;
+		break;
+	case F54_HIGH_RESISTANCE:
+		f54->report_size = HIGH_RESISTANCE_DATA_SIZE;
+		break;
+	case F54_TX_TO_TX_SHORT:
+	case F54_TX_OPEN:
+	case F54_TX_TO_GROUND:
+		f54->report_size = (tx + 7) / 8;
+		break;
+	case F54_RX_TO_RX1:
+	case F54_RX_OPENS1:
+		if (rx < tx)
+			f54->report_size = 2 * rx * rx;
+		else
+			f54->report_size = 2 * rx * tx;
+		break;
+	case F54_FULL_RAW_CAP_MIN_MAX:
+		f54->report_size = FULL_RAW_CAP_MIN_MAX_DATA_SIZE;
+		break;
+	case F54_RX_TO_RX2:
+	case F54_RX_OPENS2:
+		if (rx <= tx)
+			f54->report_size = 0;
+		else
+			f54->report_size = 2 * rx * (rx - tx);
+		break;
+	case F54_TREX_OPENS:
+	case F54_TREX_TO_GND:
+	case F54_TREX_SHORTS:
+		f54->report_size = TREX_DATA_SIZE;
+		break;
+	default:
+		f54->report_size = 0;
+	}
+
+	return;
+}
+
+static int set_interrupt(bool set)
+{
+	int retval;
+	unsigned char ii;
+	unsigned char zero = 0x00;
+	unsigned char *intr_mask;
+	unsigned short f01_ctrl_reg;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	intr_mask = rmi4_data->intr_mask;
+	f01_ctrl_reg = rmi4_data->f01_ctrl_base_addr + 1 + f54->intr_reg_num;
+
+	if (!set) {
+		retval = f54->fn_ptr->write(rmi4_data,
+				f01_ctrl_reg,
+				&zero,
+				sizeof(zero));
+		if (retval < 0)
+			return retval;
+	}
+
+	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
+		if (intr_mask[ii] != 0x00) {
+			f01_ctrl_reg = rmi4_data->f01_ctrl_base_addr + 1 + ii;
+			if (set) {
+				retval = f54->fn_ptr->write(rmi4_data,
+						f01_ctrl_reg,
+						&zero,
+						sizeof(zero));
+				if (retval < 0)
+					return retval;
+			} else {
+				retval = f54->fn_ptr->write(rmi4_data,
+						f01_ctrl_reg,
+						&(intr_mask[ii]),
+						sizeof(intr_mask[ii]));
+				if (retval < 0)
+					return retval;
+			}
+		}
+	}
+
+	f01_ctrl_reg = rmi4_data->f01_ctrl_base_addr + 1 + f54->intr_reg_num;
+
+	if (set) {
+		retval = f54->fn_ptr->write(rmi4_data,
+				f01_ctrl_reg,
+				&f54->intr_mask,
+				1);
+		if (retval < 0)
+			return retval;
+	}
+
+	return 0;
+}
+
+#ifdef WATCHDOG_HRTIMER
+static void timeout_set_status(struct work_struct *work)
+{
+	int retval;
+	unsigned char command;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->status_mutex);
+	if (f54->status == STATUS_BUSY) {
+		retval = f54->fn_ptr->read(rmi4_data,
+				f54->command_base_addr,
+				&command,
+				sizeof(command));
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read command register\n",
+					__func__);
+		} else if (command & COMMAND_GET_REPORT) {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Report type not supported by FW\n",
+					__func__);
+		} else {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Get report not detected\n",
+					__func__);
+		}
+		f54->status = -ETIMEDOUT;
+		f54->report_type = INVALID_REPORT_TYPE;
+		f54->report_size = 0;
+		set_interrupt(false);
+		wake_unlock(&f54->test_wake_lock);
+	}
+	mutex_unlock(&f54->status_mutex);
+
+	return;
+}
+
+static enum hrtimer_restart get_report_timeout(struct hrtimer *timer)
+{
+	schedule_work(&(f54->timeout_work));
+
+	return HRTIMER_NORESTART;
+}
+#endif
+
+#ifdef RAW_HEX
+static void print_raw_hex_report(void)
+{
+	unsigned int ii;
+
+	pr_info("%s: Report data (raw hex)\n", __func__);
+
+	switch (f54->report_type) {
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_HIGH_RESISTANCE:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP_MIN_MAX:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+	case F54_SENSOR_SPEED:
+	case F54_ADC_RANGE:
+	for (ii = 0; ii < f54->report_size; ii += 2) {
+		pr_info("%03d: 0x%02x%02x\n",
+				ii / 2,
+				f54->report_data[ii + 1],
+				f54->report_data[ii]);
+	}
+		break;
+	default:
+		for (ii = 0; ii < f54->report_size; ii++)
+			pr_info("%03d: 0x%02x\n", ii, f54->report_data[ii]);
+		break;
+	}
+
+	return;
+}
+#endif
+
+#ifdef HUMAN_READABLE
+static void print_image_report(void)
+{
+	unsigned int ii;
+	unsigned int jj;
+	short *report_data;
+
+	switch (f54->report_type) {
+	case F54_16BIT_IMAGE:
+	case F54_RAW_16BIT_IMAGE:
+	case F54_TRUE_BASELINE:
+	case F54_FULL_RAW_CAP:
+	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
+		pr_info("%s: Report data (image)\n", __func__);
+
+		report_data = (short *)f54->report_data;
+
+		for (ii = 0; ii < f54->rmi4_data->num_of_tx; ii++) {
+			for (jj = 0; jj < f54->rmi4_data->num_of_rx; jj++) {
+				if (*report_data < -64)
+					pr_cont(".");
+				else if (*report_data < 0)
+					pr_cont("-");
+				else if (*report_data > 64)
+					pr_cont("*");
+				else if (*report_data > 0)
+					pr_cont("+");
+				else
+					pr_cont("0");
+
+				report_data++;
+			}
+			pr_info("");
+		}
+		pr_info("%s: End of report\n", __func__);
+		break;
+	default:
+		pr_info("%s: Image not supported for report type %d\n",
+				__func__, f54->report_type);
+	}
+
+	return;
+}
+#endif
+
+static void free_control_mem(void)
+{
+	struct f54_control control = f54->control;
+
+	kfree(control.reg_0);
+	kfree(control.reg_1);
+	kfree(control.reg_2);
+	kfree(control.reg_3);
+	kfree(control.reg_4__6);
+	kfree(control.reg_7);
+	kfree(control.reg_8__9);
+	kfree(control.reg_10);
+	kfree(control.reg_11);
+	kfree(control.reg_12__13);
+	kfree(control.reg_14);
+	kfree(control.reg_15->data);
+	kfree(control.reg_15);
+	kfree(control.reg_16->data);
+	kfree(control.reg_16);
+	kfree(control.reg_17->data);
+	kfree(control.reg_17);
+	kfree(control.reg_18->data);
+	kfree(control.reg_18);
+	kfree(control.reg_19->data);
+	kfree(control.reg_19);
+	kfree(control.reg_20);
+	kfree(control.reg_21);
+	kfree(control.reg_22__26);
+	kfree(control.reg_27);
+	kfree(control.reg_28);
+	kfree(control.reg_29);
+	kfree(control.reg_30);
+	kfree(control.reg_31);
+	kfree(control.reg_32__35);
+	kfree(control.reg_36->data);
+	kfree(control.reg_36);
+	kfree(control.reg_37->data);
+	kfree(control.reg_37);
+	kfree(control.reg_38->data);
+	kfree(control.reg_38);
+	kfree(control.reg_39->data);
+	kfree(control.reg_39);
+	kfree(control.reg_40->data);
+	kfree(control.reg_40);
+	kfree(control.reg_89);
+	kfree(control.reg_95->data);
+	kfree(control.reg_95);
+	kfree(control.reg_99);
+	kfree(control.reg_99);
+
+	return;
+}
+
+static void free_data_mem(void)
+{
+	struct f54_data data = f54->data;
+
+	kfree(data.reg_4);
+	kfree(data.reg_6);
+	kfree(data.reg_7_0);
+	kfree(data.reg_7_1);
+	kfree(data.reg_8);
+	kfree(data.reg_9);
+	kfree(data.reg_10);
+	kfree(data.reg_14);
+	kfree(data.reg_16);
+	kfree(data.reg_17);
+}
+
+static void remove_sysfs(void)
+{
+	int reg_num;
+
+	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);
+
+	sysfs_remove_group(f54->attr_dir, &attr_group);
+
+	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++)
+		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);
+
+	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_data_regs); reg_num++)
+		sysfs_remove_group(f54->attr_dir, &attrs_data_regs[reg_num]);
+
+	kobject_put(f54->attr_dir);
+
+	return;
+}
+
+static int synaptics_rmi4_f54_reset(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->status_mutex);
+
+	rmi4_data->irq_enable(rmi4_data, false);
+
+	retval = rmi4_data->reset_device(rmi4_data, NULL);
+
+	rmi4_data->irq_enable(rmi4_data, true);
+
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Failed to issue reset command, error = %d\n",
+				__func__, retval);
+		return retval;
+	}
+
+	f54->status = STATUS_IDLE;
+
+	mutex_unlock(&f54->status_mutex);
+
+	return 0;
+}
+
+static ssize_t synaptics_rmi4_f54_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int reset;
+
+	if (sscanf(buf, "%u", &reset) != 1)
+		return -EINVAL;
+
+	if (reset != 1)
+		return -EINVAL;
+
+	retval = synaptics_rmi4_f54_reset();
+	if (retval < 0)
+		return retval;
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", f54->status);
+}
+
+static ssize_t synaptics_rmi4_f54_report_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_size);
+}
+
+static ssize_t synaptics_rmi4_f54_num_of_mapped_rx_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->rmi4_data->num_of_rx);
+}
+
+static ssize_t synaptics_rmi4_f54_num_of_mapped_tx_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->rmi4_data->num_of_tx);
+}
+
+static ssize_t synaptics_rmi4_f54_no_auto_cal_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->no_auto_cal);
+}
+
+static ssize_t synaptics_rmi4_f54_no_auto_cal_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char data;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting > 1)
+		return -EINVAL;
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->control_base_addr,
+			&data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read control register\n",
+				__func__);
+		return retval;
+	}
+
+	if ((data & NO_AUTO_CAL_MASK) == setting)
+		return count;
+
+	data = (data & ~NO_AUTO_CAL_MASK) | (data & NO_AUTO_CAL_MASK);
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->control_base_addr,
+			&data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write control register\n",
+				__func__);
+		return retval;
+	}
+
+	f54->no_auto_cal = (setting == 1);
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_report_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", f54->report_type);
+}
+
+static int synaptics_rmi4_f54_report_type_set(enum f54_report_types report_type)
+{
+	int retval = -EINVAL;
+	unsigned char data;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+	int report_type_valid = is_report_type_valid(report_type);
+
+	if (!report_type_valid)
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Report type not supported by driver\n", __func__);
+
+	if (report_type_valid) {
+		mutex_lock(&f54->status_mutex);
+		f54->report_type = report_type;
+		data = (unsigned char)report_type;
+		retval = f54->fn_ptr->write(rmi4_data,
+				f54->data_base_addr,
+				&data,
+				sizeof(data));
+		mutex_unlock(&f54->status_mutex);
+	} else
+		f54->report_type = INVALID_REPORT_TYPE;
+
+	if (retval < 0)
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Failed to write data register\n", __func__);
+
+	return retval;
+}
+
+static ssize_t synaptics_rmi4_f54_report_type_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (f54->status != STATUS_BUSY) {
+		retval = synaptics_rmi4_f54_report_type_set(
+			(enum f54_report_types)setting);
+
+		if (retval < 0)
+			return retval;
+
+		return count;
+	} else {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Previous get report still ongoing\n",
+				__func__);
+		return -EINVAL;
+	}
+}
+
+static ssize_t synaptics_rmi4_f54_user_report_type1_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->user_report_type1);
+}
+
+static ssize_t synaptics_rmi4_f54_user_report_type2_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->user_report_type2);
+}
+
+static ssize_t synaptics_rmi4_f54_fifoindex_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	unsigned char data[2];
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
+			data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read data registers\n",
+				__func__);
+		return retval;
+	}
+
+	batohs(&f54->fifoindex, data);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", f54->fifoindex);
+}
+static ssize_t synaptics_rmi4_f54_fifoindex_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char data[2];
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	f54->fifoindex = setting;
+
+	hstoba(data, (unsigned short)setting);
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
+			data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write data registers\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+ssize_t send_get_report_command(void)
+{
+	int retval;
+	unsigned char command = (unsigned char)COMMAND_GET_REPORT;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+	mutex_lock(&f54->status_mutex);
+
+	if (f54->status != STATUS_IDLE) {
+		if (f54->status != STATUS_BUSY) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Invalid status (%d)\n",
+					__func__, f54->status);
+		} else {
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Previous get report still ongoing\n",
+					__func__);
+		}
+		mutex_unlock(&f54->status_mutex);
+		return -EBUSY;
+	}
+
+	wake_lock(&f54->test_wake_lock);
+	set_interrupt(true);
+	f54->status = STATUS_BUSY;
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+
+	mutex_unlock(&f54->status_mutex);
+
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write get report command\n",
+				__func__);
+		goto error_exit;
+	}
+
+#ifdef WATCHDOG_HRTIMER
+	hrtimer_start(&f54->watchdog,
+			ktime_set(WATCHDOG_TIMEOUT_S, 0),
+			HRTIMER_MODE_REL);
+#endif
+out:
+	return retval;
+
+error_exit:
+	mutex_lock(&f54->status_mutex);
+	set_interrupt(false);
+	wake_unlock(&f54->test_wake_lock);
+	f54->status = retval;
+	mutex_unlock(&f54->status_mutex);
+
+	goto out;
+}
+
+static ssize_t synaptics_rmi4_f54_get_report_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return -EINVAL;
+
+	if (!is_report_type_valid(f54->report_type)) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Invalid report type\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	retval = send_get_report_command();
+	if (retval < 0)
+		return retval;
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_force_update_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	unsigned char data[1];
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->command_base_addr,
+			data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read command 0 register\n",
+				__func__);
+		return retval;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+		(data[0] & COMMAND_FORCE_UPDATE) == COMMAND_FORCE_UPDATE);
+}
+
+static ssize_t synaptics_rmi4_f54_force_update_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char command;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return count;
+
+	command = (unsigned char)COMMAND_FORCE_UPDATE;
+
+	if (f54->status == STATUS_BUSY)
+		return -EBUSY;
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write force update command\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_f54_enter_in_cell_test_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	unsigned char data[1];
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->command_base_addr,
+			data,
+			sizeof(data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read command 0 register\n",
+				__func__);
+		return retval;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+		(data[0] & COMMAND_ENTER_IN_CELL_TESTMODE) ==
+			COMMAND_ENTER_IN_CELL_TESTMODE);
+}
+
+
+static ssize_t synaptics_rmi4_f54_enter_in_cell_test_mode_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char command;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return count;
+
+	command = (unsigned char)COMMAND_ENTER_IN_CELL_TESTMODE;
+
+	if (f54->status == STATUS_BUSY)
+		return -EBUSY;
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+		"%s: Failed to write Enter In-Cell Test Mode command\n",
+			__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+
+static ssize_t synaptics_rmi4_f54_force_cal_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned char command;
+	unsigned long setting;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	retval = sstrtoul(buf, 10, &setting);
+	if (retval)
+		return retval;
+
+	if (setting != 1)
+		return count;
+
+	command = (unsigned char)COMMAND_FORCE_CAL;
+
+	if (f54->status == STATUS_BUSY)
+		return -EBUSY;
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->command_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write force cal command\n",
+				__func__);
+		return retval;
+	}
+
+	return count;
+}
+
+simple_show_func_unsigned(query, num_of_rx_electrodes)
+simple_show_func_unsigned(query, num_of_tx_electrodes)
+simple_show_func_unsigned(query, has_image16)
+simple_show_func_unsigned(query, has_image8)
+simple_show_func_unsigned(query, has_baseline)
+simple_show_func_unsigned(query, clock_rate)
+simple_show_func_unsigned(query, touch_controller_family)
+simple_show_func_unsigned(query, has_pixel_touch_threshold_adjustment)
+simple_show_func_unsigned(query, has_sensor_assignment)
+simple_show_func_unsigned(query, has_interference_metric)
+simple_show_func_unsigned(query, has_sense_frequency_control)
+simple_show_func_unsigned(query, has_firmware_noise_mitigation)
+simple_show_func_unsigned(query, has_two_byte_report_rate)
+simple_show_func_unsigned(query, has_one_byte_report_rate)
+simple_show_func_unsigned(query, has_relaxation_control)
+simple_show_func_unsigned(query, curve_compensation_mode)
+simple_show_func_unsigned(query, has_iir_filter)
+simple_show_func_unsigned(query, has_cmn_removal)
+simple_show_func_unsigned(query, has_cmn_maximum)
+simple_show_func_unsigned(query, has_touch_hysteresis)
+simple_show_func_unsigned(query, has_edge_compensation)
+simple_show_func_unsigned(query, has_per_frequency_noise_control)
+simple_show_func_unsigned(query, has_enhanced_stretch)
+simple_show_func_unsigned(query, has_force_fast_relaxation)
+simple_show_func_unsigned(query, has_multi_metric_state_machine)
+simple_show_func_unsigned(query, has_signal_clarity)
+simple_show_func_unsigned(query, has_variance_metric)
+simple_show_func_unsigned(query, has_0d_relaxation_control)
+simple_show_func_unsigned(query, has_0d_acquisition_control)
+simple_show_func_unsigned(query, has_status)
+simple_show_func_unsigned(query, has_slew_metric)
+simple_show_func_unsigned(query, has_h_blank)
+simple_show_func_unsigned(query, has_v_blank)
+simple_show_func_unsigned(query, has_long_h_blank)
+simple_show_func_unsigned(query, has_startup_fast_relaxation)
+simple_show_func_unsigned(query, has_esd_control)
+simple_show_func_unsigned(query, has_noise_mitigation2)
+simple_show_func_unsigned(query, has_noise_state)
+simple_show_func_unsigned(query, has_energy_ratio_relaxation)
+simple_show_func_unsigned(query12, number_of_sensing_frequencies)
+simple_show_func_unsigned(query17, q17_num_of_sense_freqs)
+show_store_func_unsigned(data, reg_4, d4_inhibit_freq_shift)
+show_store_func_unsigned(data, reg_4, d4_baseline_sel)
+show_store_func_unsigned(data, reg_4, d4_sense_freq_sel)
+show_store_func_unsigned(data, reg_16, d16_freq_scan_im_lsb)
+show_store_func_unsigned(data, reg_16, d16_freq_scan_im_msb)
+show_store_func_unsigned(data, reg_17, d17_inhibit_freq_shift)
+show_store_func_unsigned(data, reg_17, d17_freq)
+show_func_unsigned(data, reg_6, d6_interference_metric_lsb)
+show_func_unsigned(data, reg_6, d6_interference_metric_msb)
+show_func_unsigned(data, reg_7_0, d7_current_report_rate_lsb)
+show_func_unsigned(data, reg_7_1, d7_current_report_rate_msb)
+show_func_unsigned(data, reg_8, d8_variance_metric_lsb)
+show_func_unsigned(data, reg_8, d8_variance_metric_msb)
+show_func_unsigned(data, reg_9, d9_averaged_im_lsb)
+show_func_unsigned(data, reg_9, d9_averaged_im_msb)
+show_func_unsigned(data, reg_10, d10_noise_state)
+show_func_unsigned(data, reg_14, d14_cid_im_lsb)
+show_func_unsigned(data, reg_14, d14_cid_im_msb)
+
+show_store_func_unsigned(control, reg_0, no_relax)
+show_store_func_unsigned(control, reg_0, no_scan)
+show_store_func_unsigned(control, reg_1, bursts_per_cluster)
+show_store_func_unsigned(control, reg_2, saturation_cap)
+show_store_func_unsigned(control, reg_3, pixel_touch_threshold)
+show_store_func_unsigned(control, reg_4__6, rx_feedback_cap)
+show_store_func_unsigned(control, reg_4__6, low_ref_cap)
+show_store_func_unsigned(control, reg_4__6, low_ref_feedback_cap)
+show_store_func_unsigned(control, reg_4__6, low_ref_polarity)
+show_store_func_unsigned(control, reg_4__6, high_ref_cap)
+show_store_func_unsigned(control, reg_4__6, high_ref_feedback_cap)
+show_store_func_unsigned(control, reg_4__6, high_ref_polarity)
+show_store_func_unsigned(control, reg_7, cbc_cap)
+show_store_func_unsigned(control, reg_7, cbc_polarity)
+show_store_func_unsigned(control, reg_7, cbc_tx_carrier_selection)
+show_store_func_unsigned(control, reg_8__9, integration_duration)
+show_store_func_unsigned(control, reg_8__9, reset_duration)
+show_store_func_unsigned(control, reg_10, noise_sensing_bursts_per_image)
+show_store_func_unsigned(control, reg_12__13, slow_relaxation_rate)
+show_store_func_unsigned(control, reg_12__13, fast_relaxation_rate)
+show_store_func_unsigned(control, reg_14, rxs_on_xaxis)
+show_store_func_unsigned(control, reg_14, curve_comp_on_txs)
+show_store_func_unsigned(control, reg_20, disable_noise_mitigation)
+show_store_func_unsigned(control, reg_21, freq_shift_noise_threshold)
+show_store_func_unsigned(control, reg_22__26, medium_noise_threshold)
+show_store_func_unsigned(control, reg_22__26, high_noise_threshold)
+show_store_func_unsigned(control, reg_22__26, noise_density)
+show_store_func_unsigned(control, reg_22__26, frame_count)
+show_store_func_unsigned(control, reg_27, iir_filter_coef)
+show_store_func_unsigned(control, reg_28, quiet_threshold)
+show_store_func_unsigned(control, reg_29, cmn_filter_disable)
+show_store_func_unsigned(control, reg_30, cmn_filter_max)
+show_store_func_unsigned(control, reg_31, touch_hysteresis)
+show_store_func_unsigned(control, reg_32__35, rx_low_edge_comp)
+show_store_func_unsigned(control, reg_32__35, rx_high_edge_comp)
+show_store_func_unsigned(control, reg_32__35, tx_low_edge_comp)
+show_store_func_unsigned(control, reg_32__35, tx_high_edge_comp)
+
+show_replicated_func_unsigned(control, reg_15, sensor_rx_assignment)
+show_replicated_func_unsigned(control, reg_16, sensor_tx_assignment)
+show_replicated_func_unsigned(control, reg_17, disable)
+show_replicated_func_unsigned(control, reg_17, filter_bandwidth)
+show_replicated_func_unsigned(control, reg_19, stretch_duration)
+show_replicated_func_unsigned(control, reg_38, noise_control_1)
+show_replicated_func_unsigned(control, reg_39, noise_control_2)
+show_replicated_func_unsigned(control, reg_40, noise_control_3)
+
+show_store_replicated_func_unsigned(control, reg_36, axis1_comp)
+show_store_replicated_func_unsigned(control, reg_37, axis2_comp)
+
+show_store_func_unsigned(control, reg_89, c89_cid_sel_opt)
+show_store_func_unsigned(control, reg_89, c89_cid_voltage_sel)
+show_store_func_unsigned(control, reg_89, c89_cid_im_noise_threshold_lsb)
+show_store_func_unsigned(control, reg_89, c89_cid_im_noise_threshold_msb)
+show_store_func_unsigned(control, reg_89, c89_fnm_pixel_touch_mult)
+show_store_func_unsigned(control, reg_89, c89_freq_scan_threshold_lsb)
+show_store_func_unsigned(control, reg_89, c89_freq_scan_threshold_msb)
+show_store_func_unsigned(control, reg_89, c89_quiet_im_threshold_lsb)
+show_store_func_unsigned(control, reg_89, c89_quiet_im_threshold_msb)
+
+show_store_func_unsigned(control, reg_93, c93_freq_shift_noise_threshold_lsb)
+show_store_func_unsigned(control, reg_93, c93_freq_shift_noise_threshold_msb)
+
+show_store_replicated_func_unsigned(control, reg_95, c95_disable)
+show_store_replicated_func_unsigned(control, reg_95, c95_filter_bw)
+show_store_replicated_func_unsigned(control, reg_95, c95_first_burst_length_lsb)
+show_store_replicated_func_unsigned(control, reg_95, c95_first_burst_length_msb)
+show_store_replicated_func_unsigned(control, reg_95, c95_addl_burst_length_lsb)
+show_store_replicated_func_unsigned(control, reg_95, c95_addl_burst_length_msb)
+show_store_replicated_func_unsigned(control, reg_95, c95_i_stretch)
+show_store_replicated_func_unsigned(control, reg_95, c95_r_stretch)
+show_store_replicated_func_unsigned(control, reg_95, c95_noise_control1)
+show_store_replicated_func_unsigned(control, reg_95, c95_noise_control2)
+show_store_replicated_func_unsigned(control, reg_95, c95_noise_control3)
+show_store_replicated_func_unsigned(control, reg_95, c95_noise_control4)
+
+show_store_func_unsigned(control, reg_99, c99_int_dur_lsb)
+show_store_func_unsigned(control, reg_99, c99_int_dur_msb)
+show_store_func_unsigned(control, reg_99, c99_reset_dur)
+
+show_store_func_unsigned(control, reg_107, c107_abs_int_dur)
+show_store_func_unsigned(control, reg_107, c107_abs_reset_dur)
+show_store_func_unsigned(control, reg_107, c107_abs_filter_bw)
+show_store_func_unsigned(control, reg_107, c107_abs_rstretch)
+show_store_func_unsigned(control, reg_107, c107_abs_burst_count_1)
+show_store_func_unsigned(control, reg_107, c107_abs_burst_count_2)
+show_store_func_unsigned(control, reg_107, c107_abs_stretch_dur)
+show_store_func_unsigned(control, reg_107, c107_abs_adc_clock_div)
+show_store_func_unsigned(control, reg_107, c107_abs_sub_burtst_size)
+show_store_func_unsigned(control, reg_107, c107_abs_trigger_delay)
+
+show_store_func_unsigned(control, reg_137, c137_cmnr_adjust)
+
+simple_show_func_unsigned(query_f55_0_2, f55_q2_has_single_layer_multitouch)
+show_func_unsigned(control, reg_0_f55, f55_c0_receivers_on_x)
+show_func_unsigned(control, reg_8_f55, f55_c8_pattern_type)
+
+static ssize_t synaptics_rmi4_f54_burst_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int retval;
+	int size = 0;
+	unsigned char ii;
+	unsigned char *temp;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->control_mutex);
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->control.reg_17->address,
+			(unsigned char *)f54->control.reg_17->data,
+			f54->control.reg_17->length);
+	if (retval < 0) {
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read control reg_17\n",
+				__func__);
+	}
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->control.reg_18->address,
+			(unsigned char *)f54->control.reg_18->data,
+			f54->control.reg_18->length);
+	if (retval < 0) {
+		dev_dbg(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read control reg_18\n",
+				__func__);
+	}
+
+	mutex_unlock(&f54->control_mutex);
+
+	temp = buf;
+
+	for (ii = 0; ii < f54->control.reg_17->length; ii++) {
+		retval = snprintf(temp, PAGE_SIZE - size, "%u ", (1 << 8) *
+			f54->control.reg_17->data[ii].burst_count_b8__10 +
+			f54->control.reg_18->data[ii].burst_count_b0__7);
+		if (retval < 0) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Faild to write output\n",
+					__func__);
+			return retval;
+		}
+		size += retval;
+		temp += retval;
+	}
+
+	retval = snprintf(temp, PAGE_SIZE - size, "\n");
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Faild to write null terminator\n",
+				__func__);
+		return retval;
+	}
+
+	return size + retval;
+}
+
+static ssize_t synaptics_rmi4_f54_user_get_report_show(
+	char *buf, enum f54_report_types report_type)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	if (f54->status != STATUS_IDLE) {
+		if (f54->status == STATUS_BUSY)
+			dev_err(&rmi4_data->i2c_client->dev,
+				"%s: WARNING: Resetting in busy state\n",
+				__func__);
+
+		retval = synaptics_rmi4_f54_reset();
+		if (retval < 0)
+			goto out;
+	}
+
+	retval = synaptics_rmi4_f54_report_type_set(report_type);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Failed to set report type\n", __func__);
+		goto out;
+	}
+
+	retval = send_get_report_command();
+
+out:
+	retval = scnprintf(buf, PAGE_SIZE, "%d\n", retval);
+	return retval;
+}
+
+static ssize_t synaptics_rmi4_f54_user_get_report1_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return synaptics_rmi4_f54_user_get_report_show(
+		buf, f54->user_report_type1);
+}
+
+static ssize_t synaptics_rmi4_f54_user_get_report2_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return synaptics_rmi4_f54_user_get_report_show(
+		buf, f54->user_report_type2);
+}
+
+static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
+		struct kobject *kobj, struct bin_attribute *attributes,
+		char *buf, loff_t pos, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	mutex_lock(&f54->data_mutex);
+
+	if (!f54->report_data || !f54->report_size) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Report type %d data not available\n",
+				__func__, f54->report_type);
+		mutex_unlock(&f54->data_mutex);
+		return -EINVAL;
+	}
+	if (pos > f54->report_size || pos < 0) {
+		mutex_unlock(&f54->data_mutex);
+		return 0;
+	}
+
+	count = min_t(loff_t, count, f54->report_size - pos);
+	memcpy(buf, f54->report_data + pos, count);
+	mutex_unlock(&f54->data_mutex);
+	return count;
+}
+
+static int synaptics_rmi4_f54_set_sysfs(void)
+{
+	int retval;
+	int reg_num;
+	int dreg_num;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	f54->attr_dir = kobject_create_and_add("f54",
+			&rmi4_data->i2c_client->dev.kobj);
+	if (!f54->attr_dir) {
+		dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Failed to create sysfs directory\n",
+			__func__);
+		goto exit_1;
+	}
+
+	retval = sysfs_create_bin_file(f54->attr_dir, &dev_report_data);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create sysfs bin file\n",
+				__func__);
+		goto exit_2;
+	}
+
+	retval = sysfs_create_group(f54->attr_dir, &attr_group);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create sysfs attributes\n",
+				__func__);
+		goto exit_3;
+	}
+
+	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++) {
+		if (attrs_ctrl_regs_exist[reg_num]) {
+			retval = sysfs_create_group(f54->attr_dir,
+					&attrs_ctrl_regs[reg_num]);
+			if (retval < 0) {
+				dev_err(&rmi4_data->i2c_client->dev,
+						"%s: Failed to create sysfs attributes\n",
+						__func__);
+				goto exit_4;
+			}
+		}
+	}
+
+	for (dreg_num = 0; dreg_num < ARRAY_SIZE(attrs_data_regs); dreg_num++) {
+		if (attrs_data_regs_exist[dreg_num]) {
+			retval = sysfs_create_group(f54->attr_dir,
+					&attrs_data_regs[dreg_num]);
+			if (retval < 0) {
+				dev_err(&rmi4_data->i2c_client->dev,
+						"%s: Failed to create sysfs attributes for data register %d\n",
+						__func__, dreg_num);
+				goto exit_5;
+			}
+		}
+	}
+
+	return 0;
+
+exit_5:
+	for (dreg_num--; dreg_num >= 0; dreg_num--)
+		sysfs_remove_group(f54->attr_dir, &attrs_data_regs[dreg_num]);
+
+exit_4:
+	for (reg_num--; reg_num >= 0; reg_num--)
+		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);
+
+	sysfs_remove_group(f54->attr_dir, &attr_group);
+
+exit_3:
+	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);
+
+exit_2:
+	kobject_put(f54->attr_dir);
+
+exit_1:
+	return -ENODEV;
+}
+
+/*
+ * Fill in base register address and offset of F54
+ * control registers to allow run time patching
+ */
+int synaptics_rmi4_scan_f54_ctrl_reg_info(
+	struct synaptics_rmi4_func_packet_regs *f54_ctrl_regs)
+{
+	int ii, error = f54_ctrl_regs->nr_regs;
+	unsigned char *data;
+	struct synaptics_rmi4_packet_reg *reg;
+	struct synaptics_rmi4_subpkt *subpkt;
+
+	f54_ctrl_regs->base_addr = f54->control_base_addr;
+	for (ii = 0; ii < f54_ctrl_regs->nr_regs; ii++) {
+		reg = &f54_ctrl_regs->regs[ii];
+		subpkt = &reg->subpkt[0];
+		if (reg->r_number == 2 && f54->control.reg_2) {
+			data = kzalloc(sizeof(f54->control.reg_2->data),
+					GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->control.reg_2->address -
+					f54->control_base_addr;
+			reg->size = 2;
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+			error--;
+			continue;
+		}
+
+		if (reg->r_number == 95 && f54->control.reg_95) {
+			int jj, num_of_subpkts;
+			data = kzalloc(f54->control.reg_95->length, GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->control.reg_95->address -
+					f54->control_base_addr;
+			reg->size = f54->control.reg_95->length;
+			reg->data = data;
+			/* not going over the number of predefined subpackets */
+			num_of_subpkts = min((int)reg->nr_subpkts,
+				(int)(f54->control.reg_95->length /
+				subpkt->size));
+			for (jj = 0; jj < num_of_subpkts; jj++) {
+				subpkt = &reg->subpkt[jj];
+				subpkt->present = true;
+				subpkt->offset = jj * subpkt->size;
+			}
+			error--;
+		}
+	}
+	return error;
+}
+
+/*
+ * Fill in base register address and offset of F54
+ * command register to allow run time patching
+ */
+int synaptics_rmi4_scan_f54_cmd_reg_info(
+	struct synaptics_rmi4_func_packet_regs *f54_cmd_regs)
+{
+	unsigned char *data;
+	struct synaptics_rmi4_packet_reg *reg = f54_cmd_regs->regs;
+	struct synaptics_rmi4_subpkt *subpkt = &reg->subpkt[0];
+
+	f54_cmd_regs->base_addr = f54->command_base_addr;
+	data = kzalloc(1, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+	reg->offset = 0;
+	reg->size = 1;
+	reg->data = data;
+	subpkt->present = true;
+	subpkt->offset = 0;
+	return 0;
+}
+
+/*
+  * Fill in base register address and offset of F54 query
+  * register 12 to allow run time access
+  */
+int synaptics_rmi4_scan_f54_query_reg_info(
+	struct synaptics_rmi4_func_packet_regs *f54_query_regs)
+{
+	struct synaptics_rmi4_packet_reg *reg = f54_query_regs->regs;
+	struct synaptics_rmi4_subpkt *subpkt = &reg->subpkt[0];
+	unsigned char *data = kzalloc(sizeof(f54->query12.data),
+					GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+	f54_query_regs->base_addr = f54->query_base_addr;
+	/* need an offset off of base address here */
+	reg->offset = 12;
+	reg->size = sizeof(f54->query12.data);
+	reg->data = data;
+	subpkt->present = true;
+	subpkt->offset = 0;
+	return 0;
+}
+
+/*
+ * Fill in base register address and offset of F54 data
+ * registers 10 & 17 to allow run time access
+ */
+int synaptics_rmi4_scan_f54_data_reg_info(
+	struct synaptics_rmi4_func_packet_regs *f54_data_regs)
+{
+	int ii, error = f54_data_regs->nr_regs;
+	unsigned char *data;
+	struct synaptics_rmi4_subpkt *subpkt;
+	struct synaptics_rmi4_packet_reg *reg;
+
+	f54_data_regs->base_addr = f54->data_base_addr;
+	for (ii = 0; ii < f54_data_regs->nr_regs; ii++) {
+		reg = &f54_data_regs->regs[ii];
+		if (reg->r_number == 6 && f54->data.reg_6) {
+			subpkt = &reg->subpkt[0];
+			data = kzalloc(sizeof(f54->data.reg_6->data),
+					GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->data.reg_6->address -
+					f54->data_base_addr;
+			reg->size = sizeof(f54->data.reg_6->data);
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+			error--;
+			continue;
+		}
+
+		if (reg->r_number == 10 && f54->data.reg_10) {
+			subpkt = &reg->subpkt[0];
+			data = kzalloc(sizeof(f54->data.reg_10->data),
+					GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->data.reg_10->address -
+					f54->data_base_addr;
+			reg->size = sizeof(f54->data.reg_10->data);
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+			error--;
+			continue;
+		}
+
+		if (reg->r_number == 14 && f54->data.reg_14) {
+			subpkt = &reg->subpkt[0];
+			data = kzalloc(sizeof(f54->data.reg_14->data),
+					GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->data.reg_14->address -
+					f54->data_base_addr;
+			reg->size = sizeof(f54->data.reg_14->data);
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+			error--;
+			continue;
+		}
+
+		if (reg->r_number == 16 && f54->data.reg_16) {
+			subpkt = &reg->subpkt[0];
+			data = kzalloc(sizeof(f54->data.reg_16->data),
+					GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->data.reg_16->address -
+					f54->data_base_addr;
+			reg->size = sizeof(f54->data.reg_16->data);
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+			error--;
+			continue;
+		}
+
+		if (reg->r_number == 17 && f54->data.reg_17) {
+			subpkt = &reg->subpkt[0];
+			data = kzalloc(sizeof(f54->data.reg_17->data),
+					GFP_KERNEL);
+			if (!data)
+				return -ENOMEM;
+			/* need an offset off of base address here */
+			reg->offset = f54->data.reg_17->address -
+					f54->data_base_addr;
+			reg->size = sizeof(f54->data.reg_17->data);
+			reg->data = data;
+			subpkt->present = true;
+			subpkt->offset = 0;
+			error--;
+		}
+	}
+	return error ? -ENOSYS : error;
+}
+
+static int synaptics_rmi4_f54_set_ctrl(void)
+{
+	unsigned char length;
+	unsigned char reg_num = 0;
+	unsigned short reg_addr = f54->control_base_addr;
+	struct f54_control *control = &f54->control;
+	struct f54_query *query = &f54->query;
+	struct f54_query12 *query12 = &f54->query12;
+	struct f54_query13 *query13 = &f54->query13;
+	struct f54_query15 *query15 = &f54->query15;
+	struct f54_query16 *query16 = &f54->query16;
+	struct f54_query17 *query17 = &f54->query17;
+	struct f54_query21 *query21 = &f54->query21;
+	struct f54_query22 *query22 = &f54->query22;
+	struct f54_query23 *query23 = &f54->query23;
+	struct f54_query25 *query25 = &f54->query25;
+	struct f54_query27 *query27 = &f54->query27;
+	struct f54_query29 *query29 = &f54->query29;
+	struct f54_query30 *query30 = &f54->query30;
+	struct f54_query32 *query32 = &f54->query32;
+	struct f54_query33 *query33 = &f54->query33;
+	struct f54_query35 *query35 = &f54->query35;
+	struct f54_query36 *query36 = &f54->query36;
+	struct f54_query38 *query38 = &f54->query38;
+	struct f54_query40 *query40 = &f54->query40;
+	struct f54_query46 *query46 = &f54->query46;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	/* control 0 */
+	attrs_ctrl_regs_exist[reg_num] = true;
+	control->reg_0 = kzalloc(sizeof(*(control->reg_0)),
+			GFP_KERNEL);
+	if (!control->reg_0)
+		goto exit_no_mem;
+	control->reg_0->address = reg_addr;
+	reg_addr += sizeof(control->reg_0->data);
+	reg_num++;
+
+	/* control 1 */
+	if ((f54->query.touch_controller_family == 0) ||
+			(f54->query.touch_controller_family == 1)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_1 = kzalloc(sizeof(*(control->reg_1)),
+				GFP_KERNEL);
+		if (!control->reg_1)
+			goto exit_no_mem;
+		control->reg_1->address = reg_addr;
+		reg_addr += sizeof(control->reg_1->data);
+	}
+	reg_num++;
+
+	/* control 2 */
+	attrs_ctrl_regs_exist[reg_num] = true;
+	control->reg_2 = kzalloc(sizeof(*(control->reg_2)),
+			GFP_KERNEL);
+	if (!control->reg_2)
+		goto exit_no_mem;
+	control->reg_2->address = reg_addr;
+	reg_addr += sizeof(control->reg_2->data);
+	reg_num++;
+
+	/* control 3 */
+	if (f54->query.has_pixel_touch_threshold_adjustment == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_3 = kzalloc(sizeof(*(control->reg_3)),
+				GFP_KERNEL);
+		if (!control->reg_3)
+			goto exit_no_mem;
+		control->reg_3->address = reg_addr;
+		reg_addr += sizeof(control->reg_3->data);
+	}
+	reg_num++;
+
+	/* controls 4 5 6 */
+	if ((f54->query.touch_controller_family == 0) ||
+			(f54->query.touch_controller_family == 1)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_4__6 = kzalloc(sizeof(*(control->reg_4__6)),
+				GFP_KERNEL);
+		if (!control->reg_4__6)
+			goto exit_no_mem;
+		control->reg_4__6->address = reg_addr;
+		reg_addr += sizeof(control->reg_4__6->data);
+	}
+	reg_num++;
+
+	/* control 7 */
+	if (f54->query.touch_controller_family == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_7 = kzalloc(sizeof(*(control->reg_7)),
+				GFP_KERNEL);
+		if (!control->reg_7)
+			goto exit_no_mem;
+		control->reg_7->address = reg_addr;
+		reg_addr += sizeof(control->reg_7->data);
+	}
+	reg_num++;
+
+	/* controls 8 9 */
+	if ((f54->query.touch_controller_family == 0) ||
+			(f54->query.touch_controller_family == 1)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_8__9 = kzalloc(sizeof(*(control->reg_8__9)),
+				GFP_KERNEL);
+		if (!control->reg_8__9)
+			goto exit_no_mem;
+		control->reg_8__9->address = reg_addr;
+		reg_addr += sizeof(control->reg_8__9->data);
+	}
+	reg_num++;
+
+	/* control 10 */
+	if (f54->query.has_interference_metric == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_10 = kzalloc(sizeof(*(control->reg_10)),
+				GFP_KERNEL);
+		if (!control->reg_10)
+			goto exit_no_mem;
+		control->reg_10->address = reg_addr;
+		reg_addr += sizeof(control->reg_10->data);
+	}
+	reg_num++;
+
+	/* control 11 */
+	if (f54->query.has_ctrl11 == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_11 = kzalloc(sizeof(*(control->reg_11)),
+				GFP_KERNEL);
+		if (!control->reg_11)
+			goto exit_no_mem;
+		control->reg_11->address = reg_addr;
+		reg_addr += sizeof(control->reg_11->data);
+	}
+	reg_num++;
+
+	/* controls 12 13 */
+	if (f54->query.has_relaxation_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_12__13 = kzalloc(sizeof(*(control->reg_12__13)),
+				GFP_KERNEL);
+		if (!control->reg_12__13)
+			goto exit_no_mem;
+		control->reg_12__13->address = reg_addr;
+		reg_addr += sizeof(control->reg_12__13->data);
+	}
+	reg_num++;
+
+	/* controls 14 15 16 */
+	if (f54->query.has_sensor_assignment == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		control->reg_14 = kzalloc(sizeof(*(control->reg_14)),
+				GFP_KERNEL);
+		if (!control->reg_14)
+			goto exit_no_mem;
+		control->reg_14->address = reg_addr;
+		reg_addr += sizeof(control->reg_14->data);
+
+		control->reg_15 = kzalloc(sizeof(*(control->reg_15)),
+				GFP_KERNEL);
+		if (!control->reg_15)
+			goto exit_no_mem;
+		control->reg_15->length = f54->query.num_of_rx_electrodes;
+		control->reg_15->data = kzalloc(control->reg_15->length *
+				sizeof(*(control->reg_15->data)), GFP_KERNEL);
+		if (!control->reg_15->data)
+			goto exit_no_mem;
+		control->reg_15->address = reg_addr;
+		reg_addr += control->reg_15->length;
+
+		control->reg_16 = kzalloc(sizeof(*(control->reg_16)),
+				GFP_KERNEL);
+		if (!control->reg_16)
+			goto exit_no_mem;
+		control->reg_16->length = f54->query.num_of_tx_electrodes;
+		control->reg_16->data = kzalloc(control->reg_16->length *
+				sizeof(*(control->reg_16->data)), GFP_KERNEL);
+		if (!control->reg_16->data)
+			goto exit_no_mem;
+		control->reg_16->address = reg_addr;
+		reg_addr += control->reg_16->length;
+	}
+	reg_num++;
+
+	/* controls 17 18 19 */
+	if (f54->query.has_sense_frequency_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		length = f54->query12.number_of_sensing_frequencies;
+
+		control->reg_17 = kzalloc(sizeof(*(control->reg_17)),
+				GFP_KERNEL);
+		if (!control->reg_17)
+			goto exit_no_mem;
+		control->reg_17->length = length;
+		control->reg_17->data = kzalloc(length *
+				sizeof(*(control->reg_17->data)), GFP_KERNEL);
+		if (!control->reg_17->data)
+			goto exit_no_mem;
+		control->reg_17->address = reg_addr;
+		reg_addr += length;
+
+		control->reg_18 = kzalloc(sizeof(*(control->reg_18)),
+				GFP_KERNEL);
+		if (!control->reg_18)
+			goto exit_no_mem;
+		control->reg_18->length = length;
+		control->reg_18->data = kzalloc(length *
+				sizeof(*(control->reg_18->data)), GFP_KERNEL);
+		if (!control->reg_18->data)
+			goto exit_no_mem;
+		control->reg_18->address = reg_addr;
+		reg_addr += length;
+
+		control->reg_19 = kzalloc(sizeof(*(control->reg_19)),
+				GFP_KERNEL);
+		if (!control->reg_19)
+			goto exit_no_mem;
+		control->reg_19->length = length;
+		control->reg_19->data = kzalloc(length *
+				sizeof(*(control->reg_19->data)), GFP_KERNEL);
+		if (!control->reg_19->data)
+			goto exit_no_mem;
+		control->reg_19->address = reg_addr;
+		reg_addr += length;
+	}
+	reg_num++;
+
+	/* control 20 */
+	attrs_ctrl_regs_exist[reg_num] = true;
+	control->reg_20 = kzalloc(sizeof(*(control->reg_20)),
+			GFP_KERNEL);
+	if (!control->reg_20)
+		goto exit_no_mem;
+	control->reg_20->address = reg_addr;
+	reg_addr += sizeof(control->reg_20->data);
+	reg_num++;
+
+	/* control 21 */
+	if (f54->query.has_sense_frequency_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_21 = kzalloc(sizeof(*(control->reg_21)),
+				GFP_KERNEL);
+		if (!control->reg_21)
+			goto exit_no_mem;
+		control->reg_21->address = reg_addr;
+		reg_addr += sizeof(control->reg_21->data);
+	}
+	reg_num++;
+
+	/* controls 22 23 24 25 26 */
+	if (f54->query.has_firmware_noise_mitigation == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_22__26 = kzalloc(sizeof(*(control->reg_22__26)),
+				GFP_KERNEL);
+		if (!control->reg_22__26)
+			goto exit_no_mem;
+		control->reg_22__26->address = reg_addr;
+		reg_addr += sizeof(control->reg_22__26->data);
+	}
+	reg_num++;
+
+	/* control 27 */
+	if (f54->query.has_iir_filter == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_27 = kzalloc(sizeof(*(control->reg_27)),
+				GFP_KERNEL);
+		if (!control->reg_27)
+			goto exit_no_mem;
+		control->reg_27->address = reg_addr;
+		reg_addr += sizeof(control->reg_27->data);
+	}
+	reg_num++;
+
+	/* control 28 */
+	if (f54->query.has_firmware_noise_mitigation == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_28 = kzalloc(sizeof(*(control->reg_28)),
+				GFP_KERNEL);
+		if (!control->reg_28)
+			goto exit_no_mem;
+		control->reg_28->address = reg_addr;
+		reg_addr += sizeof(control->reg_28->data);
+	}
+	reg_num++;
+
+	/* control 29 */
+	if (f54->query.has_cmn_removal == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_29 = kzalloc(sizeof(*(control->reg_29)),
+				GFP_KERNEL);
+		if (!control->reg_29)
+			goto exit_no_mem;
+		control->reg_29->address = reg_addr;
+		reg_addr += sizeof(control->reg_29->data);
+	}
+	reg_num++;
+
+	/* control 30 */
+	if (f54->query.has_cmn_maximum == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_30 = kzalloc(sizeof(*(control->reg_30)),
+				GFP_KERNEL);
+		if (!control->reg_30)
+			goto exit_no_mem;
+		control->reg_30->address = reg_addr;
+		reg_addr += sizeof(control->reg_30->data);
+	}
+	reg_num++;
+
+	/* control 31 */
+	if (f54->query.has_touch_hysteresis == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_31 = kzalloc(sizeof(*(control->reg_31)),
+				GFP_KERNEL);
+		if (!control->reg_31)
+			goto exit_no_mem;
+		control->reg_31->address = reg_addr;
+		reg_addr += sizeof(control->reg_31->data);
+	}
+	reg_num++;
+
+	/* controls 32 33 34 35 */
+	if (f54->query.has_edge_compensation == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+		control->reg_32__35 = kzalloc(sizeof(*(control->reg_32__35)),
+				GFP_KERNEL);
+		if (!control->reg_32__35)
+			goto exit_no_mem;
+		control->reg_32__35->address = reg_addr;
+		reg_addr += sizeof(control->reg_32__35->data);
+	}
+	reg_num++;
+
+	/* control 36 */
+	if ((f54->query.curve_compensation_mode == 1) ||
+			(f54->query.curve_compensation_mode == 2)) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		if (f54->query.curve_compensation_mode == 1) {
+			length = max(f54->query.num_of_rx_electrodes,
+					f54->query.num_of_tx_electrodes);
+		} else if (f54->query.curve_compensation_mode == 2) {
+			length = f54->query.num_of_rx_electrodes;
+		}
+
+		control->reg_36 = kzalloc(sizeof(*(control->reg_36)),
+				GFP_KERNEL);
+		if (!control->reg_36)
+			goto exit_no_mem;
+		control->reg_36->length = length;
+		control->reg_36->data = kzalloc(length *
+				sizeof(*(control->reg_36->data)), GFP_KERNEL);
+		if (!control->reg_36->data)
+			goto exit_no_mem;
+		control->reg_36->address = reg_addr;
+		reg_addr += length;
+	}
+	reg_num++;
+
+	/* control 37 */
+	if (f54->query.curve_compensation_mode == 2) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		control->reg_37 = kzalloc(sizeof(*(control->reg_37)),
+				GFP_KERNEL);
+		if (!control->reg_37)
+			goto exit_no_mem;
+		control->reg_37->length = f54->query.num_of_tx_electrodes;
+		control->reg_37->data = kzalloc(control->reg_37->length *
+				sizeof(*(control->reg_37->data)), GFP_KERNEL);
+		if (!control->reg_37->data)
+			goto exit_no_mem;
+
+		control->reg_37->address = reg_addr;
+		reg_addr += control->reg_37->length;
+	}
+	reg_num++;
+
+	/* controls 38 39 40 */
+	if (f54->query.has_per_frequency_noise_control == 1) {
+		attrs_ctrl_regs_exist[reg_num] = true;
+
+		control->reg_38 = kzalloc(sizeof(*(control->reg_38)),
+				GFP_KERNEL);
+		if (!control->reg_38)
+			goto exit_no_mem;
+		control->reg_38->length =
+			f54->query12.number_of_sensing_frequencies;
+
+		control->reg_38->data = kzalloc(control->reg_38->length *
+				sizeof(*(control->reg_38->data)), GFP_KERNEL);
+		if (!control->reg_38->data)
+			goto exit_no_mem;
+		control->reg_38->address = reg_addr;
+		reg_addr += control->reg_38->length;
+
+		control->reg_39 = kzalloc(sizeof(*(control->reg_39)),
+				GFP_KERNEL);
+		if (!control->reg_39)
+			goto exit_no_mem;
+		control->reg_39->length =
+			f54->query12.number_of_sensing_frequencies;
+		control->reg_39->data = kzalloc(control->reg_39->length *
+				sizeof(*(control->reg_39->data)), GFP_KERNEL);
+		if (!control->reg_39->data)
+			goto exit_no_mem;
+		control->reg_39->address = reg_addr;
+		reg_addr += control->reg_39->length;
+
+		control->reg_40 = kzalloc(sizeof(*(control->reg_40)),
+				GFP_KERNEL);
+		if (!control->reg_40)
+			goto exit_no_mem;
+		control->reg_40->length =
+			f54->query12.number_of_sensing_frequencies;
+		control->reg_40->data = kzalloc(control->reg_40->length *
+				sizeof(*(control->reg_40->data)), GFP_KERNEL);
+		if (!control->reg_40->data)
+			goto exit_no_mem;
+		control->reg_40->address = reg_addr;
+		reg_addr += control->reg_40->length;
+	}
+	reg_num++;
+
+	CTRL_REG_PRESENCE(41, 1, query->has_signal_clarity);
+	CTRL_REG_PRESENCE(42, 2, query->has_variance_metric);
+	CTRL_REG_PRESENCE(43, 2, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(44, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(45, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(46, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(47, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(48, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(49, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(50, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(51, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(52, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(53, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(53, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(54, 1, query->has_multi_metric_state_machine);
+	CTRL_REG_PRESENCE(55, 1, query->has_0d_relaxation_control);
+	CTRL_REG_PRESENCE(56, 1, query->has_0d_relaxation_control);
+	CTRL_REG_PRESENCE(57, 1, query->has_0d_acquisition_control);
+	CTRL_REG_PRESENCE(58, 1, query->has_0d_acquisition_control);
+	CTRL_REG_PRESENCE(59, 2, query->has_h_blank);
+	CTRL_REG_PRESENCE(60, 1, query->has_h_blank || query->has_v_blank ||
+				query->has_long_h_blank);
+	CTRL_REG_PRESENCE(61, 1, query->has_h_blank || query->has_v_blank ||
+				query->has_long_h_blank);
+	CTRL_REG_PRESENCE(62, 1, query->has_h_blank || query->has_v_blank ||
+				query->has_long_h_blank);
+	CTRL_REG_PRESENCE(63, 1, query->has_h_blank || query->has_v_blank ||
+				query->has_long_h_blank ||
+				query->has_slew_metric ||
+				query->has_slew_option ||
+				query->has_noise_mitigation2);
+
+	if (query->has_h_blank) {
+		CTRL_REG_PRESENCE(64, 7, 1);
+		CTRL_REG_PRESENCE(65, 7, 1);
+	} else if (query->has_v_blank || query->has_long_h_blank) {
+		CTRL_REG_PRESENCE(64, 1, 1);
+		CTRL_REG_PRESENCE(65, 1, 1);
+	}
+
+	if (query->has_h_blank || query->has_v_blank ||
+		query->has_long_h_blank) {
+		CTRL_REG_PRESENCE(66, 1, 1);
+		CTRL_REG_PRESENCE(67, 1, 1);
+		CTRL_REG_PRESENCE(68, 1, 1);
+		CTRL_REG_PRESENCE(69, 1, 1);
+		CTRL_REG_PRESENCE(70, 1, 1);
+		CTRL_REG_PRESENCE(71, 1, 1);
+		CTRL_REG_PRESENCE(72, 2, 1);
+		CTRL_REG_PRESENCE(73, 2, 1);
+	}
+	CTRL_REG_PRESENCE(74, 2, query->has_slew_metric);
+	CTRL_REG_PRESENCE(75, query12->number_of_sensing_frequencies,
+				query->has_enhanced_stretch &&
+				query->has_sense_frequency_control);
+	CTRL_REG_PRESENCE(76, 1, query->has_startup_fast_relaxation);
+	CTRL_REG_PRESENCE(77, 1, query->has_esd_control);
+	CTRL_REG_PRESENCE(78, 1, query->has_esd_control);
+	CTRL_REG_PRESENCE(79, 1, query->has_noise_mitigation2);
+	CTRL_REG_PRESENCE(80, 1, query->has_noise_mitigation2);
+	CTRL_REG_PRESENCE(81, 1, query->has_noise_mitigation2);
+	CTRL_REG_PRESENCE(82, 1, query->has_noise_mitigation2);
+	CTRL_REG_PRESENCE(83, 1, query->has_noise_mitigation2);
+	CTRL_REG_PRESENCE(84, 1, query->has_energy_ratio_relaxation);
+	CTRL_REG_PRESENCE(85, 1, query->has_energy_ratio_relaxation);
+	CTRL_REG_PRESENCE(86, 1, query13->has_ctrl86);
+	CTRL_REG_PRESENCE(87, 1, query13->has_ctrl87);
+	CTRL_REG_PRESENCE(88, 1, query->has_ctrl88);
+
+	CTRL_REG_ADD(89, 1, query13->has_cid_im ||
+				query13->has_noise_mitigation_enh ||
+				query13->has_rail_im);
+
+	CTRL_REG_PRESENCE(90, 1, query15->has_ctrl90);
+	CTRL_REG_PRESENCE(91, 1, query21->has_ctrl91);
+	CTRL_REG_PRESENCE(92, 1, query16->has_ctrl92);
+
+	CTRL_REG_ADD(93, 1, query16->has_ctrl93);
+
+	CTRL_REG_PRESENCE(94, 1, query16->has_ctrl94_query18);
+
+	CTRL_REG_ADD_EXT(95, 1, query16->has_ctrl95_query19,
+		sizeof(struct f54_control_95n) *
+		query17->q17_num_of_sense_freqs);
+
+	CTRL_REG_PRESENCE(96, 1, query21->has_ctrl96);
+	CTRL_REG_PRESENCE(97, 1, query21->has_ctrl97);
+	CTRL_REG_PRESENCE(98, 1, query21->has_ctrl98);
+
+	CTRL_REG_ADD(99, 1, query->touch_controller_family == 2);
+
+	CTRL_REG_PRESENCE(100, 1, query16->has_ctrl100);
+	CTRL_REG_PRESENCE(101, 1, query22->has_ctrl101);
+	CTRL_REG_PRESENCE(102, 1, query23->has_ctrl102);
+	CTRL_REG_PRESENCE(103, 1, query22->has_ctrl103_query26);
+	CTRL_REG_PRESENCE(104, 1, query22->has_ctrl104);
+	CTRL_REG_PRESENCE(105, 1, query22->has_ctrl105);
+	CTRL_REG_PRESENCE(106, 1, query25->has_ctrl106);
+
+	CTRL_REG_ADD(107, 1, query25->has_ctrl107);
+
+	CTRL_REG_PRESENCE(108, 1, query25->has_ctrl108);
+	CTRL_REG_PRESENCE(109, 1, query25->has_ctrl109);
+	CTRL_REG_PRESENCE(110, 1, query27->has_ctrl110);
+	CTRL_REG_PRESENCE(111, 1, query27->has_ctrl111);
+	CTRL_REG_PRESENCE(112, 1, query27->has_ctrl112);
+	CTRL_REG_PRESENCE(113, 1, query27->has_ctrl113);
+	CTRL_REG_PRESENCE(114, 1, query27->has_ctrl114);
+	CTRL_REG_PRESENCE(115, 1, query29->has_ctrl115);
+	CTRL_REG_PRESENCE(116, 1, query29->has_ctrl116);
+	CTRL_REG_PRESENCE(117, 1, query29->has_ctrl117);
+	CTRL_REG_PRESENCE(118, 1, query30->has_ctrl118);
+	CTRL_REG_PRESENCE(119, 1, query30->has_ctrl119);
+	CTRL_REG_PRESENCE(120, 1, query30->has_ctrl120);
+	CTRL_REG_PRESENCE(121, 1, query30->has_ctrl121);
+	CTRL_REG_PRESENCE(122, 1, query30->has_ctrl122_query31);
+	CTRL_REG_PRESENCE(123, 1, query30->has_ctrl123);
+	CTRL_REG_PRESENCE(124, 1, query30->has_ctrl124);
+	CTRL_REG_PRESENCE(125, 1, query32->has_ctrl125);
+	CTRL_REG_PRESENCE(126, 1, query32->has_ctrl126);
+	CTRL_REG_PRESENCE(127, 1, query32->has_ctrl127);
+	CTRL_REG_PRESENCE(128, 1, query33->has_ctrl128);
+	CTRL_REG_PRESENCE(129, 1, query33->has_ctrl129);
+	CTRL_REG_PRESENCE(130, 1, query33->has_ctrl130);
+	CTRL_REG_PRESENCE(131, 1, query33->has_ctrl131);
+	CTRL_REG_PRESENCE(132, 1, query33->has_ctrl132);
+	CTRL_REG_PRESENCE(133, 1, query33->has_ctrl133);
+	CTRL_REG_PRESENCE(134, 1, query33->has_ctrl134);
+	CTRL_REG_PRESENCE(135, 1, query35->has_ctrl135);
+	CTRL_REG_PRESENCE(136, 1, query35->has_ctrl136);
+
+	CTRL_REG_ADD(137, 1, query35->has_ctrl137);
+
+	CTRL_REG_PRESENCE(138, 1, query35->has_ctrl138);
+	CTRL_REG_PRESENCE(139, 1, query35->has_ctrl139);
+	CTRL_REG_PRESENCE(140, 1, query35->has_ctrl140);
+	CTRL_REG_PRESENCE(141, 1, query36->has_ctrl141);
+	CTRL_REG_PRESENCE(142, 1, query36->has_ctrl142);
+	CTRL_REG_PRESENCE(143, 1, query36->has_ctrl143);
+	CTRL_REG_PRESENCE(144, 1, query36->has_ctrl144);
+	CTRL_REG_PRESENCE(145, 1, query36->has_ctrl145);
+	CTRL_REG_PRESENCE(146, 1, query36->has_ctrl146);
+	CTRL_REG_PRESENCE(147, 1, query38->has_ctrl147);
+	CTRL_REG_PRESENCE(148, 1, query38->has_ctrl148);
+	CTRL_REG_PRESENCE(149, 1, query38->has_ctrl149);
+	CTRL_REG_RESERVED_PRESENCE(150, 1, 0);
+	CTRL_REG_PRESENCE(151, 1, query38->has_ctrl151);
+	CTRL_REG_RESERVED_PRESENCE(152, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(153, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(154, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(155, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(156, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(157, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(158, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(159, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(160, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(161, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(162, 1, 0);
+	CTRL_REG_PRESENCE(163, 1, query40->has_ctrl163_query41);
+	CTRL_REG_RESERVED_PRESENCE(164, 1, 0);
+	CTRL_REG_PRESENCE(165, 1, query40->has_ctrl165_query42);
+	CTRL_REG_RESERVED_PRESENCE(166, 1, 0);
+	CTRL_REG_PRESENCE(167, 1, query40->has_ctrl167);
+	CTRL_REG_RESERVED_PRESENCE(168, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(169, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(170, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(171, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(172, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(173, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(174, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(175, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(176, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(177, 1, 0);
+	CTRL_REG_RESERVED_PRESENCE(178, 1, 0);
+	CTRL_REG_PRESENCE(179, 1, query46->has_ctrl179);
+
+	/* add F55 control registers */
+	reg_addr = f54->fn55->control_base_addr;
+
+	CTRL_REG_ADD(0_f55, 1, f54->query_f55_0_2.has_sensor_assignment);
+
+	CTRL_REG_PRESENCE(1_f55, 1, f54->query_f55_0_2.has_sensor_assignment);
+	CTRL_REG_PRESENCE(2_f55, 1, f54->query_f55_0_2.has_sensor_assignment);
+	CTRL_REG_PRESENCE(3_f55, 1, f54->query_f55_0_2.has_edge_compensation);
+	CTRL_REG_PRESENCE(4_f55, 1, f54->query_f55_0_2.curve_compensation_mode);
+	CTRL_REG_PRESENCE(5_f55, 1, f54->query_f55_0_2.curve_compensation_mode);
+	CTRL_REG_PRESENCE(6_f55, 1, f54->query_f55_0_2.has_ctrl6);
+	CTRL_REG_PRESENCE(7_f55, 1,
+		f54->query_f55_0_2.has_alternate_tx_assignment);
+
+	CTRL_REG_ADD(8_f55, 1,
+		f54->query_f55_0_2.f55_q2_has_single_layer_multitouch &&
+		f54->query_f55_3.f55_q3_has_ctrl8);
+	return 0;
+
+exit_no_mem:
+	dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Failed to alloc mem for control registers\n",
+			__func__);
+	return -ENOMEM;
+}
+
+static int synaptics_rmi4_f54_set_data(void)
+{
+	unsigned char reg_num = 0;
+	unsigned short reg_addr = f54->data_base_addr;
+	struct f54_data *data = &f54->data;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	/* data 0 - data 3: skip mandatory registers */
+	reg_addr += 4;
+
+	/* data 4 */
+	if (f54->query.has_sense_frequency_control == 1) {
+		pr_debug("d4 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_4 = kzalloc(sizeof(*data->reg_4), GFP_KERNEL);
+		if (!data->reg_4)
+			goto exit_no_mem;
+		data->reg_4->address = reg_addr;
+		reg_addr += sizeof(data->reg_4->data);
+	}
+	reg_num++;
+
+	/* F54_ANALOG_Data5 (reserved) is not present */
+	/* - do not increment */
+
+	/* data 6 */
+	if (f54->query.has_interference_metric) {
+		pr_debug("d6 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_6 = kzalloc(sizeof(*data->reg_6), GFP_KERNEL);
+		if (!data->reg_6)
+			goto exit_no_mem;
+		data->reg_6->address = reg_addr;
+		reg_addr += sizeof(data->reg_6->data);
+	}
+	reg_num++;
+
+	/* data 7.0 */
+	if (f54->query.has_one_byte_report_rate ||
+		f54->query.has_two_byte_report_rate) {
+		pr_debug("d7.0 addr = 0x%02x\n", reg_addr);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_7_0 = kzalloc(sizeof(*data->reg_7_0), GFP_KERNEL);
+		if (!data->reg_7_0)
+			goto exit_no_mem;
+		data->reg_7_0->address = reg_addr;
+		reg_addr += 1;
+	}
+	reg_num++;
+
+	/* data 7.1 */
+	if (f54->query.has_two_byte_report_rate) {
+		pr_debug("d7.1 addr = 0x%02x\n", reg_addr);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_7_1 = kzalloc(sizeof(*data->reg_7_1), GFP_KERNEL);
+		if (!data->reg_7_1)
+			goto exit_no_mem;
+		data->reg_7_1->address = reg_addr;
+		reg_addr += 1;
+	}
+	reg_num++;
+
+	/* data 8 */
+	if (f54->query.has_variance_metric) {
+		pr_debug("d8 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_8 = kzalloc(sizeof(*data->reg_8), GFP_KERNEL);
+		if (!data->reg_8)
+			goto exit_no_mem;
+		data->reg_8->address = reg_addr;
+		reg_addr += sizeof(data->reg_8->data);
+	}
+	reg_num++;
+
+	/* data 9 */
+	if (f54->query.has_multi_metric_state_machine) {
+		pr_debug("d9 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_9 = kzalloc(sizeof(*data->reg_9), GFP_KERNEL);
+		if (!data->reg_9)
+			goto exit_no_mem;
+		data->reg_9->address = reg_addr;
+		reg_addr += sizeof(data->reg_9->data);
+	}
+	reg_num++;
+
+	/* data 10 */
+	if (f54->query.has_multi_metric_state_machine ||
+			f54->query.has_noise_state) {
+		pr_debug("d10 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_10 = kzalloc(sizeof(*data->reg_10), GFP_KERNEL);
+		if (!data->reg_10)
+			goto exit_no_mem;
+		data->reg_10->address = reg_addr;
+		reg_addr += sizeof(data->reg_10->data);
+	}
+	reg_num++;
+
+	/* data 11 */
+	if (f54->query.has_status) {
+		pr_debug("d11 addr = 0x%02x\n", reg_addr);
+		reg_addr += 1;
+	}
+
+	/* data 12 */
+	if (f54->query.has_slew_metric) {
+		pr_debug("d12 addr = 0x%02x\n", reg_addr);
+		reg_addr += 2;
+	}
+
+	/* data 13 */
+	if (f54->query.has_multi_metric_state_machine) {
+		pr_debug("d13 addr = 0x%02x\n", reg_addr);
+		reg_addr += 2;
+	}
+
+	/* data 14 */
+	if (f54->query13.has_cid_im) {
+		pr_debug("d14 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_14 = kzalloc(sizeof(*data->reg_14), GFP_KERNEL);
+		if (!data->reg_14)
+			goto exit_no_mem;
+		data->reg_14->address = reg_addr;
+		reg_addr += 1; /* replicated register */
+	}
+	reg_num++;
+
+	/* data 15 */
+	if (f54->query13.has_rail_im) {
+		pr_debug("d15 addr = 0x%02x\n", reg_addr);
+		reg_addr += 1;
+	}
+
+	/* data 16 */
+	if (f54->query13.has_noise_mitigation_enh) {
+		pr_debug("d16 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_16 = kzalloc(sizeof(*data->reg_16), GFP_KERNEL);
+		if (!data->reg_16)
+			goto exit_no_mem;
+		data->reg_16->address = reg_addr;
+		reg_addr += 1;
+	}
+	reg_num++;
+
+	/* data 17 */
+	if (f54->query16.has_data17) {
+		pr_debug("d17 addr = 0x%02x num = %d\n", reg_addr, reg_num);
+		attrs_data_regs_exist[reg_num] = true;
+		data->reg_17 = kzalloc(sizeof(*data->reg_17), GFP_KERNEL);
+		if (!data->reg_17)
+			goto exit_no_mem;
+		data->reg_17->address = reg_addr;
+		reg_addr += sizeof(data->reg_17->data);
+	}
+	reg_num++;
+
+	return 0;
+
+exit_no_mem:
+	dev_err(&rmi4_data->i2c_client->dev,
+			"%s: Failed to alloc mem for data registers\n",
+			__func__);
+	return -ENOMEM;
+}
+
+static int synaptics_rmi4_f55_read_query(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+	uint16_t reg_addr;
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->fn55->query_base_addr,
+			f54->query_f55_0_2.data,
+			sizeof(f54->query_f55_0_2.data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read F55 query registers 0-2\n",
+				__func__);
+		goto err;
+	}
+
+	reg_addr  = f54->fn55->query_base_addr;
+
+	QUERY_REG_READ(_f55_0_2, 1);
+	QUERY_REG_READ(_f55_3,
+		f54->query_f55_0_2.f55_q2_has_single_layer_multitouch);
+return 0;
+
+err:
+	return retval;
+}
+
+static void synaptics_rmi4_f54_sensor_mapping(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+	struct f54_control *control = &f54->control;
+	unsigned int rx_len;
+	unsigned int tx_len;
+	unsigned char *buffer;
+	unsigned char *rx_buffer;
+	unsigned char *tx_buffer;
+	unsigned short offset;
+	int i;
+
+	rmi4_data->num_of_rx = 0;
+	rmi4_data->num_of_tx = 0;
+
+	if (f54->query.has_sensor_assignment == 1) {
+		rx_len = control->reg_15->length;
+		tx_len = control->reg_16->length;
+		offset = control->reg_15->address;
+
+	} else if (f54->fn55) {
+		if (f54->query_f55_0_2.has_sensor_assignment) {
+			rx_len = f54->query_f55_0_2.num_of_rx_electrodes;
+			tx_len = f54->query_f55_0_2.num_of_tx_electrodes;
+
+			offset = f54->fn55->control_base_addr + 1;
+		} else {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Has sensor assignment is not set in F55\n",
+					__func__);
+			return;
+		}
+	} else {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Cannot find sensor mapping\n",
+				__func__);
+		return;
+	}
+
+	buffer = kzalloc((rx_len +  tx_len) * sizeof(unsigned char),
+				GFP_KERNEL);
+
+	retval = f54->fn_ptr->read(rmi4_data, offset, buffer, rx_len + tx_len);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read control registers\n",
+				__func__);
+		goto exit;
+	}
+	rx_buffer = buffer;
+	tx_buffer = buffer + rx_len;
+
+	for (i = 0; i < rx_len; i++) {
+		if (rx_buffer[i] != 0xFF)
+			rmi4_data->num_of_rx++;
+	}
+	for (i = 0; i < tx_len; i++) {
+		if (tx_buffer[i] != 0xFF)
+			rmi4_data->num_of_tx++;
+	}
+
+	dev_info(&rmi4_data->i2c_client->dev,
+				"RxTx mapped from F$%s\n" \
+				"\n\tRx mapped count %d(%d)\n\tTx \
+				mapped count %d(%d)\n\n",
+				f54->fn55 ? "55" : "54",
+				rmi4_data->num_of_rx,
+				rx_len,
+				rmi4_data->num_of_tx,
+				tx_len);
+exit:
+	kfree(buffer);
+}
+
+static void synaptics_rmi4_f54_status_work(struct work_struct *work)
+{
+	int retval;
+	unsigned char report_index[2];
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+
+	if (f54->status != STATUS_BUSY)
+		return;
+
+	set_report_size();
+	if (f54->report_size == 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Report data size = 0\n",
+				__func__);
+		retval = -EINVAL;
+		goto error_exit;
+	}
+
+	if (f54->data_buffer_size < f54->report_size) {
+		mutex_lock(&f54->data_mutex);
+		if (f54->data_buffer_size)
+			kfree(f54->report_data);
+		f54->report_data = kzalloc(f54->report_size, GFP_KERNEL);
+		if (!f54->report_data) {
+			dev_err(&rmi4_data->i2c_client->dev,
+					"%s: Failed to alloc mem for data buffer\n",
+					__func__);
+			f54->data_buffer_size = 0;
+			mutex_unlock(&f54->data_mutex);
+			retval = -ENOMEM;
+			goto error_exit;
+		}
+		f54->data_buffer_size = f54->report_size;
+		mutex_unlock(&f54->data_mutex);
+	}
+
+	report_index[0] = 0;
+	report_index[1] = 0;
+
+	retval = f54->fn_ptr->write(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
+			report_index,
+			sizeof(report_index));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to write report data index\n",
+				__func__);
+		retval = -EINVAL;
+		goto error_exit;
+	}
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->data_base_addr + DATA_REPORT_DATA_OFFSET,
+			f54->report_data,
+			f54->report_size);
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read report data\n",
+				__func__);
+		retval = -EINVAL;
+		goto error_exit;
+	}
+
+	retval = STATUS_IDLE;
+
+#ifdef RAW_HEX
+	print_raw_hex_report();
+#endif
+
+#ifdef HUMAN_READABLE
+	print_image_report();
+#endif
+
+error_exit:
+	mutex_lock(&f54->status_mutex);
+	set_interrupt(false);
+	wake_unlock(&f54->test_wake_lock);
+	f54->status = retval;
+	mutex_unlock(&f54->status_mutex);
+
+	return;
+}
+
+static void synaptics_rmi4_f54_attn(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char intr_mask)
+{
+	if (f54->intr_mask & intr_mask) {
+		queue_delayed_work(f54->status_workqueue,
+				&f54->status_work,
+				msecs_to_jiffies(STATUS_WORK_INTERVAL));
+	}
+
+	return;
+}
+
+int synaptics_rmi4_f54_read_query(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
+	uint16_t reg_addr;
+
+	retval = f54->fn_ptr->read(rmi4_data,
+			f54->query_base_addr,
+			f54->query.data,
+			sizeof(f54->query.data));
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read query registers\n",
+				__func__);
+		goto err;
+	}
+
+	reg_addr  = f54->query_base_addr + sizeof(f54->query.data);
+
+	QUERY_REG_READ(12, f54->query.has_sense_frequency_control);
+	QUERY_REG_READ(13, f54->query.has_query13);
+	QUERY_REG_READ(14, f54->query13.has_ctrl87);
+	QUERY_REG_READ(15, f54->query.has_query15);
+	QUERY_REG_READ(16, f54->query15.has_query16);
+	QUERY_REG_READ(17, f54->query16.has_query17);
+	QUERY_REG_READ(18, f54->query16.has_ctrl94_query18);
+	QUERY_REG_READ(19, f54->query16.has_ctrl95_query19);
+	QUERY_REG_READ(20, f54->query15.has_query20);
+	QUERY_REG_READ(21, f54->query15.has_query21);
+	QUERY_REG_READ(22, f54->query15.has_query22);
+	QUERY_REG_READ(23, f54->query22.has_query23);
+	QUERY_REG_READ(24, f54->query21.has_query24_data18);
+	QUERY_REG_READ(25, f54->query15.has_query25);
+	QUERY_REG_READ(26, f54->query22.has_ctrl103_query26);
+	QUERY_REG_READ(27, f54->query25.has_query27);
+	QUERY_REG_READ(28, f54->query22.has_query28);
+	QUERY_REG_READ(29, f54->query27.has_query29);
+	QUERY_REG_READ(30, f54->query29.has_query30);
+	QUERY_REG_READ(31, f54->query30.has_ctrl122_query31);
+	QUERY_REG_READ(32, f54->query30.has_query32);
+	QUERY_REG_READ(33, f54->query32.has_query33);
+	QUERY_REG_READ(34, f54->query32.has_query34);
+	QUERY_REG_READ(35, f54->query32.has_query35);
+	QUERY_REG_READ(36, f54->query33.has_query36);
+	if (f54->query36.has_query37)
+		reg_addr += 1;
+	QUERY_REG_READ(38, f54->query36.has_query38);
+	QUERY_REG_READ(39, f54->query38.has_query39);
+	QUERY_REG_READ(40, f54->query39.has_query40);
+	QUERY_REG_READ(41, f54->query40.has_ctrl163_query41);
+	QUERY_REG_READ(42, f54->query40.has_ctrl165_query42);
+	QUERY_REG_READ(43, f54->query40.has_query43);
+	reg_addr += 1; /* query44 is reserved - always present */
+	reg_addr += 1; /* query45 is reserved - always present */
+	QUERY_REG_READ(46, f54->query43.has_query46);
+
+return 0;
+
+err:
+	return retval;
+}
+
+static int synaptics_rmi4_f54_init(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	bool hasF54 = false;
+	bool hasF55 = false;
+	unsigned short ii;
+	unsigned char page;
+	unsigned char intr_count = 0;
+	unsigned char intr_offset;
+
+	struct synaptics_rmi4_fn_desc rmi_fd;
+
+	f54 = kzalloc(sizeof(*f54), GFP_KERNEL);
+	if (!f54) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for f54\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	f54->fn_ptr = kzalloc(sizeof(*(f54->fn_ptr)), GFP_KERNEL);
+	if (!f54->fn_ptr) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to alloc mem for fn_ptr\n",
+				__func__);
+		retval = -ENOMEM;
+		goto exit_free_f54;
+	}
+
+	f54->rmi4_data = rmi4_data;
+	f54->fn_ptr->read = rmi4_data->i2c_read;
+	f54->fn_ptr->write = rmi4_data->i2c_write;
+	f54->fn_ptr->enable = rmi4_data->irq_enable;
+
+	for (page = 0; page < PAGES_TO_SERVICE; page++) {
+		for (ii = PDT_START; ii > PDT_END; ii -= PDT_ENTRY_SIZE) {
+			ii |= (page << 8);
+
+			retval = f54->fn_ptr->read(rmi4_data,
+					ii,
+					(unsigned char *)&rmi_fd,
+					sizeof(rmi_fd));
+			if (retval < 0)
+				goto exit_free_mem;
+
+			if (!rmi_fd.fn_number)
+				break;
+
+			if (rmi_fd.fn_number == SYNAPTICS_RMI4_F54) {
+				hasF54 = true;
+				f54->query_base_addr =
+					rmi_fd.query_base_addr | (page << 8);
+				pr_debug("query_base_addr 0x%04x\n",
+					f54->query_base_addr);
+				f54->control_base_addr =
+					rmi_fd.ctrl_base_addr | (page << 8);
+				pr_debug("ctrl_base_addr 0x%04x\n",
+					f54->control_base_addr);
+				f54->data_base_addr =
+					rmi_fd.data_base_addr | (page << 8);
+				pr_debug("data_base_addr 0x%04x\n",
+					f54->data_base_addr);
+				f54->command_base_addr =
+					rmi_fd.cmd_base_addr | (page << 8);
+				pr_debug("command_base_addr 0x%04x\n",
+					f54->command_base_addr);
+			} else if (rmi_fd.fn_number == SYNAPTICS_RMI4_F55) {
+				hasF55 = true;
+				f54->fn55 = kmalloc(sizeof(*f54->fn55),
+								GFP_KERNEL);
+				f54->fn55->query_base_addr =
+					rmi_fd.query_base_addr | (page << 8);
+				f54->fn55->control_base_addr =
+					rmi_fd.ctrl_base_addr | (page << 8);
+			}
+
+			if (hasF54 && hasF55)
+				goto found;
+
+			if (!hasF54)
+				intr_count +=
+					(rmi_fd.intr_src_count & MASK_3BIT);
+		}
+	}
+
+	if (!hasF54) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: F$54 is not available\n",
+				__func__);
+		goto exit;
+	}
+found:
+	f54->intr_reg_num = (intr_count + 7) / 8;
+	if (f54->intr_reg_num != 0)
+		f54->intr_reg_num -= 1;
+
+	f54->intr_mask = 0;
+	intr_offset = intr_count % 8;
+	for (ii = intr_offset;
+			ii < ((rmi_fd.intr_src_count & MASK_3BIT) +
+			intr_offset);
+			ii++) {
+		f54->intr_mask |= 1 << ii;
+	}
+
+	retval = synaptics_rmi4_f54_read_query();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to read query registers\n",
+				__func__);
+		goto exit_free_mem;
+	}
+
+	retval = synaptics_rmi4_f55_read_query();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to set up F55 query registers\n",
+				__func__);
+		goto exit_free_control;
+	}
+
+	retval = synaptics_rmi4_f54_set_ctrl();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to set up control registers\n",
+				__func__);
+		goto exit_free_control;
+	}
+
+	synaptics_rmi4_f54_sensor_mapping();
+
+	retval = synaptics_rmi4_f54_set_data();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to set up data registers\n",
+				__func__);
+		goto exit_free_data;
+	}
+
+	mutex_init(&f54->status_mutex);
+	mutex_init(&f54->data_mutex);
+	mutex_init(&f54->control_mutex);
+
+	retval = synaptics_rmi4_f54_set_sysfs();
+	if (retval < 0) {
+		dev_err(&rmi4_data->i2c_client->dev,
+				"%s: Failed to create sysfs entries\n",
+				__func__);
+		goto exit_sysfs;
+	}
+
+	f54->status_workqueue =
+			create_singlethread_workqueue("f54_status_workqueue");
+	INIT_DELAYED_WORK(&f54->status_work,
+			synaptics_rmi4_f54_status_work);
+
+	f54->user_report_type1 = F54_16BIT_IMAGE;
+	f54->user_report_type2 = F54_RAW_16BIT_IMAGE;
+
+	wake_lock_init(&f54->test_wake_lock, WAKE_LOCK_SUSPEND,
+		"synaptics_test_report");
+
+#ifdef WATCHDOG_HRTIMER
+	/* Watchdog timer to catch unanswered get report commands */
+	hrtimer_init(&f54->watchdog, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	f54->watchdog.function = get_report_timeout;
+
+	/* Work function to do actual cleaning up */
+	INIT_WORK(&f54->timeout_work, timeout_set_status);
+#endif
+
+	return 0;
+
+exit_sysfs:
+exit_free_data:
+	free_data_mem();
+
+exit_free_control:
+	free_control_mem();
+
+exit_free_mem:
+	kfree(f54->fn_ptr);
+
+exit_free_f54:
+	kfree(f54);
+
+exit:
+	return retval;
+}
+
+static void synaptics_rmi4_f54_remove(struct synaptics_rmi4_data *rmi4_data)
+{
+#ifdef WATCHDOG_HRTIMER
+	hrtimer_cancel(&f54->watchdog);
+#endif
+
+	cancel_delayed_work_sync(&f54->status_work);
+	flush_workqueue(f54->status_workqueue);
+	destroy_workqueue(f54->status_workqueue);
+
+	remove_sysfs();
+
+	free_data_mem();
+	free_control_mem();
+
+	kfree(f54->report_data);
+	kfree(f54->fn55);
+	kfree(f54->fn_ptr);
+	kfree(f54);
+
+	complete(&remove_complete);
+
+	return;
+}
+
+static int __init rmi4_f54_module_init(void)
+{
+	synaptics_rmi4_new_function(RMI_F54, true,
+			synaptics_rmi4_f54_init,
+			synaptics_rmi4_f54_remove,
+			synaptics_rmi4_f54_attn,
+			IC_MODE_UI);
+
+	return 0;
+}
+
+static void __exit rmi4_f54_module_exit(void)
+{
+	init_completion(&remove_complete);
+	synaptics_rmi4_new_function(RMI_F54, false,
+			synaptics_rmi4_f54_init,
+			synaptics_rmi4_f54_remove,
+			synaptics_rmi4_f54_attn,
+			IC_MODE_UI);
+
+	wait_for_completion(&remove_complete);
+	return;
+}
+
+module_init(rmi4_f54_module_init);
+module_exit(rmi4_f54_module_exit);
+
+MODULE_AUTHOR("Synaptics, Inc.");
+MODULE_DESCRIPTION("Synaptics DSX Test Reporting Module");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(SYNAPTICS_DSX_DRIVER_VERSION);
diff --git a/include/linux/input/synaptics_rmi_dsx.h b/include/linux/input/synaptics_rmi_dsx.h
new file mode 100644
index 00000000000..a4dc94a3cc1
--- /dev/null
+++ b/include/linux/input/synaptics_rmi_dsx.h
@@ -0,0 +1,78 @@
+/*
+ * Synaptics DSX touchscreen driver
+ *
+ * Copyright (C) 2012 Synaptics Incorporated
+ *
+ * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SYNAPTICS_DSX_H_
+#define _SYNAPTICS_DSX_H_
+
+/*
+ * struct synaptics_dsx_cap_button_map - 0d button map
+ * @nbuttons: number of 0d buttons
+ * @map: pointer to array of button types
+ */
+struct synaptics_dsx_cap_button_map {
+	unsigned char nbuttons;
+	unsigned char *map;
+};
+
+/*
+ * struct synaptics_dsx_platform_data - dsx platform data
+ * @x_flip: x flip flag
+ * @y_flip: y flip flag
+ * @i2c_pull_up: pull up i2c bus with regulator
+ * @power_down_enable: enable complete regulator shutdown in suspend
+ * @irq_gpio: attention interrupt gpio
+ * @irq_flags: flags used by the irq
+ * @reset_flags: flags used by reset line
+ * @reset_gpio: reset gpio
+ * @disp_maxx: display panel maximum values on the x
+ * @disp_maxy: display panel maximum values on the y
+ * @disp_minx: display panel minimum values on the x
+ * @disp_miny: display panel minimum values on the y
+ * @panel_maxx: touch panel maximum values on the x
+ * @panel_maxy: touch panel maximum values on the y
+ * @panel_minx: touch panel minimum values on the x
+ * @panel_miny: touch panel minimum values on the y
+ * @reset_delay: reset delay
+ * @gpio_config: pointer to gpio configuration function
+ * @cap_button_map: pointer to 0d button map
+ */
+struct synaptics_dsx_platform_data {
+	bool x_flip;
+	bool y_flip;
+	bool i2c_pull_up;
+	bool power_down_enable;
+	bool disable_gpios;
+	bool do_lockdown;
+	bool regulator_en;
+	unsigned irq_gpio;
+	unsigned long irq_flags;
+	unsigned reset_gpio;
+	unsigned panel_minx;
+	unsigned panel_miny;
+	unsigned panel_maxx;
+	unsigned panel_maxy;
+	unsigned disp_minx;
+	unsigned disp_miny;
+	unsigned reset_delay;
+	int (*gpio_config)(struct synaptics_dsx_platform_data *pdata,
+							bool configure);
+	struct synaptics_dsx_cap_button_map *cap_button_map;
+};
+
+#endif
diff --git a/include/linux/mmi_hall_notifier.h b/include/linux/mmi_hall_notifier.h
new file mode 100644
index 00000000000..8eee776555c
--- /dev/null
+++ b/include/linux/mmi_hall_notifier.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Motorola Mobility, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MMI_HALL_NOTIFIER_H__
+#define __MMI_HALL_NOTIFIER_H__
+
+#include <linux/notifier.h>
+
+/* Hall effect sensor type is a position of the */
+/* bit representing its state. For example, */
+/*	MMI_HALL_FOLIO  0 */
+/*	MMI_HALL_SECOND 1 */
+/*	MMI_HALL_THIRD  2 */
+#define MMI_HALL_FOLIO 0
+#define MMI_HALL_MAX   8
+
+struct mmi_hall_data {
+	unsigned int enabled;
+	unsigned int state;
+	struct blocking_notifier_head nhead[MMI_HALL_MAX];
+};
+
+#ifdef CONFIG_MMI_HALL_NOTIFICATIONS
+struct mmi_hall_data *mmi_hall_init(void);
+void mmi_hall_free(struct mmi_hall_data *data);
+int mmi_hall_register_notifier(struct notifier_block *nb,
+		unsigned long type, bool report);
+int mmi_hall_unregister_notifier(struct notifier_block *nb,
+		unsigned long type);
+void mmi_hall_notify(unsigned long type, int data);
+#else
+#include <linux/errno.h>
+static inline struct mmi_hall_data *mmi_hall_init(void)
+{
+	return NULL;
+}
+static inline void mmi_hall_free(struct mmi_hall_data *data) {}
+static inline int mmi_hall_register_notifier(struct notifier_block *nb,
+		unsigned long type, bool report)
+{
+	return -ENOSYS;
+}
+static inline int mmi_hall_unregister_notifier(struct notifier_block *nb,
+		unsigned long type)
+{
+	return -ENOSYS;
+}
+static inline void mmi_hall_notify(unsigned long type, int data) {}
+#endif
+#endif
+
diff --git a/include/uapi/linux/input.h b/include/uapi/linux/input.h
index 415d4da3292..6318f144cf1 100644
--- a/include/uapi/linux/input.h
+++ b/include/uapi/linux/input.h
@@ -200,6 +200,8 @@ struct input_keymap_entry {
 #define SYN_DROPPED		3
 #define SYN_TIME_SEC		4
 #define SYN_TIME_NSEC		5
+#define SYN_MAX			0xf
+#define SYN_CNT			(SYN_MAX+1)
 
 /*
  * Keys and buttons
-- 
2.11.0

