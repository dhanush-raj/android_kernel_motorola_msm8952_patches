From 7aed4ab39351781ceb9d8144ddafc4239e21b1d6 Mon Sep 17 00:00:00 2001
From: Jingnan Zhu <e3334c@motorola.com>
Date: Sun, 11 Oct 2015 11:33:00 -0500
Subject: [PATCH 398/959] IKQCOMSD1-2951: input: misc: vl5310: mot changes

1. device config reading and power up/down sequence
2. change for cci and i2c co-exist in code instead of compile option
3. sar basic functions
4. state managerment for sar, calibaration, camera
5. added some camera required interface
6. added cleanup logic for laser device close
7. minor bug fix in st code
8. removed some unneed code in st drivers

Change-Id: If2a933c993e187cbcdf21f324528be73761e2fcc
Signed-off-by: Jingnan Zhu <e3334c@motorola.com>
Reviewed-on: http://gerrit.mot.com/790453
SME-Granted: SME Approvals Granted
SLTApproved: Slta Waiver <sltawvr@motorola.com>
Tested-by: Jira Key <jirakey@motorola.com>
Reviewed-by: Oleg Klementiev <oleg@motorola.com>
Reviewed-by: Christopher Fries <cfries@motorola.com>
Submit-Approved: Jira Key <jirakey@motorola.com>
---
 drivers/input/misc/Kconfig                       |    5 +-
 drivers/input/misc/Makefile                      |    1 +
 drivers/input/misc/vl53L0/stmvl53l0-cci.h        |    5 +-
 drivers/input/misc/vl53L0/stmvl53l0-i2c.h        |   11 +-
 drivers/input/misc/vl53L0/stmvl53l0.h            |   79 +-
 drivers/input/misc/vl53L0/stmvl53l0_module-cci.c |  240 ++--
 drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c |  250 ++--
 drivers/input/misc/vl53L0/stmvl53l0_module.c     | 1455 +++++++++++++---------
 include/uapi/media/msmb_camera.h                 |    3 +-
 9 files changed, 1228 insertions(+), 821 deletions(-)

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 95ddc97ca3a..e8cfcc41225 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -862,6 +862,9 @@ config SENSORS_ISL29044A
 	depends on I2C
 	help
 	 This option enables support for the INTERSIL ISL29044A P/L sensor.
-
+config STMVL53L0
+	tristate "STMVL53L0 support"
+	help
+	laser sensor driver.
 endif
 
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 59bd27d055c..ea5b7bd7074 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -89,3 +89,4 @@ endif
 
 obj-$(CONFIG_SENSORS_MC3430)	+= mc3xxx.o
 obj-$(CONFIG_SENSORS_ISL29044A)	+= isl29044a.o
+obj-$(CONFIG_STMVL53L0)	+= vl53L0/
diff --git a/drivers/input/misc/vl53L0/stmvl53l0-cci.h b/drivers/input/misc/vl53L0/stmvl53l0-cci.h
index 7dc1e26dece..f1d9cf6cd79 100644
--- a/drivers/input/misc/vl53L0/stmvl53l0-cci.h
+++ b/drivers/input/misc/vl53L0/stmvl53l0-cci.h
@@ -24,7 +24,6 @@
 #define STMVL53L0_CCI_H
 #include <linux/types.h>
 
-#ifdef CAMERA_CCI
 #include <soc/qcom/camera2.h>
 #include "msm_camera_i2c.h"
 #include "msm_camera_dt_util.h"
@@ -52,10 +51,12 @@ struct cci_data {
 	char subdev_initialized;
 	uint32_t subdev_id;
 	uint8_t power_up;
+	struct msm_camera_gpio_conf gconf;
+	struct msm_pinctrl_info pinctrl_info;
 };
 int stmvl53l0_init_cci(void);
 void stmvl53l0_exit_cci(void *);
 int stmvl53l0_power_down_cci(void *);
 int stmvl53l0_power_up_cci(void *, unsigned int *);
-#endif /* CAMERA_CCI */
+
 #endif /* STMVL53L0_CCI_H */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0-i2c.h b/drivers/input/misc/vl53L0/stmvl53l0-i2c.h
index 64fefb1f29c..3bc54b255cf 100644
--- a/drivers/input/misc/vl53L0/stmvl53l0-i2c.h
+++ b/drivers/input/misc/vl53L0/stmvl53l0-i2c.h
@@ -23,17 +23,24 @@
 #ifndef STMVL53L0_I2C_H
 #define STMVL53L0_I2C_H
 #include <linux/types.h>
+#include <soc/qcom/camera2.h>
+#include "msm_camera_i2c.h"
+#include "msm_camera_dt_util.h"
+#include "msm_camera_io_util.h"
+#include "msm_cci.h"
 
-#ifndef CAMERA_CCI
 struct i2c_data {
 	struct i2c_client *client;
 	struct regulator *vana;
 	uint8_t power_up;
+	uint32_t lowv;
+	uint32_t highv;
+	struct msm_camera_gpio_conf gconf;
+	struct msm_pinctrl_info pinctrl_info;
 };
 int stmvl53l0_init_i2c(void);
 void stmvl53l0_exit_i2c(void *);
 int stmvl53l0_power_up_i2c(void *, unsigned int *);
 int stmvl53l0_power_down_i2c(void *);
 
-#endif /* NOT CAMERA_CCI */
 #endif /* STMVL53L0_I2C_H */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0.h b/drivers/input/misc/vl53L0/stmvl53l0.h
index 54db94fbd08..602df4eed16 100644
--- a/drivers/input/misc/vl53L0/stmvl53l0.h
+++ b/drivers/input/misc/vl53L0/stmvl53l0.h
@@ -46,18 +46,35 @@
 
 #define VL53L0_VDD_MIN      2600000
 #define VL53L0_VDD_MAX      3000000
+/*driver working mode*/
+#define	OFF_MODE  0
+#define	CAM_MODE  1
+#define	SAR_MODE  2
+#define	SUPER_MODE  3
+#define	XTALKCAL_MODE  4
+#define	OFFSETCAL_MODE  5
+/*user actions*/
+#define	CAM_ON  0
+#define	CAM_OFF 1
+#define	SAR_ON  2
+#define	SAR_OFF 3
+#define	XTALKCAL_ON 4
+#define	OFFSETCAL_ON 5
+#define	CAL_OFF 6
+/*parameter types*/
+#define	OFFSET_PAR 0
+#define	XTALKRATE_PAR 1
+#define	XTALKENABLE_PAR 2
+#define	SNRVAL_PRA 3
+#define	SNRCTL_PRA 4
+#define	WRAPAROUNDCTL_PRA 5
+#define	INTERMEASUREMENTPERIOD_PAR 6
+#define	MEASUREMENTTIMINGBUDGET_PAR 7
+
+
+#define	CCI_BUS  0
+#define	I2C_BUS  1
 
-typedef enum {
-	NORMAL_MODE = 0,
-	OFFSETCALIB_MODE = 1,
-	XTALKCALIB_MODE = 2,
-} init_mode_e;
-
-typedef enum {
-	OFFSET_PAR = 0,
-	XTALKRATE_PAR = 1,
-	XTALKENABLE_PAR = 2,
-} parameter_name_e;
 
 /*
  *  IOCTL register data structs
@@ -75,7 +92,7 @@ struct stmvl53l0_register {
  */
 struct stmvl53l0_parameter {
 	uint32_t is_read; /*1: Get 0: Set*/
-	parameter_name_e name;
+	uint32_t name;
 	int32_t value;
 	int32_t status;
 };
@@ -84,27 +101,22 @@ struct stmvl53l0_parameter {
  *  driver data structs
  */
 struct stmvl53l0_data {
-
-	VL53L0_DevData_t Data;	/* !<embed ST VL53L0 Dev data as
-								"dev_data" */
-	uint8_t   I2cDevAddr;	/*!< i2c device address user specific field
-							*/
-	uint8_t   comms_type;	/*!< Type of comms : VL53L0_COMMS_I2C
-							or VL53L0_COMMS_SPI */
-	uint16_t  comms_speed_khz;	/*!< Comms speed [kHz] :
-						typically 400kHz for I2C */
-#ifdef CAMERA_CCI
-	struct cci_data client_object;
-#else
-	struct i2c_data client_object;
-#endif
+	/* embed ST VL53L0 Dev data as "dev_data" */
+	VL53L0_DevData_t Data;
+	/* i2c device address user specific field */
+	uint8_t   I2cDevAddr;
+	uint8_t   comms_type;
+	uint16_t  comms_speed_khz;
+
+	struct cci_data cci_client_object;
+	struct i2c_data i2c_client_object;
+	void *client_object;
 	struct mutex update_lock;
 	struct delayed_work	dwork;		/* for PS  work handler */
 	struct input_dev *input_dev_ps;
 	struct kobject *range_kobj;
 
 	const char *dev_name;
-	/* function pointer */
 
 	/* misc device */
 	struct miscdevice miscdev;
@@ -125,13 +137,18 @@ struct stmvl53l0_data {
 
 
 	/* delay time in miniseconds*/
-	uint8_t delay_ms;
+	unsigned int delay_ms;
 
 	struct mutex work_mutex;
 
 	/* Debug */
 	unsigned int enableDebug;
 	uint8_t interrupt_received;
+	int d_mode;
+	uint8_t w_mode;
+	/*for SAR mode indicate low range interrupt*/
+	uint8_t lowint;
+	uint8_t bus_type;
 };
 
 /*
@@ -144,6 +161,10 @@ struct stmvl53l0_module_fn_t {
 	int (*power_down)(void *);
 };
 
-int stmvl53l0_setup(struct stmvl53l0_data *data);
+struct stmvl53l0_data *stmvl53l0_getobject(void);
+int stmvl53l0_setup(struct stmvl53l0_data *data, uint8_t type);
+int stmvl53l0_checkmoduleid(struct stmvl53l0_data *data,
+	void *client, uint8_t type);
+void i2c_setclient(void *client, uint8_t type);
 
 #endif /* STMVL53L0_H */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c b/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c
index de97d0426d7..e26396f4317 100644
--- a/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c
+++ b/drivers/input/misc/vl53L0/stmvl53l0_module-cci.c
@@ -1,23 +1,22 @@
 /*
- *  stmvl53l0_module-cci.c - Linux kernel modules for STM VL53L0 FlightSense TOF
- *							sensor
- *
- *  Copyright (C) 2015 STMicroelectronics Imaging Division.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+*  stmvl53l0_module-cci.c - Linux kernel modules for STM VL53L0 FlightSense TOF
+*							sensor
+*
+*  Copyright (C) 2015 STMicroelectronics Imaging Division.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2 of the License, or
+*  (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program;
+*/
 #include <linux/uaccess.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -51,8 +50,9 @@
 #include "stmvl53l0-cci.h"
 #include "stmvl53l0-i2c.h"
 #include "stmvl53l0.h"
+#define LASER_SENSOR_PINCTRL_STATE_SLEEP "laser_suspend"
+#define LASER_SENSOR_PINCTRL_STATE_DEFAULT "laser_default"
 
-#ifdef CAMERA_CCI
 /*
  * Global data
  */
@@ -77,11 +77,31 @@ static int stmvl53l0_get_dt_data(struct device *dev, struct cci_data *data);
 static int stmvl53l0_get_dt_data(struct device *dev, struct cci_data *data)
 {
 	int rc = 0;
+	struct msm_camera_gpio_conf *gconf = NULL;
+	uint16_t *gpio_array = NULL;
+	uint16_t gpio_array_size = 0;
+	int i;
+	struct msm_pinctrl_info *sensor_pctrl = NULL;
+
 	vl53l0_dbgmsg("Enter\n");
 
+	sensor_pctrl = &data->pinctrl_info;
+	sensor_pctrl->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR_OR_NULL(sensor_pctrl->pinctrl)) {
+		pr_err("%s:%d Getting pinctrl handle failed\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+	sensor_pctrl->gpio_state_active =
+		pinctrl_lookup_state(sensor_pctrl->pinctrl,
+		LASER_SENSOR_PINCTRL_STATE_DEFAULT);
+
+	sensor_pctrl->gpio_state_suspend
+		= pinctrl_lookup_state(sensor_pctrl->pinctrl,
+		LASER_SENSOR_PINCTRL_STATE_SLEEP);
+
 	if (dev->of_node) {
 		struct device_node *of_node = dev->of_node;
-		struct msm_tof_vreg *vreg_cfg;
 
 		if (!of_node) {
 			vl53l0_errmsg("failed %d\n", __LINE__);
@@ -95,8 +115,8 @@ static int stmvl53l0_get_dt_data(struct device *dev, struct cci_data *data)
 			return rc;
 		}
 		vl53l0_dbgmsg("cell-index: %d\n", data->pdev->id);
-		rc = of_property_read_u32(of_node, "qcom,cci-master",
-				&data->cci_master);
+		rc = of_property_read_u32(of_node,
+			"qcom,cci-master", &data->cci_master);
 		if (rc < 0) {
 			vl53l0_errmsg("failed %d\n", __LINE__);
 			/* Set default master 0 */
@@ -104,74 +124,50 @@ static int stmvl53l0_get_dt_data(struct device *dev, struct cci_data *data)
 			rc = 0;
 		}
 		vl53l0_dbgmsg("cci_master: %d\n", data->cci_master);
-		if (of_find_property(of_node, "qcom,cam-vreg-name", NULL)) {
-			vreg_cfg = &data->vreg_cfg;
-			rc = msm_camera_get_dt_vreg_data(of_node,
-				&vreg_cfg->cam_vreg, &vreg_cfg->num_vreg);
-			if (rc < 0) {
-				vl53l0_errmsg("failed %d\n", __LINE__);
-				return rc;
-			}
-		}
-		vl53l0_dbgmsg("vreg-name: %s min_volt: %d max_volt: %d",
-			vreg_cfg->cam_vreg->reg_name,
-			vreg_cfg->cam_vreg->min_voltage,
-			vreg_cfg->cam_vreg->max_voltage);
-	}
-	vl53l0_dbgmsg("End rc =%d\n", rc);
 
-	return rc;
-}
+		gpio_array_size = of_gpio_count(of_node);
+		gconf = &data->gconf;
 
-static int32_t stmvl53l0_vreg_control(struct cci_data *data, int config)
-{
-	int rc = 0, i, cnt;
-	struct msm_tof_vreg *vreg_cfg;
+		if (gpio_array_size) {
+			gpio_array = kcalloc(gpio_array_size, sizeof(uint16_t),
+				GFP_KERNEL);
 
-	vl53l0_dbgmsg("Enter\n");
+			for (i = 0; i < gpio_array_size; i++) {
+				gpio_array[i] = of_get_gpio(of_node, i);
+				pr_err("%s gpio_array[%d] = %d\n", __func__, i,
+					gpio_array[i]);
+			}
 
-	vreg_cfg = &data->vreg_cfg;
-	cnt = vreg_cfg->num_vreg;
-	vl53l0_dbgmsg("num_vreg: %d\n", cnt);
-	if (!cnt) {
-		vl53l0_errmsg("failed %d\n", __LINE__);
-		return 0;
-	}
+			rc = msm_camera_get_dt_gpio_req_tbl(of_node, gconf,
+				gpio_array, gpio_array_size);
+			if (rc < 0) {
+				pr_err("%s failed %d\n", __func__, __LINE__);
+				return rc;
+			}
 
-	if (cnt >= MSM_TOF_MAX_VREGS) {
-		vl53l0_errmsg("failed %d cnt %d\n", __LINE__, cnt);
-		return -EINVAL;
-	}
+			rc = msm_camera_get_dt_gpio_set_tbl(of_node, gconf,
+				gpio_array, gpio_array_size);
+			if (rc < 0) {
+				pr_err("%s failed %d\n", __func__, __LINE__);
+				return rc;
+			}
 
-	for (i = 0; i < cnt; i++) {
-		rc = msm_camera_config_single_vreg(&(data->pdev->dev),
-				&vreg_cfg->cam_vreg[i],
-				(struct regulator **)&vreg_cfg->data[i],
-				config);
+			rc = msm_camera_init_gpio_pin_tbl(of_node, gconf,
+				gpio_array, gpio_array_size);
+			if (rc < 0) {
+				pr_err("%s failed %d\n", __func__, __LINE__);
+				return rc;
+			}
+		}
 	}
+	vl53l0_dbgmsg("End rc =%d\n", rc);
 
-	vl53l0_dbgmsg("EXIT rc =%d\n", rc);
 	return rc;
 }
 
-
 static int msm_tof_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	int rc = 0;
-/*
-	struct msm_tof_ctrl_t *tof_ctrl =  v4l2_get_subdevdata(sd);
-	if (!tof_ctrl) {
-		pr_err("failed\n");
-		return -EINVAL;
-	}
-	if (tof_ctrl->tof_device_type == MSM_CAMERA_PLATFORM_DEVICE) {
-		rc = tof_ctrl->i2c_client.i2c_func_tbl->i2c_util(
-			&tof_ctrl->i2c_client, MSM_CCI_RELEASE);
-		if (rc < 0)
-			pr_err("cci_init failed\n");
-	}
-    tof_ctrl->i2c_state = TOF_I2C_RELEASE;
-*/
 	return rc;
 }
 
@@ -212,6 +208,7 @@ static int stmvl53l0_cci_init(struct cci_data *data)
 		data->client->cci_client =
 			kzalloc(sizeof(struct msm_camera_cci_client),
 			GFP_KERNEL);
+
 		if (!data->client->cci_client) {
 			vl53l0_errmsg("%d, failed no memory\n", __LINE__);
 			return -ENOMEM;
@@ -223,8 +220,8 @@ static int stmvl53l0_cci_init(struct cci_data *data)
 		v4l2_set_subdevdata(&data->msm_sd.sd, data);
 		data->msm_sd.sd.internal_ops = &msm_tof_internal_ops;
 		data->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-		snprintf(data->msm_sd.sd.name, ARRAY_SIZE(data->msm_sd.sd.name),
-			"msm_tof");
+		snprintf(data->msm_sd.sd.name,
+				ARRAY_SIZE(data->msm_sd.sd.name), "msm_tof");
 		media_entity_init(&data->msm_sd.sd.entity, 0, NULL, 0);
 		data->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
 		data->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_TOF;
@@ -235,6 +232,7 @@ static int stmvl53l0_cci_init(struct cci_data *data)
 		data->subdev_initialized = TRUE;
 	}
 
+	vl53l0_dbgmsg("inited\n");
 	cci_client->sid = 0x29;
 	cci_client->retries = 3;
 	cci_client->id_map = 0;
@@ -245,7 +243,6 @@ static int stmvl53l0_cci_init(struct cci_data *data)
 		return rc;
 	}
 	vl53l0_dbgmsg("CCI Init Succeeded\n");
-
 	data->client->addr_type = MSM_CAMERA_I2C_BYTE_ADDR;
 
 	return 0;
@@ -255,46 +252,54 @@ static int32_t stmvl53l0_platform_probe(struct platform_device *pdev)
 {
 	struct stmvl53l0_data *vl53l0_data = NULL;
 	struct cci_data *data = NULL;
+	unsigned int present = 0;
+
 	int32_t rc = 0;
 
 	vl53l0_dbgmsg("Enter\n");
 
 	if (!pdev->dev.of_node) {
-		vl53l0_errmsg("of_node NULL\n");
+		vl53l0_errmsg("%d,of_node NULL\n", __LINE__);
 		return -EINVAL;
 	}
 
 	vl53l0_data = stmvl53l0_getobject();
 	if (NULL == vl53l0_data) {
-		vl53l0_errmsg("Object not found!\n");
+		vl53l0_errmsg("%d,Object not found!\n", __LINE__);
 		return -EINVAL;
 	}
-
-	data = &(vl53l0_data->client_object);
+	data = &(vl53l0_data->cci_client_object);
 	if (!data) {
-		vl53l0_errmsg("data NULL\n");
+		vl53l0_errmsg("%d,data NULL\n", __LINE__);
 		return -EINVAL;
 	}
 
-	data->client = (struct msm_camera_i2c_client *)&data->g_client;
-
-	/* setup platform i2c client */
-	i2c_setclient((void *)data->client);
-
 	/* Set platform device handle */
 	data->subdev_ops = &msm_tof_subdev_ops;
 	data->pdev = pdev;
-	rc = stmvl53l0_get_dt_data(&pdev->dev, data);
-	if (rc < 0) {
-		vl53l0_errmsg("%d, failed rc %d\n", __LINE__, rc);
-		return rc;
-	}
+	stmvl53l0_get_dt_data(&pdev->dev, data);
 	data->subdev_id = pdev->id;
 
 	/* Set device type as platform device */
 	data->device_type = MSM_CAMERA_PLATFORM_DEVICE;
 	data->subdev_initialized = FALSE;
 
+	data->client = (struct msm_camera_i2c_client *)&data->g_client;
+
+	rc = stmvl53l0_power_up_cci(data, &present);
+	if (rc) {
+		vl53l0_errmsg("%d,error rc %d\n", __LINE__, rc);
+		return rc;
+	}
+	rc = stmvl53l0_checkmoduleid(vl53l0_data, data->client, CCI_BUS);
+	if (rc != 0) {
+		vl53l0_errmsg("%d,error rc %d\n", __LINE__, rc);
+		stmvl53l0_power_down_cci(data);
+		return rc;
+	}
+	stmvl53l0_power_down_cci(data);
+	stmvl53l0_setup(vl53l0_data, CCI_BUS);
+
 	vl53l0_dbgmsg("End\n");
 
 	return rc;
@@ -322,26 +327,23 @@ int stmvl53l0_power_up_cci(void *cci_object, unsigned int *preset_flag)
 	struct cci_data *data = (struct cci_data *)cci_object;
 
 	vl53l0_dbgmsg("Enter");
-
+	pinctrl_select_state(data->pinctrl_info.pinctrl,
+		data->pinctrl_info.gpio_state_active);
 	/* need to init cci first */
 	ret = stmvl53l0_cci_init(data);
 	if (ret) {
 		vl53l0_errmsg("stmvl53l0_cci_init failed %d\n", __LINE__);
 		return ret;
 	}
-	/* actual power up */
-	if (data && data->device_type == MSM_CAMERA_PLATFORM_DEVICE) {
-		ret = stmvl53l0_vreg_control(data, 1);
-		if (ret < 0) {
-			vl53l0_errmsg("stmvl53l0_vreg_control failed %d\n",
-				__LINE__);
-			return ret;
-		}
-	}
+
+	msm_camera_request_gpio_table(
+		data->gconf.cam_gpio_req_tbl,
+		data->gconf.cam_gpio_req_tbl_size, 1);
+	gpio_set_value_cansleep(data->gconf.cam_gpio_req_tbl[0].gpio, 1);
 	data->power_up = 1;
 	*preset_flag = 1;
 	vl53l0_dbgmsg("End\n");
-
+	msleep(200);
 	return ret;
 }
 
@@ -356,18 +358,18 @@ int stmvl53l0_power_down_cci(void *cci_object)
 		ret = data->client->i2c_func_tbl->i2c_util(data->client,
 				MSM_CCI_RELEASE);
 		if (ret < 0)
-			vl53l0_errmsg("CCI Release failed rc %d\n", ret);
-
-		/* actual power down */
-		if (data->device_type == MSM_CAMERA_PLATFORM_DEVICE) {
-			ret = stmvl53l0_vreg_control(data, 0);
-			if (ret < 0) {
-				vl53l0_errmsg(
-					"stmvl53l0_vreg_control failed %d\n",
-					__LINE__);
-				return ret;
-			}
-		}
+			vl53l0_errmsg("%d,CCI Release failed rc %d\n",
+			__LINE__, ret);
+
+		pinctrl_select_state(data->pinctrl_info.pinctrl,
+			data->pinctrl_info.gpio_state_suspend);
+
+		msm_camera_request_gpio_table(
+			data->gconf.cam_gpio_req_tbl,
+			data->gconf.cam_gpio_req_tbl_size, 0);
+
+		gpio_set_value_cansleep(
+			data->gconf.cam_gpio_req_tbl[0].gpio, 0);
 	}
 	data->power_up = 0;
 	vl53l0_dbgmsg("End\n");
@@ -399,4 +401,4 @@ void stmvl53l0_exit_cci(void *cci_object)
 
 	vl53l0_dbgmsg("End\n");
 }
-#endif /* end of CAMERA_CCI */
+
diff --git a/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c b/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c
index f0c5ed74827..fb47333210d 100644
--- a/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c
+++ b/drivers/input/misc/vl53L0/stmvl53l0_module-i2c.c
@@ -1,23 +1,22 @@
 /*
- *  stmvl53l0_module-i2c.c - Linux kernel modules for STM VL53L0 FlightSense TOF
- *							sensor
- *
- *  Copyright (C) 2015 STMicroelectronics Imaging Division.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+*  stmvl53l0_module-i2c.c - Linux kernel modules for STM VL53L0 FlightSense TOF
+*							sensor
+*
+*  Copyright (C) 2015 STMicroelectronics Imaging Division.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2 of the License, or
+*  (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program;
+*/
 #include <linux/uaccess.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -51,7 +50,10 @@
 #include "stmvl53l0-i2c.h"
 #include "stmvl53l0-cci.h"
 #include "stmvl53l0.h"
-#ifndef CAMERA_CCI
+
+#define LASER_SENSOR_PINCTRL_STATE_SLEEP "laser_suspend"
+#define LASER_SENSOR_PINCTRL_STATE_DEFAULT "laser_default"
+
 
 /*
  * Global data
@@ -69,7 +71,8 @@ static int stmvl53l0_parse_vdd(struct device *dev, struct i2c_data *data)
 	if (dev->of_node) {
 		data->vana = regulator_get(dev, "vdd");
 		if (IS_ERR(data->vana)) {
-			vl53l0_errmsg("vdd supply is not provided\n");
+			vl53l0_errmsg("%d,vdd supply is not provided\n",
+				__LINE__);
 			ret = -1;
 		}
 	}
@@ -78,12 +81,117 @@ static int stmvl53l0_parse_vdd(struct device *dev, struct i2c_data *data)
 	return ret;
 }
 
+int get_dt_threshold_data(struct device_node *of_node, int *lowv, int *highv)
+{
+	int rc = 0;
+	uint32_t count = 0;
+	uint32_t v_array[2];
+
+	count = of_property_count_strings(of_node, "st,sensorthreshold");
+
+	if (!count)
+		return 0;
+
+	rc = of_property_read_u32_array(of_node, "st,sensorthreshold",
+		v_array, 2);
+
+	if (rc != -EINVAL) {
+		if (rc < 0) {
+			pr_err("%s failed %d\n", __func__, __LINE__);
+		} else {
+			*lowv = v_array[0];
+			*highv = v_array[1];
+		}
+	} else {
+		rc = 0;
+	}
+
+	return rc;
+}
+
+static int stmvl53l0_get_dt_data(struct device *dev, struct i2c_data *data)
+{
+	int rc = 0;
+	struct msm_camera_gpio_conf *gconf = NULL;
+	uint16_t *gpio_array = NULL;
+	uint16_t gpio_array_size = 0;
+	int i;
+	struct msm_pinctrl_info *sensor_pctrl = NULL;
+
+	vl53l0_dbgmsg("Enter\n");
+
+	sensor_pctrl = &data->pinctrl_info;
+	sensor_pctrl->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR_OR_NULL(sensor_pctrl->pinctrl)) {
+		pr_err("%s:%d Getting pinctrl handle failed\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+	sensor_pctrl->gpio_state_active =
+		pinctrl_lookup_state(sensor_pctrl->pinctrl,
+		LASER_SENSOR_PINCTRL_STATE_DEFAULT);
+
+	sensor_pctrl->gpio_state_suspend
+		= pinctrl_lookup_state(sensor_pctrl->pinctrl,
+		LASER_SENSOR_PINCTRL_STATE_SLEEP);
+
+	if (dev->of_node) {
+		struct device_node *of_node = dev->of_node;
+
+		if (!of_node) {
+			vl53l0_errmsg("failed %d\n", __LINE__);
+			return -EINVAL;
+		}
+
+		gpio_array_size = of_gpio_count(of_node);
+		gconf = &data->gconf;
+
+		if (gpio_array_size) {
+			gpio_array = kcalloc(gpio_array_size, sizeof(uint16_t),
+				GFP_KERNEL);
+
+			for (i = 0; i < gpio_array_size; i++) {
+				gpio_array[i] = of_get_gpio(of_node, i);
+				pr_err("%s gpio_array[%d] = %d\n", __func__, i,
+					gpio_array[i]);
+			}
+
+			rc = msm_camera_get_dt_gpio_req_tbl(of_node, gconf,
+				gpio_array, gpio_array_size);
+			if (rc < 0) {
+				pr_err("%s failed %d\n", __func__, __LINE__);
+				return rc;
+			}
+
+			rc = msm_camera_get_dt_gpio_set_tbl(of_node, gconf,
+				gpio_array, gpio_array_size);
+			if (rc < 0) {
+				pr_err("%s failed %d\n", __func__, __LINE__);
+				return rc;
+			}
+
+			rc = msm_camera_init_gpio_pin_tbl(of_node, gconf,
+				gpio_array, gpio_array_size);
+			if (rc < 0) {
+				pr_err("%s failed %d\n", __func__, __LINE__);
+				return rc;
+			}
+		}
+		rc = get_dt_threshold_data(of_node,
+			&(data->lowv), &(data->highv));
+	}
+	vl53l0_dbgmsg("End rc =%d\n", rc);
+
+	return rc;
+}
+
 static int stmvl53l0_probe(struct i2c_client *client,
 				   const struct i2c_device_id *id)
 {
 	int rc = 0;
 	struct stmvl53l0_data *vl53l0_data = NULL;
 	struct i2c_data *i2c_object = NULL;
+	int present;
 
 	vl53l0_dbgmsg("Enter\n");
 
@@ -92,13 +200,14 @@ static int stmvl53l0_probe(struct i2c_client *client,
 		return rc;
 	}
 
-	vl53l0_data = kzalloc(sizeof(struct stmvl53l0_data), GFP_KERNEL);
+	vl53l0_data = stmvl53l0_getobject();
 	if (!vl53l0_data) {
-		rc = -ENOMEM;
-		return rc;
+		vl53l0_errmsg("%d,data NULL\n", __LINE__);
+		return -EINVAL;
 	}
+
 	if (vl53l0_data)
-		i2c_object = &(vl53l0_data->client_object);
+		i2c_object = &(vl53l0_data->i2c_client_object);
 	i2c_object->client = client;
 
 	/* setup regulator */
@@ -113,9 +222,21 @@ static int stmvl53l0_probe(struct i2c_client *client,
 	/* setup client data */
 	i2c_set_clientdata(client, vl53l0_data);
 
+	stmvl53l0_get_dt_data(&client->dev, i2c_object);
+	rc = stmvl53l0_power_up_i2c(i2c_object, &present);
+	if (rc) {
+		vl53l0_errmsg("%d,error rc %d\n", __LINE__, rc);
+		return rc;
+	}
+	rc = stmvl53l0_checkmoduleid(vl53l0_data, i2c_object->client, I2C_BUS);
+	if (rc != 0) {
+		vl53l0_errmsg("%d,error rc %d\n", __LINE__, rc);
+		stmvl53l0_power_down_i2c(i2c_object);
+		return rc;
+	}
+	stmvl53l0_power_down_i2c(i2c_object);
 
-	/* setup other stuff */
-	rc = stmvl53l0_setup(vl53l0_data);
+	rc = stmvl53l0_setup(vl53l0_data, I2C_BUS);
 
 	vl53l0_dbgmsg("End\n");
 	return rc;
@@ -123,12 +244,12 @@ static int stmvl53l0_probe(struct i2c_client *client,
 
 static int stmvl53l0_remove(struct i2c_client *client)
 {
-	struct stmvl53l0_data *data = i2c_get_clientdata(client);
+	struct stmvl53l0_data *data = stmvl53l0_getobject();
 
 	vl53l0_dbgmsg("Enter\n");
 
 	/* Power down the device */
-	stmvl53l0_power_down_i2c((void *)&data->client_object);
+	stmvl53l0_power_down_i2c((void *)data->client_object);
 
 	vl53l0_dbgmsg("End\n");
 	return 0;
@@ -160,27 +281,19 @@ static struct i2c_driver stmvl6180_driver = {
 int stmvl53l0_power_up_i2c(void *i2c_object, unsigned int *preset_flag)
 {
 	int ret = 0;
-#ifndef STM_TEST
+
 	struct i2c_data *data = (struct i2c_data *)i2c_object;
-#endif
-	vl53l0_dbgmsg("Enter\n");
 
-	/* actual power on */
-#ifndef STM_TEST
-	ret = regulator_set_voltage(data->vana,	VL53L0_VDD_MIN, VL53L0_VDD_MAX);
-	if (ret < 0) {
-		vl53l0_errmsg("set_vol(%p) fail %d\n", data->vana , ret);
-		return ret;
-	}
-	ret = regulator_enable(data->vana);
-	msleep(3);
-	if (ret < 0) {
-		vl53l0_errmsg("reg enable(%p) failed.rc=%d\n", data->vana, ret);
-		return ret;
-	}
+	vl53l0_dbgmsg("Enter i2c powerup\n");
+
+	msm_camera_request_gpio_table(
+		data->gconf.cam_gpio_req_tbl,
+		data->gconf.cam_gpio_req_tbl_size, 1);
+
+	gpio_set_value_cansleep(data->gconf.cam_gpio_req_tbl[0].gpio, 1);
+
 	data->power_up = 1;
 	*preset_flag = 1;
-#endif
 
 	vl53l0_dbgmsg("End\n");
 	return ret;
@@ -189,20 +302,23 @@ int stmvl53l0_power_up_i2c(void *i2c_object, unsigned int *preset_flag)
 int stmvl53l0_power_down_i2c(void *i2c_object)
 {
 	int ret = 0;
-#ifndef STM_TEST
+
 	struct i2c_data *data = (struct i2c_data *)i2c_object;
-#endif
+
 
 	vl53l0_dbgmsg("Enter\n");
-#ifndef STM_TEST
-	msleep(3);
-	ret = regulator_disable(data->vana);
-	if (ret < 0)
-		vl53l0_errmsg("reg disable(%p) failed.rc=%d\n",
-			data->vana, ret);
+	if (data->power_up) {
+		pinctrl_select_state(data->pinctrl_info.pinctrl,
+			data->pinctrl_info.gpio_state_suspend);
+
+		msm_camera_request_gpio_table(
+			data->gconf.cam_gpio_req_tbl,
+			data->gconf.cam_gpio_req_tbl_size, 0);
+
+		gpio_set_value_cansleep(
+			data->gconf.cam_gpio_req_tbl[0].gpio, 0);
+	}
 
-	data->power_up = 0;
-#endif
 
 	vl53l0_dbgmsg("End\n");
 	return ret;
@@ -212,15 +328,6 @@ int stmvl53l0_init_i2c(void)
 {
 	int ret = 0;
 
-#ifdef STM_TEST
-	struct i2c_client *client = NULL;
-	struct i2c_adapter *adapter;
-	struct i2c_board_info info = {
-		.type = "stmvl53l0",
-		.addr = STMVL53L0_SLAVE_ADDR,
-	};
-#endif
-
 	vl53l0_dbgmsg("Enter\n");
 
 	/* register as a i2c client device */
@@ -228,18 +335,6 @@ int stmvl53l0_init_i2c(void)
 	if (ret)
 		vl53l0_errmsg("%d erro ret:%d\n", __LINE__, ret);
 
-#ifdef STM_TEST
-	if (!ret) {
-		adapter = i2c_get_adapter(4);
-		if (!adapter)
-			ret = -EINVAL;
-		else
-			client = i2c_new_device(adapter, &info);
-		if (!client)
-			ret = -EINVAL;
-	}
-#endif
-
 	vl53l0_dbgmsg("End with rc:%d\n", ret);
 
 	return ret;
@@ -253,4 +348,3 @@ void stmvl53l0_exit_i2c(void *i2c_object)
 	vl53l0_dbgmsg("End\n");
 }
 
-#endif /* end of NOT CAMERA_CCI */
diff --git a/drivers/input/misc/vl53L0/stmvl53l0_module.c b/drivers/input/misc/vl53L0/stmvl53l0_module.c
index f0343d15845..798e5981039 100644
--- a/drivers/input/misc/vl53L0/stmvl53l0_module.c
+++ b/drivers/input/misc/vl53L0/stmvl53l0_module.c
@@ -1,23 +1,22 @@
 /*
- *  stmvl53l0_module.c - Linux kernel modules for STM VL53L0 FlightSense TOF
- *						 sensor
- *
- *  Copyright (C) 2015 STMicroelectronics Imaging Division.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+*  stmvl53l0_module.c - Linux kernel modules for STM VL53L0 FlightSense TOF
+*						 sensor
+*
+*  Copyright (C) 2015 STMicroelectronics Imaging Division.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2 of the License, or
+*  (at your option) any later version.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with this program;
+*/
 #include <linux/uaccess.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -36,8 +35,8 @@
 #include <linux/platform_device.h>
 #include <linux/kobject.h>
 /*
- * API includes
- */
+* API includes
+*/
 #include "vl53l0_api.h"
 /*
 #include "vl53l0_def.h"
@@ -54,25 +53,26 @@
 struct timeval start_tv, stop_tv;
 #endif
 
-/*
- * Global data
- */
+#define SAR_LOW    30
+#define SAR_HIGH   40
+static char *devname = "laser";
+
+static struct stmvl53l0_data *gp_vl53l0_data;
 
-#ifdef CAMERA_CCI
-static struct stmvl53l0_module_fn_t stmvl53l0_module_func_tbl = {
+static struct stmvl53l0_module_fn_t stmvl53l0_module_func_tbl_cci = {
 	.init = stmvl53l0_init_cci,
 	.deinit = stmvl53l0_exit_cci,
 	.power_up = stmvl53l0_power_up_cci,
 	.power_down = stmvl53l0_power_down_cci,
 };
-#else
-static struct stmvl53l0_module_fn_t stmvl53l0_module_func_tbl = {
+
+static struct stmvl53l0_module_fn_t stmvl53l0_module_func_tbl_i2c = {
 	.init = stmvl53l0_init_i2c,
 	.deinit = stmvl53l0_exit_i2c,
 	.power_up = stmvl53l0_power_up_i2c,
 	.power_down = stmvl53l0_power_down_i2c,
 };
-#endif
+
 struct stmvl53l0_module_fn_t *pmodule_func_tbl;
 
 /*
@@ -81,6 +81,7 @@ struct stmvl53l0_module_fn_t *pmodule_func_tbl;
 #define VL53L0_IOCTL_INIT			_IO('p', 0x01)
 #define VL53L0_IOCTL_XTALKCALB		_IO('p', 0x02)
 #define VL53L0_IOCTL_OFFCALB		_IO('p', 0x03)
+#define VL53L0_IOCTL_STOPCALB		_IO('p', 0x04)
 #define VL53L0_IOCTL_STOP			_IO('p', 0x05)
 #define VL53L0_IOCTL_SETXTALK		_IOW('p', 0x06, unsigned int)
 #define VL53L0_IOCTL_SETOFFSET		_IOW('p', 0x07, int8_t)
@@ -91,135 +92,31 @@ struct stmvl53l0_module_fn_t *pmodule_func_tbl;
 #define VL53L0_IOCTL_PARAMETER \
 			_IOWR('p', 0x0d, struct stmvl53l0_parameter)
 
-#define CALIBRATION_FILE 1
-#ifdef CALIBRATION_FILE
-int8_t offset_calib;
-int16_t xtalk_calib;
-#endif
 
 static long stmvl53l0_ioctl(struct file *file,
 							unsigned int cmd,
 							unsigned long arg);
-/*static int stmvl53l0_flush(struct file *file, fl_owner_t id);*/
+static int stmvl53l0_flush(struct file *file, fl_owner_t id);
 static int stmvl53l0_open(struct inode *inode, struct file *file);
+static int stmvl53l0_close(struct inode *inode, struct file *file);
 static int stmvl53l0_init_client(struct stmvl53l0_data *data);
-static int stmvl53l0_start(struct stmvl53l0_data *data, uint8_t scaling,
-			init_mode_e mode);
+static int stmvl53l0_start(struct stmvl53l0_data *data);
 static int stmvl53l0_stop(struct stmvl53l0_data *data);
 
-#ifdef CALIBRATION_FILE
-static void stmvl53l0_read_calibration_file(struct stmvl53l0_data *data)
+void stmvl53l0_dumpreg(struct stmvl53l0_data *data)
 {
-	struct file *f;
-	char buf[8];
-	mm_segment_t fs;
-	int i, is_sign = 0;
-
-	f = filp_open("/data/calibration/offset", O_RDONLY, 0);
-	if (f != NULL && !IS_ERR(f) && f->f_dentry != NULL) {
-		fs = get_fs();
-		set_fs(get_ds());
-		/* init the buffer with 0 */
-		for (i = 0; i < 8; i++)
-			buf[i] = 0;
-		f->f_op->read(f, buf, 8, &f->f_pos);
-		set_fs(fs);
-		vl53l0_dbgmsg("offset as:%s, buf[0]:%c\n", buf, buf[0]);
-		offset_calib = 0;
-		for (i = 0; i < 8; i++) {
-			if (i == 0 && buf[0] == '-')
-				is_sign = 1;
-			else if (buf[i] >= '0' && buf[i] <= '9')
-				offset_calib = offset_calib * 10 +
-					(buf[i] - '0');
-			else
-				break;
-		}
-		if (is_sign == 1)
-			offset_calib = -offset_calib;
-		vl53l0_dbgmsg("offset_calib as %d\n", offset_calib);
-/*later
-		VL6180x_SetOffsetCalibrationData(vl53l0_dev, offset_calib);
-*/
-		filp_close(f, NULL);
-	} else {
-		vl53l0_errmsg("no offset calibration file exist!\n");
-	}
+	int i = 0;
+	uint8_t reg;
 
-	is_sign = 0;
-	f = filp_open("/data/calibration/xtalk", O_RDONLY, 0);
-	if (f != NULL && !IS_ERR(f) && f->f_dentry != NULL) {
-		fs = get_fs();
-		set_fs(get_ds());
-		/* init the buffer with 0 */
-		for (i = 0; i < 8; i++)
-			buf[i] = 0;
-		f->f_op->read(f, buf, 8, &f->f_pos);
-		set_fs(fs);
-		vl53l0_dbgmsg("xtalk as:%s, buf[0]:%c\n", buf, buf[0]);
-		xtalk_calib = 0;
-		for (i = 0; i < 8; i++) {
-			if (i == 0 && buf[0] == '-')
-				is_sign = 1;
-			else if (buf[i] >= '0' && buf[i] <= '9')
-				xtalk_calib = xtalk_calib * 10 + (buf[i] - '0');
-			else
-				break;
+	if (data->enableDebug) {
+		for (i = 1; i <= 0xff; i++) {
+			VL53L0_RdByte(data, i, &reg);
+			pr_err("STM VL53L0 reg= %x. value:%x.\n", i, reg);
 		}
-		if (is_sign == 1)
-			xtalk_calib = -xtalk_calib;
-		vl53l0_dbgmsg("xtalk_calib as %d\n", xtalk_calib);
-/* later
-		VL6180x_SetXTalkCompensationRate(vl53l0_dev, xtalk_calib);
-*/
-		filp_close(f, NULL);
-	} else {
-		vl53l0_errmsg("no xtalk calibration file exist!\n");
 	}
-	return;
-}
-
-static void stmvl53l0_write_offset_calibration_file(void)
-{
-	struct file *f;
-	char buf[8];
-	mm_segment_t fs;
-
-	f = filp_open("/data/calibration/offset", O_WRONLY|O_CREAT, 0644);
-	if (f != NULL) {
-		fs = get_fs();
-		set_fs(get_ds());
-		sprintf(buf, "%d", offset_calib);
-		vl53l0_dbgmsg("write offset as:%s, buf[0]:%c\n", buf, buf[0]);
-		f->f_op->write(f, buf, 8, &f->f_pos);
-		set_fs(fs);
-	}
-	filp_close(f, NULL);
 
-	return;
 }
 
-static void stmvl53l0_write_xtalk_calibration_file(void)
-{
-	struct file *f;
-	char buf[8];
-	mm_segment_t fs;
-
-	f = filp_open("/data/calibration/xtalk", O_WRONLY|O_CREAT, 0644);
-	if (f != NULL) {
-		fs = get_fs();
-		set_fs(get_ds());
-		sprintf(buf, "%d", xtalk_calib);
-		vl53l0_dbgmsg("write xtalk as:%s, buf[0]:%c\n", buf, buf[0]);
-		f->f_op->write(f, buf, 8, &f->f_pos);
-		set_fs(fs);
-	}
-	filp_close(f, NULL);
-
-	return;
-}
-#endif
-
 
 static void stmvl53l0_ps_read_measurement(struct stmvl53l0_data *data)
 {
@@ -249,132 +146,351 @@ static void stmvl53l0_ps_read_measurement(struct stmvl53l0_data *data)
 	if (data->enableDebug)
 		vl53l0_errmsg("range:%d, signalRateRtnMegaCps:%d, \
 				error:0x%x,rtnambrate:%u,measuretime:%u\n",
-			data->rangeData.RangeMilliMeter,
-			data->rangeData.SignalRateRtnMegaCps,
-			data->rangeData.RangeStatus,
-			data->rangeData.AmbientRateRtnMegaCps,
-			data->rangeData.MeasurementTimeUsec);
+				data->rangeData.RangeMilliMeter,
+				data->rangeData.SignalRateRtnMegaCps,
+				data->rangeData.RangeStatus,
+				data->rangeData.AmbientRateRtnMegaCps,
+				data->rangeData.MeasurementTimeUsec);
 
+}
 
+static void stmvl53l0_enter_off(struct stmvl53l0_data *data, uint8_t from)
+{
+	vl53l0_dbgmsg("Enter, stmvl53l0_enter_off from:%d\n", from);
+	mutex_lock(&data->work_mutex);
+		/* turn off tof sensor */
+		if (data->enable_ps_sensor == 1) {
+			data->enable_ps_sensor = 0;
+			/* to stop */
+			stmvl53l0_stop(data);
+		}
+
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
 }
+static void stmvl53l0_enter_cam(struct stmvl53l0_data *data, uint8_t from)
+{
+	mutex_lock(&data->work_mutex);
+	vl53l0_dbgmsg("Enter, stmvl53l0_enter_cam from:%d\n", from);
+	/* turn on tof sensor */
+	if (data->enable_ps_sensor == 0)
+		stmvl53l0_start(data);
+
+	vl53l0_dbgmsg("Call of VL53L0_DEVICEMODE_CONTINUOUS_RANGING\n");
+	VL53L0_SetGpioConfig(data, 0, 0,
+		VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY,
+		VL53L0_INTERRUPTPOLARITY_LOW);
+	VL53L0_SetDeviceMode(data,
+		VL53L0_DEVICEMODE_CONTINUOUS_RANGING);
+	VL53L0_StartMeasurement(data);
 
-static void stmvl53l0_cancel_handler(struct stmvl53l0_data *data)
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
+}
+static void stmvl53l0_enter_sar(struct stmvl53l0_data *data, uint8_t from)
+{
+	mutex_lock(&data->work_mutex);
+	vl53l0_dbgmsg("Enter,  from:%d\n", from);
+	/* turn on tof sensor */
+	if (data->enable_ps_sensor == 0)
+		stmvl53l0_start(data);
+
+	VL53L0_SetInterMeasurementPeriodMilliSeconds(data, data->delay_ms);
+
+	VL53L0_SetGpioConfig(data, 0, 0,
+		VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+		VL53L0_INTERRUPTPOLARITY_LOW);
+	VL53L0_SetSnrLimitValue(
+		data, 0, 1500);
+	VL53L0_SetSigmaLimitValue(data, 0, 10);
+	VL53L0_SetRateLimitValue(data, 0, 0xffffff);
+	VL53L0_SetSnrLimitValue(
+		data, 1, 3000);
+	VL53L0_SetSigmaLimitValue(data, 1, 10);
+	VL53L0_SetRateLimitValue(data, 1, 0xffffff);
+	VL53L0_SetSigmaLimitCheckEnable(data, 0, 1);
+	VL53L0_SetSnrLimitCheckEnable(data, 0, 1);
+	VL53L0_SetRateLimitCheckEnable(data, 0, 1);
+	VL53L0_SetSigmaLimitCheckEnable(data, 1, 1);
+	VL53L0_SetSnrLimitCheckEnable(data, 1, 1);
+	VL53L0_SetRateLimitCheckEnable(data, 1, 1);
+	VL53L0_SetInterruptThresholds(data, 0, 30 << 16, 40 << 16);
+	VL53L0_SetDeviceMode(data,
+		VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING);
+	data->lowint = 1;
+	msleep(20);
+	VL53L0_StartMeasurement(data);
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
+	stmvl53l0_dumpreg(data);
+}
+static void stmvl53l0_enter_super(struct stmvl53l0_data *data, uint8_t from)
+{
+	mutex_lock(&data->work_mutex);
+	vl53l0_dbgmsg("Enter, stmvl53l0_enter_super flag:%d\n", from);
+	if (from == SAR_MODE) {
+		vl53l0_dbgmsg("Call of VL53L0_DEVICEMODE_CONTINUOUS_RANGING\n");
+		VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+		VL53L0_SetDeviceMode(data,
+			VL53L0_DEVICEMODE_CONTINUOUS_RANGING);
+		VL53L0_StartMeasurement(data);
+	}
+
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
+}
+static void stmvl53l0_enter_xtalkcal(struct stmvl53l0_data *data,
+	uint8_t from)
+{
+	FixPoint1616_t XTalkCompensationRateMegaCps;
+
+	mutex_lock(&data->work_mutex);
+	vl53l0_dbgmsg("Enter, stmvl53l0_enter_cal flag:%d\n", from);
+	if (data->enable_ps_sensor == 0)
+		stmvl53l0_start(data);
+
+	VL53L0_SetXTalkCompensationEnable(data, 0);
+
+	VL53L0_PerformXTalkCalibration(data,
+		(100 << 16), &XTalkCompensationRateMegaCps);
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
+}
+static void stmvl53l0_enter_offsetcal(struct stmvl53l0_data *data,
+	uint8_t from)
+{
+	mutex_lock(&data->work_mutex);
+	vl53l0_dbgmsg("Enter, stmvl53l0_enter_cal flag:%d\n", from);
+	if (data->enable_ps_sensor == 0)
+		stmvl53l0_start(data);
+
+	VL53L0_SetXTalkCompensationEnable(data, 0);
+	VL53L0_SetOffsetCalibrationDataMicroMeter(data, 0);
+	vl53l0_dbgmsg("End\n");
+	mutex_unlock(&data->work_mutex);
+}
+static void stmvl53l0_work_state(
+struct stmvl53l0_data *data, uint8_t input)
 {
 	unsigned long flags;
-	bool ret;
+	int nochange = 0;
+	uint8_t from = data->w_mode;
 
+	vl53l0_dbgmsg("Enter, stmvl53l0_work_state:%d\n", input);
 	spin_lock_irqsave(&data->update_lock.wait_lock, flags);
-	/*
-	 * If work is already scheduled then subsequent schedules will not
-	 * change the scheduled time that's why we have to cancel it first.
-	 */
-	ret = cancel_delayed_work(&data->dwork);
-	if (ret == 0)
-		vl53l0_errmsg("cancel_delayed_work return FALSE\n");
+	switch (data->w_mode) {
+	case OFF_MODE:
+		if (input == CAM_ON)
+			data->w_mode = CAM_MODE;
+		else if (input == SAR_ON)
+			data->w_mode = SAR_MODE;
+		else if (input == XTALKCAL_ON)
+			data->w_mode = XTALKCAL_MODE;
+		else if (input == OFFSETCAL_ON)
+			data->w_mode = OFFSETCAL_MODE;
+		else {
+			vl53l0_dbgmsg("unsopport status = %d,cs = OFF_MODE",
+				input);
+			nochange = 1;
+		}
+		break;
+	case CAM_MODE:
+		if (input == CAM_OFF)
+			data->w_mode = OFF_MODE;
+		else if (input == SAR_ON)
+			data->w_mode = SUPER_MODE;
+		else {
+		vl53l0_dbgmsg("unsopport status = %d,cs = CAM_MODE", input);
+			nochange = 1;
+		}
+		break;
+	case SAR_MODE:
+		if (input == CAM_ON)
+			data->w_mode = SUPER_MODE;
+		else if (input == SAR_OFF)
+			data->w_mode = OFF_MODE;
+		else {
+		vl53l0_dbgmsg("unsopport status = %d,cs = SAR_MODE", input);
+			nochange = 1;
+		}
+		break;
+	case SUPER_MODE:
+		if (input == CAM_OFF)
+			data->w_mode = SAR_MODE;
+		else if (input == SAR_OFF)
+			data->w_mode = CAM_MODE;
+		else {
+		vl53l0_dbgmsg("unsopport status= %d,cs = SUPER_MODE", input);
+			nochange = 1;
+		}
+		break;
+	case XTALKCAL_MODE:
+		if (input == CAL_OFF)
+			data->w_mode = OFF_MODE;
+		else {
+		vl53l0_dbgmsg("unsopport status = %d,cs= SUPER_MODE", input);
+			data->w_mode = OFF_MODE;
+		}
+		break;
+	case OFFSETCAL_MODE:
+		if (input == CAL_OFF)
+			data->w_mode = OFF_MODE;
+		else {
+		vl53l0_dbgmsg("unsopport status= %d,cs = SUPER_MODE", input);
+			data->w_mode = OFF_MODE;
+		}
+		break;
+	default:
+		vl53l0_dbgmsg("unsopport status= %d,cs = unknown", input);
+		nochange = 1;
+		break;
+	}
 
 	spin_unlock_irqrestore(&data->update_lock.wait_lock, flags);
-
-	return;
+	if (nochange) {
+		vl53l0_dbgmsg("unsopport status= %d,cs = %d",
+		input, data->w_mode);
+		return;
+	}
+	switch (data->w_mode) {
+	case OFF_MODE:
+		stmvl53l0_enter_off(data, from);
+		break;
+	case CAM_MODE:
+		stmvl53l0_enter_cam(data, from);
+		break;
+	case SAR_MODE:
+		stmvl53l0_enter_sar(data, from);
+		break;
+	case SUPER_MODE:
+		stmvl53l0_enter_super(data, from);
+		break;
+	case XTALKCAL_MODE:
+		stmvl53l0_enter_xtalkcal(data, from);
+		break;
+	case OFFSETCAL_MODE:
+		stmvl53l0_enter_offsetcal(data, from);
+		break;
+	default:
+		pr_err("status unknown, input = %d", input);
+		break;
+	}
 }
 
-static void stmvl53l0_schedule_handler(struct stmvl53l0_data *data)
+static void stmvl53l0_cancel_handler(struct stmvl53l0_data *data)
 {
 	unsigned long flags;
+	bool ret;
 
 	spin_lock_irqsave(&data->update_lock.wait_lock, flags);
 	/*
 	 * If work is already scheduled then subsequent schedules will not
 	 * change the scheduled time that's why we have to cancel it first.
 	 */
-	cancel_delayed_work(&data->dwork);
-	schedule_delayed_work(&data->dwork, msecs_to_jiffies(data->delay_ms));
+	ret = cancel_delayed_work(&data->dwork);
+	if (ret == 0)
+		vl53l0_errmsg("%d,cancel_delayed_work return FALSE\n",
+		__LINE__);
+
 	spin_unlock_irqrestore(&data->update_lock.wait_lock, flags);
 
 	return;
 }
 
+static void stmvl53l0_state_process(void)
+{
+VL53L0_RangingMeasurementData_t    RMData;
+struct stmvl53l0_data *data = gp_vl53l0_data;
+VL53L0_DEV vl53l0_dev = data;
+char *envplow[2] = { "SAR LOW=1", NULL };
+char *envphigh[2] = { "SAR HIGH=1", NULL };
+
+VL53L0_GetRangingMeasurementData(vl53l0_dev, &RMData);
+
+vl53l0_dbgmsg("which MODE =%d\n", data->w_mode);
+memcpy(&(data->rangeData), &RMData,
+	sizeof(VL53L0_RangingMeasurementData_t));
+	if (CAM_MODE == data->w_mode) {
+		vl53l0_dbgmsg("CAM_MODE\n");
+		if (data->enableDebug)
+			pr_err("range:%d, signalRateRtnMegaCps:%d",
+			RMData.RangeMilliMeter,
+			RMData.SignalRateRtnMegaCps);
+	} else if (SAR_MODE == data->w_mode) {
+		vl53l0_dbgmsg("SAR_MODE\n");
+		if (RMData.RangeMilliMeter < SAR_LOW) {
+			vl53l0_dbgmsg("SAR enter LOW\n");
+			stmvl53l0_ps_read_measurement(vl53l0_dev);
+			VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+			VL53L0_SetInterMeasurementPeriodMilliSeconds(
+				data, data->delay_ms);
+
+			VL53L0_SetInterruptThresholds(
+			data, 0, SAR_LOW << 16, SAR_HIGH << 16);
+			VL53L0_SetDeviceMode(data,
+				VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING);
+			data->lowint = 0;
+			VL53L0_StartMeasurement(data);
+			kobject_uevent_env(&(data->miscdev.this_device->kobj),
+				KOBJ_CHANGE, envplow);
+			vl53l0_dbgmsg("SAR enter LOW sent uevent\n");
+		} else if (RMData.RangeMilliMeter > SAR_HIGH) {
+			vl53l0_dbgmsg("SAR enter HIGH\n");
+			stmvl53l0_ps_read_measurement(vl53l0_dev);
+			VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+			VL53L0_SetInterMeasurementPeriodMilliSeconds(
+				data, data->delay_ms);
+
+			VL53L0_SetInterruptThresholds(
+				data, 0, SAR_LOW << 16, SAR_HIGH << 16);
+			VL53L0_SetDeviceMode(data,
+				VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING);
+			data->lowint = 1;
+			VL53L0_StartMeasurement(data);
+			kobject_uevent_env(&(data->miscdev.this_device->kobj),
+				KOBJ_CHANGE, envphigh);
+		}
+	} else if (SUPER_MODE == data->w_mode) {
+		vl53l0_dbgmsg("SUPER_MODE\n");
+		if (RMData.RangeMilliMeter < SAR_LOW) {
+			vl53l0_dbgmsg("SAR enter LOW\n");
+			stmvl53l0_ps_read_measurement(vl53l0_dev);
+			kobject_uevent_env(&(data->miscdev.this_device->kobj),
+				KOBJ_CHANGE, envplow);
+		} else if (RMData.RangeMilliMeter > SAR_HIGH) {
+			vl53l0_dbgmsg("SAR enter HIGH\n");
+			stmvl53l0_ps_read_measurement(vl53l0_dev);
+			kobject_uevent_env(&(data->miscdev.this_device->kobj),
+				KOBJ_CHANGE, envphigh);
+		}
+	}
+	VL53L0_ClearInterruptMask(vl53l0_dev, 0);
+}
 /* interrupt work handler */
 static void stmvl53l0_work_handler(struct work_struct *work)
 {
-	struct stmvl53l0_data *data = container_of(work, struct stmvl53l0_data,
-				dwork.work);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
 	VL53L0_DEV vl53l0_dev = data;
-	uint8_t reg_val;
-	VL53L0_Error Status = VL53L0_ERROR_NONE;
-#ifdef DEBUG_TIME_LOG
-	long total_sec, total_msec;
-#endif
+	uint32_t InterruptMask;
+
+	vl53l0_dbgmsg("get in the handler\n");
 
 	mutex_lock(&data->work_mutex);
 
 	if (data->enable_ps_sensor == 1) {
-#ifdef USE_INT
-		VL53L0_RdByte(vl53l0_dev, VL53L0_REG_RESULT_INTERRUPT_STATUS,
-			&reg_val);
-		if (data->enableDebug)
-			pr_err("interrupt status reg as:0x%x, \
-				interrupt_received:%d\n",
-				reg_val, data->interrupt_received);
-
-		if (data->interrupt_received == 1) {
+		VL53L0_GetInterruptMaskStatus(vl53l0_dev, &InterruptMask);
 
+		vl53l0_dbgmsg(" InterruptMasksssss :%d\n", InterruptMask);
+		if (InterruptMask > 0 && data->interrupt_received == 1) {
 			data->interrupt_received = 0;
-			if ((reg_val & 0x07) > 0) {
-				Status = VL53L0_ClearInterruptMask(vl53l0_dev,
-						0);
-				Status = VL53L0_GetRangingMeasurementData(
-						vl53l0_dev, &(data->rangeData));
-				if (data->enableDebug)
-					pr_err("Measured range:%d\n",
-					data->rangeData.RangeMilliMeter);
-			}
+			stmvl53l0_state_process();
 		}
-
-
-		if (data->ps_is_singleshot == 1) {
-			VL53L0_SetDeviceMode(vl53l0_dev,
-				VL53L0_DEVICEMODE_SINGLE_RANGING);
-		    Status = VL53L0_StartMeasurement(vl53l0_dev);
-		} else if (data->ps_is_started == 0) { /*this is for continuous
-			mode  */
-			/*VL53L0_SetDeviceMode(vl53l0_dev,
-				VL53L0_DEVICEMODE_CONTINUOUS_RANGING); */
-			VL53L0_SetDeviceMode(vl53l0_dev,
-				VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING);
-
-			VL53L0_SetInterMeasurementPeriodMilliSeconds(vl53l0_dev,
-				20);
-		    Status = VL53L0_StartMeasurement(vl53l0_dev);
-			data->ps_is_started = 1;
-		}
-
-#else
-		/* vl53l0_dbgmsg("Enter\n"); */
-#ifdef DEBUG_TIME_LOG
-		do_gettimeofday(&start_tv);
-#endif
-		Status = VL53L0_PerformSingleRangingMeasurement(vl53l0_dev,
-			&(data->rangeData));
-#ifdef DEBUG_TIME_LOG
-		do_gettimeofday(&stop_tv);
-		total_sec = stop_tv.tv_sec - start_tv.tv_sec;
-		total_msec = (stop_tv.tv_usec - start_tv.tv_usec)/1000;
-		total_msec += total_sec * 1000;
-		pr_err("VL6180x_RangeGetMeasurement,\
-			elapsedTime:%ld\n", total_msec);
-#endif
-		/* to push the measurement *
-		if (RangingMeasurementData.status not equal NOT VALID)
-			stmvl53l0_ps_read_measurement(data);
-		*/
-		pr_err("Measured range:%d\n",\
-			data->rangeData.RangeMilliMeter);
-
-		/* restart timer */
-		schedule_delayed_work(&data->dwork,
-			msecs_to_jiffies((data->delay_ms)));
-#endif
-	    /* vl53l0_dbgmsg("End\n"); */
 	}
 
 	mutex_unlock(&data->work_mutex);
@@ -382,41 +498,29 @@ static void stmvl53l0_work_handler(struct work_struct *work)
 	return;
 }
 
-#ifdef USE_INT
-static irqreturn_t stmvl53l0_interrupt_handler(int vec, void *info)
-{
-
-	struct stmvl53l0_data *data = (struct stmvl53l0_data *)info;
-
-	if (data->irq == vec) {
-		data->interrupt_received = 1;
-		schedule_delayed_work(&data->dwork, 0);
-	}
-	return IRQ_HANDLED;
-}
-#endif
-
 /*
  * SysFS support
  */
 static ssize_t stmvl53l0_show_enable_ps_sensor(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
 
-	return sprintf(buf, "%d\n", data->enable_ps_sensor);
+	return snprintf(buf, 2, "%d\n", data->enable_ps_sensor);
 }
 
 static ssize_t stmvl53l0_store_enable_ps_sensor(struct device *dev,
-				struct device_attribute *attr, const char *buf,
-				size_t count)
+		struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
 
-	unsigned long val = simple_strtoul(buf, NULL, 10);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return count;
 
 	if ((val != 0) && (val != 1)) {
-		vl53l0_errmsg("store unvalid value=%ld\n", val);
+		vl53l0_errmsg("%d,store unvalid value=%ld\n", __LINE__, val);
 		return count;
 	}
 	mutex_lock(&data->work_mutex);
@@ -428,9 +532,9 @@ static ssize_t stmvl53l0_store_enable_ps_sensor(struct device *dev,
 		/* turn on tof sensor */
 		if (data->enable_ps_sensor == 0) {
 			/* to start */
-			stmvl53l0_start(data, 3, NORMAL_MODE);
+			stmvl53l0_start(data);
 		} else {
-			vl53l0_errmsg("Already enabled. Skip !");
+			vl53l0_errmsg("%d,Already enabled. Skip !", __LINE__);
 		}
 	} else {
 		/* turn off tof sensor */
@@ -447,27 +551,152 @@ static ssize_t stmvl53l0_store_enable_ps_sensor(struct device *dev,
 }
 
 static DEVICE_ATTR(enable_ps_sensor, S_IWUGO | S_IRUGO,
-				   stmvl53l0_show_enable_ps_sensor,
-					stmvl53l0_store_enable_ps_sensor);
+	stmvl53l0_show_enable_ps_sensor, stmvl53l0_store_enable_ps_sensor);
+static ssize_t stmvl53l0_show_set_mode(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+
+	return snprintf(buf, 3, "%d\n", data->d_mode);
+}
+
+/* for debug */
+static ssize_t stmvl53l0_store_set_mode(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+	VL53L0_RangingMeasurementData_t    RMData;
+	long on;
+	VL53L0_Error Status = VL53L0_ERROR_NONE;
+
+	if (kstrtoul(buf, 10, &on))
+		return count;
+	if (on > 6) {
+		vl53l0_errmsg("%d,set d_mode=%ld\n", __LINE__, on);
+		return count;
+	}
+	data->d_mode = on;
+	/* turn on tof sensor */
+	if (data->enable_ps_sensor == 0) {
+		/* to start */
+		stmvl53l0_start(data);
+	}
+	if (VL53L0_DEVICEMODE_SINGLE_RANGING == data->d_mode) {
+		vl53l0_dbgmsg("Call of VL53L0_DEVICEMODE_SINGLE_RANGING\n");
+		Status = VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+		Status = VL53L0_SetDeviceMode(data,
+			VL53L0_DEVICEMODE_SINGLE_RANGING);
+		Status = VL53L0_PerformSingleRangingMeasurement(data,
+			&RMData);
+		stmvl53l0_ps_read_measurement(data);
+	} else if (1 == data->d_mode) {
+		vl53l0_dbgmsg("Call of mode 1\n");
+		Status = VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+		Status = VL53L0_SetDeviceMode(data,
+			VL53L0_DEVICEMODE_CONTINUOUS_RANGING);
+		VL53L0_StartMeasurement(data);
+	} else if (2 == data->d_mode) {
+		vl53l0_dbgmsg("Call of mode 2\n");
+		Status = VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+		Status = VL53L0_SetDeviceMode(data,
+			VL53L0_DEVICEMODE_CONTINUOUS_RANGING);
+		VL53L0_SetInterruptThresholds(data, 0, 60 << 16, 80 << 16);
+		msleep(20);
+		VL53L0_StartMeasurement(data);
+
+	} else if (3 == data->d_mode) {
+		vl53l0_dbgmsg("Call  mode 3\n");
+		VL53L0_SetInterMeasurementPeriodMilliSeconds(data, 0x00001388);
+		VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_NEW_MEASURE_READY,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+
+		VL53L0_SetInterruptThresholds(data, 0, 30 << 16, 40 << 16);
+		Status = VL53L0_SetDeviceMode(data,
+			VL53L0_DEVICEMODE_CONTINUOUS_TIMED_RANGING);
+
+		VL53L0_StartMeasurement(data);
+	} else if (4 == data->d_mode) {
+		vl53l0_dbgmsg("Call of mode 4\n");
+		Status = VL53L0_SetGpioConfig(data, 0, 0,
+			VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH,
+			VL53L0_INTERRUPTPOLARITY_LOW);
+		Status = VL53L0_SetDeviceMode(data,
+			VL53L0_DEVICEMODE_CONTINUOUS_RANGING);
+		VL53L0_SetInterruptThresholds(data, 0, 30 << 16, 40 << 16);
+		msleep(20);
+		VL53L0_StartMeasurement(data);
+	} else if (5 == data->d_mode)
+		stmvl53l0_work_state(data, CAM_ON);
+	else if (6 == data->d_mode)
+		stmvl53l0_work_state(data, CAM_OFF);
+
+	return count;
+}
+/* DEVICE_ATTR(name,mode,show,store) */
+static DEVICE_ATTR(set_mode, S_IWUSR | S_IRUGO,
+	stmvl53l0_show_set_mode, stmvl53l0_store_set_mode);
+
+static ssize_t stmvl53l0_show_enable_sar(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+
+	return snprintf(buf, 3, "%d\n", data->w_mode);
+}
+
+/* for debug */
+static ssize_t stmvl53l0_store_enable_sar(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+	long on;
+
+	if (kstrtoul(buf, 10, &on))
+		return count;
+	if ((on != 0) && (on != 1)) {
+		vl53l0_errmsg("%d,set debug=%ld\n", __LINE__, on);
+		return count;
+	}
+
+	if (on)
+		stmvl53l0_work_state(data, SAR_ON);
+	else
+		stmvl53l0_work_state(data, SAR_OFF);
+
+	return count;
+}
+
+/* DEVICE_ATTR(name,mode,show,store) */
+static DEVICE_ATTR(enable_sar, S_IWUSR | S_IRUGO,
+	stmvl53l0_show_enable_sar, stmvl53l0_store_enable_sar);
+
 
 static ssize_t stmvl53l0_show_enable_debug(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct stmvl53l0_data *data = dev_get_drvdata(dev);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
 
-	return sprintf(buf, "%d\n", data->enableDebug);
+	return snprintf(buf, 3, "%d\n", data->enableDebug);
 }
 
 /* for debug */
 static ssize_t stmvl53l0_store_enable_debug(struct device *dev,
-					struct device_attribute *attr, const
-					char *buf, size_t count)
+		struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct stmvl53l0_data *data = dev_get_drvdata(dev);
-	long on = simple_strtoul(buf, NULL, 10);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+	long on;
 
+	if (kstrtoul(buf, 10, &on))
+		return count;
 	if ((on != 0) &&  (on != 1)) {
-		vl53l0_errmsg("set debug=%ld\n", on);
+		vl53l0_errmsg("%d,set debug=%ld\n", __LINE__, on);
 		return count;
 	}
 	data->enableDebug = on;
@@ -477,26 +706,27 @@ static ssize_t stmvl53l0_store_enable_debug(struct device *dev,
 
 /* DEVICE_ATTR(name,mode,show,store) */
 static DEVICE_ATTR(enable_debug, S_IWUSR | S_IRUGO,
-				   stmvl53l0_show_enable_debug,
-					stmvl53l0_store_enable_debug);
+	stmvl53l0_show_enable_debug, stmvl53l0_store_enable_debug);
 
 static ssize_t stmvl53l0_show_set_delay_ms(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct stmvl53l0_data *data = dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", data->delay_ms);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+
+	return snprintf(buf, 3, "%d\n", data->delay_ms);
 }
 
 /* for work handler scheduler time */
 static ssize_t stmvl53l0_store_set_delay_ms(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
+	struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct stmvl53l0_data *data = dev_get_drvdata(dev);
-	long delay_ms = simple_strtoul(buf, NULL, 10);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+	long delay_ms;
 
+	if (kstrtoul(buf, 10, &delay_ms))
+		return count;
 	if (delay_ms == 0) {
-		vl53l0_errmsg("set delay_ms=%ld\n", delay_ms);
+		vl53l0_errmsg("%d,set delay_ms=%ld\n", __LINE__, delay_ms);
 		return count;
 	}
 	mutex_lock(&data->work_mutex);
@@ -508,13 +738,36 @@ static ssize_t stmvl53l0_store_set_delay_ms(struct device *dev,
 
 /* DEVICE_ATTR(name,mode,show,store) */
 static DEVICE_ATTR(set_delay_ms, S_IWUGO | S_IRUGO,
-				   stmvl53l0_show_set_delay_ms,
-					stmvl53l0_store_set_delay_ms);
+	stmvl53l0_show_set_delay_ms, stmvl53l0_store_set_delay_ms);
+
+static ssize_t stmvl53l0_show_near(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+
+	return snprintf(buf, 5, "%d\n",
+		data->rangeData.RangeMilliMeter);
+}
+
+/* for work handler scheduler time */
+static ssize_t stmvl53l0_store_near(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	return count;
+}
+
+/* DEVICE_ATTR(name,mode,show,store) */
+static DEVICE_ATTR(near, S_IRUGO,
+	stmvl53l0_show_near, stmvl53l0_store_near);
+
 
 static struct attribute *stmvl53l0_attributes[] = {
 	&dev_attr_enable_ps_sensor.attr,
 	&dev_attr_enable_debug.attr,
 	&dev_attr_set_delay_ms.attr ,
+	&dev_attr_set_mode.attr,
+	&dev_attr_enable_sar.attr,
+	&dev_attr_near.attr,
 	NULL
 };
 
@@ -523,19 +776,18 @@ static const struct attribute_group stmvl53l0_attr_group = {
 	.attrs = stmvl53l0_attributes,
 };
 
+
 /*
- * misc device file operation functions
- */
+* misc device file operation functions
+*/
 static int stmvl53l0_ioctl_handler(struct file *file,
-			unsigned int cmd, unsigned long arg,
-			void __user *p)
+	unsigned int cmd, unsigned long arg, void __user *p)
 {
 	int rc = 0;
 	unsigned int xtalkint = 0;
 	int8_t offsetint = 0;
-	struct stmvl53l0_data *data =
-			container_of(file->private_data,
-				struct stmvl53l0_data, miscdev);
+	struct stmvl53l0_data *data = gp_vl53l0_data;
+
 	struct stmvl53l0_register reg;
 	struct stmvl53l0_parameter parameter;
 	VL53L0_DEV vl53l0_dev = data;
@@ -545,29 +797,17 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 
 	vl53l0_dbgmsg("Enter enable_ps_sensor:%d\n", data->enable_ps_sensor);
 	switch (cmd) {
-	/* enable */
+		/* enable */
 	case VL53L0_IOCTL_INIT:
 		vl53l0_dbgmsg("VL53L0_IOCTL_INIT\n");
-		/* turn on tof sensor only if it's not enabled by other
-		client */
-		if (data->enable_ps_sensor == 0) {
-			/* to start */
-			stmvl53l0_start(data, 3, NORMAL_MODE);
-		} else
-			rc = -EINVAL;
+		stmvl53l0_work_state(data, CAM_ON);
 		break;
-	/* crosstalk calibration */
+		/* crosstalk calibration */
 	case VL53L0_IOCTL_XTALKCALB:
 		vl53l0_dbgmsg("VL53L0_IOCTL_XTALKCALB\n");
-		/* turn on tof sensor only if it's not enabled by other
-		client */
-		if (data->enable_ps_sensor == 0) {
-			/* to start */
-			stmvl53l0_start(data, 3, XTALKCALIB_MODE);
-		} else
-			rc = -EINVAL;
+		stmvl53l0_work_state(data, XTALKCAL_ON);
 		break;
-	/* set up Xtalk value */
+		/* set up Xtalk value */
 	case VL53L0_IOCTL_SETXTALK:
 		vl53l0_dbgmsg("VL53L0_IOCTL_SETXTALK\n");
 		if (copy_from_user(&xtalkint, (unsigned int *)p,
@@ -576,24 +816,17 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 			return -EFAULT;
 		}
 		vl53l0_dbgmsg("SETXTALK as 0x%x\n", xtalkint);
-#ifdef CALIBRATION_FILE
-		xtalk_calib = xtalkint;
-		stmvl53l0_write_xtalk_calibration_file();
-#endif
-/* later
-		VL6180x_SetXTalkCompensationRate(vl53l0_dev, xtalkint);
-*/
 		break;
-	/* offset calibration */
+		/* offset calibration */
 	case VL53L0_IOCTL_OFFCALB:
 		vl53l0_dbgmsg("VL53L0_IOCTL_OFFCALB\n");
-		if (data->enable_ps_sensor == 0) {
-			/* to start */
-			stmvl53l0_start(data, 3, OFFSETCALIB_MODE);
-		} else
-			rc = -EINVAL;
+		stmvl53l0_work_state(data, OFFSETCAL_ON);
 		break;
-	/* set up offset value */
+	case VL53L0_IOCTL_STOPCALB:
+		vl53l0_dbgmsg("VL53L0_IOCTL_OFFCALB\n");
+		stmvl53l0_work_state(data, CAL_OFF);
+		break;
+		/* set up offset value */
 	case VL53L0_IOCTL_SETOFFSET:
 		vl53l0_dbgmsg("VL53L0_IOCTL_SETOFFSET\n");
 		if (copy_from_user(&offsetint, (int8_t *)p, sizeof(int8_t))) {
@@ -601,25 +834,14 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 			return -EFAULT;
 		}
 		vl53l0_dbgmsg("SETOFFSET as %d\n", offsetint);
-#ifdef CALIBRATION_FILE
-		offset_calib = offsetint;
-		stmvl53l0_write_offset_calibration_file();
-#endif
-/* later
-		VL6180x_SetOffsetCalibrationData(vl53l0_dev, offsetint);
-*/
+
 		break;
-	/* disable */
+		/* disable */
 	case VL53L0_IOCTL_STOP:
 		vl53l0_dbgmsg("VL53L0_IOCTL_STOP\n");
-		/* turn off tof sensor only if it's enabled by other client */
-		if (data->enable_ps_sensor == 1) {
-			data->enable_ps_sensor = 0;
-			/* to stop */
-			stmvl53l0_stop(data);
-		}
+		stmvl53l0_work_state(data, CAL_OFF);
 		break;
-	/* Get all range data */
+		/* Get all range data */
 	case VL53L0_IOCTL_GETDATAS:
 		vl53l0_dbgmsg("VL53L0_IOCTL_GETDATAS\n");
 		if (copy_to_user((VL53L0_RangingMeasurementData_t *)p,
@@ -629,9 +851,14 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 			return -EFAULT;
 		}
 		break;
-	/* Register tool */
+		/* Register tool */
 	case VL53L0_IOCTL_REGISTER:
 		vl53l0_dbgmsg("VL53L0_IOCTL_REGISTER\n");
+		/* turn on tof sensor */
+		if (data->enable_ps_sensor == 0) {
+			/* to start */
+			stmvl53l0_start(data);
+		}
 		if (copy_from_user(&reg, (struct stmvl53l0_register *)p,
 			sizeof(struct stmvl53l0_register))) {
 			vl53l0_errmsg("%d, fail\n", __LINE__);
@@ -639,8 +866,7 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 		}
 		reg.status = 0;
 		page_num = (uint8_t)((reg.reg_index & 0x0000ff00) >> 8);
-		vl53l0_dbgmsg("VL53L0_IOCTL_REGISTER,\
-			page number:%d\n", page_num);
+		vl53l0_dbgmsg("IOCTL_REGISTER, page num:%d\n", page_num);
 		if (page_num != 0)
 			reg.status = VL53L0_WrByte(vl53l0_dev, 0xFF, page_num);
 
@@ -648,32 +874,30 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 		case(4):
 			if (reg.is_read)
 				reg.status = VL53L0_RdDWord(vl53l0_dev,
-					(uint8_t)reg.reg_index,
-					&reg.reg_data);
+				(uint8_t)reg.reg_index, &reg.reg_data);
 			else
 				reg.status = VL53L0_WrDWord(vl53l0_dev,
-					(uint8_t)reg.reg_index,
-					reg.reg_data);
+				(uint8_t)reg.reg_index, reg.reg_data);
 			break;
 		case(2):
 			if (reg.is_read)
 				reg.status = VL53L0_RdWord(vl53l0_dev,
-					(uint8_t)reg.reg_index,
-					(uint16_t *)&reg.reg_data);
+				(uint8_t)reg.reg_index,
+				(uint16_t *)&reg.reg_data);
 			else
 				reg.status = VL53L0_WrWord(vl53l0_dev,
-					(uint8_t)reg.reg_index,
-					(uint16_t)reg.reg_data);
+				(uint8_t)reg.reg_index,
+				(uint16_t)reg.reg_data);
 			break;
 		case(1):
 			if (reg.is_read)
 				reg.status = VL53L0_RdByte(vl53l0_dev,
-					(uint8_t)reg.reg_index,
-					(uint8_t *)&reg.reg_data);
+				(uint8_t)reg.reg_index,
+				(uint8_t *)&reg.reg_data);
 			else
 				reg.status = VL53L0_WrByte(vl53l0_dev,
-					(uint8_t)reg.reg_index,
-					(uint8_t)reg.reg_data);
+				(uint8_t)reg.reg_index,
+				(uint8_t)reg.reg_data);
 			break;
 		default:
 			reg.status = -1;
@@ -684,16 +908,21 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 
 
 		if (copy_to_user((struct stmvl53l0_register *)p, &reg,
-				sizeof(struct stmvl53l0_register))) {
+			sizeof(struct stmvl53l0_register))) {
 			vl53l0_errmsg("%d, fail\n", __LINE__);
 			return -EFAULT;
 		}
 		break;
-	/* parameter access */
+		/* parameter access */
 	case VL53L0_IOCTL_PARAMETER:
 		vl53l0_dbgmsg("VL53L0_IOCTL_PARAMETER\n");
+		/* turn on tof sensor */
+		if (data->enable_ps_sensor == 0) {
+			/* to start */
+			stmvl53l0_start(data);
+		}
 		if (copy_from_user(&parameter, (struct stmvl53l0_parameter *)p,
-				sizeof(struct stmvl53l0_parameter))) {
+			sizeof(struct stmvl53l0_parameter))) {
 			vl53l0_errmsg("%d, fail\n", __LINE__);
 			return -EFAULT;
 		}
@@ -703,46 +932,96 @@ static int stmvl53l0_ioctl_handler(struct file *file,
 			if (parameter.is_read)
 				parameter.status =
 				VL53L0_GetOffsetCalibrationDataMicroMeter(
-						vl53l0_dev, &parameter.value);
+				vl53l0_dev, &parameter.value);
 			else
 				parameter.status =
 				VL53L0_SetOffsetCalibrationDataMicroMeter(
-						vl53l0_dev, parameter.value);
+					vl53l0_dev, parameter.value);
 			break;
 		case (XTALKRATE_PAR):
 			if (parameter.is_read)
 				parameter.status =
-					VL53L0_GetXTalkCompensationRateMegaCps(
-						vl53l0_dev, (FixPoint1616_t *)
-						&parameter.value);
+				VL53L0_GetXTalkCompensationRateMegaCps(
+				vl53l0_dev, (FixPoint1616_t *)&parameter.value);
 			else
 				parameter.status =
-					VL53L0_SetXTalkCompensationRateMegaCps(
-						vl53l0_dev,
-						(FixPoint1616_t)
-							parameter.value);
+				VL53L0_SetXTalkCompensationRateMegaCps(
+				vl53l0_dev, (FixPoint1616_t)parameter.value);
 
 			break;
 		case (XTALKENABLE_PAR):
 			if (parameter.is_read)
 				parameter.status =
-					VL53L0_GetXTalkCompensationEnable(
-						vl53l0_dev,
-						(uint8_t *) &parameter.value);
+				VL53L0_GetXTalkCompensationEnable(
+				vl53l0_dev, (uint8_t *)&parameter.value);
+			else
+				parameter.status =
+				VL53L0_SetXTalkCompensationEnable(
+				vl53l0_dev, (uint8_t)parameter.value);
+			break;
+
+		case (SNRVAL_PRA):
+			if (parameter.is_read)
+				parameter.status =
+				VL53L0_GetSnrLimitValue(vl53l0_dev,
+				0, (FixPoint1616_t *)&parameter.value);
+			else
+				parameter.status =
+				VL53L0_SetSnrLimitValue(
+				vl53l0_dev, 0, (FixPoint1616_t)parameter.value);
+			break;
+
+		case (SNRCTL_PRA):
+			if (parameter.is_read)
+				parameter.status =
+				VL53L0_GetSnrLimitCheckEnable(vl53l0_dev,
+				0, (uint8_t *)&parameter.value);
 			else
 				parameter.status =
-					VL53L0_SetXTalkCompensationEnable(
-						vl53l0_dev,
-						(uint8_t) parameter.value);
+				VL53L0_SetSnrLimitCheckEnable(
+				vl53l0_dev, 0, (uint8_t)parameter.value);
 			break;
 
+		case (WRAPAROUNDCTL_PRA):
+			if (parameter.is_read)
+				parameter.status =
+				VL53L0_GetWrapAroundCheckEnable(
+				vl53l0_dev, (uint8_t *)&parameter.value);
+			else
+				parameter.status =
+				VL53L0_SetWrapAroundCheckEnable(
+				vl53l0_dev, (uint8_t)parameter.value);
+			break;
+
+		case (INTERMEASUREMENTPERIOD_PAR):
+			if (parameter.is_read)
+				parameter.status =
+				VL53L0_GetInterMeasurementPeriodMilliSeconds(
+				vl53l0_dev, (uint32_t *)&parameter.value);
+			else
+				parameter.status =
+				VL53L0_SetInterMeasurementPeriodMilliSeconds(
+				vl53l0_dev, (uint32_t)parameter.value);
+			break;
+
+		case (MEASUREMENTTIMINGBUDGET_PAR):
+			if (parameter.is_read)
+				parameter.status =
+				VL53L0_GetMeasurementTimingBudgetMicroSeconds(
+				vl53l0_dev, (uint32_t *)&parameter.value);
+			else
+				parameter.status =
+				VL53L0_SetMeasurementTimingBudgetMicroSeconds(
+				vl53l0_dev, (uint32_t)parameter.value);
+			break;
 		}
-		if (copy_to_user((struct stmvl53l0_parameter *)p, &reg,
-				sizeof(struct stmvl53l0_register))) {
+		if (copy_to_user((struct stmvl53l0_parameter *)p, &parameter,
+			sizeof(struct stmvl53l0_parameter))) {
 			vl53l0_errmsg("%d, fail\n", __LINE__);
 			return -EFAULT;
 		}
 		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -755,39 +1034,91 @@ static int stmvl53l0_open(struct inode *inode, struct file *file)
 {
 	return 0;
 }
-#if 0
-static int stmvl53l0_flush(struct file *file, fl_owner_t id)
+
+static int stmvl53l0_close(struct inode *inode, struct file *file)
 {
-	struct stmvl53l0_data *data = container_of(file->private_data,
-						struct stmvl53l0_data, miscdev);
-	(void) file;
-	(void) id;
+	struct stmvl53l0_data *data = gp_vl53l0_data;
 
-	if (data) {
-		if (data->enable_ps_sensor == 1) {
-			/* turn off tof sensor if it's enabled */
-			data->enable_ps_sensor = 0;
-			/* to stop */
-			stmvl53l0_stop(data);
-		}
-	}
+	if (data->w_mode == CAM_MODE || data->w_mode == SUPER_MODE)
+		stmvl53l0_work_state(data, CAM_OFF);
+	if (data->w_mode == XTALKCAL_MODE || data->w_mode == OFFSETCAL_MODE)
+		stmvl53l0_work_state(data, CAL_OFF);
 	return 0;
 }
-#endif
+
+static int stmvl53l0_flush(struct file *file, fl_owner_t id)
+{
+	return 0;
+}
+
 static long stmvl53l0_ioctl(struct file *file,
 				unsigned int cmd, unsigned long arg)
 {
 	int ret;
-	struct stmvl53l0_data *data =
-			container_of(file->private_data,
-					struct stmvl53l0_data, miscdev);
-	mutex_lock(&data->work_mutex);
 	ret = stmvl53l0_ioctl_handler(file, cmd, arg, (void __user *)arg);
-	mutex_unlock(&data->work_mutex);
-
 	return ret;
 }
 
+
+int stmvl53l0_checkmoduleid(struct stmvl53l0_data *data,
+	void *client, uint8_t type)
+{
+	uint8_t id = 0;
+	int err;
+
+	vl53l0_dbgmsg("Enter\n");
+	if (type == CCI_BUS) {
+		struct msm_camera_i2c_client *cci_pclient =
+			(struct msm_camera_i2c_client *)client;
+
+		cci_pclient->i2c_func_tbl->i2c_read_seq(cci_pclient,
+			0xc0, &id, 1);
+	} else {
+		struct i2c_client *i2c_pclient = (struct i2c_client *)client;
+		struct i2c_msg msg[1];
+		uint8_t buff;
+
+		buff = 0xc0;
+		msg[0].addr = i2c_pclient->addr;
+		msg[0].flags = I2C_M_WR;
+		msg[0].buf = &buff;
+		msg[0].len = 1;
+
+		err = i2c_transfer(i2c_pclient->adapter, msg, 1);
+		if (err != 1) {
+			pr_err("%s: i2c_transfer err:%d, addr:0x%x, reg:0x%x\n",
+				__func__, err, i2c_pclient->addr, buff);
+			err = -1;
+			return err;
+		}
+
+		msg[0].addr = i2c_pclient->addr;
+		msg[0].flags = I2C_M_RD | i2c_pclient->flags;
+		msg[0].buf = &id;
+		msg[0].len = 1;
+
+		err = i2c_transfer(i2c_pclient->adapter, &msg[0], 1);
+		if (err != 1) {
+			pr_err("%s: Read i2c_transfer err:%d, addr:0x%x\n",
+				__func__, err, i2c_pclient->addr);
+			err = -1;
+			return err;
+		}
+	}
+	/* Read Model ID */
+
+	vl53l0_dbgmsg("read MODLE_ID: 0x%x\n", id);
+	if (id == 0xee) {
+		vl53l0_errmsg("STM VL53L0 Found %d\n", __LINE__);
+		return 0;
+	}
+
+	vl53l0_errmsg("Not found STM VL53L0 %d\n", __LINE__);
+		return -EIO;
+
+
+}
+
 /*
  * Initialization function
  */
@@ -800,99 +1131,91 @@ static int stmvl53l0_init_client(struct stmvl53l0_data *data)
 	VL53L0_DEV vl53l0_dev = data;
 
 	vl53l0_dbgmsg("Enter\n");
-
-
 	/* Read Model ID */
-	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_MODEL_ID, &id);
-	vl53l0_errmsg("read MODLE_ID: 0x%x\n", id);
+	VL53L0_RdByte(vl53l0_dev, 0xc0, &id);
+	vl53l0_dbgmsg("read MODLE_ID: 0x%x\n", id);
 	if (id == 0xee) {
-		vl53l0_errmsg("STM VL53L0 Found\n");
+		vl53l0_errmsg("%d,STM VL53L0 Found\n", __LINE__);
 	} else if (id == 0) {
-		vl53l0_errmsg("Not found STM VL53L0\n");
+		vl53l0_errmsg("%d,Not found STM VL53L0\n", __LINE__);
 		return -EIO;
 	}
-	VL53L0_RdByte(vl53l0_dev, 0xc1, &id);
-	vl53l0_errmsg("read 0xc1: 0x%x\n", id);
-	VL53L0_RdByte(vl53l0_dev, 0xc2, &id);
-	vl53l0_errmsg("read 0xc2: 0x%x\n", id);
-	VL53L0_RdByte(vl53l0_dev, 0xc3, &id);
-	vl53l0_errmsg("read 0xc3: 0x%x\n", id);
 
 	/* Read Model Version */
-	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_MODEL_TYPE, &type);
-	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_REVISION_ID,
-		&revision);
-	VL53L0_RdByte(vl53l0_dev, VL53L0_REG_IDENTIFICATION_MODULE_ID,
-		&module_id);
-	vl53l0_errmsg("STM VL53L0 Model type : %d. rev:%d. module:%d\n", type,
-		revision, module_id);
-
-	vl53l0_dev->I2cDevAddr      = 0x52;
-	vl53l0_dev->comms_type      =  1;
-	vl53l0_dev->comms_speed_khz =  400;
+
+	VL53L0_RdByte(vl53l0_dev,
+		VL53L0_REG_IDENTIFICATION_MODEL_TYPE, &type);
+	VL53L0_RdByte(vl53l0_dev,
+		VL53L0_REG_IDENTIFICATION_REVISION_ID, &revision);
+	VL53L0_RdByte(vl53l0_dev,
+		VL53L0_REG_IDENTIFICATION_MODULE_ID, &module_id);
+
+	vl53l0_dev->I2cDevAddr = 0x29;
+	vl53l0_dev->comms_type = 1;
+	vl53l0_dev->comms_speed_khz = 400;
 
 	if (Status == VL53L0_ERROR_NONE && data->reset) {
-		pr_err("Call of VL53L0_DataInit\n");
-		Status = VL53L0_DataInit(vl53l0_dev); /* Data initialization */
+		vl53l0_dbgmsg("Call of VL53L0_DataInit\n");
+		Status = VL53L0_DataInit(vl53l0_dev);
 		data->reset = 0;
 	}
 
 	if (Status == VL53L0_ERROR_NONE) {
-		pr_err("VL53L0_GetDeviceInfo:\n");
+		vl53l0_dbgmsg("VL53L0_GetDeviceInfo:\n");
 		Status = VL53L0_GetDeviceInfo(vl53l0_dev, &DeviceInfo);
 		if (Status == VL53L0_ERROR_NONE) {
-			pr_err("Device Name : %s\n", DeviceInfo.Name);
-			pr_err("Device Type : %s\n", DeviceInfo.Type);
-			pr_err("ProductType : %d\n", DeviceInfo.ProductType);
-			pr_err("ProductRevisionMajor : %d\n",
+			vl53l0_dbgmsg("Device Name : %s\n", DeviceInfo.Name);
+			vl53l0_dbgmsg("Device Type : %s\n", DeviceInfo.Type);
+			vl53l0_dbgmsg("ProductType : %d\n",
+				DeviceInfo.ProductType);
+			vl53l0_dbgmsg("ProductRevisionMajor : %d\n",
 				DeviceInfo.ProductRevisionMajor);
-			pr_err("ProductRevisionMinor : %d\n",
+			vl53l0_dbgmsg("ProductRevisionMinor : %d\n",
 				DeviceInfo.ProductRevisionMinor);
 		}
 	}
 
 	if (Status == VL53L0_ERROR_NONE) {
-		pr_err("Call of VL53L0_StaticInit\n");
+		vl53l0_dbgmsg("Call of VL53L0_StaticInit\n");
 		Status = VL53L0_StaticInit(vl53l0_dev);
-		/* Device Initialization */
 	}
 
 	if (Status == VL53L0_ERROR_NONE) {
 
-		pr_err("Call of VL53L0_SetDeviceMode\n");
+		vl53l0_dbgmsg("Call of VL53L0_SetDeviceMode\n");
 		Status = VL53L0_SetDeviceMode(vl53l0_dev,
-					VL53L0_DEVICEMODE_SINGLE_RANGING);
-		/* Setup in	single ranging mode */
+			VL53L0_DEVICEMODE_SINGLE_RANGING);
 	}
-	/*  Enable/Disable Sigma and Signal check */
+	/* Enable/Disable Sigma and Signal check*/
 	if (Status == VL53L0_ERROR_NONE)
 		Status = VL53L0_SetSigmaLimitCheckEnable(vl53l0_dev, 0, 1);
 
 	if (Status == VL53L0_ERROR_NONE)
 		Status = VL53L0_SetSignalLimitCheckEnable(vl53l0_dev, 0, 1);
 
-	/* set user calibration data - need to be called after
-	VL6180x_InitData
-	*/
-#ifdef CALIBRATION_FILE
-	/*stmvl53l0_read_calibration_file(data);*/
-#endif
-
 	vl53l0_dbgmsg("End\n");
 
 	return 0;
 }
 
-static int stmvl53l0_start(struct stmvl53l0_data *data, uint8_t scaling,
-	init_mode_e mode)
+irqreturn_t laser_isr(int irq, void *dev)
 {
-	int rc = 0;
-	VL53L0_DEV vl53l0_dev = data;
+	struct stmvl53l0_data *data = gp_vl53l0_data;
 
-	vl53l0_dbgmsg("Enter\n");
+	vl53l0_dbgmsg("interrupt called");
+	if (data->w_mode != OFF_MODE || data->d_mode > 0) {
+		data->interrupt_received = 1;
+		schedule_delayed_work(&data->dwork, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+static int stmvl53l0_start(struct stmvl53l0_data *data)
+{
+	int rc = 0;
 
 	/* Power up */
-	rc = pmodule_func_tbl->power_up(&data->client_object, &data->reset);
+	rc = pmodule_func_tbl->power_up(data->client_object, &data->reset);
 	if (rc) {
 		vl53l0_errmsg("%d,error rc %d\n", __LINE__, rc);
 		return rc;
@@ -901,41 +1224,11 @@ static int stmvl53l0_start(struct stmvl53l0_data *data, uint8_t scaling,
 	rc = stmvl53l0_init_client(data);
 	if (rc) {
 		vl53l0_errmsg("%d, error rc %d\n", __LINE__, rc);
-		pmodule_func_tbl->power_down(&data->client_object);
+		pmodule_func_tbl->power_down(data->client_object);
 		return -EINVAL;
 	}
 
-	/* check mode */
-	if (mode != NORMAL_MODE)
-		VL53L0_SetXTalkCompensationEnable(vl53l0_dev, 0);
-
-	if (mode == OFFSETCALIB_MODE)
-		VL53L0_SetOffsetCalibrationDataMicroMeter(vl53l0_dev, 0);
-	else if (mode == XTALKCALIB_MODE) {
-		FixPoint1616_t XTalkCompensationRateMegaCps;
-		/*caltarget distance : 100mm and convert to
-		* fixed point 16 16 format
-		*/
-		VL53L0_PerformXTalkCalibration(vl53l0_dev, (100<<16),
-			&XTalkCompensationRateMegaCps);
-		pr_err("Xtalk comensation:%u\n", XTalkCompensationRateMegaCps);
-	}
-
-	VL53L0_SetGpioConfig(vl53l0_dev, 0, 0,
-		VL53L0_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW,
-		VL53L0_INTERRUPTPOLARITY_LOW);
-	VL53L0_SetInterruptThresholds(vl53l0_dev, 0, (100<<16), 0);
-
-	/* ps_is_singleshot:	1-> for single shot mode
-	*						0-> for continus mode
-	*/
-	data->ps_is_singleshot = 0;
-	data->ps_is_started = 0; /* mainly for continuous mode*/
 	data->enable_ps_sensor = 1;
-
-	/* enable work handler */
-	stmvl53l0_schedule_handler(data);
-
 	vl53l0_dbgmsg("End\n");
 
 	return rc;
@@ -944,27 +1237,23 @@ static int stmvl53l0_start(struct stmvl53l0_data *data, uint8_t scaling,
 static int stmvl53l0_stop(struct stmvl53l0_data *data)
 {
 	int rc = 0;
-	VL53L0_DEV vl53l0_dev = data;
 
 	vl53l0_dbgmsg("Enter\n");
-
-	/* stop - if continuous mode */
-	if (data->ps_is_singleshot == 0)
-		VL53L0_StopMeasurement(vl53l0_dev);
+		VL53L0_StopMeasurement(data);
 
 	/* clean interrupt */
-	VL53L0_ClearInterruptMask(vl53l0_dev, 0);
-
+	VL53L0_ClearInterruptMask(data, 0);
 	/* cancel work handler */
 	stmvl53l0_cancel_handler(data);
 	/* power down */
-	rc = pmodule_func_tbl->power_down(&data->client_object);
+	rc = pmodule_func_tbl->power_down(data->client_object);
 	if (rc) {
 		vl53l0_errmsg("%d, error rc %d\n", __LINE__, rc);
 		return rc;
 	}
 	vl53l0_dbgmsg("End\n");
 
+
 	return rc;
 }
 
@@ -975,7 +1264,8 @@ static const struct file_operations stmvl53l0_ranging_fops = {
 	.owner =			THIS_MODULE,
 	.unlocked_ioctl =	stmvl53l0_ioctl,
 	.open =				stmvl53l0_open,
-	/*.flush =			stmvl53l0_flush,*/
+	.flush =			stmvl53l0_flush,
+	.release =			stmvl53l0_close,
 };
 
 /*
@@ -986,49 +1276,54 @@ static struct miscdevice stmvl53l0_ranging_dev = {
 };
 */
 
-int stmvl53l0_setup(struct stmvl53l0_data *data)
+int stmvl53l0_setup(struct stmvl53l0_data *data, uint8_t type)
 {
 	int rc = 0;
-#ifdef USE_INT
-	int irq = 0;
-#endif
+	int irq;
+	int gpio;
 
 	vl53l0_dbgmsg("Enter\n");
+	if (type == CCI_BUS) {
+		data->bus_type = CCI_BUS;
+		data->client_object = &(data->cci_client_object);
+		/* assign function table */
+		pmodule_func_tbl = &stmvl53l0_module_func_tbl_cci;
+		gpio = data->cci_client_object.gconf.cam_gpio_req_tbl[1].gpio;
+	} else {
+		data->bus_type = I2C_BUS;
+		data->client_object = &(data->i2c_client_object);
+		pmodule_func_tbl = &stmvl53l0_module_func_tbl_i2c;
+		gpio = data->i2c_client_object.gconf.cam_gpio_req_tbl[1].gpio;
+	}
 
-	/* init mutex */
-	mutex_init(&data->update_lock);
-	mutex_init(&data->work_mutex);
-
-#ifdef USE_INT
 	/* init interrupt */
-	gpio_request(IRQ_NUM, "vl53l0_gpio_int");
-	gpio_direction_input(IRQ_NUM);
-	irq = gpio_to_irq(IRQ_NUM);
+	gpio_request(gpio, "vl6180_gpio_int");
+	gpio_direction_input(gpio);
+	irq = gpio_to_irq(gpio);
+
 	if (irq < 0) {
-		vl53l0_errmsg("filed to map GPIO: %d to interrupt:%d\n",
-			IRQ_NUM, irq);
+		vl53l0_errmsg("%d,filed to map GPIO: %d to interrupt:%d\n",
+			__LINE__, gpio, irq);
 	} else {
+
 		vl53l0_dbgmsg("register_irq:%d\n", irq);
-		/* IRQF_TRIGGER_FALLING- poliarity:0 IRQF_TRIGGER_RISNG -
-		poliarty:1 */
-		rc = request_threaded_irq(irq, NULL,
-				stmvl53l0_interrupt_handler,
-				IRQF_TRIGGER_FALLING,
-				"vl53l0_interrupt",
-				(void *)data);
+/* IRQF_TRIGGER_FALLING- poliarity:0 IRQF_TRIGGER_RISNG - poliarty:1 */
+		rc = request_threaded_irq(irq, NULL, laser_isr,
+			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+			"vl6180_lb_gpio_int", (void *)data);
 		if (rc) {
-			vl53l0_errmsg("%d, Could not allocate STMVL53L0_INT !\
-				result:%d\n",  __LINE__, rc);
-#ifdef USE_INT
-			free_irq(irq, data);
-#endif
-			goto exit_free_irq;
+			vl53l0_errmsg("%d, Could not allocate INT %d\n",
+				__LINE__, rc);
+				goto exit_free_irq;
 		}
 	}
 	data->irq = irq;
-	vl53l0_errmsg("interrupt is hooked\n");
-#endif
-
+	enable_irq_wake(irq);
+	vl53l0_dbgmsg("interrupt is hooked\n");
+	/* init mutex */
+	mutex_init(&data->update_lock);
+	mutex_init(&data->work_mutex);
+	data->w_mode = OFF_MODE;
 	/* init work handler */
 	INIT_DELAYED_WORK(&data->dwork, stmvl53l0_work_handler);
 
@@ -1037,109 +1332,77 @@ int stmvl53l0_setup(struct stmvl53l0_data *data)
 	if (!data->input_dev_ps) {
 		rc = -ENOMEM;
 		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
-/*
-#ifdef USE_INT
-		free_irq(irq, data);
-#endif
-*/
+
 		goto exit_free_irq;
 	}
 	set_bit(EV_ABS, data->input_dev_ps->evbit);
 	/* range in cm*/
-	input_set_abs_params(data->input_dev_ps, ABS_DISTANCE, 0, 76, 0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_DISTANCE, 0, 76, 0, 0);
 	/* tv_sec */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT0X, 0, 0xffffffff,
-		0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT0X, 0, 0xffffffff, 0, 0);
 	/* tv_usec */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT0Y, 0, 0xffffffff,
-		0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT0Y, 0, 0xffffffff, 0, 0);
 	/* range in_mm */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT1X, 0, 765, 0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT1X, 0, 765, 0, 0);
 	/* error code change maximum to 0xff for more flexibility */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT1Y, 0, 0xff, 0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT1Y, 0, 0xff, 0, 0);
 	/* rtnRate */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT2X, 0, 0xffffffff,
-		0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT2X, 0, 0xffffffff, 0, 0);
 	/* rtn_amb_rate */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT2Y, 0, 0xffffffff,
-		0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT2Y, 0, 0xffffffff, 0, 0);
 	/* rtn_conv_time */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT3X, 0, 0xffffffff,
-		0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT3X, 0, 0xffffffff, 0, 0);
 	/* dmax */
-	input_set_abs_params(data->input_dev_ps, ABS_HAT3Y, 0, 0xffffffff,
-		0, 0);
+	input_set_abs_params(
+		data->input_dev_ps, ABS_HAT3Y, 0, 0xffffffff, 0, 0);
 	data->input_dev_ps->name = "STM VL53L0 proximity sensor";
 
 	rc = input_register_device(data->input_dev_ps);
 	if (rc) {
 		rc = -ENOMEM;
 		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
-/*
-#ifdef USE_INT
-		free_irq(irq, data);
-#endif
-		input_free_device(data->input_dev_ps);
-		return rc;
-*/
 		goto exit_free_dev_ps;
 	}
-	/* setup drv data */
-	input_set_drvdata(data->input_dev_ps, data);
 
 	/* Register sysfs hooks */
 	data->range_kobj = kobject_create_and_add("range", kernel_kobj);
 	if (!data->range_kobj) {
 		rc = -ENOMEM;
 		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
-/*
-#ifdef USE_INT
-		free_irq(irq, data);
-#endif
 
-		input_unregister_device(data->input_dev_ps);
-		input_free_device(data->input_dev_ps);
-		return rc;
-*/
 		goto exit_unregister_dev_ps;
 	}
-	/*rc = sysfs_create_group(data->range_kobj, &stmvl53l0_attr_group);
-	 rc = sysfs_create_group(&data->client_object.client->dev.kobj,
-			&stmvl53l0_attr_group);
-	*/
-	rc = sysfs_create_group(&data->input_dev_ps->dev.kobj,
-			&stmvl53l0_attr_group);
+	rc = sysfs_create_group(data->range_kobj, &stmvl53l0_attr_group);
 	if (rc) {
 		rc = -ENOMEM;
 		vl53l0_errmsg("%d error:%d\n", __LINE__, rc);
-/*
-#ifdef USE_INT
-		free_irq(irq, data);
-#endif
-		kobject_put(data->range_kobj);
-		input_unregister_device(data->input_dev_ps);
-		input_free_device(data->input_dev_ps);
-		return rc;
-*/
+
 		goto exit_unregister_dev_ps_1;
 	}
 
 	/* to register as a misc device */
 	data->miscdev.minor = MISC_DYNAMIC_MINOR;
-	data->miscdev.name = "stmvl53l0_ranging";
+	data->dev_name = devname;
+	data->miscdev.name = data->dev_name;
 	data->miscdev.fops = &stmvl53l0_ranging_fops;
-	vl53l0_errmsg("Misc device registration name:%s\n", data->dev_name);
+
 	if (misc_register(&data->miscdev) != 0)
-		vl53l0_errmsg("Could not register misc. dev for stmvl53l0\
-				ranging\n");
+		vl53l0_errmsg("%d,Couldn't register misc dev\n", __LINE__);
 
 	/* init default value */
 	data->enable_ps_sensor = 0;
 	data->reset = 1;
-	data->delay_ms = 30;	/* delay time to 30ms */
+	data->delay_ms = 0x3e8;	/* delay time to 1s */
 	data->enableDebug = 0;
-	data->client_object.power_up = 0;
-	/* for those one-the-fly power on/off flag */
+/*	data->client_object.power_up = 0; */
 
 	vl53l0_dbgmsg("support ver. %s enabled\n", DRIVER_VERSION);
 	vl53l0_dbgmsg("End");
@@ -1149,44 +1412,52 @@ exit_unregister_dev_ps_1:
 	kobject_put(data->range_kobj);
 exit_unregister_dev_ps:
 	input_unregister_device(data->input_dev_ps);
+
 exit_free_dev_ps:
 	input_free_device(data->input_dev_ps);
+
 exit_free_irq:
-#ifdef USE_INT
+
 	free_irq(irq, data);
-#endif
 	kfree(data);
 	return rc;
 }
 
 static int __init stmvl53l0_init(void)
 {
+	struct stmvl53l0_data *vl53l0_data = NULL;
 	int ret = -1;
 
 	vl53l0_dbgmsg("Enter\n");
 
-	/* assign function table */
-	pmodule_func_tbl = &stmvl53l0_module_func_tbl;
-#if 0
-	vl53l0_data = kzalloc(sizeof(struct stmvl53l0_data), GFP_KERNEL);
-	if (!vl53l0_data) {
-		vl53l0_errmsg("%d failed no memory\n", __LINE__);
-		return -ENOMEM;
+
+	if (gp_vl53l0_data == NULL) {
+		vl53l0_data =
+		kzalloc(sizeof(struct stmvl53l0_data), GFP_KERNEL);
+		if (!vl53l0_data) {
+			vl53l0_errmsg("%d failed no memory\n", __LINE__);
+			return -ENOMEM;
+		}
+		/* assign to global variable */
+		gp_vl53l0_data = vl53l0_data;
+	} else {
+		vl53l0_data = gp_vl53l0_data;
 	}
-	/* assign to global variable */
-	gp_vl53l0_data = vl53l0_data;
 	/* assign function table */
-	vl53l0_data->pmodule_func_tbl = &stmvl53l0_module_func_tbl;
-#endif
+
 	/* client specific init function */
-	ret = pmodule_func_tbl->init();
-#if 0
-	if (!ret)
-		ret = stmvl53l0_setup(vl53l0_data);
-#endif
-	if (ret)
-		vl53l0_errmsg("%d failed with %d\n", __LINE__, ret);
+	ret = stmvl53l0_module_func_tbl_cci.init();
+	if (ret) {
+		vl53l0_errmsg("%d failed with cci try on i2c %d\n",
+			__LINE__, ret);
+		ret = stmvl53l0_module_func_tbl_i2c.init();
+	}
 
+	if (ret) {
+		kfree(vl53l0_data);
+		gp_vl53l0_data = NULL;
+		vl53l0_errmsg("%d failed with %d\n", __LINE__, ret);
+	}
 	vl53l0_dbgmsg("End\n");
 
 	return ret;
@@ -1202,10 +1473,10 @@ static void __exit stmvl53l0_exit(void)
 #ifdef USE_INT
 		free_irq(data->irq, gp_vl53l0_data);
 #endif
-		sysfs_remove_group(gp_vl53l0_data->range_kobj,
-&stmvl53l0_attr_group);
-
-gp_vl53l0_data->pmodule_func_tbl->deinit(&gp_vl53l0_data->client_object);
+		sysfs_remove_group(
+			gp_vl53l0_data->range_kobj, &stmvl53l0_attr_group);
+		gp_vl53l0_data->pmodule_func_tbl->deinit(
+			gp_vl53l0_data->client_object);
 		kfree(gp_vl53l0_data);
 		gp_vl53l0_data = NULL;
 	}
@@ -1214,11 +1485,17 @@ gp_vl53l0_data->pmodule_func_tbl->deinit(&gp_vl53l0_data->client_object);
 }
 
 
+struct stmvl53l0_data *stmvl53l0_getobject(void)
+{
+	return gp_vl53l0_data;
+}
+
+
 MODULE_AUTHOR("STMicroelectronics Imaging Division");
 MODULE_DESCRIPTION("ST FlightSense Time-of-Flight sensor driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRIVER_VERSION);
 
-module_init(stmvl53l0_init);
+late_initcall(stmvl53l0_init);
 module_exit(stmvl53l0_exit);
 
diff --git a/include/uapi/media/msmb_camera.h b/include/uapi/media/msmb_camera.h
index f48890da71c..d7dd2ff2fd3 100644
--- a/include/uapi/media/msmb_camera.h
+++ b/include/uapi/media/msmb_camera.h
@@ -51,7 +51,8 @@
 #define MSM_CAMERA_SUBDEV_SENSOR_INIT  14
 #define MSM_CAMERA_SUBDEV_OIS          15
 #define MSM_CAMERA_SUBDEV_FLASH        16
-#define MSM_CAMERA_SUBDEV_EXT          17
+#define MSM_CAMERA_SUBDEV_TOF          17
+#define MSM_CAMERA_SUBDEV_EXT          18
 
 #define MSM_MAX_CAMERA_SENSORS  5
 
-- 
2.11.0

